#INCLUDE "SPEDFISCAL.CH"
#INCLUDE "PROTHEUS.CH"
#INCLUDE "FWCOMMAND.CH"
#INCLUDE "SPEDXDEF.CH"
#INCLUDE "FWLIBVERSION.CH"

#DEFINE PULALINHA Chr(13) + Chr(10)

/* 
> CRIADO PROGRAMA SPEDXFUN QUE DEVERAH CONTER TODAS AS FUNCTIONS (PUBLICAS) DO SPED <

Programa  ³SPEDFISCAL³ Autor ³Gustavo G. Rueda ³ Data ³11.03.2011³±±
Descri‡…o ³Preparacao do meio-magnetico SPEDFISCAL
*/
// Chamada das funcoes de cache do dicionario na inicializacao do SPEDXFUN.

STATIC aSPDSX2		:=	SpedLoadX2()
STATIC aSPDSX3		:=	SpedLoadX3()
STATIC aSPDSX6		:=	SpedLoadX6()
STATIC aExistBloc	:=	SPDFRetPEs()
STATIC aSPDFil		:=  fGetSpdFil()

STATIC cSGBD		:= AllTrim(Upper(TcGetDb()))// Tipo do banco de dados
STATIC cQryInsert	:= ""
STATIC __nCountIns	:= 0

STATIC lGrvLoja		:= .F.

STATIC __oORGTXT	:= Nil

STATIC oHHierarq	:= Nil
STATIC oHHBloco0	:= Nil
STATIC oHHBlocoB	:= Nil
STATIC oHHBlocoC	:= Nil
STATIC oHHBlocoD	:= Nil
STATIC oHHBlocoE	:= Nil
STATIC oHHBlocoG	:= Nil
STATIC oHHBlocoH	:= Nil
STATIC oHHBlocoK	:= Nil
STATIC oHHBloco1	:= Nil
STATIC oHHBloco9	:= Nil

//Objeto de Json da CDA
STATIC oJRetCda		:= Nil

STATIC cSemafLoj	:= ""
STATIC nTamFT_IT	:= TAMSX3("FT_ITEM")[1]
STATIC nTTRBITEM	:= 7     //Tamanho maximo de casas que o numero de itens por registro do manual podera ter
STATIC cRelacPri	:= ""
STATIC lUseBulk     := TCGetBuild()  >= "20181212" .and. FwLibVersion() >= "20201009"
STATIC lDelH010		:= FindFunction("DelTblH010")
STATIC oNfOrItXml      := Nil

Function SPEDFISCAL(aWizScreen)

Local	cCmpsNaoEx	:=	""
Local	cNew       	:=	"HMNew()"
Local	cNomWiz		:=	"SPEDFIS" + FWGRPCOMPANY() + FWGETCODFILIAL
Local	cNomeAnt	:=	Iif(File(cNomWiz+".cfp"),"","SPEDFIS" + FWGETCODFILIAL)
Local	cFileDest	:=	"SPEDFISCAL.TXT"
Local	cPerfil		:=	aSPDSX6[MV_PRFSPED]

Local	lEnd		:=	.F.
Local	lCmpsVld	:=	.F.
Local	lTabComp	:=	.F.
Local	lTabCDT		:=	.F.
Local	lTabCD0		:=	.F.
Local	lTabCD1		:=	.F.
Local	lTabCE5		:=	.F.
Local	lIntTMS		:=	.F.
Local	lJob		:=	.F.
Local	lTabF0A		:=  .F.
Local	lTabCDD		:=  .F.
Local	lTabCDE		:=  .F.
Local	lTabCDF		:=  .F.
Local	lTabCDG		:=  .F.
Local 	lVerpesssen := Iif(FindFunction("Verpesssen"),Verpesssen(),.T.)

Private oHash0200
Private oHashC800
Private oHashC850
Private oHashC860
Private oHashC870
Private oHashC890
Private oHash0210
Private oHash0150
Private oHashINFP
Private oHashTMSM

Private oHMBK02010
Private aBK02010	:= {}
Private aReg0205	:=	{}				//O array aReg0205 e aReg0206 precisou ser declarado Private para que a mudanca de estrutura do reg. 0200 nao influencie em todo o
										//proces da rotina. Como os reg 0205 e 0220 passaram a ter um relacionamento com o reg pai 0200, foi necessario efetuar
										//esse tratamento, evitando maiores impactos nas chamadas da funcao SFRG0200(() e no desenv de outros Pontos de Entrada.
Private aReg0206	:=	{}
Private cVersao		:=	""
Private lBuild    	:=	GetBuild() >= "7.00.131227A"
Private oTempTab 	//Necessaria a criação desta variavel para a construção correta da tabela temporaria TRB criada na função SPDGerTrb
Private __cTblName	:= ""
//- objeto para insert temporario via bulk 
Private oBulkTMP as object 
//- controle do buffer do insert temporario 
Private lCanUseBulk := lUseBulk .and. FwBulk():CanBulk()
Private aDadosBulk  := {}

DEFAULT aWizScreen	:= {}				//Wizard preenchido antes de chamar function SpedFiscal, permitindo utilizar SpedFiscal via Job/RPC

If lBuild
    oHash0200 := &cNew
    oHashC800 := &cNew
    oHashC850 := &cNew
    oHashC860 := &cNew
	oHashC870 := &cNew
    oHashC890 := &cNew
    oHash0210 := &cNew
	oHash0150 := &cNew
	oHashINFP := &cNew
	oHashTMSM := &cNew
	
EndIf

If lVerpesssen
	lJob := IIF(Len(aWizScreen) > 0,.T.,.F.)

	//³funcao de inicializacao de ambiente³
	cCmpsNaoEx	:=	SPEDOpenEnv(@lTabComp,@lTabCDT,@lTabCD0,@lIntTMS,@lCmpsVld,@lTabCE5,@lTabCD1,@lTabF0A,@lTabCDD,@lTabCDE,@lTabCDF,@lTabCDG)
	//³Msg de alerta quando nao existir os campos criados pelo UPDFIS e que sao utilizados pela rotina³
	If lJob .Or. lCmpsVld .Or. (!lCmpsVld .And. MsgYesNo(STR0020+CRLF+CRLF+"Campos: "+cCmpsNaoEx,STR0021)) //"Alguns campos import. criados pelo compatib UPDFIS não foram encontrados na base de dados para o correto proces do SPED Fiscal. Deseja continuar mesmo sem esses campos ? (As informações poderão ser geradas de forma divergente) "###"Atenção!!!"
		//³Chamada da funcao que monta o Wizard da rotina³
		If lJob .Or. SpedMntWiz(cNomWiz,cPerfil,cNomeAnt)
			If !lJob
				FwMsgRun(,{|oSay|PrSped(@lEnd,@cFileDest,cPerfil,oSay,lTabComp,lTabCDT,lTabCD0,lTabCE5,lIntTMS,aWizScreen,lTabCD1,lTabF0A,lTabCDD,lTabCDE,lTabCDF,lTabCDG)},STR0022,"") //"Processamento SPED Fiscal"
			Else
				Processa( {|lEnd |PrSped(@lEnd,@cFileDest,cPerfil,Nil,lTabComp,lTabCDT,lTabCD0,lTabCE5,lIntTMS,aWizScreen,lTabCD1,lTabF0A,lTabCDD,lTabCDE,lTabCDF,lTabCDG)})
			EndIf
		EndIf
	EndIf
EndIf

Return
/*
Programa  ³  PrSped  ³ Autor ³Gustavo G. Rueda ³ 15.03.2011
*/
Static Function PrSped (lEnd,cFileDest,cPerfil,oSay,lTabComp,lTabCDT,lTabCD0,lTabCE5,lIntTMS,aWizScreen,lTabCD1,lTabF0A,lTabCDD,lTabCDE,lTabCDF,lTabCDG)

//³Variaveis de diversos controles - OBS. deverá seguir a sequencia de tipo de variáveis, mantendo assim todos organizados ³
//Array
Local	aPartDoc		:=	{}
Local	aWizard			:=	{}
Local	aLanCDA			:=	{}
Local	aInfE313		:=	{}
Local	aInfE531		:=	{}
Local	aLanCDA2		:=	{}
Local	aArq			:=	{}
Local	aParFil			:=	{}
Local	aParFil2		:=	{}
Local	aLisFil			:=	{}
Local	aCmpAntSFT		:=	{}
Local	aHistSA			:=	{}
Local	aHistSA4		:=	{}
Local	aHistSB1		:=	{}
Local	aProdB1			:=	{}
Local	aSpdInfC		:=	{}
Local	aAreaSA			:=	{}
Local	aPartREM		:=	{}
Local	aPartDES		:=	{}
Local	aPartCON		:=	{}
Local	aPartDPC		:=	{}
Local	aRetPart		:=	{}
Local	aRetAux			:=	{}
Local	aParcTit		:=	{}
Local	aF2EspVol		:=	{}
Local	aVlrMovST		:=	{}
Local	aResF3FT		:=	{}
Local	aIcmPago		:=	{}
Local	aSpdFis02		:=	{}
Local	aAvImport		:=	{}
Local	aPTransp		:=	{}
Local	aMVRLCSPD		:=	{}
Local	aMVSPDPROD		:=	{}
Local	aMovSemIe		:=	{}
Local	aDadSFU			:=	{}
Local   aStruCDA		:=  {} 
Local	aNatOper		:=	{"",""}
Local	aInfCompl		:=	{"",""}
Local	aTotaliza		:=	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
Local	aTpMov			:=	{'E','S'} //- Tipo de Movimentos
Local	aClasFis		:=	{"","","",""}
Local	aProd			:=	{"","","","","","","","","","",""}
Local	aSM0			:=	FWLoadSM0()
Local	aAreaSM0		:=	SM0->(GetArea ())

//Caractere
Local	cAlsSF			:=	""
Local	cAlsSD			:=	""
Local	cAlsSA			:=	""
Local	cFilAlsSA		:=	""
Local	cEntSai			:=	""
Local	cEspecie		:=	""
Local	cIndEmit		:=	""
Local	cMVSUBTRIB		:=	""
Local	cMVEstado		:=	""
Local	cOpSemF			:=	""
Local	cSituaDoc		:=	""
Local	cNrLivro		:=	""
Local	cFilDe			:=	""
Local	cFilAte			:=	""
Local	cDir			:=	""
Local	cIndex			:=	""
Local	cChvSeek		:=	""
Local	cChvSFT			:=	""
Local	cIteSFT			:=	""
Local	cFilSF3			:=	""
Local	cFrete			:=	""
Local	cCodMunDest		:=  ""
Local	cSitExt			:=	""
Local	cUnid			:=	""
Local	cProd			:=	""
Local	cCdMunDes		:=	""
Local	cAntUnid		:=	""
Local	cCDTChv			:=	""
Local	cCDCChv			:=	""
Local	cDTCChv			:=	""
Local	cCodTes			:=	""
Local	cCodNat			:=	""
Local	cDescNat		:=	""
Local	cProtocolo		:=	""
Local	cTpCv			:=	""
Local	cMVCFE210		:=	SpedPrSeq("MV_CFE210","1410,1411,1414,1415,1660,1661,1662,2410,2411,2414,2415,2660,2661,2662")
Local	cPRDPRIB5		:=	Alltrim(aSPDSX6[MV_PRDPRI])
Local	cMVSTNIEUF		:=	aSPDSX6[MV_STNIEUF]
Local	cUFRESpd		:=	aSPDSX6[MV_UFRESPD]		// Acrescentado UF de GO como Default para atender Chamado:TDSAFI
Local	cCodRefLj		:=	aSPDSX6[MV_LJSPED]		// Codigo dat Tabela CCE para Cupom Referenciado 
Local	cMVCOMPFRT		:=	aSPDSX6[MV_COMPFRT]		// 1-Valor do frete por peso/volume, 2-Valores do SEC/CAT, 3-Valores de despacho, 4-Valores de pedagio
Local	cMvD162			:=	aSPDSX6[MV_NGD162]		
// Identifica os CFOP s, que nao gera registro D162.
Local	cMV_StUf		:=	aSPDSX6[MV_STUF]		// Define os estados a serem utilizados para o artigo 281
Local	cMV_StUfS		:=	aSPDSX6[MV_STUFS]		// Define os estados a serem utilizados para o artigo 281 - para as saidas
Local	cMVCFC195		:=	aSPDSX6[MV_CFC195]
Local	nMVSPDIFC		:=	aSPDSX6[MV_SPDIFC]
Local	cMVSPDTC95		:=	aSPDSX6[MV_SPDTC95]
Local	cNomeCfp		:=	"SPEDFIS" + FWGRPCOMPANY() + FWGETCODFILIAL
Local	cAlertCfop		:=	STR0030
Local	cSolucCfop		:=	STR0031+cMVCFE210+"."
Local	cMVDTINCB1		:=	IIF(AllTrim(aSPDSX6[MV_DTINCB1]) != "", AllTrim(aSPDSX6[MV_DTINCB1]),"B1_DATREF")
Local	cMV_DifTr		:=	GetSubTrib("",.T.)      // Pega IE de Difal
Local	cMVUFBsSt		:=	aSPDSX6[MV_UFBSST]		// Define os estados a serem utilizados para CAT nº 3/2015
Local 	cMvNfSS			:=	aSPDSX6[MV_COTNFSS]     // Contém o modelo de nota fiscal de serviço simplificada e a espécie à qual se refere.
Local	lIntGTP			:= .F.						// Controle de Integração com SIGAGTP - Gestão de Transporte de Passageiros.

//Data
Local	dDataDe			:=	CToD ("//")
Local	dDataAte		:=	CToD ("//")
Local	dDtarec			:=	CToD("  /  /  ")
Local	dDtEntSai		:=	CToD("  /  /  ")

//Lógica
Local	lNotaC350		:=	.T.
Local	lNotaC300		:=	.T.
Local	lNotaD300		:=	.T.
Local   lNotaD410       :=  .T.
Local	lFirstNF		:=	.T.
Local	lLogCfop		:=	.F.
Local	lPisZero		:=	.F.
Local	lCofZero		:=	.F.
Local	lIcmStTran		:=	.F.
Local	lCompIcm		:=	.F.
Local	lIss			:=	.F.
Local	lUsaSelo		:=	.F.
Local	lIpiPauta		:=	.F.
Local	lTop			:=	.F.
Local	lImpCrdST		:=	.F.
Local	lGerouC170		:=	.F.
Local	lJob			:=	.F.
Local	lNewCFrt		:=	.F.
Local	lOperGar		:=	.F.
Local	lLegisPer		:=	.F.
Local	lGera			:=	.F.
Local	lCondC120		:=	.F.
Local	lGr2001400		:=	.F.
Local	lRefazInd		:=	.F.
Local	lDifal			:=	.F.
Local	lMVUFICSEP		:=	.F.
Local	lIsBlind		:=	IsBlind()
Local	lSPDFIS02		:=	aExistBloc[01]
Local	lCadParti		:=	aExistBloc[02]
Local	lSpedRTms		:=	aExistBloc[03]
Local	lSPDFIS08		:=	aExistBloc[04]
Local	lF4_VLAGREG		:=	aSPDSX3[FP_F4_VLAGREG]
Local	lL2Sit			:=	aSPDSX3[FP_D2_SITTRIB]
Local	lIndFrete		:=	aSPDSX3[FP_CDT_INDFRT]
Local	lCmpDscComp		:=	aSPDSX3[FP_CDT_DCCOMP]
Local	lDUESol			:=	aSPDSX3[FP_DUE_CODSOL]
Local	lSitDocExt		:=	aSPDSX3[FP_CDT_SITEXT] .And. aSPDSX3[FP_CDT_DTAREC]
Local	lMVSFRBCD2		:=	aSPDSX6[MV_SFRBCD2]
Local	lConvC115		:=	aSPDSX6[MV_CONV115]
Local	lMVCF3ENTR		:=	aSPDSX6[MV_CF3ENTR]
Local	lResF3FT		:=	aSPDSX6[MV_RESF3FT]
Local	lMVSpedAz		:=	aSPDSX6[MV_SPEDAZ]
Local	lSpedNat		:=	aSPDSX6[MV_SPEDNAT]
Local	lSigaEEC		:=	aSPDSX6[MV_EECFAT]
Local	lEECSPED		:=	aSPDSX6[MV_EECSPED]
Local	lSigaEIC		:=	aSPDSX6[MV_EASY] == "S"
Local	lHistTab		:=	aSPDSX6[MV_HISTTAB] .And. aSPDSX2[AI_AIF]
Local	lUsaSped		:=	aSPDSX6[MV_USASPED] .And. aSPDSX2[AI_CDH] .And. aSPDSX2[AI_CDA] .And. aSPDSX2[AI_CC6]
Local	lPCLLOJA		:=	FindFunction("T_TpPcSped") .And. aSPDSX2[AI_LF1] .AND. aSPDSX2[AI_LEG] .AND. ;
							aSPDSX2[AI_LEJ] .AND. aSPDSX2[AI_LEI] .AND. !aExistBloc[07]
Local	lOldLan			:=	(aSPDSX2[AI_CC6] .And. aSPDSX3[FP_CC6_TIPOAJ])
Local   lBlocoB         :=  .F.
Local 	oObjSpdMov		:= SPEDMOV():New()
Local 	aMunDevPre		:= {}
Local 	cEstPres		:= ""
Local 	cMunPres		:= ""
Local   lInscrito       := .T.
Local   lproctit	    := .T. 
//Novos campos ressarcimento ICMS ST - C176
Local lCmpCD0			:=	aSPDSX3[FP_CD0_CHVNFE] .And. aSPDSX3[FP_CD0_ITENFE] .And. aSPDSX3[FP_CD0_VLUNOP] .And.;
							aSPDSX3[FP_CD0_PICMSE] .And. aSPDSX3[FP_CD0_ALQSTE] .And. aSPDSX3[FP_CD0_RESPRE] .And.;
							aSPDSX3[FP_CD0_MOTRES] .And. aSPDSX3[FP_CD0_CHNFRT] .And. aSPDSX3[FP_CD0_PANFRT] .And.;
							aSPDSX3[FP_CD0_SRNFRT] .And. aSPDSX3[FP_CD0_NRNFRT] .And. aSPDSX3[FP_CD0_ITNFRT] .And.;
							aSPDSX3[FP_CD0_CODDA]  .And. aSPDSX3[FP_CD0_NUMDA]  .And. aSPDSX3[FP_CD0_VLUNRE] .And.;
							aSPDSX3[FP_CD0_BSULMT] .And. aSPDSX3[FP_CD0_VLUNCR]

//Novos campos Cadastro de Intermediador bloco 1601
Local lCmpA1U			:=  aSPDSX3[FP_A1U_PAIS] .And. aSPDSX3[FP_A1U_EST] .And. aSPDSX3[FP_A1U_CODMUN] .And.;
							aSPDSX3[FP_A1U_END] .And. aSPDSX3[FP_A1U_NUMEND] .And. aSPDSX3[FP_A1U_COMPL] .And.;
							aSPDSX3[FP_A1U_BAIRRO]  .And. aSPDSX3[FP_A1U_INSCR]  .And. aSPDSX3[FP_A1U_SUFRAM] 
//Iem por XML
Local	lCSDXML			:=  aSPDSX6[MV_CSDXML] .and. Iif( FindFunction('VerTabXml'), VerTabXml(), .F.)
Local   lProcXml		:=  .F.
Local   lComplXml       :=  .F.
Local   nContXml		:=  0
Local   cItXml			:=  ""
//Obejto que guarda a posição do array relacionado com a posição do item do XML por registro
Local oPosItXML 		:= Nil

Local oRegC171 := JsonObject():New()
Local oRegC173 := JsonObject():New()
Local oRegC175 := JsonObject():New()
Local lGeraC175 := .F.
Local lGeraC173 := .F.
Local lGeraC171 := .F.

//Numérico
Local	cRelacDoc		:=	"0"
Local	cRelacItXml		:=	"0"
Local 	nRelacAux		:=	0
Local 	nItem			:=	0
Local 	nUltCDA			:=	1
Local	nX				:=	0
Local	nI				:=	0
Local	nPosGener		:=	0
Local	nContMov		:=	0
Local	nApurIpi		:=	0
Local	nFilial			:=	0
Local	nValST			:=	0
Local	nRedBSICM		:=	0
Local	nCtdFil			:=	1
Local	nCountTot		:=	1
Local	nRegsProc		:=	0
Local	nEmpProc		:=	0
Local	nQtde			:=	0
Local	nFatorPE		:=	0
Local	nAbatNT			:=	0
Local	nDifalDest		:=	0
Local	nDifalOrig		:=	0
Local	nDifalFEcp		:=	0
Local	nPosSemIe		:=	0
Local	nRetCpy			:=	1
Local	nQtReg0200		:=	0	//Variavel auxiliar apenas para controlar a quantidde de registros existentes no array "aReg0200"
Local	nPosSFU			:=	0
Local	nKeyCD2			:=	1
Local	nRecnoSF3		:=	Nil
Local	nRecnoCD0		:=	Nil
Local	nRecnoCDT		:=	Nil
Local	nRecnoCD1		:=	Nil
Local	nRecnoCD2		:=	Nil
Local	nRecnoCD3		:=	Nil
Local	nRecnoCD7		:=	Nil
Local 	nRecnoF0A		:=	Nil
Local	nRecnoCD8		:=	Nil
Local	nRecnoCD9		:=	Nil
Local	nRecnoSFU		:=	Nil
Local	nRecnoSFX		:=	Nil
Local	nRecnoDT6		:=	Nil
Local	nRecnoDUD1		:=	Nil
Local	nRecnoDUD2		:=	Nil
Local 	nRecnoDUD		:=  Nil
Local	nRecnoCCE		:=	Nil
Local	nRecSF3DBF		:=	Nil
Local	nRecnoCD6		:=	Nil
Local	nRecnoCDC		:=	Nil
Local	nRecnoCDA		:=	Nil
Local	nRecnoCDD		:=	Nil
Local	nRecnoCDE		:=	Nil
Local	nRecnoCDF		:=	Nil
Local	nRecnoCDG		:=	Nil

Local 	cMunSM0			:= ""
Local   cSitDocGZU      := ""
Local   aDadosGZU       := {}
Local   cDTCancela      := ""
Local   cDTEmissao      := ""

//Bloco
Local	bWhileSM0		:=	{||!SM0->(Eof ()) .And. ((!"1"$aWizard[1][12] .And. cEmpAnt==SM0->M0_CODIGO .And. FWGETCODFILIAL<=cFilAte) .Or. ("1"$aWizard[1][12] .And. Len(aLisFil)>0 .And. cEmpAnt==SM0->M0_CODIGO))}

//Variáveis que dependem de outras para serem alimentadas
Local	aMVCOMPFRT		:=	Iif(Len(&(cMVCOMPFRT))<>4,{},&(cMVCOMPFRT))

//³Variaveis para nomes de campos³
Local	cCmpUm			:=	""
Local	cCmpTrans		:=	""
Local	cCmpEst			:=	""
Local	cCmpTipo		:=	""
Local	cCmpTes			:=	""
Local	cCmpNFCupom		:=	""
Local	cCmpPrefixo		:=	""
Local	cCmpDupl		:=	""
Local	cCmpPBruto		:=	""
Local	cCmpPLiqui		:=	""
Local	cCmpVeic1		:=	""
Local	cCmpVeic2		:=	""
Local	cCmpVeic3		:=	""
Local	cCmpSimpN		:=	""
Local	cCmpRegPB		:=	""
Local	cCmpFrete		:=	""
Local	cCmpHawb		:=	""
Local	cCmpTPCTE		:=	""
Local	cCmpDescIcm		:=	""
Local	cCmpMenNota		:=	""
Local   cCmpUfOriTr     :=  ""
Local   cCmpUfDesTr     :=  ""
Local   cCmpMuOriTr     :=  ""
Local   cCmpMuDesTr     :=  ""
Local   cTipoNf			:=  ""
Local 	cCpUfOri     	:=  ""
Local 	cCpUfDes     	:=  ""
Local 	cCpMuOri     	:=  ""
Local 	cCpMuDes     	:=  ""	

//³Variaveis de FLAG de seek³
Local	lAchouCD0		:=	.F.
Local	lAchouCD1		:=	.F.
Local	lAchouCD2		:=	.F.
Local	lAchouCD3		:=	.F.
Local	lAchouCD4		:=	.F.
Local	lAchouCD5		:=	.F.
Local	lAchouCD6		:=	.F.
Local	lAchouCD7		:=	.F.
Local 	lAchouF0A		:=	.F.
Local	lAchouCD8		:=	.F.
Local	lAchouCD9		:=	.F.
Local	lAchouCDC		:=	.F.
Local	lAchouCDD		:=	.F.
Local	lAchouCDE		:=	.F.
Local	lAchouCDF		:=	.F.
Local	lAchouCDG		:=	.F.
Local	lAchouCDT		:=	.F.
Local	lSitDocCDT		:=	.F.
Local	lAchouDA3		:=	.F.
Local	lAchouDT5		:=	.F.
Local	lAchouDT6		:=	.F.
Local	lAchouDT8		:=	.F.
Local	lAchouDTC		:=	.F.
Local	lAchouDUD		:=	.F.
Local	lAchouDUL		:=	.F.
Local	lAchouSF4		:=	.T.
Local	lAchouSFU		:=	.T.
Local	lAchouSFX		:=	.T.
Local	lAchSFSD		:=	.F.
Local	lAchouCCE		:=	.T.
Local	lAchouDTQ		:=	.F.
Local	lAchouDTR		:=	.F.
Local	lAchou2DUL		:=	.F.
Local	lAchouDUY		:=	.F.
Local	lGeraC177B		:=	.F.
Local	lAchouCDA		:=	.F.
Local 	lAchouSF3		:=  .F.

//³Variaveis de alias de tabelas³
Local	cAlias			:=	""
Local	cAliasCD2		:=	"CD2"
Local	cAliasCD4		:=	"CD4"
Local	cAliasCD5		:=	"CD5"
Local	cAliasCD6		:=	"CD6"
Local	cAliasCDC		:=	"CDC"
Local	cAliasCDD		:=	"CDD"
Local	cAliasCDE		:=	"CDE"
Local	cAliasCDF		:=	"CDF"
Local	cAliasCDG		:=	"CDG"
Local	cAliasCDT		:=	"CDT"
Local	cAliasDT5		:=	"DT5"
Local	cAliasDT8		:=	"DT8"
Local	cAliasDTC		:=	"DTC"
Local	cAliasDUD		:=	"DUD"
Local	cAliasDUL		:=	"DUL"
Local	cAliasSB1		:=	"SB1"
Local	cAliasSB5		:=	"SB5"
Local	cAliasSF4		:=	"SF4"
Local	cAliasSFT		:=	"SFT"
Local	cAliasSA4		:=	"SA4"
Local	cAliasSF6		:=	"SF6"
Local	cAliasDTQ		:=	"DTQ"
Local	cAliasDTR		:=	"DTR"
Local	cAliasSD1		:=	"SD1"

//³Variaveis de relacionamento de registros atraves de posicao³
Local	nPosC110		:= 0
Local	nPosC300		:= 0
Local	nPosC600		:= 0
Local	nPosC700		:= 0
Local	nPosD300		:= 0
Local	nPosD600		:= 0
Local   nPosD400        := 0
Local   nPosD410        := 0

//³Variaveis de FLAG para gravacao de registrso³
Local	lGrava0150		:= .F.
Local	lGrava0200		:= .F.
Local	lGrava1500		:= .F.
Local	lGravaC500		:= .F.
Local	lGravaC700		:= .F.
Local	lGravaD500		:= .F.

//³Variaveis de registros³
Local	aReg0150		:=	{}
Local	aReg0190		:=	{}
Local	aReg0200		:=	{}
Local	aReg0210		:=	{}
Local	aReg0220		:=	{}
Local	aReg0400		:=	{}
Local	aReg0450		:=	{}
Local	aReg0460		:=	{}
Local	aRegB020		:=	{}
Local	aRegB025		:=	{}
Local	aRegB030		:=	{}
Local	aRegB035		:=	{}
Local   aRegB350        :=  {}
Local	aRegB420		:=	{}
Local	aRegB440		:=	{}
Local	aRegB460		:=	{}
Local	aRegB470		:=	{}
Local	aRegB500		:=	{}
Local	aRegB510		:=	{}
Local	aRegC100		:=	{}
Local	aRegC110		:=	{}
Local	aRegC111		:=	{}
Local	aRegC112		:=	{}
Local	aRegC113		:=	{}
Local	aRegC114		:=	{}
Local	aRegC115		:=	{}
Local	aRegC116		:=	{}
Local	aRegC130		:=	{"C130", 0, 0, 0, 0, 0, 0, 0}
Local	aRegC165		:=	{}
Local	aRegC170		:=	{}
Local	aRegC190		:=	{}
Local 	aRegC191		:=  {}
Local	aRegC300		:=	{}
Local	aRegC310		:=	{}
Local	aRegC320		:=	{}
Local	aRegC321		:=	{}
Local	aRegC330		:=	{}
Local	aRegC390		:=	{}
Local	aRegC400		:=	{}
Local	aRegC405		:=	{}
Local	aRegC410		:=	{}
Local	aRegC420		:=	{}
Local	aRegC425		:=	{}
Local	aRegC430		:=	{}
Local	aRegC460		:=	{}
Local	aRegC470		:=	{}
Local	aRegC480		:=	{}
Local	aRegC490		:=	{}
Local	aRegC495		:=	{}
Local	aRegC500		:=	{}
Local	aRegC510		:=	{}
Local	aRegC590		:=	{}
Local	aRegC591		:=	{}
Local	aRegC600		:=	{}
Local	aRegC601		:=	{}
Local	aRegC610		:=	{}
Local	aRegC690		:=	{}
Local	aRegC700		:=	{}
Local	aRegC790		:=	{}
Local	aRegC791		:=	{}
Local	aRegC800		:=	{}
Local	aRegC810		:=	{}
Local	aRegC815		:=	{}
Local	aRegC850		:=	{}
Local	aRegC860		:=	{}
Local	aRegC870		:=	{}
Local	aRegC880		:=	{}
Local	aRegC890		:=	{}
Local   aRegC895		:=  {}
Local   aRegC897		:=  {}
Local	aRegD190		:=	{}
Local	aRegD300		:=	{}
Local	aRegD301		:=	{}
Local	aRegD310		:=	{}
Local	aRegD500		:=	{}
Local	aRegD510		:=	{}
Local	aRegD590		:=	{}
Local	aRegD610		:=	{}
Local	aRegD600		:=	{}
Local	aRegD690		:=	{}
Local	aRegD695		:=	{}
Local	aRegD696		:=	{}
Local	aRegD697		:=	{}
Local	aRegE510		:=	{}
Local	aReg1400		:=	{}
Local	aReg1600		:=	{} // Array para guardar os dados dos cartoes de Credito e Debito para o Bloco 1000 Registro 1600- será substituido em 2022 pelo Reg 1601
Local	aReg1601		:=	{} // Array para guardar os dados dos Pagamentos eletronicos para o Registro 1601
Local	aReg1700		:=	{}
Local	aReg1710		:=	{}
Local	aReg1010		:=	{}
Local	aReg1250		:=	{}
Local	aReg1255		:=	{}
Local	aReg1300		:=	{}
Local	aReg1310		:=	{}
Local	aReg1320		:=	{}
Local	aReg1350		:=	{}
Local	aReg1360		:=	{}
Local	aReg1370		:=	{}
Local   aRegD350        :=  {}
Local   aRegD355        :=  {}
Local   aRegD360        :=  {}
Local   aRegD365        :=  {}
Local   aRegD370        :=  {}
Local   aRegD390        :=  {}
Local   aRegD400        :=  {}
Local   aRegD410        :=  {}
Local   aRegD411        :=  {}
Local   aRegD420        :=  {}
Local   nVlContOMun		:= 0

Local	aAreaCDE		:=	{}
Local	aLiv1900		:=	{}
Local	aLancFis		:=	{}

Local	aAux0200		:=	{}
Local	aLivGIAF		:=	{}
Local	aBloco8			:=	{}
Local	lProcGiaf		:= .F.
Local 	lImport			:= FindFunction("GiafEntPrd")

Local	lEstBLK			:= .F.
Local	lProcBLK		:= .F.
Local 	lE300Ori		:= .F.

Local cDtHoraIni := ""
Local cDtHoraFim := ""
Local nRetType   := 0

Local cMVCFERES := SpedPrSeq("MV_CFERES","1603,2603")

Local lCpoMunSF1 := aSPDSX3[FP_F1_UFORITR] .And. aSPDSX3[FP_F1_UFDESTR] .And. aSPDSX3[FP_F1_MUORITR] .And. aSPDSX3[FP_F1_MUDESTR] 
Local lCpoMunSF2 := aSPDSX3[FP_F2_UFORIG] .And. aSPDSX3[FP_F2_UFDEST] .And. aSPDSX3[FP_F2_CMUNOR] .And. aSPDSX3[FP_F2_CMUNDE] 
Local c66	     := ""

Local lFindDT6Re := .F.	//Remetente do conhecimento
Local lFindDT6Co := .F.	//Destinatario do conhecimento

Local cChvSeekv	 := ""
Local cChvDUY	 := ""

Local lAuxDA3Ant := .F.

Local aAreaOriSFT
Local cItSFTOri	:= ""

local aPartSM0 := {}

Local aTMSCMRet := {} //Array retorno do HashTMSCM

Local lPriItem	:= .T.

Local lEICImport := .F.

Local cHiC800_60 := ""
Local cHiC810_70 := ""
Local cHiC815    := ""
Local cChv890	 := ""
Local nPosC890	 := ""

Local lProsSPE	:= Findfunction('EstProsSPE')
Local lFISA300	:= FindFunction("FISA300")
Local lInfCTEO	:= FindFunction('GetInfCTEO')
Local lDevLanc	:= FindFunction("DevLanc")

Local lVldBlkTp := FindFunction('VldBlkTp')
Local cC500C700	:= ""
Local lEntraC500:= .T.
Local nLenCDA	:= 0 

#IFDEF TOP
	If TcSrvType() <> "AS/400"
		lTop	:= .T.
	Endif
#ENDIF

DEFAULT aWizScreen	:= {} //Recebe via Job/Rpc aWizard preenchida

Private lConcFil	:= .T.
Private cLib		:= ""
Private lRegCompST	:= .F.
Private cAlsFormu   := "" // Cópia do cAliasSFT para clientes utilizarem na estruturação de formulas bloco C195 campo 03. Issue DSERFIS1-29003

//Verifica se aWizScreen preenchido, sinalizando processamento via Job/Rpc
lJob := Iif(Len(aWizScreen) > 0, .T.,.F.)

//Atribuo o conteudo do CFP gerado pelo wizard no array aWizard
If !lJob
	cNomeCfp := Iif(File(cNomeCfp+".cfp"),cNomeCfp,"SPEDFIS")
	If !xMagLeWiz(cNomeCfp,@aWizard,.T.)
		Return	//Se por algum motivo a leitura do CFP falhar aborto a rotina.
	EndIf
	//Wizard preenchido antes de chamar function SpedFiscal, tratamento para RPC
Else
	aWizard := aWizScreen
EndIf

//Consistencias do SIGALOJA antes de iniciar o processamento do SPED Fiscal
If ("1"$aWizard[1][9]) 			//Removida condição de checar a tabela SLG por estourar error.log para quem não configurou módulo de loja e entrou com a opção de emitir ECF.
	If !aSPDSX3[FP_LG_SERPDV]
		MsgAlert(STR0015)		//"Deve ser criado o campo LG_SERPDV. Verificar os procedimentos para execução do U_UPDLOJ28 conforme o Boletim Tecnico do SPED Fiscal"
		Return
	EndIf
	If !ChkFile("SLX")
		MsgAlert(STR0016)		//"Deve ser criado arquivo Log de Cancelamento(SLX). Verificar os procedimentos para execução do U_UPDLOJ28 conforme o Boletim Tecnico do SPED Fiscal"
		Return
	Else
		If !aSPDSX3[FP_LX_ALIQICM]
			MsgAlert(STR0017)	//"Deve ser criado o campo LX_ALIQICM. Verificar os procedimentos para execução do U_UPDLOJ28 conforme o Boletim Tecnico do SPED Fiscal"
			Return
		EndIf
	EndIf
	If !SIX->(MsSeek("SFI"+"3"))
		MsgAlert(STR0019)		//"Deve ser criado um indice no arquivo SFI. Verificar os procedimentos para execução do U_UPDLOJ28 conforme o Boletim Tecnico do SPED Fiscal"
		Return
	EndIf
	If !lL2Sit  .AND. lTop
		MsgAlert(STR0014)		//"Deve ser criado o campo D2_SITTRIB. Verificar os procedimentos para execução do U_UPDLOJ40/U_UPDLOJ50 conforme o Boletim Tecnico do SPED Fiscal."
		Return
	EndIf
EndIf

//Quando o perfil nao for informado no parametro, pego o que foi configurado no WIZARD
If Empty(cPerfil)
	cPerfil 	:= SubStr(aWizard[2][4],1,1)
EndIf

//Criacao do TRB para ser alimentado durante o processamento da rotina
If !lJob
	oSay:cCaption := ("Criando tabelas temporarias")
	ProcessMessages()
EndIf 
SPDGerTrb(1,@aArq,@cAlias,, @oTempTab,@oBulkTMP)
dDataDe		:=	SToD(aWizard[1][1])
dDataAte	:=	SToD(aWizard[1][2])
cNrLivro	:=	aWizard[1][3]
cFilDe		:=	aWizard[2][2]
cFilAte		:=	aWizard[2][3]
cDir		:=	AllTrim(aWizard[1][4])
lImpCrdST	:=	Iif("1"$aWizard[1][11],.T.,.F.)
nApurIpi	:=	Iif(!Empty(aWizard[1][13]),Val(aWizard[1][13]),0)
lDifal		:= 	dDataDe >= ctod('01/01/2016') .AND. '1' $ aWizard[1][18] .and. aSPDSX2[AI_F0I] .and. aSPDSX2[AI_F0J] .and. ;
				aSPDSX2[AI_F0K] .AND.	aSPDSX3[FP_FT_DIFAL] .AND. aSPDSX3[FP_FT_VFCPDIF]

lIntGTP	    := FindFunction('GtpXFis') .And. GtpXFis(dDataDe, dDataAte)		

cC500C700	:= Left(aWizard[1][28],1) //1 - Ambos, 2 - Analitico, 3-Consolidado

//Tratamento para Linux onde a barra e invertida
If GetRemoteType() == 2 // REMOTE_LINUX  
	If !Empty(cDir) .And. (SubStr (cDir, Len (cDir), 1)<>"/")
		cDir	+=	"/"
	EndIf
Else
	If !Empty(cDir) .And. (SubStr (cDir, Len (cDir), 1)<>"\")
		cDir	+=	"\"
	EndIf
EndIf
cFileDest	:=	AllTrim(cDir)+AllTrim(aWizard[1][5])

//Verifico se devo abrir a tela para fazer o processamento de multifiliais
If !lJob .And. "1"$aWizard[1][12]
	aLisFil  :=	MatFilCalc(.T.,,,IIf("1"$aWizard[2][6],.T.,.F.),,IIf("1"$aWizard[2][6],1,0))
	If !Empty(aLisFil)
		cFilDe	:=	PadR("",FWGETTAMFILIAL)
		cFilAte	:=	Repl("Z",FWGETTAMFILIAL)
	Else
		MsgAlert(OemToAnsi(STR0018))		//"Nenhuma filial foi selecionada para o processamento. Será considerada a filial corrente."
		//Para considerar a filial corrente, preciso alem de atribuir o cFilAnt, preciso forcar a opcao 2 neste array que eh o resultado do wizard
		aWizard[1][12]	:=	"2 - Não"
		cFilDe			:=	cFilAnt
		cFilAte			:=	cFilAnt
	EndIf
ElseIf lJob
	aWizard[1][12]	:=	"2 - Não"
	cFilDe			:=	cFilAnt
	cFilAte			:=	cFilAnt
EndIf
If (Empty (cFilDe) .And. Empty (cFilAte))
	cFilDe	:=	cFilAnt
	cFilAte	:=	cFilAnt
EndIf

cDtHoraIni := DToC(Date()) + "-" + Time()

ConOut("INICIO PRSPED: " + DToC(Date()) + " - " + Time())

SetHierarq() //Carrega Hash de Hierarquia para gravação dos registros com suas definicoes de hierarquia de impressao.

Reg0000(aWizard, cAlias, dDataDe, dDataAte)

lRegCompST := GerCompST(aWizard,DTOS(dDataDe),DTOS(dDataAte))

If cVersao >= "014" .and. SubStr(aWizard[2][5], 1, 1) == "0"
	Reg0002 (aWizard, cAlias)
EndIf
Reg0005 (aWizard, cAlias, aSM0, lIsBlind)
Reg0100 (aWizard, cAlias, dDataDe, dDataAte)
SpedRg1010 (aWizard, cAlias, @aReg1010)

DbSelectArea("SM0")
SM0->(DbGoTop())
SM0->(MsSeek(cEmpAnt+cFilDe, .T.)) //Pego a filial mais proxima 
//Quando a opcao de seleciona filiais estiver configurada como sim, sera considerado as filiais selecionadas no browse. Caso contrario, valera o que estiver configurado na pergunta 'Filial DE/ATE'
Do While Eval(bWhileSM0)

	cFilAnt := FWGETCODFILIAL
	If Len(aLisFil)>0 .And. cFilAnt <= cFilAte
		nFilial := Ascan(aLisFil,{|x|x[2]==cFilAnt})
		If nFilial==0 .Or. !(aLisFil[nFilial,1]) //Filial não marcada, vai para proxima
			SM0->( dbSkip() )
			Loop
		EndIf
	Else
		If "1"$aWizard[1][12] //Somente faz skip se a opção de selecionar filiais estiver como Sim.
			SM0->(dbSkip())
			Loop
		EndIf
	EndIf
	
	fFreeObjXF() //Reinicializa a variavel __oStat3 Referente a query statment da tabela DUY, pois neste ponto posso estar em outra filial.

	FreeObj(oJRetCda) // Reinicia o Objeto da CDA por Filial
	oJRetCda := Nil

	FreeObj(oPosItXML) //Reinicia o Objeto  por Filial
	oPosItXML := Nil
	oPosItXML := JsonObject():New()   

	aSPDSX6  := SpedLoadX6()
	aSPDFil	 := fGetSpdFil() // Refazendo o cache xFilial 

	nEmpProc += 1
	//Qdo é um job ele nao atribui o objeto, por isso deve-se vetar o acesso ao objeto senão nao executa a função por Job
	If !lJob
		oSay:cCaption := (STR0023+cEmpAnt+"/"+cFilAnt+" - "+StrZero(nEmpProc,3)+"/"+StrZero(nCtdFil,3)) //"Processando empresa :"
		ProcessMessages()
	EndIf

	/*     *** Processamento do SIGALOJA ***
	REGISTRO C400 - EQUIPAMENTO ECF
	REGISTRO C405 - REDUCAO Z
	REGISTRO C410 - PIS E COFINS TOTALIZADOS NO DIA
	REGISTRO C420 - TOTALIZADORES PARCIAIS DA REDUCAO Z
	REGISTRO C425 - RESUMO DE ITENS DO MOVIMENTO DIARIO
	REGISTRO C460 - DOCUMENTO FISCAL EMITIDO POR ECF
	REGISTRO C470 - ITENS DO DOCUMENTO FISCAL EMITIDO POR ECF
	REGISTRO C490 - REGISTRO ANALITICO DO MOVIMENTO DIARIO
	REGISTRO C495 - RESUMO MENSAL DE ITENS DO ECF POR ESTABELECIMENTO
	*/	
	cFilSF3		:= aSPDFil[PFIL_SF3]
	cMVSUBTRIB	:= SpedPrSeq("MV_SUBTRI")
	cOpSemF		:=	SpedPrSeq("MV_OPSEMF") 
	cMVEstado	:= aSPDSX6[MV_ESTADO]
	lConcFil	:= aSPDSX6[MV_COFLSPD]
	lMVUFICSEP	:= cMvEstado$aSPDSX6[MV_UFICSEP]

	//Consistencias do no BlocoK antes de iniciar o processamento do SPED Fiscal
	lProcBLK := !(aWizard[1][16]=="9-Não") //(aWizard[1][16]=="1-Sim" .Or. aWizard[1][16]=="3-Sim - K200/K280")
	
	iF lProcBLK .And. cVersao >= "013" .and. !aExistBloc[24] //Verifica existencia do ponto de entrada para geração do bloco K		
		If lProsSPE .And. aSPDSX2[AI_D3K]
			lEstBLK := EstProsSPE(dDataDe,dDataAte)
			If !lEstBLK .And. !lJob
				MsgAlert(STR0037) // Inconsistencia no Bloco K, Verificar saldo de terceiros a Distribuir MATA037				
				SPDGerTrb(2,@aArq,@cAlias, , @oTempTab,@oBulkTMP)
				Return
			ElseIf lJob .And. !lEstBLK
				ConOut(STR0037)				
				SPDGerTrb(2,@aArq,@cAlias, , @oTempTab,@oBulkTMP)
				Return
			EndIf
		EndIf
		
		If lVldBlkTp .And. !VldBlkTp() 
			MsgAlert(STR0040) // Não é permitido mesmo tipo de produto em parâmetro MV_BLKTP(*) diferentes.
			Return
		EndIf
	EndIf	

	//Processa registros Giaf
	iF cVersao >= "013"
		lProcGiaf := Iif("S"$aReg1010[1][11] .OR. "S"$aReg1010[1][12] .OR. "S"$aReg1010[1][13],.T.,.F.)
	Endif

	//Processa registro modelo 66 para leiaute 14 ou superior
	c66 := Iif(cVersao >= '014','#66','')


	If ("1"$aWizard[1][9])
		If lTop 	//Ambiente TopConnect
			RegEcfTOP(	@aRegC400,	@aRegC405, 	@aRegC410,	@aRegC420,;	
						@aRegC425,	@aRegC460,	@aRegC470,	@aRegC490,;
						@aRegC495,	@aProdB1,	dDataDe,	dDataAte,;
						cPerfil,	cAlias,		@aReg0200,	@aReg0190,;
						@aReg0220,	@aReg1600,	@aReg0150,	aWizard,;
						lTop,		cMVEstado,	@nQtReg0200,lJob,;
						lLegisPer,	cNrLivro,	aArq,		@lRefazInd,	oSay, @aRegC430, @aReg1601 )
		Else
			RegEcf(	@aRegC400,	@aRegC405, 	@aRegC410,	@aRegC420,;	
					@aRegC425,	@aRegC460,	@aRegC470,	@aRegC490,;
					@aRegC495,	@aProdB1,	dDataDe,	dDataAte,;
					cPerfil,	cAlias,		@aReg0200,	@aReg0190,;
					@aReg0220,	@aReg1600,	@aReg0150,	aWizard,;
					lTop,		cMVEstado,	lLegisPer,	cNrLivro )
		EndIf
	EndIf

	// Registros do GTP que envolvem ECF...
	If lTop .And. lIntGTP
		RegEcfGTP(@aRegD350, @aRegD355, @aRegD360, @aRegD365, @aRegD370, @aRegD390, dDataDe, dDataAte, cPerfil)
	EndIf

	//---Indicador de geração do Bloco B---//
	If "1"$aWizard[1][25] .And. cMVEstado == 'DF' .And. cVersao >= "013" .And. AliasIndic("F1P") .And. lFISA300
		lBlocoB := .T.
		//---Verifica se declarante é contribuinte do ICMS---//
		lInscrito := Iif(Empty(SM0->M0_INSC) .Or. "ISENT"$SM0->M0_INSC .Or. aSPDSX6[MV_SM0CONT]=="2",.F.,.T.)
	EndIf

	//FOR criado para inserir o campo FT_TIPOMOV na query para usar o indice 1 da tabela SFT
	For nContMov := 1 to Len(aTpMov)
		//Chamando funcao que monta a query principal de processamento do SPED Fiscal		
		SPEDQryPri(,aTpMov[nContMov],dDataDe,dDataAte,@aF2EspVol,lTabComp,lIntTMS,cNrLivro,@cAliasSFT,lTabCD1,lTabCD0, lTabCDT, lCSDXML, lTabCDD, lTabCDE, lTabCDF, lTabCDG)
		//Para ambiente TOP, as tabelas abaixos estao no JOIN e o alias eh o mesmo da query³
		If lTop
			cAliasSF4 := cAliasSFT
			cAliasSB1 := cAliasSFT
			cAliasSA4 := cAliasSFT
			cAliasSB5 := cAliasSFT
			cAliasSD1 := cAliasSFT
			cAlsFormu := cAliasSFT

			//Atualiza Variavel Global PutGlbValue( 'cAliasSFT', cAliasSFT )
            //Issue DSERFIS1-30181
            PutGlbValue( 'cAliasSFT', cAliasSFT )
		EndIf

		If !lJob
			oSay:cCaption := ("Processando Documentos Fiscais...")
			ProcessMessages()
		EndIf
		
		lGera := !(lLegisPer .And. aTpMov[nContMov]$"S")

		Conout('	Inicio execucao movimentos:' + aTpMov[nContMov] + ' - ' + DToC(Date()) + " - " + Time())
		Do While !(cAliasSFT)->(Eof ())
			//Inicializacao de variaveis utilizadas no processamento
			cChvSFT  := (cAliasSFT)->(FT_TIPOMOV+FT_NFISCAL+FT_SERIE+FT_ESPECIE)
			cEspecie := AModNot((cAliasSFT)->FT_ESPECIE)		//Modelo NF
			//Quando modelo for 57#63#67 campo de origem e destino é obrigatorio no registro D100
			If cEspecie$"57#63#67" .And. Empty(cMunSM0)
				cMunSM0	:= Iif(Len(Alltrim(SM0->M0_CODMUN))<=5,UfCodIBGE(SM0->M0_ESTENT),"")+SM0->M0_CODMUN
			Endif
			//FT_PDV somente estarah alimentado quando se referir a nota fiscais de saida geradas pelo SIGALOJA.
			If !Empty((cAliasSFT)->FT_PDV) .AND. AllTrim((cAliasSFT)->FT_ESPECIE)$"CF|ECF"
				cEspecie	:=	"2D"
			ElseIf lBlocoB .AND. (cAliasSFT)->FT_TIPO == "S"
				
				If AllTrim((cAliasSFT)->FT_ESPECIE) == Alltrim(Substr(cMvNfSS,At("=",cMvNfSS)+1,5))								
					cEspecie := Left(cMvNfSS,At("=",cMvNfSS)-1)
				
				ElseIF Empty(cEspecie)
					cEspecie := "03"
				EndIF

			EndIf
			//Determina o Alias para as Tabelas SF1/SF2 e SD1/SD2.
			cEntSai			:=	Iif ("E"$(cAliasSFT)->FT_TIPOMOV, "1", "2")
			cAlsSF			:=	"SF"+cEntSai	//Determina o Alias para as Tabelas SF1/SF2
			cAlsSD			:=	"SD"+cEntSai	//Determina o Alias para as Tabelas SD1/SD2
			//Determina o Alias para as Tabelas SA1/SA2
			cAlsSA			:=	"SA"+Iif ((cEntSai=="1" .And. !(cAliasSFT)->FT_TIPO$"BD") .or.;
										  (cEntSai=="2" .And. (cAliasSFT)->FT_TIPO$"BD"), "2", "1")	//Determina o Alias para as Tabelas SA1/SA2
			//Trata Devolução de Serviço
			if cEntSai == "1" .And. cAlsSA=="SA2" .And. cAlsSD="SD1" .And. (cAlsSD)->D1_TIPO = "D" .And. (cAliasSFT)->FT_TIPO=="S"
				// Garante que trata-se de um item da mesma nota.
				If (cAliasSFT)->(FT_FILIAL+FT_NFISCAL+FT_SERIE) == (cAlsSD)->(D1_FILIAL+D1_DOC+D1_SERIE)
					cAlsSA:="SA1"
				EndIf
			Endif

			cFilAlsSA 		:= IIF(cAlsSA == "SA1", aSPDFil[PFIL_SA1], aSPDFil[PFIL_SA2]) //cacheia a xfilial

							//   1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26
			aTotaliza		:=	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
			//cRelacDoc++		//Utilizado para relacionar os documentos fiscais aos seus elementos inferiores/dependentes
			nRelacAux++
			lPriItem		:= .T.

			nItem			:=	1
			aLanCDA			:=	{}
			lCompIcm		:=	.F.
			cFrete			:=	""
			cCodMunDest		:=  ""
			dDtarec			:=	CToD("  /  /  ")
			cSitExt			:=	""
			cIndEmit		:=	""
			aParFil			:=	{}
			aParFil2		:=	{}
			aHistSA			:=	{}
			aHistSA4		:=	{}
			aHistSB1		:=	{}
			aInfCompl		:=	{"",""}
			aAreaSA			:=	{}
			cCdMunOri		:=	""
			aPartREM		:=	{}
			cCdMunDes		:=	""
			aPartDES		:=	{}
			aPartCON		:=	{}
			aPartDPC		:=	{}
			lGerouC170		:=	.F.
			aParcTit		:=	{}
			nPosGener		:=	0
			nPosC600		:=	0
			nPosC700		:=	0
			nPosD600		:=	0
			nRecnoSF3		:=	Iif(lTop,(cAliasSFT)->SF3RECNO,Nil)			
			nRecnoDT6		:=	Iif(lTop .And. lIntTMS,(cAliasSFT)->DT6RECNO,Nil)
			nRecnoCDT		:=	Iif(lTop .And. lTabCDT,(cAliasSFT)->CDTRECNO,Nil)
			nRecnoDUD1		:=	Iif(lTop .And. lIntTMS,(cAliasSFT)->DUD1RECNO,Nil)
			nRecnoDUD2		:=	Iif(lTop .And. lIntTMS,(cAliasSFT)->DUD2RECNO,Nil)
			nRecnoDUD		:=  0
			nRecnoCDC		:=	Iif(lTop .And. lTabComp,(cAliasSFT)->CDCRECNO,Nil)
			nRecnoCDD		:=	Iif(lTop .And. lTabCDD,(cAliasSFT)->CDDRECNO,Nil)
			nRecnoCDE		:=	Iif(lTop .And. lTabCDE,(cAliasSFT)->CDERECNO,Nil)
			nRecnoCDF		:=	Iif(lTop .And. lTabCDF,(cAliasSFT)->CDFRECNO,Nil)
			nRecnoCDG		:=	Iif(lTop .And. lTabCDG,(cAliasSFT)->CDGRECNO,Nil)
			aResF3FT		:=	{}
			aAvImport		:=	{}
			aPTransp		:=	{}
			lPisZero		:=	.F.
			lCofZero		:=	.F.
			lFirstNF		:=	.T.
			nPosB020		:=  0
			nPosB030		:=  0
			//Variaveis de registros
			aRegC500		:=	{}
			aRegC510		:=	{}
			aRegC100		:=	{}
			aRegC190		:=	{}
			aRegC191		:=	{}
			aLancFis		:=	{}
			aRegC390		:=	{}
			aRegC590		:=	{}
			aRegC591		:=	{}
			aRegD190		:=	{}
			aRegD590		:=	{}
			aRegC110		:=	{}
			aRegC111		:=	{}
			aRegC112		:=	{}
			aRegC113		:=	{}
			aRegC114		:=	{}
			aRegC116		:=	{}
			aRegC115		:=	{}
			aRegD500		:=	{}
			aRegD510		:=	{}
			aRegC130		:=	{"C130", 0, 0, 0, 0, 0, 0, 0}
			aRegB020        :=  {}
			aRegB025        :=  {}
			aRegB030		:=  {}
			aRegB035		:=  {}
			aPartSM0        :=  {}
			//Variaveis de seek
			lAchouSFU		:=	.F.
			lAchouSFX		:=	.F.
			lAchouCD0		:=	.F.
			lAchouCD2		:=	.F.
			lAchouCDG		:=	.F.
			lAchouCDT		:=	.F.
			lAchouCDC		:=	.F.
			lAchouCDD		:=	.F.
			lAchouCDE		:=	.F.
			lAchouCDF		:=	.F.
			lAchouCD3		:=	.F.
			lAchouCD4		:=	.F.
			lAchouCD5		:=	.F.
			lAchouCD6		:=	.F.
			lAchouDA3		:=	.F.
			lAchouSF4		:=	.F.
			lAchouDT5		:=	.F.
			lAchouDT6		:=	.F.
			lAchouDUD		:=	.F.
			lAchouDT8		:=	.F.
			lAchouDTC		:=	.F.
			lAchouCDA		:=	.F.
			lAchouSF3		:=  .F.

			lAchouDUL		:=	.F.
			lAchSFSD		:=	.F.
			lAchouCCE		:=	.F.
			lAchou2DUL		:=	.F.
			lAchouDTQ		:=	.F.
			lAchouDTR		:=	.F.
			lGeraC177B		:=	.F.
			lproctit	    :=  .T. 
			lEICImport		:=  .F.

			//Flag de gravacoes
			lGravaC500		:=	.F.
			lGravaC700		:=	.F.
			lGrava1500		:=	.F.
			lGravaD500		:=	.F.
			lGrava0150		:=	.F.
			nDifalDest		:= 	0
			nDifalOrig		:= 	0
			nDifalFEcp		:= 	0
			//Campos das tabelas SF/SD
			cCmpEst			:=	SubStr(cAlsSA,2,2)+"_EST"
			cCmpUm			:=	SubStr(cAlsSD,2,2)+"_UM"
			cCmpTipo		:=	SubStr(cAlsSD,2,2)+"_TIPO"
			cCmpTes			:=	SubStr(cAlsSD,2,2)+"_TES"
			cCmpDescIcm		:=	SubStr(cAlsSD,2,2)+"_DESCICM"
			cCmpPrefixo		:=	SubStr(cAlsSF,2,2)+"_PREFIXO"
			cCmpDupl		:=	SubStr(cAlsSF,2,2)+"_DUPL"
			cCmpMenNota		:=	SubStr(cAlsSF,2,2)+"_MENNOTA"
			cCmpMenNota		:=	Iif((cAlsSF)->(FieldPos(cCmpMenNota))>0, cCmpMenNota, "")
			cCmpTrans		:=	Iif(cEntSai=="2",SubStr(cAlsSF,2,2)+"_TRANSP","")
			cCmpNFCupom		:=	Iif(cEntSai=="2",SubStr(cAlsSF,2,2)+"_NFCUPOM","")
			cCmpPBruto		:=	Iif(cEntSai=="2",SubStr(cAlsSF,2,2)+"_PBRUTO","")
			cCmpPLiqui		:=	Iif(cEntSai=="2",SubStr(cAlsSF,2,2)+"_PLIQUI","")
			cCmpVeic1		:=	Iif(cEntSai=="2",SubStr(cAlsSF,2,2)+"_VEICUL1","")
			cCmpVeic2		:=	Iif(cEntSai=="2",SubStr(cAlsSF,2,2)+"_VEICUL2","")
			cCmpVeic3		:=	Iif(cEntSai=="2",SubStr(cAlsSF,2,2)+"_VEICUL3","")
			cCmpSimpN		:=	SubStr(cAlsSA,2,2)+"_SIMPNAC"
			cCmpSimpN		:=	Iif((cAlsSA)->(FieldPos(cCmpSimpN))>0, cCmpSimpN, "")
			cCmpRegPB		:=	SubStr(cAlsSA,2,2)+"_REGPB"
			cCmpRegPB		:=	Iif((cAlsSA)->(FieldPos(cCmpRegPB))>0, cCmpRegPB, "")
			cCmpFrete		:=	SubStr(cAlsSF, 2, 2)+"_FRETE"
			cCmpHawb		:=	"F1_HAWB"
			cCmpTPCTE		:=	"F1_TPCTE"
			cCmpTPCTE		:=	Iif((cAlsSF)->(FieldPos(cCmpTPCTE))>0,cCmpTPCTE,"")
			cCmpUfOriTr     :=  "F1_UFORITR"
			cCmpUfDesTr     :=  "F1_UFDESTR"
			cCmpMuOriTr     :=  "F1_MUORITR"
			cCmpMuDesTr     :=  "F1_MUDESTR"
			cCpUfOri     	:=  "F2_UFORIG"
			cCpUfDes     	:=  "F2_UFDEST"
			cCpMuOri     	:=  "F2_CMUNOR"
			cCpMuDes     	:=  "F2_CMUNDE"			
			//Variaveis de Alias de tabelas
			cAliasCDT		:=	"CDT"
			cAliasDT5		:=	"DT5"
			cAliasDT8		:=	"DT8"
			cAliasDTC		:=	"DTC"
			cAliasDUD		:=	"DUD"
			cAliasDUL		:=	"DUL"
			cAliasCDC		:=	"CDC"
			cAliasCDD		:=	"CDD"
			cAliasCDE		:=	"CDE"
			cAliasCDF		:=	"CDF"
			cAliasCDG		:=	"CDG"
			cAliasCD5		:=	"CD5"
			cAliasCD2		:=	"CD2"
			cAliasCD4		:=	"CD4"
			cAliasCD6		:=	"CD6"
			cTipoNf			:= (&(cAlsSF+"->"+SubStr (cAlsSF,2,2)+"_TIPO"))
			nPosD400        := 0
			cSitDocGZU      := ""
			aDadosGZU       := {}
			lFindDT6Re		:= .F.
			lFindDT6Co		:= .F.
			nContXml		:= 0
			oPosItXML		:= Nil
			nLenCDA			:= 0

			//Efetuo o pocisionamento da tabela SF3 para utilizar a tabela na funcao SPEDSitDoc 
			cChvSeek	:= cFilSF3+(cAliasSFT)->(DToS(FT_ENTRADA)+FT_NFISCAL+FT_SERIE+FT_CLIEFOR+FT_LOJA+FT_CFOP+STR(FT_ALIQICM,5,2))
			lAchouSF3 	:= SPEDSeek("SF3",,cChvSeek,nRecnoSF3)
						
			If aSPDSX3[FP_F3_PROTOC]
				cProtocolo	:= (cAliasSFT)->F3_PROTOC
			Endif
			//Efetuo o pocisionamento da tabela SA(1/2) para utilizar a tabela na funcao SPEDSitDoc
			If !lTop
				SPEDSeek(cAlsSA,,cFilAlsSA+(cAliasSFT)->(FT_CLIEFOR+FT_LOJA))
			EndIf
			/*Tratamento para o campo FRETE
			1 - Verifica existencia do campo CDT_INDFRT no complemento da Nota Fiscal. Se existir e estiver preenchido, utiliza o que foi selecionado.
			2 - Senao, verifica parametro MV_OPSEMF. Se o parametro estiver configurado, utilizar "Sem Frete" Senao, faz a verificacao 'padrao'
			3 - Verificacao padrao: se for CIF ou FOB, entao e' Emitente. 
			Tratamento para Situação extemporânea de documentos:
			1 - Verifica existencia dos campo na variavel lSitDocExt 
			2 - Atraves da função SPEDSitDoc encontra a situação de extemporaneidade */
			aParFil	:=	{}
			aAdd(aParFil,(cAliasSFT)->FT_TIPOMOV)
			aAdd(aParFil,(cAliasSFT)->FT_NFISCAL)
			aAdd(aParFil,(cAliasSFT)->FT_SERIE)
			aAdd(aParFil,(cAliasSFT)->FT_CLIEFOR)
			aAdd(aParFil,(cAliasSFT)->FT_LOJA)

			If lTabCDT 

				If nRecnoCDT != Nil .And. nRecnoCDT > 0
					/* Funcao que efetua um SELECT ou INDREGUA na tabela CDT conforme param passados. Se existir mais de um CDT para a mesma NF,
					utilizo somente o primeiro, pois conforme manual, soh pode existir um por documento   */ 
					cCDTChv := aSPDFil[PFIL_CDT]+aParFil[1]+aParFil[2]+aParFil[3]+aParFil[4]+aParFil[5]
					If (cAliasSFT)->COUNTCDT > 1
						lAchouCDT := SPEDSeek(cAliasCDT, 1, cCDTChv)	
					Else						
						lAchouCDT := SPEDSeek(cAliasCDT, 1, cCDTChv, nRecnoCDT)
					EndIf	
				EndIf	
				
				lSitDocCDT:= lSitDocExt .AND. lAchouCDT
				If lAchouCDT
					If lSitDocExt
						dDtarec := (cAliasCDT)->CDT_DTAREC
						cSitExt := (cAliasCDT)->CDT_SITEXT
					EndIf
					If lIndFrete
						cFrete := (cAliasCDT)->CDT_INDFRT
					EndIf
					IF aSPDSX3[FP_CDT_MDEST] .AND. aSPDSX3[FP_CDT_UFDEST]
						cCodMunDest := UfCodIBGE((cAliasCDT)->CDT_UFDEST) + (cAliasCDT)->CDT_MDEST
					Endif
					/*Como o registro da CDT pode ter  as configuracoes basicas, sem relacionar  o codigo das informacoes complementares, utilizo o campo acima para definir o 
					frete e depois valido novamente para saber se posso utilizar nos tratamentos seguintes. */
					lAchouCDT := !Empty((cAliasCDT)->CDT_IFCOMP)
				EndIf
			EndIf

			If !(cEspecie$"01#1B#02#2D#03#3A#3B#04#06#07#08#8B#09#10#11#13#14#15#16#21#22#26#27#28#29#55#57#59#63#65#67"+c66)
				(cAliasSFT)->(DbSkip ())
				Loop
			EndIf

			/* As informacoes CTR e NFST necessarias para o SPED somente estao disponiveis
			quando o TMS estiver envolvido (SAIDAS) ou ENTRADAS quando envolver aviso de recebimento.*/
			If ((cEspecie$"07#08") .And. (!lIntTMS .And. !lSpedRTms .And. "S"$(cAliasSFT)->FT_TIPOMOV))
				(cAliasSFT)->(DbSkip ())
				Loop
			EndIf

			cSituaDoc  := SPEDSitDoc(,cAliasSFT,Iif(lTop,cAliasSFT,cAlsSA),cCmpSimpN,,,(cMVEstado$cUFRESpd),lSitDocCDT,cSitExt, , , , ,lAchouSF3)
			cSitDocInf := SPEDSitInf(cAliasSFT,, nRecnoSF3)
			
			/*Para as notas fiscais de transportes vindas do TMS sempre devera haver um DT6 correspondente, caso nao haja, saltar para a proxima nota.
			 Obs.Instrucoes passadas pela equipe do TMS. */
			If cEspecie$"#07#08#8B#09#10#11#26#27#57" .And. "S"$(cAliasSFT)->FT_TIPOMOV .And. lIntTMS .AND. !lSpedRTms
				If !(lAchouDT6 := (nRecnoDT6 != Nil .And. nRecnoDT6 > 0)) .And. !cSituaDoc$"02/03/04/05" //Cancelado
					(cAliasSFT)->(DbSkip ())
					Loop			
				EndIf

				If lAchouDT6 .And. cEntSai=="2" // Somente o prestador deve informar estes registros				
					
					//³Remetente do conhecimento³					
					If !Empty((cAliasSFT)->(DT6_CLIREM+DT6_LOJREM))
						cChvSeek 	:= cFilAlsSA+(cAliasSFT)->(DT6_CLIREM+DT6_LOJREM)
						aPartREM 	:= fHashInfP(cAlsSA, cChvSeek)
						If Len(aPartREM) > 0
							cCdMunOri 	:= TMSCodMun((cAliasSFT)->DT6_CDRORI,.T., , aPartREM[7], aPartREM[13])
						EndIf	
					EndIf	
					lFindDT6Re	:= Len(aPartREM) > 0

					//³Destinatario do conhecimento³
					If !Empty((cAliasSFT)->(DT6_CLICAL+DT6_LOJCAL))
						cChvSeek 	:= cFilAlsSA+(cAliasSFT)->(DT6_CLICAL+DT6_LOJCAL)
						aPartDES 	:= fHashInfP(cAlsSA, cChvSeek)
						If Len(aPartDES) > 0 
							cCdMunDes 	:= TMSCodMun((cAliasSFT)->DT6_CDRCAL,.T., , aPartDES[7], aPartDES[13])
						EndIf	
					EndIf	
					lFindDT6Co	:= Len(aPartDES) > 0 					
					
					If ("1"$aWizard[1][7])
						//³Consignatario do conhecimento³
						If !Empty((cAliasSFT)->(DT6_CLICON+DT6_LOJCON))
							cChvSeek := cFilAlsSA+(cAliasSFT)->(DT6_CLICON+DT6_LOJCON)	
							aPartCON := fHashInfP(cAlsSA, cChvSeek)
						EndIf	

						//³Despachante da mercadoria³
						If !Empty((cAliasSFT)->(DT6_CLIDPC+DT6_LOJDPC))
							cChvSeek := cFilAlsSA+(cAliasSFT)->(DT6_CLIDPC+DT6_LOJDPC)
							aPartDPC := fHashInfP(cAlsSA, cChvSeek)
						EndIf	

					EndIf	
				EndIf					
			EndIf
			
			/* Inicio do processamento da rotina apos execucao dos filtros anteriores. Quando for TOP, os referidos campos já estao no SELECT³ */
			If lTop
				lAchSFSD	:=	!cSituaDoc$"02/03/04/05"
				If lAchSFSD
					lCompIcm	:=	(cAliasSFT)->(&(cCmpTipo))	//D1/D2_TIPO
					
					/* Nesta execucao do FOR, altero o conteudo do array de onte estah o nome dos campos para seus conteudos. 
					Este array tem a mesma finalidade do aCmpAntSFT. Como nao posso utiliza-lo, tive de criar outro, pois os campos sao variaveis e depende da base.  */
					For nX := 1 To Len(aF2EspVol)
						aF2EspVol[nX,2]	:=	(cAliasSFT)->(&(aF2EspVol[nX,1]))
						aF2EspVol[nX,4]	:=	(cAliasSFT)->(&(aF2EspVol[nX,3]))
					Next nX
				EndIf
			Else
				SPEDSeek(cAlsSA,,cFilAlsSA+(cAliasSFT)->(FT_CLIEFOR+FT_LOJA))
				lAchSFSD	:=	SPEDSeek(cAlsSF,,xFilial(cAlsSF)+(cAliasSFT)->(FT_NFISCAL+FT_SERIE+FT_CLIEFOR+FT_LOJA))
				If lAchSFSD
					lCompIcm	:=	(&(cAlsSF+"->"+SubStr (cAlsSF,2,2)+"_TIPO")=="I") // Indica se NF de complemento de ICMS
					
					/* Nesta execucao do FOR, altero o conteudo do array de onte estah o nome dos campos para seus conteudos. 
					 Este array tem a mesma finalidade do aCmpAntSFT. Como nao posso utiliza-lo, tive de criar outro, pois os campos sao variaveis e depende da base. */
					For nX := 1 To Len(aF2EspVol)
						aF2EspVol[nX,2]	:=	(cAlsSF)->(&(aF2EspVol[nX,1]))
						aF2EspVol[nX,4]	:=	(cAlsSF)->(&(aF2EspVol[nX,3]))
					Next nX
				EndIf
			EndIf
			//Obtendo o historico de alteracoes cadastrais
			If lHistTab
				If cEntSai=="2" .And. lAchSFSD
					If lTop .And. !Empty(&(cAliasSFT+"->"+cCmpTrans))
						aHistSA4	:=	MsConHist("SA4",,,dDataDe,,,&(cAliasSFT+"->"+cCmpTrans))
						aPTransp	:=	InfPartDoc("SA4",dDataDe,dDataAte,cAliasSFT,,aHistSA4)
					ElseIf !lTop .And. !Empty(&(cAlsSF+"->"+cCmpTrans)) .And. SPEDSeek(cAliasSA4,,xFilial(cAliasSA4)+&(cAlsSF+"->"+cCmpTrans))
						aHistSA4	:=	MsConHist("SA4",,,dDataDe,,,&(cAlsSF+"->"+cCmpTrans))
						aPTransp	:=	InfPartDoc("SA4",dDataDe,dDataAte,cAliasSFT,,aHistSA4)
					EndIf
				EndIf
			ElseIf cEntSai=="2" .And. lAchSFSD .And. !lTop .And. !Empty(&(cAlsSF+"->"+cCmpTrans))
				SPEDSeek(cAliasSA4,,xFilial(cAliasSA4)+&(cAlsSF+"->"+cCmpTrans))
				aPTransp	:=	InfPartDoc("SA4",dDataDe,dDataAte,cAliasSFT,,aHistSA4)
			EndIf
			// SAIDA : Quando for NF de Saida e houver integracao com o TMS  utilizo a regra do modulo TMS para obter alguns dados do transporte
			If lAchouDT6
				aParFil2	:=	{}
				If (cAliasSFT)->DT6_DOCTMS<>StrZero(8,Len((cAliasSFT)->DT6_DOCTMS))
					aAdd(aParFil2,(cAliasSFT)->DT6_FILDOC)
					aAdd(aParFil2,(cAliasSFT)->DT6_DOC)
					aAdd(aParFil2,(cAliasSFT)->DT6_SERIE)
					aAdd(aParFil2,(cAliasSFT)->DT6_FILORI)
					nRecnoDUD := nRecnoDUD1 
				Else
					aAdd(aParFil2,(cAliasSFT)->DT6_FILDCO)
					aAdd(aParFil2,(cAliasSFT)->DT6_DOCDCO)
					aAdd(aParFil2,(cAliasSFT)->DT6_SERDCO)
					aAdd(aParFil2,(cAliasSFT)->DT6_FILORI)
					nRecnoDUD := nRecnoDUD2
				EndIf	

				If cEntSai=="2" .And. ("1"$aWizard[1][7]) .And. lGera .And. cPerfil <> "C"

					cChvSeekv := aSPDFil[PFIL_DUD]+aParFil2[1]+aParFil2[2]+aParFil2[3]+aParFil2[4]									
					If (lAchouDUD := (nRecnoDUD != Nil .And. nRecnoDUD > 0))
						//Posicionando tabelas do TMS. O modulo SIGATMS NAO possui base DBF/ADS, somente TOP
						If (lAchouDTQ := SpedSeek(cAliasDTQ,2, ( aSPDFil[PFIL_DTQ]+(cAliasSFT)->(DUD_FILORI+DUD_VIAGEM) ) ))  ;
							.AND. (lAchouDTR:=SpedSeek(cAliasDTR,1, ( aSPDFil[PFIL_DTR]+(cAliasDTQ)->(DTQ_FILORI+DTQ_VIAGEM)  ) )) 
							If !(lAchouDA3 := SPEDSeek("DA3",1, (aSPDFil[PFIL_DA3]+(cAliasDTR)->DTR_CODVEI))) 							
								lAchouDA3 := SPEDSeek("DA3",1, (aSPDFil[PFIL_DA3]+(cAliasDTR)->DTR_CODRB1)) 							  								
							EndIf
							
						EndIf						

						lAuxDA3Ant := lAchouDA3 
					Else
						lAchouDA3 := lAuxDA3Ant	
					EndIf
										
					If cEspecie$"08#8B#09#10"
						cChvSeekv	:=  aSPDFil[PFIL_DT8]+aParFil2[1]+aParFil2[2]+ aParFil2[3]
						lAchouDT8	:=  SPEDSeek(cAliasDT8,2,cChvSeekv)
					EndIf	

					If cEspecie <> "57" //Busca necessaria apenas para especies diferentes de 57
						cChvSeekv := aSPDFil[PFIL_DT5] + aParFil2[1] + aParFil2[2]+ aParFil2[3]
						If (lAchouDT5 := SPEDSeek(cAliasDT5,3, cChvSeekv))
							If !lDUESol
								lAchou2DUL := SPEDSeek(cAliasDUL,1,aSPDFil[PFIL_DUL]+(cAliasDT5)->(DT5_DDD+DT5_TEL+DT5_SEQEND) )
							Else
								lAchou2DUL := SPEDSeek(cAliasDUL,3,aSPDFil[PFIL_DUL]+(cAliasDT5)->(DT5_CODSOL+DT5_SEQEND) )
							EndIf	
						EndIf

						cDTCChv	:= aSPDFil[PFIL_DTC]+aParFil2[1]+aParFil2[2]+ aParFil2[3]
						If lAchouDTC := SPEDSeek(cAliasDTC,3,cDTCChv)
							aParFil2 :=	{}
							aAdd(aParFil2,(cAliasSFT)->DT6_CLIDES)
							aAdd(aParFil2,(cAliasSFT)->DT6_LOJDES)
							aAdd(aParFil2,(cAliasDTC)->DTC_SQEDES)
							lAchouDUL := SPEDSeek(cAliasDUL,2,aSPDFil[PFIL_DUL]+aParFil2[1]+aParFil2[2]+aParFil2[3]) 
						EndIf
					EndIf	
				EndIf													
			// ENTRADA  :  Utilizo o aviso de recebimento do compras para obter alguns dados do transporte na entrada 
			Else

				lAchouDUD := .F.

				If cEntSai=="1"
					cChvSeek	:=	aSPDFil[PFIL_DB2]+(cAliasSFT)->(FT_NFISCAL+FT_SERIE)
					If SPEDSeek("DB2",,cChvSeek)
						cChvSeek	:=	aSPDFil[PFIL_DB1]+DB2->DB2_NRAVRC
						If SPEDSeek("DB1",,cChvSeek)
							cChvSeek	:=	aSPDFil[PFIL_DB3]+DB2->DB2_NRAVRC+DB2->DB2_ITEM
							If SPEDSeek("DB3",,cChvSeek)
								cChvSeek	:=	aSPDFil[PFIL_DA3]+DB1->DB1_IDVEI
								lAchouDA3	:=	SPEDSeek("DA3",,cChvSeek)
							EndIf
						EndIf
					EndIf	
				EndIf
			EndIf

			//lNewCFrt - Verifica se deve adotar a nova regra do codigo Indicador tipo frete Conforme publicado no guia pratico Versão 2.0.7
			lNewCFrt := ((cAliasSFT)->FT_EMISSAO >= CtoD("01/01/2012"))

			//Tratamento para obter o tipo de frete quando houver integracao com o TMS
			If cEspecie$"#07#08#8B#09#10#11#26#27#57" .And. "S"$(cAliasSFT)->FT_TIPOMOV .And. lIntTMS .And. lAchouDT6
				If !Empty(cOpSemF) .And. AllTrim((cAliasSFT)->FT_CFOP)$cOpSemF
					cFrete	:= "9"
				ElseIf ((cAliasSFT)->DT6_DEVFRE$"1" .AND. (cAliasSFT)->DT6_TIPFRE == "1")
					cFrete	:=	"1" 							//Por conta do Remetente = CIF = 1
				ElseIf ((cAliasSFT)->DT6_DEVFRE$"2")
					cFrete	:=	Iif(lNewCFrt,"1","2") 			//Por conta do destinatario = FOB = 2
				Else
					cFrete	:=	Iif(lNewCFrt,"2","0") 			//Apesar do sistema gravar 2=FOB, o devedor do frete pode ser o consignatario, espachante ou outros.
				EndIf

			//Tratamento para obter o tipo de frete quando for simples faturamento/compras atraves do pedido
			Else
				If Empty(cFrete)
					If !Empty(cOpSemF) .And. AllTrim((cAliasSFT)->FT_CFOP)$cOpSemF
						cFrete	:= "9"
					Else
						//Utilizo a informacao configurada nos pedidos de venda/compra
						cFrete := SPEDSitFrt(cAliasSFT,cAlsSD,lTop,cAlsSF,cCmpFrete,lAchSFSD,,lNewCFrt)
					EndIf
				ElseIf lNewCFrt .And. lAchouCDT
					//0- Por conta do emitente
					If Alltrim(cFrete)=="1"
						cFrete := "0" 
					//1- Por conta do destinatário/remetente
					ElseIf Alltrim(cFrete)=="2"
						cFrete := "1" 
					//2- Por conta de terceiros
					ElseIf Alltrim(cFrete)=="0"
						cFrete := "2"
					EndIf
				EndIf
			EndIf

			//Tratamento para novo campo de faturamento Cliente entrega			
			IF cEntSai=="2" .and. Empty(cCodMunDest) .and. aSPDSX3[FP_F2_CLIREM] .and. aSPDSX3[FP_F2_LOJAREM] .and. (cAliasSFT)->FT_TIPO!="D"
				If !Empty((cAliasSFT)->F2_CLIREM)					
					If SPEDSeek("SA1",,aSPDFil[PFIL_SA1]+(cAliasSFT)->(F2_CLIREM + F2_LOJAREM))
						cCodMunDest := UfCodIBGE(SA1->A1_EST) + SA1->A1_COD_MUN
					Endif
				Endif
			Endif

			// Tratamento para verificar o tipo de emissao do documento fiscal 
			//Emissao de Terceiros
			If (Empty ((cAliasSFT)->FT_FORMUL)) .And. cEntSai=="1"
				cIndEmit := "1"
			//Emissao Propria
			ElseIf (Empty ((cAliasSFT)->FT_FORMUL)) .And. cEntSai=="2"
				cIndEmit := "0"
			Else
				//Emissao Propria
				If ("S"$(cAliasSFT)->FT_FORMUL)
					cIndEmit := "0"
				//Emissao de Terceiros
				Else
					cIndEmit := "1"
				EndIf
			EndIf
			//Efetua o tratamento da data de entrada/saida atraves do PE SPDFIS08 se existir ou atraves do parametro MV_CF3ENTR
			If lSPDFIS08
				dDtEntSai	:=	ExecBlock("SPDFIS08", .F., .F., {cAliasSFT})
			Else
				dDtEntSai	:=	Iif((cEntSai=="2" .And. lMVCF3ENTR) .Or. cEntSai=="1", (cAliasSFT)->FT_ENTRADA, CToD("  /  /  "))
			Endif
			//Campos que se referem ao cabecalho do documento fiscal
			aCmpAntSFT	:=	{	(cAliasSFT)->FT_NFISCAL,;																//01 - Doc. Fiscal
								(cAliasSFT)->FT_SERIE,;																	//02 - Serie NF
								(cAliasSFT)->FT_CLIEFOR,;																//03 - Cliente/Fornecedor
								(cAliasSFT)->FT_LOJA,;																	//04 - Codigo Loja
								dDtEntSai,;																				//05 - Data Docto.
								(cAliasSFT)->FT_EMISSAO,;	 															//06 - Data Emissao
								(cAliasSFT)->FT_DTCANC,;	   															//07 - Data Canc.
								(cAliasSFT)->FT_FORMUL,;																//08 - Formulario Proprio
								(cAliasSFT)->FT_CFOP,;																	//09 - CFOP
								"",;																					//10 - 
								(cAliasSFT)->FT_ALIQICM,;																//11 - Aliq. ICMS
								(cAliasSFT)->FT_PDV,;																	//12 - Nro. PDV
								(cAliasSFT)->FT_BASEICM,;																//13 - Base  ICMS
								(cAliasSFT)->FT_ALIQICM,;																//14 - Aliq. ICMS
								(cAliasSFT)->FT_VALICM,;																//15 - Valor ICMS
								(cAliasSFT)->FT_ISENICM,;																//16 - Valor Isento ICMS
								(cAliasSFT)->FT_OUTRICM,;																//17 - Outros ICMS
								(cAliasSFT)->FT_ICMSRET,;																//18 - ICMS Retido ST
								(cAliasSFT)->FT_CONTA,;																	//19 - Conta Contabil
								(cAliasSFT)->FT_TIPO,;																	//20 - Tipo Lancamento
								cFrete,;																				//21 - Tipo Frete
								(cAliasSFT)->FT_FILIAL,;																//22 - Filial
								(cAliasSFT)->FT_ESTADO,;																//23 - Estado
								(cAliasSFT)->FT_OBSERV,;																//24 - Observacao
								(cAliasSFT)->FT_CHVNFE,;																//25 - Chave NFE
								cIndEmit,;																				//26 - Tipo Emissao
								Iif(lAchSFSD,(Iif(lTop,cAliasSFT,cAlsSF))->(&(cCmpPrefixo)),""),;						//27 - Prefixo
								Iif(lAchSFSD,(Iif(lTop,cAliasSFT,cAlsSF))->(&(cCmpDupl)),""),;							//28 - Duplicata
								Iif(lAchSFSD,(Iif(lTop,cAliasSFT,cAlsSF))->(&(cCmpNFCupom)),""),;						//29 - Cupom Fiscal
								Iif(lAchSFSD,(Iif(lTop,cAliasSFT,cAlsSF))->(&(cCmpTrans)),""),;							//30 - Transportadora
								Iif(lAchSFSD,(Iif(lTop,cAliasSFT,cAlsSF))->(&(cCmpPBruto)),0),;							//31 - Peso Bruto
								Iif(lAchSFSD,(Iif(lTop,cAliasSFT,cAlsSF))->(&(cCmpPLiqui)),0),;							//32 - Peso Liquido
								Iif(lAchSFSD,(Iif(lTop,cAliasSFT,cAlsSF))->(&(cCmpVeic1)),""),;							//33 - Veiculo1
								Iif(lAchSFSD,(Iif(lTop,cAliasSFT,cAlsSF))->(&(cCmpVeic2)),""),;							//34 - Veiculo2
								Iif(lAchSFSD,(Iif(lTop,cAliasSFT,cAlsSF))->(&(cCmpVeic3)),""),;							//35 - Veiculo3
								(Iif(lTop,cAliasSFT,cAlsSA))->(&(cCmpSimpN)),;											//36 - Optante Simples Nacional
								(Iif(lTop,cAliasSFT,cAlsSA))->(&(cCmpRegPB)),;											//37 - Regime Paraiba
								(cAliasSFT)->FT_NFORI,;                                                					//38 - Nota Fiscal Original
								(cAliasSFT)->FT_SERORI,;																//39 - Serie da Nota fiscal original
								(Iif(lTop,cAliasSFT,cAlsSF))->(Iif(!Empty(cCmpTPCTE) .And. cEntSai=="1",&(cCmpTPCTE),"")),;	//40 - Flag de tipo de CTE na entrada
								dDtarec,; 																				//41 - Data de Recebimento para Lançamento extemporâneo de documento fiscal.
								(cAliasSFT)->FT_ESPECIE,;                                               				//42 - Especie do Docuemnto
								(cAliasSFT)->FT_TIPOMOV,;                                              					//43 - Tipo Mov.
								Iif(lAchSFSD,(Iif(lTop,cAliasSFT,cAlsSF))->(&(cCmpMenNota)),""),; 						//44 - Mensagem da Nota Fiscal
								(cAliasSFT)->FT_PRODUTO,; 																//45 - Produto
								(cAliasSFT)->FT_ITEM,; 																	//46 - Item
								(cAliasSFT)->FT_FORMULA,;																//47 - Formula
								Iif(aSPDSX3[FP_FT_TES],(cAliasSFT)->FT_TES,""),;    									//48 - Código da TES
								Iif(lAchSFSD .And. cEntSai == "1" .And. lCpoMunSF1,(Iif(lTop,cAliasSFT,cAlsSF))->(&(cCmpUfOriTr)),""),;  //49 - UF de Origem do Transporte
								Iif(lAchSFSD .And. cEntSai == "1" .And. lCpoMunSF1,(Iif(lTop,cAliasSFT,cAlsSF))->(&(cCmpMuOriTr)),""),;  //50 - Municipio de Origem do Transporte
								Iif(lAchSFSD .And. cEntSai == "1" .And. lCpoMunSF1,(Iif(lTop,cAliasSFT,cAlsSF))->(&(cCmpUfDesTr)),""),;  //51 - UF de Destino do Transporte
								Iif(lAchSFSD .And. cEntSai == "1" .And. lCpoMunSF1,(Iif(lTop,cAliasSFT,cAlsSF))->(&(cCmpMuDesTr)),""),;  //52 - Municipio de Destino do Transporte
								Iif(aSPDSX3[FP_F1_SUBSERI] .And. cEntSai == "1", (cAliasSFT)->F1_SUBSERI, ""),; //53 - Sub Série da nota fiscal de entrada								
								Iif(lAchSFSD .And. cEntSai == "2" .And. lCpoMunSF2,(Iif(lTop,cAliasSFT,cAlsSF))->(&(cCpUfOri)),""),;  //54 - UF de Origem do Transporte
								Iif(lAchSFSD .And. cEntSai == "2" .And. lCpoMunSF2,(Iif(lTop,cAliasSFT,cAlsSF))->(&(cCpMuOri)),""),;  //55 - Municipio de Origem do Transporte
								Iif(lAchSFSD .And. cEntSai == "2" .And. lCpoMunSF2,(Iif(lTop,cAliasSFT,cAlsSF))->(&(cCpUfDes)),""),;  //56 - UF de Destino do Transporte
								Iif(lAchSFSD .And. cEntSai == "2" .And. lCpoMunSF2,(Iif(lTop,cAliasSFT,cAlsSF))->(&(cCpMuDes)),""),;  //57 - Municipio de Destino do Transporte
								cCodMunDest,;   																			//58 - Municipio de Destino Complemento
								Iif(lTop .And. lIntTMS,(cAliasSFT)->DT6_DOCTMS,""),; //59 - Chave de Acesso SEFAZ/CTe
								Iif(lTop .And. lIntTMS,(cAliasSFT)->DT6_CHVCTE,""),; //60 - Documento de Transporte  
								Iif(lTop .And. lIntTMS,(cAliasSFT)->DT6_TIPFRE,""),;  //61 - Tipo Frete  
								Iif(lTop .And. lIntGTP .And. aSPDSX2[AI_GZH], (cAliasSFT)->COUNTGZH,0),;  //62 - Quantidade de registros encontrados na GZH
								Iif(lTop, (cAliasSFT)->B1_COD,""),;  //63 - Codigo do Produto na SB1
								Iif(lTop, (cAliasSFT)->B1_CONTA,"")}  //64 - Conta Contabil do Primeiro item 

			
			//Retorna as informacoes de importacao caso tenha integracao com o SIGAEIC
			//|          FUNCAO DISPONIBILIZADA PELA AVEGARE - FONTE AVGERAL.PRW       |
			If	lSigaEIC .And. cEntSai == "1"
				aAvImport	:=  (cAliasSFT)->(AvGetImpSped(aSPDFil[PFIL_SF1],FT_NFISCAL,FT_SERIE,FT_CLIEFOR,FT_LOJA))
				lEICImport 	:=  !Empty((Iif(lTop,cAliasSFT,cAlsSF))->(cCmpHawb)) .And. Len(aAvImport)>0
			Endif			
											       
			//Posicionamento das tabelas complementares conforme documento fiscal em processamento
			If lTabComp
				//Somente para documentos de entrada, pois se refere ao registro de importacao
				If !lEICImport .And. cEntSai=="1"
					cChvSeek := aSPDFil[PFIL_CD5]+aParFil[2]+aParFil[3]+aParFil[4]+aParFil[5]
					lAchouCD5 := SpedSeek(cAliasCD5,1,cChvSeek)
				EndIf

				If nRecnoCDC != Nil .And. nRecnoCDC > 0
					cCDCChv := aSPDFil[PFIL_CDC]+aParFil[1]+aParFil[2]+aParFil[3]+aParFil[4]+aParFil[5]
					If (cAliasSFT)->COUNTCDC > 1
						lAchouCDC := SpedSeek(cAliasCDC,1,cCDCChv)
					Else	
						lAchouCDC := SpedSeek(cAliasCDC,1,cCDCChv,nRecnoCDC)
					EndIf						
				EndIf	
				
				If !(cEspecie$"#07#08#8B#09#10#11#26#27#57")
					
					If lTabCDD .AND. nRecnoCDD != Nil .And. nRecnoCDD > 0
						cChvSeek := aSPDFil[PFIL_CDD]+aParFil[1]+aParFil[2]+aParFil[3]+aParFil[4]+aParFil[5]
						If (cAliasSFT)->COUNTCDD > 1
							lAchouCDD := SpedSeek(cAliasCDD,1,cChvSeek)
						Else	
							lAchouCDD := SpedSeek(cAliasCDD,1,cChvSeek,nRecnoCDD)
						EndIf
					EndIf

					If lTabCDE .AND. nRecnoCDE != Nil .And. nRecnoCDE > 0
						cChvSeek := aSPDFil[PFIL_CDE]+aParFil[1]+aParFil[2]+aParFil[3]+aParFil[4]+aParFil[5]
						If (cAliasSFT)->COUNTCDE > 1
							lAchouCDE := (SpedSeek(cAliasCDE,1,cChvSeek).AND.SpedSeek("CCE",1,aSPDFil[PFIL_CCE]+(cAliasCDE)->CDE_IFCOMP)) // JOIN CCE
						Else
							lAchouCDE := (SpedSeek(cAliasCDE,1,cChvSeek,nRecnoCDE).AND.SpedSeek("CCE",1,aSPDFil[PFIL_CCE]+(cAliasCDE)->CDE_IFCOMP)) // JOIN CCE
						EndIf
					EndIf

					If lTabCDF .AND. nRecnoCDF != Nil .And. nRecnoCDF > 0
						cChvSeek := aSPDFil[PFIL_CDF]+aParFil[1]+aParFil[2]+aParFil[3]+aParFil[4]+aParFil[5]
						If (cAliasSFT)->COUNTCDF > 1
							lAchouCDF := (SpedSeek(cAliasCDF,1,cChvSeek).AND.SpedSeek("CCE",1,aSPDFil[PFIL_CCE]+(cAliasCDF)->CDF_IFCOMP)) // JOIN CCE
						Else
							lAchouCDF := (SpedSeek(cAliasCDF,1,cChvSeek,nRecnoCDF).AND.SpedSeek("CCE",1,aSPDFil[PFIL_CCE]+(cAliasCDF)->CDF_IFCOMP)) // JOIN CCE
						EndIf
					EndIf

					If lTabCDG .AND. nRecnoCDG != Nil .And. nRecnoCDG > 0
						cChvSeek := aSPDFil[PFIL_CDG]+aParFil[1]+aParFil[2]+aParFil[3]+aParFil[4]+aParFil[5]
						If (cAliasSFT)->COUNTCDG > 1
							lAchouCDG := (SpedSeek(cAliasCDG,1,cChvSeek).AND.SpedSeek("CCE",1,aSPDFil[PFIL_CCE]+(cAliasCDG)->CDG_IFCOMP)) // JOIN CCE
						Else
							lAchouCDG := (SpedSeek(cAliasCDG,1,cChvSeek,nRecnoCDG).AND.SpedSeek("CCE",1,aSPDFil[PFIL_CCE]+(cAliasCDG)->CDG_IFCOMP)) // JOIN CCE
						EndIf
					EndIf

					/*Ao adaptar o processamento das notas fiscais modelo 29 (NFFA), percebeu-se uma falha na implantacao deste complemento.
					Inicialmente, ao desenvolver foram criados os campos CD4_ITEM e CD4_COD (Produto),
					porem concluiu-se que este complemento eh feito por nota e nao por item, ou seja,
					sempre ira possuir apenas um registro da tabela CD4 para cada nota fiscal.
					Por este motivo, os campos CD4_ITEM e CD4_COD foram inutilizados, mas como fazem parte da Chave Primaria nao puderam ser deletados. */
					lAchouCD4 := SpedSeek(cAliasCD4,1,aSPDFil[PFIL_CD4]+aParFil[1]+aParFil[3]+aParFil[2]+aParFil[4]+aParFil[5])
				EndIf
					
			EndIf

			//mudanca de posicao da chamada da funcao InfPartDoc, e neste momento tambem preciso do conteudo do campo (cAliasSFT)->FT_ITEM(podendo ser numerico ou nao) 
			//aPartDoc	:=	InfPartDoc(cAlsSA,dDataDe,dDataAte,cAliasSFT,lCadParti,aHistSA,lHistTab) //Retornando dados do participante em um array e efetuo a gravacao dos registros:
			aPartDoc 	:= fHashInfP(cAlsSA, cFilAlsSA+(cAliasSFT)->(FT_CLIEFOR+FT_LOJA),;
									 {cAlsSA,dDataDe,dDataAte,cAliasSFT,lCadParti,aHistSA,lHistTab})	
			
			cRelacDoc		:= cFilAnt + STRZERO(nRelacAux,10) + cChvSFT + aPartDoc[1]
			
			aDadSFU := {}
			nPosSFU := 0	

			// Tratamento para carregar os dados da filial quando a emissão é uma devolução com formulário próprio e DEVMERC = S no C100 e 0150
			If aSPDSX3[FP_F1_DEVMERC] .And. cEntSai == "1" .AND. (cAliasSFT)->F1_FORMUL == "S" .AND. (cAliasSFT)->F1_DEVMERC == 'S'
				aPartSM0 := InfPartDoc("SM0")
			EndIf

			//Processando os itens do documento fiscal.
			cChave := (cAliasSFT)->(FT_FILIAL+FT_TIPOMOV+FT_SERIE+FT_NFISCAL+FT_CLIEFOR+FT_LOJA)
			Do While !(cAliasSFT)->(Eof()) .And. cChave==(cAliasSFT)->(FT_FILIAL+FT_TIPOMOV+FT_SERIE+FT_NFISCAL+FT_CLIEFOR+FT_LOJA)
				//Inicializacao de variaveis utilizadas no processamento do item
				nRegsProc	+=	1
				lAchouSF4	:=	.F.
				cUnid		:=	""
				cAntUnid	:=	""
				cProd		:=	""
				cCodNat		:=	""
				cDescNat	:=	""
				aRegC165	:=	{}
				aRegC170	:=	{}
				lGrava0200	:=	.F.
				nValST		:=	0
				lIss		:=	(cAliasSFT)->FT_TIPO=="S"
				lUsaSelo	:=	.F.
				lIpiPauta	:=	.F.
				aProd		:=	{"","","","","","","","","","",""}
				AHistSB1	:=	{}
				nPosC300	:=	0
				nRedBSICM	:=	0
				nRecnoCD1	:=	Iif(lTop .And. lTabCD1 ,(cAliasSFT)->CD1RECNO,Nil)
				nRecnoCD3	:=	Iif(lTop .And. lTabComp,(cAliasSFT)->CD3RECNO,Nil)
				nRecnoCD7	:=	Iif(lTop .And. lTabComp,(cAliasSFT)->CD7RECNO,Nil)
				nRecnoF0A	:=	Iif(lTop .And. lTabF0A,(cAliasSFT)->F0ARECNO,Nil)
				nRecnoCD8	:=	Iif(lTop .And. lTabComp,(cAliasSFT)->CD8RECNO,Nil)
				nRecnoCD9	:=	Iif(lTop .And. lTabComp,(cAliasSFT)->CD9RECNO,Nil)
				nRecnoSFU	:=	Iif(lTop .And. lTabComp,(cAliasSFT)->SFURECNO,Nil)
				nRecnoSFX	:=	Iif(lTop .And. lTabComp,(cAliasSFT)->SFXRECNO,Nil)
				nRecnoCCE	:=	Iif(lTop .And. lTabComp,(cAliasSFT)->CCERECNO,Nil)
				nRecnoSF3	:=	Iif(lTop,(cAliasSFT)->SF3RECNO,Nil)
				nRecnoCD2	:=	Iif(lTop,(cAliasSFT)->CD2RECNO,Nil)
				nRecnoCD6	:=	Iif(lTop .And. lTabComp,(cAliasSFT)->CD6RECNO,Nil)		
				nRecnoCDA	:=	Iif(lTop .And. lTabComp,(cAliasSFT)->CDARECNO,Nil)		
				cIteSFT		:= (cAliasSFT)->FT_ITEM
				nQtde		:= (cAliasSFT)->FT_QUANT
				nRecSF3DBF	:=	Nil
				nFatorPE	:=	0
				lAchouCD2	:=	.F.
				lAchouCD6	:=  .F.
				cAliasCD2	:=	"CD2"
				nAbatNT		:=	0
				lCondC120	:=	.F.
				nKeyCD2		:=	1
				lRegEspPr	:= cMVEstado=="PR" .And. cEntSai=="1" .And. cSituaDoc$"08" .And. aCmpAntSFT[8]=="S" .And. !Empty(aCmpAntSFT[47])
				cDTCancela  :=""
				cDTEmissao  :=""
				//Reinicio as propriedades do objeto de movimentação do item
				oObjSpdMov:Clear()

				lAchouCD2 := nRecnoCD2 > 0

				cRelacDoc	:= cFilAnt + STRZERO(nRelacAux,10) + cChvSFT + aPartDoc[1] + PadL(alltrim(cIteSFT),nTamFT_IT,"0")
				// cRelacDoc	:= cFilAnt + STRZERO(nRelacAux,10) + cChvSFT + aPartDoc[1]

				lComplXml   := lProcXml := .F.
				cRelacItXml := ""

				If lCSDXML .And. (cEntSai == "1") .And. (cEspecie $ "01|1B|04|55") .And. (!cSituaDoc$"02#03#04#05") .And. (!(cAliasSFT)->FT_TIPO$"D")
					If !Empty((cAliasSFT)->DKA_ITXML) 
						lProcXml := .T.

						If !cItXml == (cAliasSFT)->DKA_ITXML
							cItXml := (cAliasSFT)->DKA_ITXML
							nContXml := 1
						Else
							nContXml += 1 
						Endif

						// Para ordenação de itens do C170 e filhos neste momento estou tirando 
						// o item FT do relacionamento e atribuindo cItXml
						cRelacItXml := RetRD(cRelacDoc) + PADL(cItXml,nTamFT_IT,"0")

					Endif

					If !Empty((cAliasSFT)->FT_NFORI) .And. Empty((cAliasSFT)->DKA_DESCFO) .And. ((cAliasSFT)->FT_TIPO$"IPC")
						lComplXml := .T.
					EndIf

				Endif

				If lPriItem
					lPriItem := .F.
		
					SetRelacPr(cRelacDoc)

					//³REGISTRO C160 - VOLUMES TRANSPORTADOS                                           ³
					//|Funca independente, gera a estrutura e efetua a gravacao no TRB documento fiscal|
					If lGera .And. lInscrito .And. !cSituaDoc$"02/03/04/05" .And. cEspecie$"01#04" .And. cEntSai=="2" .And. cPerfil <> "C"
						RegC160(cAlias,GetRelacPr(),@aReg0150,aWizard,aCmpAntSFT,lCadParti,aHistSA4,lAchouDA3,cAliasSA4,aF2EspVol) // Passo o cRelacDoc concatenado com o numero do primeiro ITEM, pois na ordem de hierarquia do manual o registro C160 sempre sera 1
					EndIf

				EndIf	

				If SF3->(Recno()) != nRecnoSF3
					//Efetuo o pocisionamento da tabela SF3 para utilizar a tabela na funcao SPEDSitDoc					
					cChvSeek := cFilSF3+(cAliasSFT)->(DToS(FT_ENTRADA)+FT_NFISCAL+FT_SERIE+FT_CLIEFOR+FT_LOJA+FT_CFOP+STR(FT_ALIQICM,5,2))
					SPEDSeek("SF3",,cChvSeek,nRecnoSF3)					
				EndIf

				//Para Top nao preciso fazer este while, pois jah estah posicionado conforme recno correto pela query principal
				If !lTop
					/*Tratamento para Apurar alguns valores durante o processamento da SFT, como se estivesse executando a RESUMEF3.
					Como na resumeF3 tem a opcao de obter as informacoes das tabelas SF3 ou SFT, tenho tambem que replicar isso aqui, para isso tenho que criar um controle para a tabela SF3, pois
					ela pode duplicar para cada SFT, entao tenho que garantir que estou processando somente 1 vez. */
					If !lResF3FT
						While SF3->(!Eof() .And. F3_FILIAL+DTOS(F3_ENTRADA)+F3_NFISCAL+F3_SERIE+F3_CLIEFOR+F3_LOJA+F3_CFO+STR(F3_ALIQICM,5,2)==cChvSeek)
							//Garanto a leitura do IDENT correto
							If SF3->F3_IDENTFT==(cAliasSFT)->FT_IDENTF3
								nRecSF3DBF	:=	SF3->(Recno())
								Exit
							EndIf
							SF3->(dbSkip())
						End
					EndIf
				EndIf
				//Posicionando tabelas de acordo com os itens dos documentos fiscais.
				If lTop
					If (lAchouSF4	:=	!Empty((cAliasSFT)->(&(cCmpTes))))
						cCodTes	:=	(cAliasSFT)->(&(cCmpTes))
					Endif
					cUnid 		:=	(cAliasSFT)->(&(cCmpUm))
				Else
					If (cAlsSD)->(MsSeek (xFilial(cAlsSD)+(cAliasSFT)->FT_NFISCAL+(cAliasSFT)->FT_SERIE+(cAliasSFT)->FT_CLIEFOR+(cAliasSFT)->FT_LOJA+(cAliasSFT)->FT_PRODUTO+(cAliasSFT)->FT_ITEM))
						If (lAchouSF4	:=	SPEDSeek("SF4",,aSPDFil[PFIL_SF4]+(cAlsSD)->(&(cCmpTes))))
							cCodTes	:= (cAlsSD)->(&(cCmpTes))
						Endif
						cUnid 		:=	(cAlsSD)->(&(cCmpUm))
					Else
						lAchouSF4	:=	.F.
					EndIf
					SPEDSeek("SB1",,aSPDFil[PFIL_SB1]+(cAliasSFT)->FT_PRODUTO)
					SPEDSeek("SB5",,aSPDFil[PFIL_SB5]+(cAliasSFT)->FT_PRODUTO)
				EndIf
				//Caso nao encontre a NF, utilizo do produto
				If Empty(cUnid)
					cUnid := (cAliasSB1)->B1_UM
				EndIf
				//Posicionamento das tabelas complementares conforme documento fiscal em processamento por item
				cChvSeek := (cAliasSFT)->(FT_TIPOMOV+FT_SERIE+FT_NFISCAL+FT_CLIEFOR+FT_LOJA+FT_ITEM+FT_PRODUTO)
				If lTabComp

					If !(cEspecie$"#07#08#8B#09#10#11#26#27#57")
						lAchouCD3 := SPEDSeek("CD3",,aSPDFil[PFIL_CD3]+cChvSeek,nRecnoCD3)
						lAchouCD7 := SPEDSeek("CD7",,aSPDFil[PFIL_CD7]+cChvSeek,nRecnoCD7)
						lAchouCD8 := SPEDSeek("CD8",,aSPDFil[PFIL_CD8]+cChvSeek,nRecnoCD8)
						lAchouCD9 := SPEDSeek("CD9",,aSPDFil[PFIL_CD9]+cChvSeek,nRecnoCD9)
						lAchouSFU := SPEDSeek("SFU",,aSPDFil[PFIL_SFU]+cChvSeek,nRecnoSFU)

						If nRecnoCD6 != Nil .And. nRecnoCD6 > 0
							If (cAliasSFT)->COUNTCD6 > 1
								lAchouCD6 := SPEDSeek("CD6",,aSPDFil[PFIL_CD6]+cChvSeek)
							Else
								lAchouCD6 := SPEDSeek("CD6",,aSPDFil[PFIL_CD6]+cChvSeek,nRecnoCD6)
							EndIf
						EndIf		

						If lAchouSF4
							lAchouCCE := SPEDSeek("CCE",,aSPDFil[PFIL_CCE]+SF4->F4_CODOBSE,nRecnoCCE)
						Endif
					EndIf

					lAchouSFX := SPEDSeek("SFX",,aSPDFil[PFIL_SFX]+cChvSeek,nRecnoSFX)
										
				EndIf

				If !(cEspecie$"#07#08#8B#09#10#11#26#27#57")
					If lTabF0A
						lAchouF0A := SPEDSeek("F0A",,aSPDFil[PFIL_F0A]+cChvSeek,nRecnoF0A)
					EndIf	
					nRecnoCD0	:=	Iif(lTop .And. lTabCD0,(cAliasSFT)->CD0RECNO,Nil)
					lAchouCD0	:= .F.
					If lTabCD0 .And. (nRecnoCD0 != Nil .And. nRecnoCD0 > 0)
						If (cAliasSFT)->COUNTCD0 > 1
							lAchouCD0 := SPEDSeek("CD0",,aSPDFil[PFIL_CD0] + cChvSeek)
						Else							
							lAchouCD0 := SPEDSeek("CD0",,aSPDFil[PFIL_CD0] + cChvSeek, nRecnoCD0 )
						EndIf												
					EndIf
				EndIf

				//Verifica se o item possui vinculo com Cadastro de Natureza da Operacao/Prestacao
				If lTabCD1
					lAchouCD1 := SPEDSeek("CD1",,aSPDFil[PFIL_CD1]+(cAliasSFT)->FT_NATOPER,nRecnoCD1)
				Endif
				//Ponto de entrada para tratamento da inform de produtos quando o mesmo estah fora do padrao do sistema
				cProd	:=	(cAliasSFT)->FT_PRODUTO+Iif(lConcFil,cFilAnt,"")
				If aExistBloc[05]
					aProd := Execblock("SPEDPROD", .F., .F., {cAliasSFT,"1105"})
					If Len(aProd)>=11
						cProd 	:= 	aProd[1]
						cUnid	:=	aProd[5]
					Else
						aProd := {"","","","","","","","","","","",""}
					EndIf
				EndIf
				/*IF lAchouSF4, significa que achou o SD1/SD2 e tambem o SF4, por isso faco este tratamento, senao nao executo o PE, mantendo a regra definida anteriormente.    
				Este PE eh utilizado para quando se deseja alterar a UM e a quantidade padrao calculada pelo sistema. Eh mais utilizado quando se utiliza a quantidade na segunda unidade de medida     */
				If lSPDFIS02 .And. lAchouSF4 .AND. !lProcXml
					cAntUnid  := cUnid
					aSpdFis02 := ExecBlock("SPDFIS02", .F., .F., { Iif(!lTop,cAlsSD,cAliasSFT) , (cAliasSFT)->FT_TIPOMOV, "C170"})
					If ValType(aSpdFis02)=="A"
						cUnid     := aSpdFis02[1]
						nQtde     := aSpdFis02[2]
						If Len(aSpdFis02) > 2
							nFatorPE  := aSpdFis02[3]
						EndIf
					    If Len(aSpdFis02) > 3  
					    	cTpCv:= aSpdFis02[4]
					    Endif
					Else
						cUnid     := ExecBlock("SPDFIS02", .F., .F., { Iif(!lTop,cAlsSD,cAliasSFT) , (cAliasSFT)->FT_TIPOMOV })
						//Caso o retorno do PE seja Nil deve-se ignorar o PE e seguir com a geracao dos registros utilizando a unidade de medida principal do produto (0200)
						If ValType(cUnid) == "U"
							cUnid := cAntUnid
						EndIf
					EndIf
				EndIf
				//Calculo da reducao de base do ICMS para o item em processamento
				nRedBSICM	:=	SPEDVLBSRD(lAchouCD2,cAliasCD2,lAchouSF4,cAliasSF4,cAliasSFT,lMVSFRBCD2,lEICImport)
				//Tratamento para flag de controle de SELO de produto
				If cSituaDoc == "00" .And. cEntSai == "2" .And. lAchouSF4 .And. (cAliasSB1)->B1_SELO=="1" .And. (cAliasSF4)->F4_SELO=="1"
					lUsaSelo	:=	.T.
				EndIf
				//Tratamento para flag de controle de IPI de Pauta
				If (cAliasSFT)->FT_PAUTIPI>0
					lIpiPauta := .T.
				ElseIf !Empty((cAliasSB1)->B1_TAB_IPI) .And. (cAliasSB1)->B1_VLR_IPI>0
					lIpiPauta := .T.
				EndIf
				/* Tratamento para flag de Nota Fiscal de ICMS-ST para Transportes
				Mesmo que o campo F4_CREDST seja = 4, deve-se considerar que os valores do ICMS-ST estao lancados na apuracao, na linha de Outros Debitos. */
				If (cAliasSF4)->F4_OBSSOL == "5" .And. (cAliasSFT)->FT_CREDST == "4"
					lIcmStTran	:=	.T.
				Endif
				/*Verifico o codigo da natureza da operacao/prestacao para preenchimento do registro 0400 e campo 12 do registro C170
				Se utiliza Cadastro de Natureza da Operacao (tabela CD1) */
				If !(cSituaDoc$"02#03#04#05") .And. "1"$aWizard[1][20]
					aNatOper := SpedNatOper( lAchouCD1 , lSpedNat , cAliasSFT , cAliasSF4 , lAchouSF4 )
					cCodNat  := aNatOper[ 1 ]
					cDescNat := aNatOper[ 2 ]
				EndIf
				
				/////////Movido para inicio devido a nescessario no registro C170
				/*Valor deve corresponder ao Abatimento não tributado e não comercial
				 -Considerando o VALOR do ICMS correspondente à redução da base de
				  cálculo quando este é descontado do valor contábil (F4_AGREG="D")
				 -Considerar também o desconto para Zona Franca de Manaus*/
				nAbatNT := (cAliasSFT)->FT_DESCZFR
				/* Tenta utilizar o campo FT_DESCICM criado para ter o mesmo valor que
				   já era gravado em SD2/SD1(D2_DESCICM) e o campo FT_AGREG criado
				   para gravar o conteúdo do F4_AGREG no momento da emissão da NF
				   caso não existam/não estejam preenchidos, verificar em SD1/SD2/SF4*/
				If (cAliasSFT)->FT_AGREG =="D" .And. (cAliasSFT)->FT_DESCICM >0
					nAbatNT += (cAliasSFT)->FT_DESCICM
				Else
					If lAchouSF4 .And. (cAliasSF4)->F4_AGREG=="D" .And. (Iif(!lTop,cAlsSD,cAliasSFT))->(&(cCmpDescIcm))>0
						nAbatNT += (Iif(!lTop,cAlsSD,cAliasSFT))->(&(cCmpDescIcm))
					EndIf
				EndIf
				
				If aSPDSX3[FP_FT_DESCFIS]
					nAbatNT += (cAliasSFT)->FT_DESCFIS
				EndIf

				//³verifica se este item da nota NAO eh um servico e a configuracao do Credito ST.     |
				If !lIss
					If	(cEntSai=="2" .And. (Empty(cMv_StUfS) .Or. (cAliasSFT)->FT_ESTADO$cMv_StUfS)) .Or.;
						(cEntSai=="2" .And. (Empty(cMv_StUf ) .Or. (cAliasSFT)->FT_ESTADO$cMv_StUf)).Or.;	//Debito por saida
						(cEntSai=="1" .And. (Empty(cMv_StUf ) .Or. (cAliasSFT)->FT_ESTADO$cMv_StUf) .And.(cAliasSFT)->FT_TIPO=="D") .Or.; //Credito por entrada (devolucoes)
						(cEntSai=="1" .And. (Empty(cMv_StUf ) .Or. (cAliasSFT)->FT_ESTADO$cMv_StUf) .And. ((cAliasSFT)->FT_ESTADO $ cMVSUBTRIB .Or. cMVEstado + (cAliasSFT)->FT_ESTADO $ AllTrim(aSPDSX6[MV_STNIEUF])) .And. AllTrim((cAliasSFT)->FT_CFOP) $ cMVCFERES) //Credito por Ressarcimento (Campo 05 reg. E210).
						
						/*Apesar dos valores de SF3 e SFT serem os mesmos, a gravacao das tabelas nao sao, e se for considerado os campos correspondentes, os valores apresentados serao
						diferentes, e para resolver isso preciso temos que saber qual tabela esta sendo considerada na apuracao de ICMS, para isso faco o tratamento abaixo.
						Se o parametro MV_RESF3FT estiver configurado para considerar a tabela SFT, tenho que somar os campos de retido+isento+outros, pois nao eh gravado conforme
						conforme a SF3, que grava sempre o ICMS retido independente da escrituracao. */
						If (cAliasSFT)->FT_CREDST <> "4" .Or. lIcmStTran
							If lResF3FT
								//Na tabela SFT o valor de ICMS Retido pode alternar nas colunas dependendo da escrituracao
								nValST	:=	(cAliasSFT)->(FT_ICMSRET+FT_OUTRRET+FT_ISENRET)
								nValST	:=	(cAliasSFT)->(Iif(nValST>0,nValST,FT_OBSSOL))
							Else
								//Na tabela SF3 o valor do ICMS Retido sempre eh gravado em ICMSRET, independente da escrituracao
								nValST	:=	(cAliasSFT)->FT_ICMSRET
								nValST	:=	(cAliasSFT)->(Iif(nValST>0,nValST,FT_OBSSOL))
							EndIf
						EndIF
					
					/*As ENTRADAS com ICMS/ST nao estao sendo consideradas devido ao SPED Fiscal assumir os valores como credito, ou seja, esses valores de ST dos documentos de entrada devem ser lancados no E210
					 campo 06 - VL_OUT_CRED_ST conforme observacao do layout para o referido campo. O SPED Fiscal utiliza um conceito de nao haver creditos de ST em operacoes interestaduais nos
					 documentos de entrada, salvo algumas excecoes de escrituracao particulares do estado, que deve utilizar ajustes manuais na Apuracao para descrever o lancamento. Podemos citar como exemplo,
					 a ANTECIPACAO DE ICMS/ST, que deve ser lancado o valor em Debitos Especiais, a GNRE deve ser gerada pelo documento fiscal, portanto pode-se cancelar a tela de geracao da apuracao. A GNRE
					 gerada pela NF deve ser amarrada via Complemento de NFs. */
					ElseIf cEntSai=="1" .And.;
							(cAliasSFT)->FT_ESTADO==cMVEstado .And. (!(cAliasSFT)->FT_CREDST$"34")
						/* Credito por entrada (do mesmo estado) -   MESMA REGRA DA APURACAO (MATA953/FISXAPUR)
						Credito de ICMS-ST na entrada, somente considera quando do mesmo estado do conrtibuinte, variando de acordo com o que foi selecionado na pergunta Imprime Cred ST */
						If lImpCrdSt .And. (cAliasSFT)->FT_SOLTRIB > 0
							nValST := (cAliasSFT)->FT_SOLTRIB

						ElseIf lImpCrdSt
						
							//³Apesar dos valores de SF3 e SFT serem os mesmos, a gravacao das tabelas nao sao,|
							//|e se for considerado os campos correspondentes, os valores apresentados serao   |
							//|diferentes, e para resolver isso preciso temos que saber qual tabela esta sendo |
							//|considerada na apuracao de ICMS, para isso faco o tratamento abaixo.            |
							//|Se o parametro MV_RESF3FT estiver configurado para considerar a tabela SFT,     |
							//| tenho que somar os campos de retido+isento+outros, pois nao eh gravado conforme|
							//| conforme a SF3, que grava sempre o ICMS retido independente da escrituracao.   |
							If lResF3FT
								//Na tabela SFT o valor de ICMS Retido pode alternar nas colunas dependendo da escrituracao
								nValST	:=	(cAliasSFT)->(FT_ICMSRET+FT_OUTRRET+FT_ISENRET)
								nValST	:=	(cAliasSFT)->(Iif(nValST>0,nValST,FT_OBSSOL))
							Else
								//Na tabela SF3 o valor do ICMS Retido sempre eh gravado em ICMSRET, independente da escrituracao
								nValST	:=	(cAliasSFT)->FT_ICMSRET
								nValST	:=	(cAliasSFT)->(Iif(nValST>0,nValST,FT_OBSSOL))
							EndIf
						EndIf
					EndIf

					/*Para as notas fiscais de entrada tipo devolucao, apos retorno da SEFAZ e analise das regras do layout e validacao do PVA, chegou-se a seguinte conclusao:                                                                                        ³
					Para as notas fiscais de entrada tipo devolucao, o valor de ICMS/ST somente deverah ser considerado nos registro C100, C170, C190 e E210, quando o contribuinte tiver IE no estado 
					emitente do documento (FT_ESTADO estah contido no SUBTRIB), caso contrario deverah levar ZERO nos respectivos campos, pois a NF original, a de saida, teve o ICMS/ST
					recolhido antecipadamente, nao tendo como compensar o credito. Quando houver IE no estado do emitente, segue o fluxo normal, pois como o valor do ICMS/ST sera 
					recolhido via Auracao, terah com compensar o debito pelo credito.
					Base legal: Alteracao efetuada conforme FNC 00000001419/2011, que contem uma consulta da SEFAZ embasando o entendimento acima.                                                                                                                 |
					Alteracao 19.08.2011 - FNC 00000016165/2011-01
					Tratamento para acordo entre os estados preenchidos no parametro MV_STNIEUF, quando em um movimento com ICMS-ST NAO e' necessario ter Incsc.Est. (MV_SUBTRIB NAO preenchido) 
					Este tratamento foi feit a partir da necessidade das UF d MG p/ PR onde existe esse acordo. PROTOCOLO ICMS CONSELHO NACIONAL DE POLÍTICA FAZENDÁRIA - CONFAZ Nº 191 DE 11.12.2009 */
					If (cAliasSFT)->FT_TIPO=="D" .And. !(cAliasSFT)->FT_ESTADO==cMVEstado .And. !(cAliasSFT)->FT_ESTADO$cMVSUBTRIB
						If (cEntSai=="1" .And. AllTrim((cAliasSFT)->FT_CFOP)$cMVCFE210) .AND. !((cMVEstado+(cAliasSFT)->FT_ESTADO)$AllTrim(aSPDSX6[MV_STNIEUF])) .Or. cEntSai=="2"
							nValST		:=	0
						ElseIf cEntSai=="1" .And. !AllTrim((cAliasSFT)->FT_CFOP)$cMVCFE210
							lLogCfop	:=	.T.
						EndIf
					EndIf
				EndIf

				//Tratamento para processar o SF3 sem duplicar - lResF3FT = .T., processa via SFT, .F. = SF3 
				If nValST>0
					If !cSituaDoc$"02/04/05/03" .And. !Empty(UfCodIBGE((cAliasSFT)->FT_ESTADO)) .And. (lResF3FT .Or. aScan(aResF3FT,{|aX|aX==nRecnoSF3})==0)
						SpedApDoc(cEntSai,cMv_StUfS,cMv_StUf,lResF3FT,cAliasSFT,lUsaSped,lImpCrdST,aCmpAntSFT,cMVEstado,@aVlrMovST)
					EndIf

					//Reposicionado a tabela SF3 caso tenha sido efetuado o SEEK anterior
					If !lResF3FT .And. aScan(aResF3FT,{|aX|aX==nRecnoSF3})==0
						aAdd(aResF3FT,nRecnoSF3)
						If !lTop
							cChvSeek := cFilSF3+(cAliasSFT)->(DToS(FT_ENTRADA)+FT_NFISCAL+FT_SERIE+FT_CLIEFOR+FT_LOJA+FT_CFOP+STR(FT_ALIQICM,5,2))
							SPEDSeek("SF3",,cChvSeek,nRecSF3DBF)
						EndIf
					EndIf
				EndIf

				//Obtem a classificacao fiscal da nota fiscal, tanto do ICMS quanto do IPI, PIS e COFINS

				aClasFis := SPDRetCCST(cAliasSFT,lAchouSF4,cEspecie,cAliasSF4,cAliasSB1,aPartDoc[13])

				/*Tratamento para alíquota zero de Pis e Cofins. Se o item estiver com CST entre 04, 05, 06, 07, 08 ou 09, será desconsiderado a alíquota e valor de PIS COFINS, considerando comente a base de cálculo. */
				If lMVSpedAz //MV_SPEDAZ
					lPisZero := .F.
					If (cAliasSFT)->FT_CSTPIS$"#04#05#06#07#08#8B#09#" 
						If lAchouSF4 .And. (cAliasSF4)->F4_PISDSZF <> "1"   //Não tem desconto para ZFM de PIS
							lPisZero := .T.
						EndIf
					EndIF

					lCofZero := .F.
					If (cAliasSFT)->FT_CSTCOF$"#04#05#06#07#08#8B#09#" 
						If lAchouSF4 .And. (cAliasSF4)->F4_COFDSZF <> "1"   //Não tem desconto para ZFM de COFINS
							lCofZero := .T.
						EndIf
					EndIF
				EndIF
				//Operação com garantia
				lOperGar := .F.
				If lAchouSF4 .And. (cAliasSF4)->F4_OPERGAR=="1" .And.;
					(cAliasSF4)->F4_CSTPIS=="98" .And. (cAliasSF4)->F4_CSTCOF=="98"
					lOperGar := .T.
				Endif

				//Guarda dados para GIAF
				IF lProcGiaf .And. !lIss .And. !cSituaDoc$"02/04/05/03" .And. cEspecie $ '01/55' .And. aSPDSX3[FP_FT_INFITEM] .and. !Empty((cAliasSFT)->FT_INFITEM) .And. !((cAliasSFT)->FT_TPPRODE $  ' #')
					Bloco8(cAliasSFT,cSituaDoc,aBloco8,lImport)
				Endif

				If lInscrito
					//O array aRegC170 deve ser zerado por item
					lGerouC170 := RegC170(cAlias,IIF(lProcXml,cRelacItXml,cRelacDoc),nItem,@aRegC170,cEspecie,cAliasSFT,lIss,aClasFis,lAchouSF4,nApurIpi,cSituaDoc,cUnid,;
											cProd,aCmpAntSFT,nValST,dDataAte,aWizard,cAliasSF4,cAliasSB1,AHistSB1,nQtde,lPisZero,lCofZero,lAchouCD0,;
											cMvEstado,cCodNat,cPerfil,lOperGar,lResF3FT,cAliasSD1,@lGeraC177B,nAbatNT,@oPosItXML,lProcXml,nContXml,lComplXml)
				EndIF

				/* A chamada da funcao abaixo "SPLancCDA" obtem os lancamentos dos dos itens amarrado no proprio documento  fiscal, atraves do TES ou manualmente.
				O array retornado por referencia, possui as informacoes dos lancamentos de todo o documento fiscal.
				Obs: A posica 13 estah sendo retornada em BRANCO, porem deverah ser atualizada a medida que os itens do SFT forem sendo passados, pois preciso deste codigo para montar o C197 por nfe. 
				Como neste momento nao tenho a variavel cProd para todos os itens, necessito atualizar depois, jah que a query vai apenas uma vez por documento no BD e retorna todos os lancamentos do documento.  */                                     ³
				If lFirstNF		//Garanto que soh chamo a funcao uma vez por documento fiscal, conforme orientacoes acima
					If lTabComp
						/* aLanCDA serah gerado somente para lancamentos de NF, para gerar os registros C195/C197
						Segundo o manual, nao eh somente para os modelos 01 e 55, este codigo tambem eh exigido nos registros: C320, C390, C790, C590, C690, D190, etc... 
						aLanCDA2 serah gerado somente quando envolver lancamentos de Apuracao, para gerar os  E113 e Registro E240.          */ 			

						If lAchouCDA := (nRecnoCDA != Nil .And. nRecnoCDA > 0)
							nUltCDA := Len(aLanCDA2)+1 //Mantem a posicao do ultimo item do processamneto anterior antes de adicionar novos itens.
							SPLancCDA(cAliasSFT,"",@aLanCDA,cMVEstado,lAchouCDT,cAliasCDT,aPartDoc[1],@aLanCDA2,;
									  lOldLan,cEspecie,cProd,@aInfE313,lDifal,,cAliasSF4,@aInfE531,lAchouCDA, lDevLanc)
						EndIf

						nLenCDA:= Len(aLanCDA)

						For nX := 1 to nLenCDA
							//Adiciono os lancamentos de observacoes dos documentos a medida que forem encontrados.
							Reg0460(@aReg0460,{aLanCDA[nX][7],aLanCDA[nX][20]})
						Next nX

					EndIf
				EndIf

				/* Quando este array estiver com conteudo, jah terah de todos os itens, neste caso, preciso atualizar somente o codigo de produto conforme o cProd - aLanCDA (Notas Fiscais) e aLanCDA2(Apuracao).	
				De acordo com o EFD de Rondonia não será considerado o 0200 para o C197 pois se trata de Redução, Isenção e Estorno de débito(RO20000002) não irá preencher o COD_ITEM */
				For nX := 1 To nLenCDA
					If aLanCDA[nX,14]==cIteSFT
						IF !aLanCDA[nX,1] $ STR0039 //Codigos de lançamentos para desconsiderar o código de produto nos registro 0200
							aLanCDA[nX,13]	:=	cProd
						EndIF
					EndIf

					// Tratativa feita com base na IN 92/21 do RS específico para o código de ajuste RS990113007 para transferência interna vinculada aos CFOPs 1.151, 1.152, 1.408 e 1.409.
					If !aLanCDA[nX,24] // Legado (Posição indica código de lancamento gerado pelo configurador de tributos.)
						If aLanCDA[nX,14]==cIteSFT .And. aLanCDA[nX,1] $ "RS99013007" .And. AllTrim((cAliasSFT)->FT_CFOP) $ "1151/1152/1408/1409" .And. !(AllTrim((cAliasSFT)->FT_CFOP) $ aLanCDA[nX,2])
							aLanCDA[nX,2] := AllTrim((cAliasSFT)->FT_CFOP)
						EndIf
					EndIf

					//Portaria CAT Nº 66 DE 25/07/2018 de São Paulo é nescessario que CFOP seja adicionado no campo de descrição do registro C197 
					If aLanCDA[nX,14]==cIteSFT .and. aLanCDA[nX,1] $ "SP90090104/SP90090278" .And. !(AllTrim((cAliasSFT)->FT_CFOP) $ aLanCDA[nX,2])
						aLanCDA[nX,2] := AllTrim((cAliasSFT)->FT_CFOP)
					//PORTARIA CAT - 54, DE 16-6-2020 de São Paulo é nescessario que seja informado o percentual de IVA-ST no VL_OUTROS 
					ElseIf aLanCDA[nX,14]==cIteSFT .and. aLanCDA[nX,1] $ "SP90090106" .and. empty(aLanCDA[nX,6])  
						aLanCDA[nX,6] := (cAliasSFT)->FT_MARGEM
					//PORTARIA CAT - 54, DE 16-6-2020 de São Paulo é nescessario que seja informado o percentual de IVA-ST no VL_OUTROS 
					ElseIf aLanCDA[nX,14]==cIteSFT .and. aLanCDA[nX,1] $ "SP40090227" .and. empty(aLanCDA[nX,6])  
						If (cAliasSF4)->F4_LFICM == "T"
							aLanCDA[nX,6]:= (cAliasSFT)->FT_VALICM
						Elseif (cAliasSF4)->F4_LFICM == "O"
							aLanCDA[nX,6]:= (cAliasSFT)->FT_OUTRICM * (aLanCDA[nX,4]/100)
						Endif
					//Para atender a Portaria CAT 157/2015 deve usar o código de ajuste SP90090102 e SP90090103, utilizar o campo “DESCR_COMPL_AJ” do registro C197 ou D197 para informar a chave de acesso da NFe que inclui o item, emitida pelo autor da encomenda.
					ElseIf aLanCDA[nX,14]==cIteSFT .and. aLanCDA[nX,1] $ "SP90090102/SP90090103" .and. !empty((cAliasSFT)->FT_NFORI) .and. !empty((cAliasSFT)->FT_SERORI)  
						aAreaOriSFT := SFT->(GetArea())

						//Este tratamento é para verificar se o FT_ITEMORI está preenchido, pois no teste com entrada não fica preenchido o FT_ITEMORI, por isso busco direto na Origem.
						If Empty(cItSFTOri := (cAliasSFT)->(FT_ITEMORI))
							cItSFTOri := IIF((cAliasSFT)->(FT_TIPOMOV) == 'S', (cAliasSFT)->D2_ITEMORI, (cAliasSFT)->D1_ITEMORI)
						Endif	

						If !empty(cItSFTOri) .and. SPEDSeek("SFT", 1, aSPDFil[PFIL_SFT] + IIF((cAliasSFT)->FT_TIPOMOV=="E","S","E") + (cAliasSFT)->(FT_SERORI + FT_NFORI + FT_CLIEFOR + FT_LOJA + alltrim(cItSFTOri) ))
							If !empty(SFT->FT_CHVNFE)
								aLanCDA[nX,2] := AllTrim(SFT->FT_CHVNFE)
							EndIf
						EndIf	
						RestArea(aAreaOriSFT)
						cItSFTOri:=""
					Endif

					/*Para o código RO99990009, o valor de ICMS deverá ser gerado no campo 05, e não 06, mesmo sendo operação e código se referindo a isenção de ICMS.
					conforme item 1º o anexo da instrução normativa 005/12 para o Estado de Rondoônia */
					IF aLanCDA[nX,1] $ "RO99990009/RO99990016/RO99990017/RO99990068/RO99990130/RO99990021/RO99990022/RO99990037/RO99990086/RO99990116/RO99990078/RO99990083"
						aLanCDA[nX,5] += aLanCDA[nX,6]
						aLanCDA[nX,6] := 0
					EndIF

					/*Para os códigos RO40000001/RO40000002 deverá ser levado no campo 6, o valor da alíquota interna, conforme item 5º e 6º do anexo da instrução
					normativa 005/12 para o Estado de Rondoônia */
					IF aLanCDA[nX,1] $ "RO40000001/RO40000002"
						//Tratamento para obter a aliquota interna do produto
						If ValType(aProd[11]) == "N"
							aLanCDA[nX,6]:=	aProd[11]
							
						ElseIf (cAliasSB1)->B1_PICM>0
							aLanCDA[nX,6]:=(cAliasSB1)->B1_PICM	
						Else
							aLanCDA[nX,6]:=aSPDSX6[MV_ICMPAD]
						EndIf
					EndIF

					If aLanCDA[nX,1] $ "RO99990165/RO99990195/RO99990166/RO99990170/RO99990183/RO99990175"
						//Tratamento para obter o Percentaul de redução
						If (cAliasSF4)->F4_BASEICM>0 .AND. lAchouCD2
							If (cAliasSF4)->F4_CONSUMO == "S"
								If (cAliasSF4)->F4_LFICM == "I"
									aLanCDA[nX,5]:= (cAliasSFT)->FT_OUTRICM * ((cAliasSFT)->CD2_ALIQ/100)
								Elseif (cAliasSF4)->F4_LFICM == "O"
									aLanCDA[nX,5]:= (cAliasSFT)->FT_ISENICM * ((cAliasSFT)->CD2_ALIQ/100)
								Endif
							Elseif (cAliasSF4)->F4_CONSUMO == "O"
								aLanCDA[nX,5]:=(cAliasSFT)->FT_OUTRICM +(cAliasSFT)->FT_ISENICM
							Endif
							aLanCDA[nX,6]:=(cAliasSF4)->F4_BASEICM
						Endif
					Endif
				Next nX
				For nX := nUltCDA To Len(aLanCDA2)
					//Verifica a chave, senao corre-se o risco de sobrescrever o produto
					If cChvSFT+aPartDoc[1]+cIteSFT==aLanCDA2[nX,11]+aLanCDA2[nX,10]+aLanCDA2[nX,9]+aLanCDA2[nX,8]+aLanCDA2[nX,15]+aLanCDA2[nX,14]
						aLanCDA2[nX,13] := cProd
					EndIf
				Next nX
				For nX := 1 To Len(aInfE531)
					//Verifica a chave, senao corre-se o risco de sobrescrever o produto
					If cChvSFT+aPartDoc[1]+cIteSFT==aInfE531[nX,11]+aInfE531[nX,10]
						aInfE531[nX,7] := cProd
					EndIf
				Next nX

				/*Novo tratamento implementado para gerar as informacoes de lancamentos fiscais de documento baseado em um campo no TES que determina o codigo da observacao do lancamento
				fiscal (F4_CODOBSE), com as informacoes do livro e formula. O parametro MV_CFC195 eh utilizado para indicar quais CFOP's serao desconsideradas no processamento automatico do registro C195. */
				If lAchouSF4 .AND. lAchouCCE .And. !(Alltrim((cAliasSFT)->FT_CFOP)$cMVCFC195) .And. cEspecie$"01#1B#04#55#57#65"
					SPEDLC195( cAliasSFT , @aLancFis , cAliasSF4 , cMVSPDTC95 , lAchouCCE )
				Endif

				If lDifal .AND. cEspecie $ '55/57/63/67' .AND. !cSituaDoc $ "02/03/04/05" .AND. (cAliasSFT)->FT_PDDES > 0 .AND. (cAliasSFT)->( FT_DIFAL+FT_ICMSCOM+FT_VFCPDIF ) > 0

					If  (!(cAliasSFT)->FT_ESTADO $  cMVSUBTRIB .Or. !(cAliasSFT)->FT_ESTADO $ cMV_DifTr )
						 nPosSemIe	:= aScan(aMovSemIe,{|aX| aX[1]==(cAliasSFT)->FT_ESTADO })
						//Tenho movimentação porém não sou inscrito, então Adiciona o estado que possui movimentação porém não tem IE						
						If nPosSemIe == 0
							aAdd(aMovSemIe, {})
							nPosSemIe	:=	Len (aMovSemIe)
							aAdd (aMovSemIe[nPosSemIe], (cAliasSFT)->FT_ESTADO)
							aAdd (aMovSemIe[nPosSemIe], 0)
							aAdd (aMovSemIe[nPosSemIe], 0)
						EndIF
						
						If cEntSai=="2"
							aMovSemIe[nPosSemIe][2] += (cAliasSFT)->FT_DIFAL
							aMovSemIe[nPosSemIe][3] += (cAliasSFT)->FT_VFCPDIF
						EndIf
					EndIf

					If cEntSai=="2"
						nDifalDest			+= (cAliasSFT)->FT_DIFAL //deverá ver se é inscrito
						nDifalOrig			+= (cAliasSFT)->FT_ICMSCOM
						nDifalFEcp			+= (cAliasSFT)->FT_VFCPDIF //sempre ve se é inscrito
					ElseIf  cEntSai=="1" .AND. (cAliasSFT)->FT_TIPO $ "B/D"
					
						//Para devolução ´recisa inverter, o destino é o próprio contribuinte.
						nDifalDest			+= (cAliasSFT)->FT_ICMSCOM
						
						If (cAliasSFT)->FT_ESTADO $  cMVSUBTRIB .Or. (cAliasSFT)->FT_ESTADO $ cMV_DifTr
							nDifalOrig			+= (cAliasSFT)->FT_DIFAL  //deverá ver se é inscrito
							nDifalFEcp			+= (cAliasSFT)->FT_VFCPDIF //sempre ve se é inscrito
						EndIf
						
					EndIF
					//zera campo 4 registro c101 e d101 quando Difal for apurada na apucaração do ICMS Proprio
					IF aSPDSX6[MV_ESTADO] $ aSPDSX6[MV_ESTE310]
						nDifalOrig := 0
					Endif
				EndIF

				If lInscrito //---Somente contribuintes do ICMS---//

					/*SOMENTE MODELOS:
					01 - NOTA FISCAL NORMAL
					1B - NOTA FISCAL AVULSA
					02 - NOTA FISCAL DE VENDA A CONSUMIDOR FINAL
					03 - NOTA FISCAL DE SERVICO
					04 - NOTA FISCAL PRODUTOR
					06 - NOTA FISCAL/CONTA DE ENERGIA ELETRICA
					21 - NOTA FISCAL DE SERVICO DE COMUNICACAO
					22 - NOTA FISCAL DE SERVICO DE TELECOMUNICACAO
					65 - NOTA FISCAL ELETRONICA AO CONSUMIDOR FINAL
					66 - NOTA FISCAL DE ENERGIA ELÉTRICA ELETRÔNICA – NF3e - c66 */

					If cEspecie$"01#1B#02#2D#04#06#21#22#28#29#55#65"+c66
						If cEspecie$"01#1B#04#55#65"
							//REGISTRO C130 - ISS/IR/PREV - A gravacao do array aRegC130 deverah ser efetua ao final de leitura da NF
							If cEntSai=="2" .And. cEspecie$"01#04"
								RegC130(cAliasSFT,@aRegC130,lIss)
							EndIf

							//Se gravaou registro c170, gravo os registros complementares caso haja
							lGeraC175 := !lLegisPer .And. lAchouCD9
							lGeraC173 := lAchouCD7 .And. !(!lGera .Or. (cEspecie$"55#65" .And. cIndEmit =="0"))
							lGeraC171 := lAchouCD6 .And. cEntSai=="1" .And. !lLegisPer

							If lGerouC170
								If (cEspecie$"01#55#04#1B" .And. !cSituaDoc$"02#03#04#05") .Or. (cEspecie$"55" .And. cSituaDoc$"02#03" .And. cSitDocInf$"08")
									/*REGISTRO C171 - Armazenamento de Combustivel
									Funcao independente, gera a estrutura e jah grava, nao precisa retornar nada */
									If !(cEspecie$"55" .And. cSituaDoc$"02#03" .And. cSitDocInf$"08") 
										If lAchouCD6
											If cEntSai=="1"
												If !lLegisPer
													RegC171(cAlias,GetRelaGrv(IIF(lProcXml,cRelacItXml,cRelacDoc), 5),nItem,cAliasSFT,cAliasCD6,@oRegC171,lGerouC170)
												EndIf												
											ElseIf cEntSai=="2" .And. lGera .And. cEspecie$"01" .And. Len(aPTransp)>0
												//³REGISTRO C165 - TRANSPORTE DE COMBUSTIVEIS
												//|Funca independente, gera a estrutura e efetua a gravacao no TRB
												//|  documento fiscal
												RegC165(@aRegC165,aPTransp,cAliasSFT,cAliasCD6)
											EndIf
										EndIf	

										//³REGISTRO C172 - ISS
										//|Funcao independente, gera a estrutura e jah grava, nao precisa retornar nada|
										If lGera .And. cEspecie$"01" .And. lIss .And. cEntSai == "2"
											RegC172(cAliasSFT,cAlias,GetRelaGrv(cRelacDoc, 5),nItem)
										EndIf
										//³REGISTRO C173 - OPERACOES COM MEDICAMENTOS
										//|Funcao independente, gera a estrutura e jah grava, nao precisa retornar nada|
										If lGeraC173
											RegC173(cAlias,GetRelaGrv(IIF(lProcXml,cRelacItXml,cRelacDoc), 5),nItem,lAchouF0A,@oRegC173, lGerouC170)
										EndIf
										//³REGISTRO C174 - OPERACOES COM ARMAS DE FOGO
										//|Funcao independente, gera a estrutura e jah grava, nao precisa retornar nada|
										If lGera .And. cEspecie$"01" .And. lAchouCD8 .And. cEntSai == "2"
											RegC174(cAlias,GetRelaGrv(cRelacDoc, 5),nItem)
										EndIf
										//³REGISTRO C175 - OPERACOES COM VEICULOS NOVOS
										//|Funcao independente, gera a estrutura e jah grava, nao precisa retornar nada|
										If lGeraC175 // !lLegisPer .And. lAchouCD9
											RegC175(cAlias,GetRelaGrv(IIF(lProcXml,cRelacItXml,cRelacDoc), 5),nItem,aPartDoc,@oRegC175,lGerouC170)
										EndIf
										//³REGISTRO C176 - RESSARCIMENTO
										//|Funcao independente, gera a estrutura e jah grava, nao precisa retornar nada|
										If lGera .And. lAchouCD0 .AND. cEntSai$"2"
											RegC176(cAlias,GetRelaGrv(cRelacDoc, 5),nItem,aCmpAntSFT,@aReg0150,aWizard,lCmpCD0,cIteSFT)
										EndIf
										
										If cVersao >= "013"
											//REGISTRO C177: COMPLEMENTO DE ITEM - OUTRAS INFORMAÇÕES (código 01, 55) -(VÁLIDO A PARTIR DE 01/01/2019)
											If lGeraC177B .And. cEspecie$"01|55"
												RegC177B(cAlias,GetRelaGrv(IIF(lProcXml,cRelacItXml,cRelacDoc), 5),cAliasSFT,nItem)
											EndIf
										Else
											//³REGISTRO C177 - OPERACOES COM PRODUTOS SUJEITOS A SELO DE CONTROLE IPI      ³
											//|Funcao independente, gera a estrutura e jah grava, nao precisa retornar nada|
											If lGera .And. cEspecie$"01" .And. lUsaSelo
												RegC177A(cAlias,GetRelaGrv(IIF(lProcXml,cRelacItXml,cRelacDoc), 5),cAliasSFT,nItem,cAliasSB1,aRegC170)
											EndIf
										Endif

										lGrava0200 := .T.

										//³REGISTRO 0400 - TABELA DE NATUREZA DA OPERACAO/PRESTACAO
										//|A gravacao do array aReg0400 deverah ser efetua da no final do processamento|
										If !cSituaDoc$"02#03#04#05" .And. "1"$aWizard[1][20]
											Reg0400(cCodNat,@aReg0400,cDescNat)
										EndIf
									EndIf

									//³REGISTRO C180 - INFORMAÇÕES COMPLEMENTARES DAS OPERAÇÕES DE ENTRADA DE MERCADORIAS SUJEITAS À SUBSTITUIÇÃO TRIBUTÁRIA (CÓDIGO 01, 1B, 04 e 55).
									If cEntSai=="1" .And. cEspecie$"01#1B#04#55"
										If (cAliasSFT)->FT_TIPO == "D" .And. cVersao >= "015"
											RegApurST("C181",,cAliasSFT,cAlias,cRelacDoc,nItem)
										ElseIf (cAliasSFT)->FT_TIPO != "D"
											RegApurST("C180",,cAliasSFT,cAlias,IIF(lProcXml,cRelacItXml,cRelacDoc),nItem,)
										EndIf
									EndIf
								EndIf
								//³REGISTRO C178 - OPERACOES COM PRODUTOS SUJEITOS A TRIBUTACAO DO IPI POR UNIDADE OU POR
								//|                QUANTIDADE
								//|Funcao independente, gera a estrutura e jah grava, nao precisa retornar nada
								If lGera .And. lIpiPauta .And. cEntSai == "2"
									RegC178(cAlias,cAliasSFT,GetRelaGrv(cRelacDoc, 5),nItem,cAliasSB1,aRegC170)
								EndIf
							Else
								If (cEspecie$"01#55#04#1B" .And. !cSituaDoc$"02#03#04#05") .Or. !(cEspecie$"55" .And. cSituaDoc$"02#03" .And. cSitDocInf$"08")									

									If lGeraC171
										RegC171(cAlias,GetRelaGrv(IIF(lProcXml,cRelacItXml,cRelacDoc), 5),nItem,cAliasSFT,cAliasCD6,@oRegC171,lGerouC170)
									EndIf
									If lGeraC173
										RegC173(cAlias,GetRelaGrv(IIF(lProcXml,cRelacItXml,cRelacDoc), 5),nItem,lAchouF0A,@oRegC173,lGerouC170)
									EndIf
									if lGeraC175
										RegC175(cAlias,GetRelaGrv(IIF(lProcXml,cRelacItXml,cRelacDoc), 5),nItem,aPartDoc,@oRegC175,lGerouC170)
									EndIf
								EndIf
							EndIf							

							//³REGISTRO C185 - INFORMAÇÕES COMPLEMENTARES DAS OPERAÇÕES DE ENTRADA DE MERCADORIAS SUJEITAS À SUBSTITUIÇÃO TRIBUTÁRIA (CÓDIGO 01, 1B, 04 e 55).
							If cEntSai=="2" .And. cEspecie$"01#1B#04#55#65"
								if (cAliasSFT)->FT_TIPO == 'D' .And. cVersao >= "015"
									RegApurST("C186",,cAliasSFT,cAlias,cRelacDoc,nItem,,aRegC170)
								elseif  (cAliasSFT)->FT_TIPO != "D"
									RegApurST("C185",,cAliasSFT,cAlias,cRelacDoc,nItem,,aRegC170)
								endif
							EndIf
							//³REGISTRO C190 - REGISTRO ANALITICO DO DOCUMENTO
							//|A gravacao do array aRegC190 deverah ser efetua ao final de leitura da NF|
							RegC190(aRegC170,cAliasSFT,@aRegC190,cSituaDoc,aLanCda,nRedBSICM,cAliasSF4,cMVCFC195,cSitDocInf,cEspecie,@aRegC191,aWizard)						
						ElseIf (cEspecie$"02") .And. cEntSai == "2"
							If cPerfil$"B/C"
								//³REGISTRO C300 - RESUMO DIARIO DAS NOTAS FISCAIS DE VENDA A CONSUMIDOR (CODIGO 02)³
								//|A gravacao do array aRegC300 deverah ser efetua da no final do processamento     |
								nPosC300	:=	RegC300(cSituaDoc,cEspecie,@aRegC300,cAliasSFT,@lNotaC300,aWizard)
								
								//³REGISTRO C310 - DOCUMENTOS CANCELADOS DE NOTAS FISCAIS DE VENDA A CONSUMIDOR (CODIGO 02)³
								//|A gravacao do array aRegC310 deverah ser efetua da no final do processamento            |

								//³Processamento de documentos cancelados
								If cSituaDoc$"02|03"
									RegC310(nPosC300,@aRegC310,cAliasSFT)

								//³Nao processa para notas fiscais canceladas³
								ElseIf !cSituaDoc$"02#03#04#05"
									//|REGISTRO C320 - REGISTRO ANALITICO DO RESUMO DIARIO DAS NOTAS FISCAIS DE VENDA A |
									//|                CONSUMIDOR(MODELO 02)
									//³REGISTRO C321 - ITENS DO RESUMO DIARIO DOS DOCUMENTOS(MODELO 02)
									//|A gravacao do array aRegC320 e aRegC321 deverah ser efetua da no final do proces |
									C320C321(nPosC300,aRegC170,@aRegC320,@aRegC321,cAliasSFT,aLanCDA,nRedBSICM,cAliasSF4,aLancFis,@aReg0460,aWizard,cPerfil,@aRegC330)
								EndIf

								If !cSituaDoc$"02#03"
									lGrava0200 := .T.
								EndIf

							ElseIf !cSituaDoc$"02#03#04#05" .And. cPerfil <> "C"	//02=Situacao de cancelada
								//³REGISTRO C370 - ITENS DO DOCUMENTO (MODELO 02)
								//|Funcao independente, gera a estrutura e jah grava, nao precisa retornar nada|
								RegC370(cAlias,cRelacDoc,aRegC170,nItem,cAliasSFT)

								//³REGISTRO C390 - REGISTRO ANALITICO DAS NOTAS FISCAIS DE VENDA A CONSUMIDOR (CODIGO 02)  ³
								//|A gravacao do array aRegC390 eh efetua ao final do processamento do documento fiscal    |
								RegC390(aRegC170,cAliasSFT,@aRegC390,cSituaDoc,aLanCDA,nRedBSICM,cAliasSF4,aLancFis,@aReg0460)

								lGrava0200 := .T.
							EndIf
						ElseIf (cEspecie$"06#28#29"+c66)

							//³Quando o contribuinte estah obrigado ao convenio 115, ele deve gerar os registros³
							//³ 700, 790, 1500 e 1510
							If cEntSai=="2" .And. cEspecie$"06#28#" .And. lConvC115  .And. cPerfil <> "C"
								lGravaC700 := .T.
								//|1510 - ITENS DO DOCUMENTO NOTA FISCAL/CONTA DE ENERGIA ELETRICA (CODIGO 06)
								//|Funcao independente, calcula e efetua a gravacao das informacoes
								If cEspecie$"06" .And. Substr((cAliasSFT)->FT_CFOP,1,1)=="6" .And. !cSituaDoc$"02#03#04#05" .And. "S"$aReg1010[1][7]
									Reg1510(cAlias,cRelacDoc,aRegC170,aPartDoc,nItem,lAchouSFU,aWizard)
									lGrava1500 := .T.
									lGrava0200 := .T.
								EndIf
							EndIf

							//³Os registro C500, C510 e C590 sao a base para os outros registros, por isso deve ³
							//| sempre entrar na funcao para montar os arrays, porem:                           |
							//³Soh irah gerar no arquivo texto quando o contribuinte NAO estiver obrigado ao    ³
							//³ convenio 115, pos gerarah os registros C500, C510 e C590 para o perfil A e      ³
							//| C600, C601, C610 e C620 para o perfil B                                         |
							If !lGravaC700 .And. ((cEntSai=="2" .And. cPerfil=="A") .Or. cEntSai=="1")
								lGravaC500 := .T.
							EndIf

							//|REGISTRO C510 - ITENS DO DOCUMENTO (MODELO 06|29|28)
							//|Funcao independente, calcula e efetua a gravacao das informacoes no TRB
							If (cEspecie$"06#28#29")
								RegC510(cAlias,cRelacDoc,aRegC170,aPartDoc,@aRegC510,nItem,lAchouSFU,lGravaC500,@lGrava0150,cSituaDoc,@lGrava0200,cEntSai,aWizard)
							ENDIF

							//|Como o registro C610 eh do perfil B e eh gerado com base no C510, preciso fazer o trata-|
							//| mento abaixo, pois o C510 nao deve ter seus filhos gerados quando for documento cance- |
							//| lado, transformando a variavel lGrava0200 como .F.. Mas  o  registro C610 exige tanto  ³
							//| documentos cancelados quanto normais, tendo entao, que gerar o 0200.
							If cEntSai=="2" .And. cPerfil=="B" .And. !lGravaC500 .And. !lGravaC700
								lGrava0200 := .T.
							EndIf

							//|REGISTRO C590 - REGISTRO ANALITICO DOS DOCUMENTOS FISCAIS (MODELOS 06, 28 E 29)
							//|A gravacao do array aRegC590 eh efetua ao final do processamento do documento fiscal
							RegC590(cAliasSFT,@aRegC590,cSituaDoc,aClasFis,aRegC170,aLanCDA,nRedBSICM,cAliasSF4,aLancFis,@aReg0460,cEspecie,@aRegC591,aWizard,lAchouSF4,nRecnoCCE)


							if cEntSai=="2" .And. cEspecie$c66 
								//Para a escrituração de documentos fiscais do modelo 66, este registro consolida o total das notas, por data de emissão
								//e série, que não utilizarem ajustes da tabela 5.3
								if nLenCDA>0 .Or. cC500C700=="2"
									lGravaC500:=.T.
									lGravaC700:=.F.
								elseif cC500C700=="1"
									lGravaC500:=.T.
									lGravaC700:=.T.
								elseif cC500C700=="3"
									lGravaC700:=.T.
									lGravaC500:=.F.
								endif
							endif

						ElseIf (cEspecie$"21#22")	//Somente modelo 21 e 22
							If Len(aRegC170)>0

								//³Conforme layout, o registro D510 deve ser gravado somente quando for
								//³ saida, prefil A nao obrigado ao Convenio 115
								If (cPerfil=="A" .And. cEntSai=="2" .And. !lConvC115) .Or. (cEntSai == "1")
									lGravaD500 := .T.
									If !cSituaDoc$"02#03#04#05" .And. cPerfil=="A" 
										lGrava0150 := .T.
									EndIF
								EndIf
								//³Conforme layout,  o registro D600 deve ser gravado somente quando for³
								//³ saida, prefil B nao obrigado ao Convenio 115
								If !cSituaDoc$"02#03#04#05"
									If cPerfil=="B" .And. cEntSai=="2" .And. !lConvC115
										lGrava0200 := .T.
									EndIf
									//|REGISTRO D510 - ITENS NOTA FISCAL DE SERVICO DE COMUNICACAO (MODELO 21) E NOTA FISCAL DE³
									//|                SERVICO DE TELECOMUNICACAO (MODELO 22)
									//|Funcao independente, calcula e efetua a gravacao das informacoes no TRB
									RegD510(cAlias,cRelacDoc,aRegC170,@aRegD510,aPartDoc,nItem,lAchouSFX,cEntSai,;
											lGravaD500,cPerfil,@lGrava0200,aWizard)

									If lGravaD500
										If cEntSai == "2"
											//|TERMINAL FATURADO (MODELO 21 E 22)
											//|Funcao independente, calcula e efetua a gravacao das informacoes no TRB
											If lAchouSFX
												RegD530(cAlias,cRelacDoc)
											EndIf
										EndIf
									EndIf

									//|REGISTRO D590 - REGISTRO ANALITICO DO DOCUMENTO
									//|A gravacao do array aRegD590 eh efetua ao final do processamento do documento fiscal
									RegD590(aRegC170,cAliasSFT,@aRegD590,aLanCDA,nRedBSICM,cSituaDoc,cAliasSF4,aLancFis,@aReg0460)
								EndIf
							EndIf
						EndIf

					ElseIf (cEspecie$"07#08#8B#09#10#11#26#57#63#67")
						If lGera .And. (cEntSai=="1" .Or. (cEntSai=="2" .And. (lIntTMS .Or. lSpedRTMS .Or. lIntGTP))) .And. !lIss .And. !(cSituaDoc$"02#03#05")  //Cancelado
							If cEntSai=="2" .And. cEspecie=="07" .And. cPerfil <> "C"								
								//|REGISTRO D110 - NOTA FISCAL DE SERVICO DE TRANSPORTE (MODELO 07)
								//|Funcao independente, calcula e efetua a gravacao das informacoes no TRB
								RegD110(cAlias,cAliasSFT,cRelacDoc,nItem,cProd,lSpedRTms,aCmpAntSFT)
								//|REGISTRO - D120 COMPLEMENTO DA NOTA FISCAL (MODELO 07)
								//|Funcao independente, calcula e efetua a gravacao das informacoes no TRB
								RegD120(cAlias,cRelacDoc,lAchouDA3,nItem,lSpedRTms,cAliasSFT,aCmpAntSFT, lAchouDT6)								
								lGrava0200 := .T.
							EndIf

							//|REGISTRO D190 - REGISTRO ANALITICO DO DOCUMENTO
							//|A gravacao do array aRegD190 eh efetua ao final do processamento do documento fiscal
							RegD190(aRegC170,cAliasSFT,@aRegD190,lSpedRTMS,aLanCDA,nRedBSICM,aCmpAntSFT,@aReg0460,cAliasSF4,aLancFis,@aReg0460)
						EndIf

					ElseIf cEspecie$"#13#14#15#16" .And. cEntSai=="2"

						// Não gero D300 se o bilhete estiver vinculado a um RMD pois serão gerados registros D400 e filhos neste caso.
						// Faço a validação apenas para ambiente TopConnect.
						If ((cEspecie <> "13") .Or. (cEspecie == "13" .And. IIf(lTop .And. aSPDSX3[FP_GIC_CODRMD], Empty((cAliasSFT)->GIC_CODRMD), .T.)))
		
							//³REGISTRO D300 - REGISTRO ANALÍTICO DOS BILHETES CONSOLIDADOS DE PASSAGEM RODOVIÁRIO (CÓDIGO 13), DE PASSAGEM
							//| AQUAVIÁRIO (CÓDIGO 14), DE PASSAGEM E NOTA DE BAGAGEM (CÓDIGO 15) E DE PASSAGEM FERROVIÁRIO (CÓDIGO 16).
		
							nPosD300 := RegD300(@aRegD300,cEspecie,cSituaDoc,nRedBSICM,@lNotaD300,cAliasSFT,aLanCDA,@aReg0460,aLancFis)
		
							//³REGISTRO D301 - DOCUMENTOS CANCELADOS DOS BILHETES DE PASSAGEM RODOVIÁRIO (CÓDIGO 13), DE PASSAGEM AQUAVIÁRIO
							//|(CÓDIGO 14), DE PASSAGEM E NOTA DE BAGAGEM (CÓDIGO 15) E DE PASSAGEM FERROVIÁRIO (CÓDIGO 16).
		
							//³Processamento de documentos cancelados³
							If cSituaDoc$"02#03"
								RegD301(nPosD300,@aRegD301,cAliasSFT)
							EndIf
		
							//³REGISTRO D310 -  COMPLEMENTO DOS BILHETES (CÓDIGO 13, 14, 15 E 16)     ³
							If cPerfil$"A/B"
								RegD310(nPosD300,@aRegD310,cAliasSFT,cSituaDoc,cAlsSD,lTop)
							EndIf
						
						//³SOMENTE MODELOS:                                                        ³
						//³13 - BILHETE DE PASSAGEM RODOVIÁRIO (VINCULADO A RMD)                     ³		
						ElseIf cEspecie == "13" .And. lIntGTP .And. IIf(lTop .And. aSPDSX3[FP_GIC_CODRMD], !Empty((cAliasSFT)->GIC_CODRMD), .F.)
						
							//³REGISTRO D400 - RESUMO DE MOVIMENTO DIÁRIO RMD                                      ³				
							nPosD400 := RegD400(cAliasSFT, @aRegD400, @aReg0150, cAlias, aWizard, aExistBloc, cRelacDoc)
							nPosD410 := RegD410(nPosD400, @aRegD410, cEspecie, cSituaDoc, cAliasSFT, @lNotaD410)

							If cSituaDoc $ "02|03"
								RegD411(nPosD410, @aRegD411, cAliasSFT)
							EndIf

							RegD420(nPosD400, @aRegD420, cAliasSFT)
						
						EndIf

					ElseIf cEspecie$"#59" .And. cEntSai=="2"					
						If cPerfil$"A"
							nPosC800 := RegC800(aRegC800,cAliasSFT,cSituaDoc,aPartDoc,aWizard, @cHiC800_60)
									cHiC810_70 := cHiC800_60
									RegApurST("C810",aRegC810,cAliasSFT,cAlias,cRelacDoc,,nPosC800,aRegC170, cHiC810_70, @cHiC815)
									RegApurST("C815",aRegC815,cAliasSFT,cAlias,cRelacDoc,,nPosC800, , cHiC815)								
									RegC850(nPosC800,aRegC850,cAliasSFT,cSituaDoc,aClasFis, cHiC800_60)
						ElseIf cPerfil$"B" 
							nPosC860 := RegC860(aRegC860,cAliasSFT,cSituaDoc, @cHiC800_60)
							If lRegCompST
								cHiC810_70 := cHiC800_60
								RegC870(nPosC860,aRegC870,cAliasSFT,cUnid,cSituaDoc,@aReg0190,@aReg0200,cAlias,@aRegC880, cHiC810_70)
							EndIf
							nPosC890 := RegC890(nPosC860,aRegC890,cAliasSFT,cSituaDoc,aClasFis, cHiC800_60, @cChv890)
						Endif

					
					EndiF
				
				EndIF
				
				//--- Geração dos Registros do Bloco B                                   ---//
				//--- 01 - NOTA FISCAL 1/1 A                                             ---//
				//--- 03 - NOTA FISCAL DE SERVIÇOS (MODELO 3) 3                          ---//
				//--- 3A - NOTA FISCAL DE SERVIÇOS - MODELO SIMPLIFICADO (MODELO 3-A) 3A ---//
				//--- 3B - NOTA FISCAL DE SERVIÇOS - MODELO AVULSO 3B                    ---//
				//--- 04 - NOTA FISCAL DE PRODUTOR 4                                     ---//
				//--- 08 - CONHECIMENTO DE TRANSPORTE RODOVIÁRIO DE CARGAS 8             ---//
				//--- 55 - NOTA FISCAL ELETRÔNICA 55                                     ---//
				//--- 65 - NOTA FISCAL DE CONSUMIDOR ELETRÔNICA- NFC-E 65                ---//

				If cEspecie$"01#03#3A#3B#04#08#55#65" .And. lBlocoB
					
					cEstPres		:= ""
					cMunPres		:= ""
					cDTCancela:=SUBSTR(DTOS((cAliasSFT)->FT_DTCANC),7,8)+SUBSTR(DTOS((cAliasSFT)->FT_DTCANC),5,2)+SUBSTR(DTOS((cAliasSFT)->FT_DTCANC),1,4)
					cDTEmissao:=SUBSTR(DTOS((cAliasSFT)->FT_EMISSAO),7,8)+SUBSTR(DTOS((cAliasSFT)->FT_EMISSAO),5,2)+SUBSTR(DTOS((cAliasSFT)->FT_EMISSAO),1,4)

					//Chama função para retornar estado e município onde o ISS foi prestado e devido
					If cEntSai == '1' .AND. aSPDSX3[FP_F1_ESTPRES] .And. aSPDSX3[FP_F1_INCISS]					
						cEstPres		:= (cAliasSFT)->F1_ESTPRES
						cMunPres		:= (cAliasSFT)->F1_INCISS					
					ElseIF aSPDSX3[FP_F2_ESTPRES] .And. aSPDSX3[FP_F2_MUNPRES]
						cEstPres		:= (cAliasSFT)->F2_ESTPRES
						cMunPres		:= (cAliasSFT)->F2_MUNPRES						
					EndIF
					
					//Chama função para definir municípios onde o serviço foi prestado e ISS devido
					aMunDevPre	:= SPDDEFMUN(cEntSai,;
											(cAliasSFT)->B1_MEPLES,;
											aPartDoc[13],;
											aPartDoc[7],;
											cEstPres,;
											cMunPres,;
											SM0->M0_ESTENT,;
											SM0->M0_CODMUN)		

					//Popula objeto de movimento 
					oObjSpdMov:setVlCont((cAliasSFT)->FT_VALCONT)
					oObjSpdMov:setMatTer((cAliasSFT)->FT_ISSMAT)
					oObjSpdMov:setIssSub((cAliasSFT)->FT_ISSSUB)
					oObjSpdMov:setIseOut((cAliasSFT)->(FT_OUTRICM+FT_ISENICM))
					oObjSpdMov:setBCIss((cAliasSFT)->FT_BASEICM)
					oObjSpdMov:setAlqIss((cAliasSFT)->FT_ALIQICM)
					oObjSpdMov:setIss((cAliasSFT)->FT_VALICM)					
					oObjSpdMov:setRecISS((cAliasSFT)->FT_RECISS)					
					oObjSpdMov:setIndOpe(Str(Val(cEntSai)-1,1))
					oObjSpdMov:setIndEmi(aCmpAntSFT[26])
					oObjSpdMov:setEspeci(cEspecie)
					oObjSpdMov:setSitDoc(cSituaDoc)
					oObjSpdMov:setNumNf( (cAliasSFT)->FT_NFISCAL)
					oObjSpdMov:setSerie(SpedSerie((cAliasSFT)->FT_SERIE, cEspecie))
					oObjSpdMov:setChvNfe(IIf(cSituaDoc <> "05", (cAliasSFT)->FT_CHVNFE, ""))
					oObjSpdMov:setCodObs("")
					oObjSpdMov:setCodIss(DefCodIssB(aProd, (cAliasSFT)->FT_PRODUTO, (cAliasSFT)->FT_CODISS))
					oObjSpdMov:setEmiss(cDTEmissao)
					oObjSpdMov:setdCanc(cDTCancela)
					oObjSpdMov:setPart(aPartDoc[01])
					oObjSpdMov:setEntSai(cEntSai)					
					
					//Envia para classe município prestado e de iss devido
					If Len(aMunDevPre) > 0
						oObjSpdMov:setEstPres(aMunDevPre[1])
						oObjSpdMov:setMunPres(aMunDevPre[2])
						oObjSpdMov:setEstDev(aMunDevPre[3])
						oObjSpdMov:setMunDev(aMunDevPre[4])
					EndIF					
					
					//Verifica antes de enviar valores retidos para a classe
					If ((cEntSai == "1" .And. (cAliasSFT)->FT_RECISS == '2') .Or. (cEntSai == "2" .And. (cAliasSFT)->FT_RECISS == '1')) .AND. Alltrim(oObjSpdMov:getMunDev()) == Alltrim(RetMunSM0())
						oObjSpdMov:setBCRet((cAliasSFT)->FT_BASEICM)
						oObjSpdMov:setIssRet((cAliasSFT)->FT_VALICM)						
					EndIf

					//Se Iss for devido em outro município totaliza o valor contábil
					If !cSituaDoc $ "02#04" .AND. cEntSai == "2" .AND. Alltrim(oObjSpdMov:getMunDev()) <> Alltrim(RetMunSM0())
						
						//Devido ao critério de validação do SPED no registro B470, exige que o valor contábil e isento de outros 
						//municípios sejam somados no registros B470. Como apuração FISA300 processa os valores separados por municípios
						//preciso aqui ir acumulando o valor de valor contábil devido em outros municípios para depois poder somar no registro B470
						nVlContOMun += oObjSpdMov:getVlCont()
					EndIF					

					If (cAliasSFT)->FT_TIPO == "S"
						If cEspecie$"01#03#3B#04#08#55#65"
							If !cSituaDoc $ "04#05" .And. cEntSai == '2' .Or. (cEntSai == '1' .And. (cAliasSFT)->FT_RECISS == '1')																					
								RegB020(@aRegB020,@aRegB025,@aRegB420,@aRegB440,@lGrava0150,oObjSpdMov,(cAliasSFT)->FT_ESTADO)
							EndIf
						Elseif cEntSai == '2' .And. cEspecie$"3A"
							//--------------------------------------
							//Processa registros B030, B035 e B420
							//--------------------------------------
							RegB030(@aRegB030,@aRegB035,@aRegB420,oObjSpdMov)							
						EndIf
					EndIf
				EndIf

				//³REGISTRO 1400 - INFORMACOES SOBRE VALORES AGREGADOS

				//|A gravacao do array aReg1400 eh efetuada ao final do processamento da rotina

				//|Tratamento utilizado para gerar o registro para todas as situacoes que o campo
				//|    F4_VLAGREG estiver configurado diferente de ' '
				If lF4_VLAGREG .And. lAchouSF4 .And. !Empty((cAliasSF4)->F4_VLAGREG) .And.;
				   !Empty(aPartDoc[7]) .And. "S"$aReg1010[1][6]
					If lAchouDT6 //TMS
					
						If cChvDUY != aSPDFil[PFIL_DUY]+(cAliasSFT)->DT6_CDRORI
							cChvDUY   := aSPDFil[PFIL_DUY]+(cAliasSFT)->DT6_CDRORI
							
							If lBuild != Nil .And. lBuild
								lAchouDUY := Len(aTMSCMRet := HashTMSCM((cAliasSFT)->DT6_CDRORI, .F., .F.)) > 0
							Else
								lAchouDUY := DUY->(MsSeek(cChvDUY))
								aTMSCMRet := {}
								aAdd(aTMSCMRet, {DUY->DUY_GRPVEN, "", DUY->DUY_EST, DUY->DUY_CODMUN, ""})
							EndIf		
						EndIf

						If lAchouDUY
							If cMVEstado==aTMSCMRet[1][3] .And. !AllTrim((cAliasSF4)->FT_CFOP) $ "1949|2949|3949|5949|6949|7949"	//Conforme Versão 2.0.15 do guia pratico EFD
								SPDReg1400(@aReg1400,cProd,UFCodIBGE(aTMSCMRet[1][3])+aTMSCMRet[1][4],cAliasSFT,cAliasSF4,.F.,@lGr2001400,cMVEstado)
							ElseIf AllTrim((cAliasSF4)->FT_CFOP) $ "1949|2949|3949|5949|6949|7949"
								SPDReg1400(@aReg1400,cProd,Alltrim(SM0->M0_CODMUN)+aTMSCMRet[1][4],cAliasSFT,cAliasSF4,.F.,@lGr2001400,cMVEstado)
							EndIf
						ElseIf cMVEstado==(cAliasSFT)->FT_ESTADO .And. !AllTrim((cAliasSF4)->FT_CFOP) $ "5949|6949|7949"//Conforme Versão 2.0.15 do guia pratico EFD
							SPDReg1400(@aReg1400,cProd,aPartDoc[7],cAliasSFT,cAliasSF4,.F.,@lGr2001400,cMVEstado)
						ElseIf AllTrim((cAliasSF4)->FT_CFOP) $ "1949|2949|3949|5949|6949|7949"
							SPDReg1400(@aReg1400,cProd,Alltrim(SM0->M0_CODMUN),cAliasSFT,cAliasSF4,.F.,@lGr2001400,cMVEstado)
						Endif
					ElseIf lCpoMunSF2 .and. cEspecie $ "13#63" .and. cMVEstado == aCmpAntSFT[54] .And. !AllTrim((cAliasSF4)->FT_CFOP) $ "1949|2949|3949|5949|6949|7949"//Conforme Versão 2.0.15 do guia pratico EFD			
						SPDReg1400(@aReg1400,cProd,UFCodIBGE(aCmpAntSFT[54])+aCmpAntSFT[55],cAliasSFT,cAliasSF4,.F.,@lGr2001400,cMVEstado)
					ElseIf cMVEstado==(cAliasSFT)->FT_ESTADO .And. !AllTrim((cAliasSF4)->FT_CFOP) $ "1949|2949|3949|5949|6949|7949"//Conforme Versão 2.0.15 do guia pratico EFD
						SPDReg1400(@aReg1400,cProd,aPartDoc[7],cAliasSFT,cAliasSF4,.F.,@lGr2001400,cMVEstado)
					ElseIf AllTrim((cAliasSF4)->FT_CFOP) $ "1949|2949|3949|5949|6949|7949" 
						SPDReg1400(@aReg1400,cProd,Alltrim(SM0->M0_CODMUN),cAliasSFT,cAliasSF4,.F.,@lGr2001400,cMVEstado)
					Endif

					// Nao usei a lGrava0200 pois se a flag vier como .T. de qualquer condicao acima e o reg. 1400 nao for gerado
					// ela ficará .F. e o 0200 nao será gerado mais abaixo, ocasionando erros na validacao.
					If lGr2001400
						//³REGISTRO 0190 - UNIDADES DE MEDIDA
						//³REGISTRO 0200 - TABELA DE IDENTIFICACAO DO ITEM
						//³REGISTRO 0205 - ALTERACOES DO ITEM
						//³REGISTRO 0220 - FATORES DE CONVERSAO DAS UNIDADES
						SFRG0200(cAlias,@aReg0200,@aReg0190,dDataDe,dDataAte,aProd,cProd,@aReg0220,cAliasSB1,cUnid,cMVDTINCB1,lSPDFIS02,nFatorPe,cMVEstado,cPRDPRIB5,cAliasSB5,cAliasCD6,lAchouCD6,Nil,cAliasSFT,,,,,,,aWizard,,cTpCv,,lProcXml)
						Reg0190(cAlias,cUnid,@aReg0190)
					EndIf
				Endif
				// A validacao para modelo 55(NFe) de Emissao propria foi retirada da funcao C195C197() - esta validacao
				// fazia com que o campo 04 - COD_ITEM do Registro C197 ficasse em branco - pois segundo o Guia Pratico
				// quando se enquadrar nesta situacao, o campo 04 deve ser gerado e o item deve gerar um registro 0200 para
				// este produto.  
				If Len(aLanCDA) > 0 .And. aCmpAntSFT[26]=="0" .And. cEspecie=="55"
					If aScan(aLanCDA,{|aX| aX[14]==cIteSFT .And. !Empty(aX[13])})>0
						lGrava0200 := .T.
					Endif
				Endif        
				//Validação conforme EFD – Manual de Orientações da Escrituração Fiscal Digital para Contribuintes do Estado de Rondônia.
				//Se o registro C197 campo 04 - COD_ITEM estiver em branco e a operação for de Rondonia com código de lançamento 
				// não será gerado o registro 0200 de acordo com EFD
				If cMVEstado=="RO" .And. aCmpAntSFT[26]=="0" .And. cEspecie=="55" .And. (( Len(aLanCDA) > 0 .Or. Len(aLancFis) > 0 )) 
		 			lGrava0200 := .F.
				Endif

				//³REGISTRO 0190 - UNIDADES DE MEDIDA
				//³REGISTRO 0200 - TABELA DE IDENTIFICACAO DO ITEM
				//³REGISTRO 0205 - ALTERACOES DO ITEM
				//³REGISTRO 0220 - FATORES DE CONVERSAO DAS UNIDADES
				//|Funcao independente, monta a estrutura dos registros e efetua as gravacoes no TRB
				If lGrava0200
					SFRG0200(cAlias,@aReg0200,@aReg0190,dDataDe,dDataAte,aProd,cProd,@aReg0220,cAliasSB1,cUnid,cMVDTINCB1,lSPDFIS02,nFatorPe,cMVEstado,cPRDPRIB5,cAliasSB5,cAliasCD6,lAchouCD6,,cAliasSFT,,,,,,,aWizard,,cTpCv,,lProcXml)
					//³REGISTRO 0190 - UNIDADES DE MEDIDA                                                      ³
					//|Funcao independente, monta a estrutura dos registros e efetua as gravacoes no TRB
					Reg0190(cAlias,cUnid,@aReg0190)
				EndIf

				//|REGISTRO E510 - CONSOLIDACAO DOS VALORES DE IPI POR CFOP E CODIGO DE SITUACAO TRIBUTARIA
				//|A gravacao do array aRegE510 eh efetuada ao final do processamento da rotina
				If !cSituaDoc$"02#03#04#05" .And. "0"$aWizard[2][5] .And. cEspecie$"2D#01#1B#04#55#65"
					RegE510(cAliasSFT,@aRegE510,cSituaDoc,aClasFis,cEntSai,cAliasSF4)
				EndIf				
				/*Como esta tabela possui escrituracao fiscal por item de documento fiscal, acumulo valores
				necessarios independente dos itens, ou seja,por NF.*/
				aTotaliza[1]	+=	(cAliasSFT)->FT_VALCONT	   							//Totliza o valor contabil do documento		
				aTotaliza[8]	+=	nQtde						   						//Totaliza a quantidade do item

				IF (cAliasSFT)->FT_TIPO == "D" .And. (cAliasSFT)->FT_TIPOMOV == 'E' .And. (cAliasSFT)->FT_DESCZFR > 0 .And. (cAliasSFT)->FT_DESCONT > 0 
					aTotaliza[9] :=	(CAliasSFT)-> FT_DESCONT - (cAliasSFT)->FT_DESCZFR 	   							//Totaliza o valor de desconto do documento
				Else
					aTotaliza[9]	+=	(cAliasSFT)->FT_DESCONT
				Endif 

				aTotaliza[10]	+=	(cAliasSFT)->FT_TOTAL + Iif( (cAliasSFT)->FT_TIPO <> "D", (cAliasSFT)->FT_DESCZFR, 0 ) //Totaliza o documento fiscal
				//Adiciona valor de IPI ou ST não creditado ao valmerc
				If cEntSai == "1" .And. (!(cAliasSF4)->F4_LFIPI$"T" .Or. (cAliasSFT)->FT_CREDST $ "3|4" ) .And. !(cAliasSFT)->FT_TIPO$"DB"
				     If!(cAliasSF4)->F4_LFIPI$"T" .And. !(cAliasSF4)->F4_IPI$"R" 
				    	aTotaliza[10]	 +=	 (cAliasSD1)->D1_VALIPI
				    EndIf       
				    
						If (cAliasSFT)->FT_CREDST $ "3|4" .And. !(cAliasSFT)->FT_ANTICMS == "1"
							aTotaliza[10]	+= 	RetStSpd(lResF3FT, cAliasSFT)												
						EndIf
				     
				EndIf
				//Adiciona valor de IPI ao valmerc para notas de Devolucao de Compra 
				If cEntSai == "2" .And. !(cAliasSF4)->F4_LFIPI$"T" .And. !(cAliasSF4)->F4_IPI$"R" .And. (cAliasSFT)->FT_TIPO$"DB"
					aTotaliza[10]	 += (cAliasSFT)->FT_IPIOBS
				EndiF
				aTotaliza[11]	+=	(cAliasSFT)->FT_FRETE	   							//Totaliza o valor de frete do documento
				aTotaliza[12]	+=	(cAliasSFT)->FT_SEGURO	   	   						//Totaliza o valor de seguro das mercadorias do documento

				//Tratamento para nao levar valor negativo
				If (cAliasSFT)->(FT_DESPESA-(FT_SEGURO+FT_FRETE))>0
					aTotaliza[13]	+=	(cAliasSFT)->(FT_DESPESA-(FT_SEGURO+FT_FRETE))	//Totaliza as outras despesas do documento fiscal. Este tratamento se faz necessario porque FRETE e SEGURO incorporam o valor da despesa no sistema
				EndIf
				aTotaliza[19]	+=	Iif(lPisZero .Or. lOperGar,0,(cAliasSFT)->FT_VALPIS)	//Totaliza o valor de PIS do documento
				aTotaliza[20]	+=	Iif(lPisZero .Or. lOperGar,0,((cAliasSFT)->FT_VALCOF - (cAliasSFT)->FT_MVALCOF))//Totaliza o valor da Cofins do documento
				aTotaliza[21]	+=	(cAliasSFT)->FT_VALPS3	//Totaliza o valor de PIS/ST do documento
				aTotaliza[22]	+=	(cAliasSFT)->FT_VALCF3	//Totaliza o valor da Cofins/ST do documento				
				aTotaliza[26]	+=	IIf(nAbatNT>0,nAbatNT,0)	//Totaliza o valor do Abatimento não tributado e não comercial
				//Valores que devem ser acumulados somente se nao for item de servico
				If !lIss
					aTotaliza[2]	+=	(cAliasSFT)->FT_BASEICM							//Totaliza a base de ICMS do documento
					aTotaliza[3]	+=	(cAliasSFT)->FT_VALICM-(cAliasSFT)->(IIF(!lMVUFICSEP.Or.Left(FT_CFOP,1)<>'5'.Or.FT_TIPO$"BD",0,FT_VALFECP))	//Totaliza o valor de ICMS do documento
					If ( nValST > 0 ).OR. ((cAliasSFT)->FT_BASERET  > 0 .AND.  (cAliasSFT)->FT_CREDST <> "4" ) .OR. ( (cAliasSFT)->FT_CREDST <> "4" .AND. (cAliasSFT)->FT_ESTADO $ cMVUFBsSt )					
						aTotaliza[4]	+=	(cAliasSFT)->FT_BASERET			 			//Totaliza a base de ICMS/ST do documento
						aTotaliza[5]	+=	nValST-(cAliasSFT)->(IIF(!lMVUFICSEP.Or.Left(FT_CFOP,1)<>'5'.Or.FT_TIPO$"BD",0,FT_VFECPST))				//Totaliza o valor de ICMS/ST do documento
					EndIf
					
					If cEntSai == "1" .And. (cAliasSF4)->F4_LFIPI$"T"
						If !(cAliasSFT)->FT_TIPO$"DB"
							aTotaliza[6]	+=	Iif((cAliasSF4)->F4_IPI$"R",0,(cAliasSD1)->D1_VALIPI) //Totaliza o valor de IPI do documento. Exc.: comercio não atacadista
						Else
							aTotaliza[6]	+= (cAliasSFT)->FT_VALIPI
						EndIf
					ElseIf cEntSai == "2"
						aTotaliza[6]	+= Iif(!(cAliasSF4)->F4_LFIPI$"T" .And. (cAliasSF4)->F4_IPI$"R",0,(cAliasSFT)->FT_VALIPI) //Totaliza o valor de IPI do documento. Exc.: comercio não atacadista
					EndIf

					aTotaliza[7] 	+=	(cAliasSFT)->(FT_OUTRICM+FT_ISENICM)			//Totaliza a parte do valor da mercadoria que nao tributada pelo ICMS
					
					/*Campo VL_NT Valor não-tributado não deve ser preenchido quando material de uso e consumo para D100
					Consultoria Tributaria: http://tdn.totvs.com/pages/releaseview.action?pageId=286744035
					*/
					aTotaliza[14]	+=	Iif((cAliasSF4)->F4_CONSUMO <> "S" .And. cEspecie$"#07#08#8B#09#10#11#26#57",(cAliasSFT)->(FT_OUTRICM+FT_OUTRRET+FT_ISENICM+FT_ISENRET),0)	//Totaliza a parte do valor da mercadoria que nao foi tributada
					
					aTotaliza[15]	+=	(cAliasSFT)->FT_BASEIPI							//Totaliza a base do IPI do documento
					aTotaliza[16]	+=	(cAliasSFT)->FT_ISENIPI							//Totaliza a parte isenta do IPI
					aTotaliza[17]	+=	(cAliasSFT)->FT_OUTRIPI							//Totaliza outras escrituracoes do IPI
					aTotaliza[18]	+=	(cAliasSFT)->FT_ICMSCOM							//Totaliza o ICMS Complementar do documento - Diferencial de aliquota
				EndIf
				
				// Para entradas totaliza os valores da tabela SFU para apresentacao
				// no registro C500. Como soh sera gerado um registro C500 por NF e
				// soh exite um campo de classe de consumo, os valores serao agrupados 
				// por classe, desta forma, nao deveria existir mais de uma linha de 
				// complemento com classes diferentes na mesma NF de entrada.				
				If cEntSai == "1" .And. lAchouSFU .And. lGravaC500
					If !Empty(SFU->FU_CLASCON)
						If (nPosSFU := aScan(aDadSFU, {|x| AllTrim(x[1]) == AllTrim(SFU->FU_CLASCON)})) == 0
							aAdd(aDadSFU, {})
							nPosSFU := Len(aDadSFU)
							aAdd(aDadSFU[nPosSFU], SFU->FU_CLASCON)                               		// 01 - Classe de consumo.
							aAdd(aDadSFU[nPosSFU], Iif(aSPDSX3[FP_FU_TIPLIGA], SFU->FU_TIPLIGA, "")) 	// 02 - Tipo de Ligacao.
							aAdd(aDadSFU[nPosSFU], Iif(aSPDSX3[FP_FU_GRUPT],SFU->FU_GRUPT,""))       	// 03 - Grupo de tensao.
							aAdd(aDadSFU[nPosSFU], SFU->FU_VALTERC)                             	   	// 04 - Valor total cobrado em nome de terceiros.
							aAdd(aDadSFU[nPosSFU], Iif(aSPDSX3[FP_FU_VLFORN], SFU->FU_VLFORN, 0))		// 05 - Valor total fornecido/consumido.							  							  					
						Else
							aDadSFU[nPosSFU, 4] += SFU->FU_VALTERC 	
							aDadSFU[nPosSFU, 5] += Iif(aSPDSX3[FP_FU_VLFORN], SFU->FU_VLFORN, 0)
						EndIf
					EndIf
				EndIf
								
				lFirstNF	:=	.F.	//Tratamento de um flag para indicar um processamento unico de nota fiscal
				nItem++
				(cAliasSFT)->(DbSkip ())
			EndDo	//ENDDO do item					

			IF lBlocoB
				//Grava registros B030 e B035
				If Len(aRegB030) > 0
					GrvRegTrS(cAlias,RetRD(cRelacDoc),aRegB030)
					GrvRegTrS(cAlias,cRelacDoc,aRegB035)
				EndIf				
				If Len(aRegB020) > 0
					GrvRegTrS(cAlias,RetRD(cRelacDoc),aRegB020)
					GrvRegTrS(cAlias,cRelacDoc,aRegB025)
				EndIf
			EndIF

			If lInscrito //---Somente contribuintes do ICMS---//
			
				//³SOMENTE MODELOS:
				//³01 - NOTA FISCAL NORMAL
				//³1B - NOTA FISCAL AVULSA
				//³02 - NOTA FISCAL PRODUTOR
				//³03 - NOTA FISCAL DE SERVICOS
				//³04 - NOTA FISCAL DE VENDA A CONSUMIDOR FINAL
				//³06 - NOTA FISCAL/CONTA DE ENERGIA ELETRICA
				//³21 - NOTA FISCAL DE SERVICO DE COMUNICACAO
				//³22 - NOTA FISCAL DE SERVICO DE TELECOMUNICACAO
				//³28 - NOTA FISCAL/CONTA DE FORNECIMENTO DE GAS
				//³29 - NOTA FISCAL/CONTA DE FORNECIMENTO D'AGUA CANALIZADA
				//³55 - NOTA FISCAL ELETRONICA
				//³65 - NOTA FISCAL ELETRONICA AO CONSUMIDOR FINAL
				// 66 - NOTA FISCAL DE ENERGIA ELÉTRICA ELETRÔNICA – NF3e - c66
				// 59 - CUPOM FISCAL MODELO SAT
				If cEspecie$"01#1B#02#2D#04#06#14#15#16#21#22#28#29#55#59"+c66+ Iif(cEntSai=="1","","#65")

					//³REGISTRO C100 - NOTA FISCAL CODIGO 01, NOTA FISCAL PRODUTOR CODIGO 04
					//³REGISTRO C140 - FATURA e C141 - VENCIMENTO DA FATURA (CODIGO 01)
					//|Funca que retorna as parcelas dos titulos do documento fiscal.
					//lproctit faço controle para não ler por item e somente por nota.
					If lproctit 
						lproctit = .F.

						If cEntSai=="1"
							aParcTit	:=	SpedProSE2(aCmpAntSFT)
						Else
							aParcTit	:=	SpedProSE1(aCmpAntSFT)
						EndIf
					EndIf					
					//³REGISTRO C100 - NOTA FISCAL CODIGO 01, NOTA FISCAL PRODUTOR CODIGO 04
					//|Funca independente, monto a estrutura e efetuo a gravacao. Porem, processo para todos,  |
					//|  pois utilizo o array para montar outros registros e ter um unico lugar com as         |
					//|  informacoes base.			
					RegC100(cEntSai,aPartDoc,cEspecie,cAlias,cRelacDoc,aCmpAntSFT,aTotaliza,@aRegC100,cSituaDoc,@lGrava0150,aParcTit,lPisZero,lCofZero,cVersao,aWizard,lOperGar,cSitDocInf,aPartSM0)

					//Grava registro C101 para informações do FECP
					If cEspecie == '55' .AND. !cSituaDoc $ "02/03/04/05" .AND. nDifalDest+nDifalOrig+nDifalFEcp > 0
						GrvRegTrS(cAlias,RetRD(cRelacDoc),{{'C101',nDifalFEcp,nDifalDest,nDifalOrig}})
						lE300Ori := .T.
					EndIF

					//³REGISTRO 1700 - DOCUMENTOS FISCAIS UTILIZADOS
					//³REGISTRO 1710 - DOCUMENTOS FISCAIS CANCELADOS/INUTILIZADOS
					//|Funca que gera a estrutura dos registros acima e os grava no final do processamento da
					//|  rotina, pois se referem a um aglutinado de documentos por codigo de dispositivo,
					//|  especie e serie
					If "S"$aReg1010[1][9] .And. (cEntSai=="2" .or. (cEntSai=="1" .and. cIndEmit == "0")) // Para documento de saida ou documento de entrada de emissão Propria
						SpdFRg1700(aRegC100,@aReg1700,@aReg1710,cSituaDoc,aCmpAntSFT[2])
					Endif
					If (cEspecie$"01#1B#04#55#65")
						If !cSituaDoc$"02#03#04#05" .Or. (cSituaDoc$"02" .And. cSitDocInf$"08")
							lCondC120 := (cEntSai=="1" .And. (lAchouCD5 .Or. lEICImport))
							If lGerouC170 .OR. (cEspecie$"55" .AND. (lAchouCDT .OR. lCondC120 .OR. aExistBloc[18] .OR. cSitDocInf$"08" .OR. lRegEspPr)) .And. cPerfil <> "C"						
								//³REGISTRO C111 - PROCESSO REFERENCIADO

								//|Funcao que gera a estrutura do registro acima, mais o G110 e 0450. A gravacao do C111
								//| ocorre no final do processamento do documento fiscal
								If lAchouCDG .Or. (cSituaDoc$"02#03" .And. cSitDocInf$"08")
									RegC111(cAliasCDG,@aRegC110,@aReg0450,@aRegC111,lTop,aCmpAntSFT,cSitDocInf,cProtocolo)
								EndIf

								//³REGISTRO C112 - GUIA REFERENCIADA
								//|Funcao que gera a estrutura do registro acima, mais o G110 e 0450. A gravacao do C112
								//| ocorre no final do processamento do documento fiscal
								If lAchouCDC
									RegC112(cAliasCDC,@aRegC110,lTop,@aReg0450,@aRegC112,@aIcmPago,aCmpAntSFT)
								EndIf
								//³REGISTRO C113 - DOCUMENTO FISCAL REFERENCIADO                                           ³
								//|Funcao que gera a estrutura do registro acima, mais o G110 e 0450. A gravacao do C113
								//| ocorre no final do processamento do documento fiscal
								If lAchouCDD
									RegC113(cAlias,cAliasCDD,@aRegC110,@aReg0450,cEntSai,aCmpAntSFT,@aReg0150,@aRegC113,aWizard,lTop, cTipoNf)
								EndIf

								//³REGISTRO C114 - CUPOM FISCAL REFERENCIADO                                               ³
								//|REGISTRO C116 - CUPOM FISCAL ELETRÔNICO REFERENCIADO - SATCE                            |
								//|Funcao que gera a estrutura do registro acima, mais o G110 e 0450. A gravacao do C114   |
								//| ocorre no final do processamento do documento fiscal                                   |
								If !lLegisPer
									//Nota sobre cupom
									If lAchouCDE .And. (cEntSai=="2" .Or. (cEntSai=="1" .And. aCmpAntSFT[20] == "D"))
										aAreaCDE := (cAliasCDE)->(GetArea())
										RegC114(cAliasCDE,@aRegC110,@aReg0450,aCmpAntSFT,@aRegC114,,aCmpAntSFT[29],lTop,cEntSai)
										RestArea(aAreaCDE)
										RegC116(cAliasCDE,@aRegC110,@aReg0450,aCmpAntSFT,@aRegC116,,aCmpAntSFT[29],lTop,cEntSai)
										RestArea(aAreaCDE)
									//³Se nao existir CDT, tenho que fazer verificacao se existe cupom fiscal referenciado³
									//³  quando tem integracao com o SIGALOJA. Para isso foi criado o parametro necessario³
									//³  para indicar um codigo de CCE valido para criar o lancamento corretamente
									ElseIf lAchouCDE .AND. cEntSai=="2" .And. !Empty(cCodRefLj)

										//³Tratamento para alterar o ALIAS da tabela SF? quando for TOP ou DBF, pois em TOP³
										//³  os campos estao no SELECT
										If !Empty(aCmpAntSFT[29])

											//³REGISTRO C114 - CUPOM FISCAL REFERENCIADO                                               ³
											//|REGISTRO C116 - CUPOM FISCAL ELETRÔNICO REFERENCIADO - SATCE                            |
											//|Funcao que gera a estrutura do registro acima, mais o G110 e 0450. A gravacao do C114   |
											//| ocorre no final do processamento do documento fiscal                                   |
											aAreaCDE := (cAliasCDE)->(GetArea())
											RegC114(cAliasCDE,@aRegC110,@aReg0450,aCmpAntSFT,@aRegC114,cCodRefLj,aCmpAntSFT[29],lTop,cEntSai)
											RestArea(aAreaCDE)
											RegC116(cAliasCDE,@aRegC110,@aReg0450,aCmpAntSFT,@aRegC116,cCodRefLj,aCmpAntSFT[29],lTop,cEntSai)
											RestArea(aAreaCDE)
										EndIf
									ElseIf lAchouCDE .AND. cEntSai=="1" .And. aCmpAntSFT[20] == "D" .And. !Empty(cCodRefLj)
										aAreaCDE := (cAliasCDE)->(GetArea())
										RegC114(cAliasCDE,@aRegC110,@aReg0450,aCmpAntSFT,@aRegC114,cCodRefLj,aCmpAntSFT[29],lTop,cEntSai)
										RestArea(aAreaCDE)
										RegC116(cAliasCDE,@aRegC110,@aReg0450,aCmpAntSFT,@aRegC116,cCodRefLj,aCmpAntSFT[29],lTop,cEntSai)
										RestArea(aAreaCDE)
									EndIf
								EndIf
								//³REGISTRO C115 - LOCAL DE COLETA ENTREGA                                                 ³
								//|Funcao que gera a estrutura do registro acima, mais o G110 e 0450. A gravacao do C115   |
								//| ocorre no final do processamento do documento fiscal                                   |
								If lAchouCDF .And. cEspecie$"01#1B#04" .And. cEntSai=="2"  .And. cPerfil <> "C"
									RegC115(cAliasCDF,@aRegC110,@aReg0450,aCmpAntSFT,@aRegC115,lTop)
								EndIf
								//³REGISTRO C110 - INFORMACAO COMPLEMENTAR DA NOTA FISCAL (CODIGO 01, 04 E 55)             ³
								//³Funcao que gera apenas o registro C110 - Informação complementar                        ³
								
								//³Geracao dos registros C110 e 0450 a partir do Ponto de Entrada SPDPISIC	³
								If aExistBloc[18] .And. cPerfil<>"C"
									aSpdInfC	:=	ExecBlock("SPDPISIC",.F.,.F.,{	aCmpAntSFT[1],; 	//FT_NFISCAL
																					aCmpAntSFT[2],; 	//FT_SERIE
																					aCmpAntSFT[3],; 	//FT_CLIEFOR
																					aCmpAntSFT[4],; 	//FT_LOJA
																					aCmpAntSFT[5],;		//FT_ENTRADA
																					cEntSai})			//Entrada/Saida
									If Len(aSpdInfC) > 0																				
										For nI := 1 To Len(aSpdInfC)
											RegC110(,@aRegC110,@nPosC110,@aReg0450,,,aSpdInfC[nI],,,,,lRegEspPr)							 		
										Next nI							 	
									ElseIf (lAchouCDT .Or. (cSituaDoc$"02#03" .And. cSitDocInf$"08") .OR. lRegEspPr)  .And. cPerfil <> "C"
										RegC110(@aInfCompl,@aRegC110,@nPosC110,@aReg0450,cAliasCDT,lTop,,aCmpAntSFT,nMVSPDIFC,lCmpDscComp)							 								
									EndIf
									
								ElseIf (lAchouCDT .Or. (cSituaDoc$"02#03" .And. cSitDocInf$"08") .OR. lRegEspPr)  .And. cPerfil <> "C"
									RegC110(@aInfCompl,@aRegC110,@nPosC110,@aReg0450,cAliasCDT,lTop,,aCmpAntSFT,nMVSPDIFC,lCmpDscComp)							 								
								EndIf

								//GRAVACAO DOS COMPLEMENTOS PROCESSADOS ANTERIORMENTE

								//REGISTRO C110 - INFORMACAO COMPLEMENTAR DA NOTA FISCAL (CODIGO 01, 04 E 55)
								//REGISTRO C111 - PROCESSO REFERENCIADO
								//REGISTRO C112 - GUIA REFERENCIADA
								//REGISTRO C113 - DOCUMENTO FISCAL REFERENCIADO
								//REGISTRO C114 - CUPOM FISCAL REFERENCIADO
								//REGISTRO C115 - LOCAL DE COLETA ENTREGA

								//|Funca que gera a estrutura dos registros acima e os grava no final do processamento do
								//|  documento fiscal

								GrRegDep(cAlias, aRegC110, aRegC111,,,,,,.T.,.T.)
								GrRegDep(cAlias, aRegC110, aRegC112,.T.,,.F.,,,.T.,.T.)
								GrRegDep(cAlias, aRegC110, aRegC113,.T.,,.F.,,,.T.,.T.)
								GrRegDep(cAlias, aRegC110, aRegC114,.T.,,.F.,,,.T.,.T.)
								GrRegDep(cAlias, aRegC110, aRegC115,.T.,,.F.,,,.T.,.T.)
								GrRegDep(cAlias, aRegC110, aRegC116,.T.,,.F.,,,.T.,.T.)
								If cEspecie$"01#55"  .And. cPerfil <> "C"
									//³REGISTRO C120 - DECLARACAO/BASE DE CALCULO DE IMPORTACAO (MODELO 01)
									//|Funca independente, gera a estrutura e efetua a gravacao no TRB
									//|  documento fiscal
									If !(lLegisPer .And. aTpMov[nContMov]$"E")
										If lCondC120
										//If cEntSai=="1" .And. (lAchouCD5 .Or. (lSigaEIC .And. !Empty((Iif(lTop,cAliasSFT,cAlsSF))->(cCmpHawb)) .And. Len(aAvImport)>0))
											RegC120(cAlias,cRelacDoc,cAliasCD5,lSigaEIC,aAvImport,lAchouCD5,aWizard)
										EndIf
									EndIf
									//³REGISTRO C140 - FATURA e C141 - VENCIMENTO DA FATURA                                    ³
									//|Funca independente, gera a estrutura e efetua a gravacao no TRB                         |
									//|  documento fiscal                                                                      |
									If !lLegisPer
										If !(cEspecie$"55")
											C140C141(cAlias,GetRelaGrv(GetRelacPr(), 8),aRegC100,aParcTit,cEntSai,aCmpAntSFT)
										EndIf
									EndIf
								EndIf

								//Somente para documentos de SAIDA

								If cEntSai == "2"
									//³REGISTRO C130 - ISS                                                                     ³
									//|Funca de gravacao do registro no arquivo de trabalho (TRB) da rotina                    |
									//|Obs: Soh devo gravar se houver valores. Este array sempre terah 1 indice, por isso tenho|
									//|     que ver os valores                                                                 |
									If lGera .And. aRegC130[2]+aRegC130[3]+aRegC130[4]+aRegC130[5]+aRegC130[6]+aRegC130[7]+aRegC130[8]>0
										GrvRegTrS(cAlias,GetRelaGrv(GetRelacPr(), 9),{aRegC130})
									EndIf
									//³REGISTRO C160 - VOLUMES TRANSPORTADOS                                                   ³
									//|Funca independente, gera a estrutura e efetua a gravacao no TRB                         |
									//|  documento fiscal                                                                      |

									//If cEspecie$"01#04" .And. cEntSai=="2"
									//	RegC160(cAlias,cRelacDoc,@aReg0150,aWizard,aCmpAntSFT,lCadParti,aHistSA4,lAchouDA3,cAliasSA4,aF2EspVol)
									//EndIf

									//³REGISTRO C165 - TRANSPORTE DE COMBUSTIVEIS
									//|Funca independente, efetua a gravacao no TRB das informacoes do registro processadas
									//|  anteriormente

									If Len(aRegC165)>0
										//GrvRegTrS(cAlias,cRelacDoc,aRegC165)
										GrvRegTrS(cAlias,GetRelaGrv(cRelacDoc, 6),aRegC165)										
									EndIf
								EndIf

							//³Tratamento para quando for modelo 55(NF-e), gerar as informacoes da GNRE por NF
							//³  somente para agregar ao registro E250, jah que conforme manual, para esta especie de
							//³  NF somente o registro C100 e C190 devem ser gerados

							EndIf
							
							If cEspecie == "55" .And. lAchouCDC
								SpdGnreDoc(@aIcmPago, cAliasSF6, cAliasCDC, cCDCChv)
							EndIf
							//REGISTRO C190 - REGISTRO ANALITICO DO DOCUMENTO                                         ³
							//REGISTRO C191: INFORMAÇÕES DO FUNDO DE COMBATE À POBREZA – FCP – NA NFe (CÓDIGO 55)		
							//|Funca de gravacao do registro no arquivo de trabalho (TRB) da rotina                    |								
							//GrvRegTrS(cAlias,cRelacDoc,aRegC190)
							//GrRegDep(cAlias,aRegC190,aRegC191,,,,cRelacDoc)
							GrRegDep(cAlias, aRegC190, aRegC191,,,,,,.T.,.T.)
						
							//³REGISTRO C195 - OBSERVACOES DO LANCAMENTO FISCAL (CODIGO 01 E 55)                       ³
							//³REGISTRO C197 - OUTRAS OBRIGACOES TRIBUTARIAS, AJUSTES E INFORMACOES DE VALORES         ³
							//|                PROVENIENTES DE DOCUMENTO FISCAL                                        |
							//|Funca independente, gera a estrutura e efetua a gravacao no TRB                         |
							//|  documento fiscal                                                                      |
							If (Len(aLanCDA) > 0 .OR. Len(aLancFis) > 0  .Or. aExistBloc[23])
								C195C197( cAlias, cRelacDoc, aLanCDA, @aReg0460, aCmpAntSFT, cEspecie, aLancFis, cMVEstado,;
										@aReg0200, @aReg0190, @aReg0220, dDataDe, dDataAte,cMVSPDTC95,aWizard )										
							EndIf         
						EndIf
					ElseIf (cEspecie$"02") .And. cEntSai == "2" .And. !(cSituaDoc$"02#03#04#05")	//02=Situacao de cancelada
						If cPerfil == "A" .And. !(cSituaDoc$"02#03#04#05")

							//³REGISTRO C350 - NOTA FISCAL DE VENDA A CONSUMIDOR (CODIGO 02)
							//|Funcao independente, pois processa e grava as informacoes do registro C350 e efetua
							//| tambem a gravacao do C390 com base nas informacoes processadas anteriormente
							C350C390(cAlias,cRelacDoc,aRegC100,aPartDoc,cAliasSFT,aRegC390,@lNotaC350,aWizard,aCmpAntSFT)
						EndIf

					ElseIf (cEspecie$"06#28#29"+c66)
						lEntraC500:=.T.
						
						If lGravaC700
							If lGera
								//|C700 - CONSOLIDACAO DOS DOCUMENTOS NF/CONTA DE ENERGIA ELETRICA (COD 06), EMITIDAS EM
								//|       VIA UNICA (EMPRESAS OBRIGADAS A ENTREGA DO ARQUIVO PREVISTO NO CONVENIO ICMS
								//|       115/03) E NOTA FISCAL/CONTA DE FORNECIMENTO DE GAS CANALIZADO (COD 28)

								//|Atribui os valores do array aRegC700 para efetuar a gravacao no final do processamento
								//|  da rotina.
								nPosC700	:=	RegC700(aRegC100,@aRegC700,lAchouSFU,aCmpAntSFT,lAchouCD3,cEspecie,cSituaDoc)

								//|C790 - REGISTRO ANALITICO DO DOCUMENTO (MODELO 06)
								//|Atribui os valores do array aRegC790 para efetuar a gravacao no final do processamento
								//|  da rotina.
								RegC790(aRegC590,nPosC700,@aRegC790,@aRegC700,@aRegC791,aCmpAntSFT,cMVSUBTRIB,cSituaDoc,@aReg0460)
								//|1500 - NOTA FISCAL CONTA DE ENERGIA ELETRICA (MODELO 06)
								//|Funcao independente, montagem e gravacao das informacoes do registro 1500
								If lGrava1500 .And. "S"$aReg1010[1][7]
									Reg1500(cAlias,cRelacDoc,aRegC100,aTotaliza,lAchouSFU,@lGrava0150,aCmpAntSFT,aWizard)
								EndIf
							EndIf
							lEntraC500:=.F.
						EndIf
						//Este trecho era o Else do if do lGravaC700, como a variável lGravaC500 é usada para controle do C600 e outras 
						// definições para os modelos 06,29,28 fiz o controle se entra aqui tbm pela variável lEntraC500
						If lEntraC500 .Or. lGravaC500 
							//³REGISTRO 0450 - TABELA DE INFORMACAO COMPLEMENTAR/OBSERVACAO
							//|Atribui os valores do array aReg0450 para efetuar a gravacao no final do processamento
							//| da rotina.
							If lAchouCDT
								If !(cAliasCDT)->(Empty(CDT_IFCOMP))
									aInfCompl	:=	{(cAliasCDT)->CDT_IFCOMP,}
									Reg0450(@aInfCompl,@aReg0450)
								EndIf
							EndIf

							//|REGISTRO C500 - NOTA FISCAL/CONTA ENERGIA ELETRICA (MODELO 06)
							//|Funcao independente, montagem e gravacao das informacoes do registro C500
							//|Retorna por parametro o array aRegC500 para ser utilizado por outras funcoes
							RegC500(cAlias,cRelacDoc,aRegC100,aTotaliza,@aRegC500,nItem,lAchouSFU,lAchouCD3,lGravaC500,@lGrava0150,aCmpAntSFT,lAchouCD4,aInfCompl,cAliasCD4,aWizard,aDadSFU,aPartDoc,lAchouCDD,cAliasCDD)
							//³Tratamento para geracao dos registros do perfil B³
							If !lGravaC500 .And. cEntSai=="2" .And. cPerfil=="B"															
								If lGera
									//³REGISTRO C600 - CONSOLIDACAO DIARIA DE NOTAS FISCAIS/CONTA DE ENERGIA ELETRICA
									//|                (MODELO 06), NOTA FISCAL/CONTA DE FORNECIMENTO D'AGUA CANALIZADA
									//|                (CODIGO 29) E NOTA FISCAL/CONTA DE FORNECIMENTO DE GAS (CODIGO 28)
									//|Atribui os valores do array aRegC600 para efetuar a gravacao no final do processamento
									//| da rotina.								
									nPosC600:=	RegC600(aRegC500,aPartDoc,@aRegC600,lAchouSFU,lAchouCD3,lAchouCD4,cAliasCD4,cSituaDoc,aWizard)
									//³REGISTRO C601 - DOCUMENTOS CANCELADOS - CONSOLIDACAO DIARIA DE NOTAS FISCAIS/CONTA DE   |
									//|                ENERGIA ELETRICA (MODELO 06), NOTA FISCAL/CONTA DE FORNECIMENTO D'AGUA  |
									//|                CANALIZADA (CODIGO 29) E NOTA FISCAL/CONTA DE FORNECIMENTO DE GAS       |
									//|                (CODIGO 28)                                                             |
									//|                                                                                        |
									//|Atribui os valores do array aRegC601 para efetuar a gravacao no final do processamento  |
									//| da rotina.                                                                             |
									RegC601(aCmpAntSFT,@aRegC600,@aRegC601,nPosC600,aRegC500)
									//³REGISTRO C610 - ITENS DO DOCUMENTO CONSOLIDADO (NOTAS FISCAIS/CONTA DE ENERGIA ELETRICA |
									//|                (MODELO 06), NOTA FISCAL/CONTA DE FORNECIMENTO D'AGUA CANALIZADA        |
									//|                (CODIGO 29) E NOTA FISCAL/CONTA DE FORNECIMENTO DE GAS (CODIGO 28)      |
									//|                                                                                        |
									//|Atribui os valores do array aRegC610 para efetuar a gravacao no final do processamento  |
									//| da rotina.                                                                             |
									RegC610(aRegC500,aRegC510,lAchouSFU,@aRegC610,nPosC600,cSituaDoc,aWizard)
									//³REGISTRO C690 - REGISTRO ANALITICO  DOS DOCUMENTOS (NOTAS FISCAIS/CONTA DE ENERGIA ELE- |
									//|                TRICA (MODELO 06), NOTA FISCAL/CONTA DE FORNECIMENTO D'AGUA CANALIZADA  |
									//|                (CODIGO 29) E NOTA FISCAL/CONTA DE FORNECIMENTO DE GAS (CODIGO 28)      |
									//|                                                                                        |
									//|Atribui os valores do array aRegC610 para efetuar a gravacao no final do processamento  |
									//| da rotina.                                                                             |
									RegC690(aRegC590,nPosC600,@aRegC690)
								EndIf
							ElseIf lGravaC500 .And. !cSituaDoc$"02#03#04#05"
								//³Gravacao do REGISTRO C590   ³								
								//GrRegDep(cAlias,aRegC590,aRegC591,,,,cRelacDoc)
								GrRegDep(cAlias, aRegC590, aRegC591,,,,,,.T.,.T.)
							EndIf

							If cVersao >= "014" .And. !cSituaDoc$"02#03#04#05"
								//Gravacao do REGISTRO C595 e C597
								C595C597(cAlias,cRelacDoc,aLanCDA,@aReg0460,aCmpAntSFT,cEspecie,aLancFis,@aReg0200,@aReg0190,@aReg0220,dDataDe,dDataAte,aWizard)
							EndIf
						EndIf
					ElseIf (cEspecie$"21#22") //  Somente para o Modelo 21 e 22

						//³REGISTRO 0450 - TABELA DE INFORMACAO COMPLEMENTAR/OBSERVACAO                            ³
						//|Atribui os valores do array aReg0450 para efetuar a gravacao no final do processamento  |
						//| da rotina.                                                                             |
						If lAchouCDT
							If !(cAliasCDT)->(Empty(CDT_IFCOMP))
								aInfCompl	:=	{(cAliasCDT)->CDT_IFCOMP,}
								Reg0450(@aInfCompl,@aReg0450)
							EndIf
						EndIf
						//³REGISTRO D500 - NOTA FISCAL DE SERVICO DE COMUNICACAO (MODELO 21) E NOTA FISCAL DE      |
						//|                SERVICO DE TELECOMUNICACAO (MODELO 22)                                  |
						//|Funcao independente, montagem e gravacao das informacoes do registro D500               |
						RegD500(cAlias,cRelacDoc,aRegC100,aTotaliza,aCmpAntSFT,@aRegD500,nItem,lAchouSFX,lGravaD500,cSituaDoc,aInfCompl,aWizard)
						//³GRAVACAO - REGISTRO D590 - REGISTRO ANALITICO DO DOCUMENTO                              |
						If lGravaD500 .And. Len(aRegD590)>0
							GrvRegTrS(cAlias,cRelacDoc,aRegD590)
							lGrava0150 := .T.
						EndIf
						//³Tratamento para gerar os registros pertinentes ao perfil B, pois apesar de gerar as in- |
						//| formacoes nos arrays C500, C510 e C590, os mesmo nao sao gravados no TRB, pois servirao|
						//| de base para montar os outros registros.                                               |
						If !lGravaD500
							If cPerfil == "B" .And. cEntSai == "2" .And. !lConvC115							
								If lGera
									//³REGISTRO D600 - CONSOLIDACAO DE NOTA FISCAL DE SERVICO DE COMUNICACAO (MODELO 21) E NOTA| 
									//|                FISCAL DE SERVICO DE TELECOMUNICACAO (MODELO 22)                        ³
									//³REGISTRO D610 - ITENS CONSOLIDADO DE NOTA FISCAL DE SERVICO DE COMUNICACAO (MODELO 21) E|
									//|                NOTA FISCAL DE SERVICO DE TELECOMUNICACAO (MODELO 22)                   ³
									//|Atribui os valores nos arrays aRegD600 e aRegD610 para efetuar a gravacao no final do   |
									//| processamento da rotina.                                                               |								
									nPosD600 := D600D610(aRegD500,aPartDoc,aCmpAntSFT,@aRegD600,aRegD510,@aRegD610,lAchouSFX,aWizard)
									//|REGISTRO D690 - REGISTRO ANALITICO DOS DOCUMENTOS NOTA FISCAL DE SERVICO DE COMUNICACAO |
									//|                (MODELO 21) E NOTA FISCAL DE SERVICO DE TELECOMUNICACAO (MODELO 22)     ³
									//|Funcao independente, montagem e gravacao das informacoes do registro D690               |
									RegD690(aRegD590,cAlias,@aRegD690,nPosD600)
								EndIf
							ElseIf cEntSai=="2" .And. lConvC115
								//³D696 - REGISTRO ANALITICO DO DOCUMENTO (MODELOS 21 e 22 )                               | 
								//³D695 - CONSOLIDACAO DOS DOCUMENTOS NFSC ou NFST EMITIDA EM VIA UNICA (CPN. ICMS 115/03) |
								//|Atribui os valores nos arrays aRegD600 e aRegD610 para efetuar a gravacao no final do   |
								//| processamento da rotina.                                                               |
								If !lLegisPer
									D695D696(@aRegD696,@aRegD695,lAchouSFX,aRegD590,aRegC100,aCmpAntSFT,@aRegD697,cSituaDoc)
								EndIf
							EndIf
						EndIf
					ElseIf cEspecie$"#59" .And. cEntSai=="2" .And. cVersao >="017" .And. Len(aLanCDA) > 0  
						If cPerfil$"A" 						 
							C855C857(cAlias, aLanCDA, aReg0460, aCmpAntSFT, cHiC800_60, aReg0200, aReg0190, aReg0220, dDataDe, dDataAte, aWizard)
						ElseIf cPerfil$"B" 
							C895C897( cAlias, aLanCDA, @aReg0460, @aReg0200, @aReg0190, @aReg0220,;
										 dDataDe, dDataAte,aWizard,@aRegC895,@aRegC897,cChv890,nPosC890)
						Endif	
					EndIf

				//³SOMENTE MODELOS:                                                          ³
				//³07 - NOTA FISCAL SERVICO DE TRANSPORTE - SAIDA/ENTRADA                    ³
				//³08 - CONHECIMENTO DE TRANSPORTE RODOVIARIO - SAIDA/ENTRADA                ³
				//³09 - CONHECIMENTO DE TRANSPORTE AQUAVIARIO - ENTRADA                      ³
				//³10 - CONHECIMENTO DE TRANSPORTE AEREO - ENTRADA                           ³
				//³11 - CONHECIMENTO DE TRANSPORTE FERROVIARIO - ENTRADA                     ³
				//³26 -                                                                      ³
				//³57 - CONHECIMENTO DE TRANSPORTE ELETRONICO                                ³			
				//³63 - BILHETE DE PASSAGEM ELETRÔNICO – BP-e                                ³
				//³67 - CONHECIMENTO DE TRANSPORTE ELETRÔNICO PARA OUTROS SERVIÇOS - CT-e OS ³
				ElseIf cEspecie$"#07#08#8B#09#10#11#26#57#63#67"
					//³As informacoes CTR e NFST necessarias para o SINTEGRA somente estao disponiveis           |
					//³ quando o TMS estiver envolvido (SAIDAS) ou ENTRADAS quando envolver aviso de recebimento.³
					If (!lIss .And. cEntSai=="1") .Or. (cEntSai=="2" .And. (lIntTMS .Or. lSpedRTMS .Or. lIntGTP )) 

						If lAchouCDT
							//|Neste ponto utilizo somente o primeiro lancamento da CDT para gerar nos|
							//| documentos que exigem somente um codigo. Por exemplo: D100            |
							While !(cAliasCDT)->(Eof()) .AND. ((cAliasCDT)->(CDT_FILIAL+CDT_TPMOV+CDT_DOC+CDT_SERIE+CDT_CLIFOR+CDT_LOJA)==cCDTChv)
								If !Empty((cAliasCDT)->CDT_IFCOMP)	//Se houver algum preenchido, devo utilizar, senao nao eh inf. complementar
									Exit
								EndIF
								(cAliasCDT)->(dbSkip())
							End
							//³DBF/ADS nao tem JOIN, preciso fazer o SEEK, e a funcao Reg0450³
							//|faz automaticamente quando a descricao estah com NIL          |
							If !(cAliasCDT)->(Eof())
								aInfCompl	:=	{(cAliasCDT)->CDT_IFCOMP,}
								//³REGISTRO 0450 - TABELA DE INFORMACAO COMPLEMENTAR/OBSERVACAO                            ³
								//|Atribui os valores do array aReg0450 para efetuar a gravacao no final do processamento  |
								//| da rotina.                                                                             |
								Reg0450(aInfCompl,@aReg0450)
							EndIf
						EndIf

						//³REGISTRO D100:                                                                          ³
						//³07 - NOTA FISCAL SERVICO DE TRANSPORTE                                                  ³
						//³08 - CONHECIMENTO DE TRANSPORTE RODOVIARIO                                              ³
						//³09 - CONHECIMENTO DE TRANSPORTE AQUAVIARIO                                              ³
						//³10 - CONHECIMENTO DE TRANSPORTE AEREO                                                   ³
						//³11 - CONHECIMENTO DE TRANSPORTE FERROVIARIO                                             ³
						//³26 - CONHECIMENTO DE TRANSPORTE FERROVIARIO                                             ³
						//³27 - NF SERVICO DE TRANSPORTE FERROVIARIO                                               ³
						//³57 - CONHECIMENTO DE TRANSPORTE ELETRONICO                                              ³
						//|Funcao independente, montagem e gravacao das informacoes do registro D100               |
						If (cEntSai=="2" .And. lIntTMS .And. cEspecie$"57#63#67") .Or. (cEntSai=="2" .And. "1"$aWizard[1][7] .And. cEspecie$"08#09#10#11#26#27#57" .And. !cSituaDoc$"02#03" )					
							//³Remetente do conhecimento³
							If !lFindDT6Re
								aPartREM := aClone(aPartDoc)
							EndIf

							//³Destinatario do conhecimento³
							If !lFindDT6Co
								aPartDES := aClone(aPartDoc)
							EndIf
						// Tratamento para quando forem informados os municipios de origem/destino no documento de entrada. Preencher com 9999999, se Exterior.
						ElseIf cEntSai == "1" .And. lCpoMunSF1 .And. cEspecie $ "57#63#67" .And. !cSituaDoc$"02#03"
							cCdMunOri := IIf(aCmpAntSFT[49]=="EX","9999999",UfCodIBGE(aCmpAntSFT[49]) + AllTrim(aCmpAntSFT[50]))
							cCdMunDes := IIf(aCmpAntSFT[51]=="EX","9999999",UfCodIBGE(aCmpAntSFT[51]) + AllTrim(aCmpAntSFT[52]))
						Endif
						
						//Operações com Bp-e e  CTEOS
						If cEntSai == "2" .And. lCpoMunSF2 .And. cEspecie $ "63#67" .And. !cSituaDoc$"02#03"
							cCdMunOri := IIf(aCmpAntSFT[54]=="EX","9999999",UfCodIBGE(aCmpAntSFT[54]) + AllTrim(aCmpAntSFT[55]))
							cCdMunDes := IIf(aCmpAntSFT[56]=="EX","9999999",UfCodIBGE(aCmpAntSFT[56]) + AllTrim(aCmpAntSFT[57]))
						Endif

						If lGera
							RegD100(cAlias,cEntSai,aPartDoc,aTotaliza,cRelacDoc,cEspecie,aCmpAntSFT,cSituaDoc,;
								@lGrava0150,cOpSemF,lSpedRTms,lIntTMS,aInfCompl,cAliasSFT,@aReg0450,cVersao,cCdMunOri,cCdMunDes,cMunSM0, lAchouDT6, lInfCTEO)

							//Grava registro C101 para informações do FECP
							If cEspecie $ "57#63#67" .AND. !cSituaDoc $ "02/03/04/05" .AND. ( nDifalDest+nDifalOrig+nDifalFEcp > 0 .OR. ( cEspecie == "63" .and. substr(cCdMunOri,1,2) <> substr(cCdMunDes,1,2) .and. cCdMunDes<>"9999999") )
								GrvRegTrS(cAlias,RetRD(cRelacDoc),{{'D101',nDifalFEcp,nDifalDest,nDifalOrig}})
								lE300Ori := .T.
							EndIf
						EndIf

						If cEspecie == "57" .And. lAchouCDC
							SpdGnreDoc(@aIcmPago, cAliasSF6, cAliasCDC, cCDCChv)
						EndIf

						If cEntSai=="2" .And. ("1"$aWizard[1][7]) // Somente o prestador deve informar estes registros

							If cEspecie$"08#09#10#11#26#27#57" .And. !cSituaDoc$"02#03"  //Cancelado

								//-- Ponto de entrada para informar os participantes para clientes que nao usam SIGATMS.
								If aExistBloc[06] 
									aRetPart := ExecBlock("SPEDPTMS",.F.,.F.,{cAliasSFT,aCmpAntSFT})
									If ValType(aRetPart) == "A" .And. Len(aRetPart) > 0
										If ValType(aRetPart[1]) <> "A"
											aRetAux := aClone(aRetPart)
											aRetPart := {aRetAux}
										EndIf
										For nX := 1 To Len(aRetPart)
											SDPF150175(@aReg0150,aRetPart[nX],cAlias,aWizard,aExistBloc)
										Next
									EndIf
								EndIf

								If cPerfil <> "C"
									If cEspecie$"08#8B"
										//³REGISTRO D130 - COMPLEMENTO DO CONHECIMENTO RODOVIARIO (MODELO 08)                      ³
										//|Funcao independente, montagem e gravacao das informacoes do registro D130               |
										If lGera
											RegD130(cAlias,cRelacDoc,lAchouDA3,cSituaDoc,aMVCOMPFRT,lSpedRTms,lAchouDT8,cAliasDT8,;
												cCdMunOri,aPartREM,cCdMunDes,aPartDES,aPartCON,aPartDPC,@aReg0150,aWizard,cAliasSFT,aCmpAntSFT, lAchouDT6)
										EndIf
									ElseIf cEspecie$"09"
										//³REGISTRO D140 - COMPLEMENTO DO CONHECIMENTO AQUAVIARIO (MODELO 08)                      ³
										//|Funcao independente, montagem e gravacao das informacoes do registro D140               |
										If lGera
											RegD140(cAlias,GetRelacPr(),lSpedRTms,lAchouDA3,lAchouDUD,lAchouDT8,cAliasDT8,aPartREM,aPartDES,aPartCON,cAliasSFT,aCmpAntSFT)
										EndIf
									ElseIf cEspecie$"10"
										//³REGISTRO D150 - COMPLEMENTO DO CONHECIMENTO AEREO (MODELO 08)                           ³
										//|Funcao independente, montagem e gravacao das informacoes do registro D150               |
										If lGera
											RegD150(cAlias,GetRelacPr(),lSpedRTms,lAchouDA3,lAchouDUD,lAchouDT8,cAliasDT8,aPartREM,aPartDES,cAliasSFT,aCmpAntSFT)
										EndIf
									EndIf

									If cEspecie <> "57"
										//³REGISTRO D160 - CARGA TRANSPORTADA (MODELO 08 e 8B)                                          ³
										//|Funcao independente, montagem e gravacao das informacoes do registro D160               |
										If lGera
											RegD160(cAlias,cRelacDoc,cEspecie,lSpedRTms,aPartREM,cCdMunOri,aPartDES,cCdMunDes,cAliasSFT,aCmpAntSFT)

											//³Montagem dos registro para o perfil "A", o "B" nao os exige                             ³
											//³REGISTRO D161 - LOCAL DE COLETA ENTREGA                                                 ³
											//³REGISTRO D162 - IDENTIFICACAO DOS DOCUMENTOS FISCAIS                                    ³
											//|Funcao independente, montagem e gravacao das informacoes dos registros D161 e d162      |
											D161D162(cAlias,cRelacDoc,cEspecie,aCmpAntSFT,cMvD162,lSpedRTms,aPartREM,cCdMunOri,aPartDES,cCdMunDes,cAliasSFT,cPerfil,;
											lAchouDT5,cAliasDT5,lAchouDUL,cAliasDUL,lAchouDTC,cAliasDTC,lAchou2DUL,cDTCChv)            
										EndIf
									EndIf
								EndIf

								If !lTop
									RestArea(aAreaSA)
								EndIf
							EndIf
						EndIf

						//³REGISTRO D190 - REGISTRO ANALITICO DO DOCUMENTO                                         ³
						//|Funcao de gravacao das informacoes do registro D190                                     |
						If !(cSituaDoc$"02#03")
							//GrvRegTrS(cAlias,cRelacDoc,aRegD190)
							GrvRegTrS(cAlias,GetRelaGrv(cRelacDoc, 2),aRegD190)
						EndIf

						//³REGISTRO D195 - OBSERVACOES DO LANCAMENTO FISCAL 				                       ³
						//³REGISTRO D197 - OUTRAS OBRIGACOES TRIBUTARIAS, AJUSTES E INFORMACOES DE VALORES         ³
						//|                PROVENIENTES DE DOCUMENTO FISCAL                                        |
						//|Funca independente, gera a estrutura e efetua a gravacao no TRB                         |
						//|  documento fiscal                                                                      |
						If lGera .And. cVersao >="006" .And. Len(aLanCDA) > 0 .Or. Len(aLancFis) > 0
							D195D197(cAlias,cRelacDoc,aLanCDA,@aReg0460,aCmpAntSFT,cEspecie,aLancFis,lLegisPer)
						EndIf
					EndIf
				EndIf
			
			EndIF

			//³GRAVACAO REGISTRO 0150 - TABELA DE CADASTRO DE PARTICIPANTES                            ³
			//³GRAVACAO REGISTRO 0175 - ALTERACAO DA TABELA DE CADASTRO DE PARTICIPANTE                ³
			//|Funcao de gravacao das informacoes dos registros 0150 e 0175                            |
			If lGrava0150
				SDPF150175(@aReg0150,aPartDoc,cAlias,aWizard,aExistBloc,,aPartSM0)
			EndIf

		EndDo	//ENDDO da NF
		
		FreeObj(oRegC171)
		oRegC171 := Nil
		FreeObj(oRegC173)
		oRegC173 := Nil
		FreeObj(oRegC175)
		oRegC175 := Nil

		Conout('	Final execucao movimentos:' + aTpMov[nContMov] + ' - ' + DToC(Date()) + " - " + Time())

		#IFDEF TOP
			If (TcSrvType ()<>"AS/400")
				DbSelectArea (cAliasSFT)
				(cAliasSFT)->(DbCloseArea())
			Else
		#ENDIF
				RetIndex("SFT")
				FErase(cIndex+OrdBagExt())
		#IFDEF TOP
			EndIf
		#ENDIF

		cAliasSFT	:=	"SFT"

	Next nContMov

	//³Chama a função para processar os registros de PCL³
	If !lLegisPer
		If lPCLLOJA .AND. "S"$aReg1010[1][4]
			If !lJob
				oSay:cCaption := ("Buscando Informações de PCL")
				ProcessMessages()
			EndIf
			SPEDPCL(@aReg1300,@aReg1310,@aReg1320,@aReg1350,@aReg1360,@aReg1370,@aReg0190,@aReg0200,@aReg0220,cAlias,dDataDe,dDataAte,aWizard)
		EndIF
	EndIf

	SM0->(DbSkip ())
EndDo	//ENDDO da SM0 para a mesma EMPRESA
Conout('	Fim Execucao Registros por filial' + ' - ' + DToC(Date()) + " - " + Time())

//Destroi objeto
FreeObj(oObjSpdMov)
oObjSpdMov:= NIL

//³Restauro a area do SM0³
RestArea(aAreaSM0)
cFilAnt := FWGETCODFILIAL
aSPDFil	:= fGetSpdFil() // Refazendo o cache xFilial

//Processamento das informacoes do BLOCO E - APURACAO DE ICMS E DO IPI
If !lJob
	oSay:cCaption := ("Obtendo Informações de Apuração de IPI")
	ProcessMessages()
EndIf
BlocoE(lTabComp,aWizard,cFilDe,cFilAte,cAlias,cMVEstado,lTop,cMVSUBTRIB,aRegE510,,aVlrMovST,aIcmPago,aLanCDA,@aLanCDA2,cMVSTNIEUF,lOldLan,@aReg0200,@aReg0190,@aReg0220,aInfE313,lDifal,aMovSemIe,,,,,,,,,,,,,,,,,,,,,,,,aInfE531,lE300Ori,@aStruCDA)

//Processamento das subApurações do ICMS pelo registro 1900 e filhos 
aMVRLCSPD:= &(aSPDSX6[MV_RLCSPD])
For nX := 1 to Len(aMVRLCSPD)
	Aadd(aLiv1900,{aMVRLCSPD[nX,1],aMVRLCSPD[nX,2] , aMVRLCSPD[nX,3]})
Next nX
If !Empty(aLiv1900)
	Grupo1900(lTabComp,aWizard,cFilDe,cFilAte,cAlias,cMVEstado,lTop,,aLanCDA,@aLanCDA2,aLiv1900,lOldLan,,,@aReg0190,@aReg0220,@aReg0200,@aReg0150,@aStruCDA)
Endif


If lProcGiaf
	//Processamento das subApurações do ICMS para registros do prodepe
	aMVSPDPROD:= &(aSPDSX6[MV_SPDPROD]) //1- Livro Protheus // 2 - Indicador da sub-apuração por tipo de benefício  // 3 - Tipo:  industria ou CD ou importação
	IF ValType(aMVSPDPROD) == "A"
		For nX := 1 to Len(aMVSPDPROD)
			Aadd(aLivGIAF,{aMVSPDPROD[nX,1],aMVSPDPROD[nX,2],aMVSPDPROD[nX,3]})
		Next nX
		If !Empty(aLivGIAF)
			If !lJob
				oSay:cCaption := ("Processando Sub-Apuração de GIAF")
				ProcessMessages()
			EndIf
			GrupoGIAF(aWizard,cAlias,aLivGIAF,aBloco8)			
			FwFreeArray(aBloco8)
		Endif
	Endif
Endif

//Geração e Gravação do Bloco G CIAP
If cVersao >= "004"
	If !lJob
		oSay:cCaption := ("Gerando Bloco G")
		ProcessMessages()
	EndIf
	ConOut("	Inicio geracao BLOCO G " + DToC(Date()) + " - " + Time() )
	BlocoG(cAlias,lTop,aWizard,@aReg0200,@aReg0190,@aReg0220,@aReg0150,cFilDe,cFilAte,aLisFil,bWhileSM0,@lEnd,nCtdFil,nCountTot,@nRegsProc)
	ConOut("	Final geracao BLOCO G " + DToC(Date()) + " - " + Time() )
EndIf

If !lJob
	oSay:cCaption := ("Processando documentos de exportacao")
	ProcessMessages()
EndIf

//REGISTROS DE EXPORTACAO 
If lSigaEEC .And. "S"$aReg1010[1][2]
	If lEECSPED
		Reg1100Av(cAlias,@aReg0200,@aReg0190,@aReg0220,@aReg0150,aWizard,cFilDe,cFilAte,aLisFil,,nCtdFil,@lEnd,bWhileSM0,nCountTot,@nRegsProc)
	Else
		Reg1100Spd(cAlias,@aReg0200,@aReg0190,@aReg0220,@aReg0150,aWizard,cFilDe,cFilAte,aLisFil,,nCtdFil,@lEnd,bWhileSM0,nCountTot,@nRegsProc)
	EndIf
ElseIf lTabComp .And. "S"$aReg1010[1][2]
	Reg1100Spd(cAlias,@aReg0200,@aReg0190,@aReg0220,@aReg0150,aWizard,cFilDe,cFilAte,aLisFil,,nCtdFil,@lEnd,bWhileSM0,nCountTot,@nRegsProc)
EndIf


If cVersao >= '014' .And. "1"$aWizard[4][14]
	R12501255(bWhileSM0,cFilDe,dDataDe,dDataAte,cAlias,aWizard,,nRegsProc,nCtdFil,aLisFil,nCountTot,@lEnd,cFilAte)
EndIf
//REGISTROS DE CONTROLE DE CRÉDITO DE ICMS 
If lTabCE5 .And. "S"$aReg1010[1][3]
	R12001210(bWhileSM0,cFilDe,dDataDe,dDataAte,cAlias,aWizard,,nRegsProc,nCtdFil,aLisFil,nCountTot,@lEnd,cFilAte)
Endif


/*GRAVACAO - REGISTRO H005 - TOTAIS DO  INVENTARIO
  GRAVACAO - REGISTRO H010 - INVENTARIO */
If "1"$aWizard[1][6] .or. lRegCompST //Gerar registro quando selecionado na Wizard ou/e quando existir registro de complemento e restituição de ICMS ST - C180,C185,C186
	If !lJob
		oSay:cCaption := ("Processando Inventário")
		ProcessMessages()
	EndIf
    SPDBlocoH(cAlias,bWhileSM0,aWizard,cFilDe,aLisFil,aReg0190,@aReg0200,@aReg0220,@aReg0150,,nCtdFil,@lEnd,cFilAte)
EndIf

//Bloco K
IF lProcBLK //aWizard[1][16]=="1-Sim" .Or. aWizard[1][16]=="3-Sim - K200/K280"
	If !lJob
		oSay:cCaption := ("Gerando Bloco K")
		ProcessMessages()
	EndIf
    BlocoK(cAlias, bWhileSM0,aWizard,cFilDe,cFilAte,aLisFil,aReg0150,aReg0200,aReg0220,aReg0190,aReg0150,lConcFil,@aReg0210)
EndIf

//---Bloco B [Registros de Apuração]---//
If lBlocoB
	
	If !lJob
		oSay:cCaption := ("Gerando Bloco B")
		ProcessMessages()
	EndIf
	
	//Processa apuração de ISS
	SPDBlocoB(dDataDe, dDataAte, @aReg0460, @aRegB350, @aRegB420, @aRegB460, @aRegB470, @aRegB500, @aRegB510, @aRegB440, @aReg0150, nVlContOMun, cAlias, aWizard, cRelacDoc)

EndIf

//PE que possibilita a geracao dos registros 1300, 1310, 1320, 1350, 1360, e 1370
If !lPCLLOJA .AND. aExistBloc[07] .And. "S"$aReg1010[1][4]	
	aAux0200 := ExecBlock("SPED1300", .F., .F., {cAlias,dDataDe,dDataAte,aReg0200,aReg0190})
	If ValType(aAux0200) == "A"
		aReg0200 := aAux0200
	Endif
EndIf

//PE que possibilita a geracao dos registros 1390, 1391 
If cVersao >= "006" .And. aExistBloc[08] .And. "S"$aReg1010[1][5]
	aAux0200 := ExecBlock("SPED1390", .F., .F., {cAlias,dDataDe,dDataAte,aReg0200,aReg0190})
	If cVersao >= "014" .And. ValType(aAux0200) == "A"
		aReg0200 := aAux0200
	Endif
EndIf

//GRAVACAO 1700 - Registro Doc Fiscais Utilizados 
//GRAVACAO 1710 - Registro Doc Fiscais Canc/Inutilizados
If Len(aReg1700) > 0
	GrRegDep(cAlias,aReg1700,aReg1710,.F.,,,,.T.)
	//Zera variaveis para desalocar memoria
	aSizeZero(@aReg1700)
	aSizeZero(@aReg1710)
EndIf


//Gravacao do REGISTRO 0200 - TABELA DE IDENTIFICACAO DO ITEM
GrRegDep(cAlias,aReg0200,aReg0205,.F.,,,,.T.)
GrRegDep(cAlias,aReg0200,aReg0206,.T.,,,,.T.)
GrRegDep(cAlias,aReg0200,aReg0210,.T.,,,,.T.)
GrRegDep(cAlias,aReg0200,aReg0220,.T.,,,,.T.)

//Zera variaveis para desalocar memoria
aSizeZero(@aReg0200)
aSizeZero(@aReg0220)

//Gravacao do REGISTRO 0400 - TABELA DE NATUREZA DA OPERACAO/PRESTACAO
GrvRegTrS (cAlias,, aReg0400)

//Zera variaveis para desalocar memoria
aSizeZero(@aReg0400)

//Gravacao do REGISTRO 0450 - TABELA DE INFORMACAO COMPLEMENTAR
GrvRegTrS (cAlias,,aReg0450)
//Zera variaveis para desalocar memoria
aSizeZero(@aReg0450)

//Gravacao do REGISTRO 0460 - TABELA DE OBSERVACOES
GrvRegTrS (cAlias,,aReg0460)

//Zera variaveis para desalocar memoria
aSizeZero(@aReg0460)

//³REGISTRO C300 - RESUMO DIARIO DAS NOTAS FISCAIS DE VENDA A CONSUMIDOR(MODELO 02)                      ³
//³REGISTRO C320 - REGISTRO ANALITICO DO RESUMO DIARIO DAS NOTAS FISCAIS DE VENDA A CONSUMIDOR(MODELO 02)³
//³REGISTRO C321 - ITENS DO RESUMO DIARIO DOS DOCUMENTOS(MODELO 02)                                      ³
//³REGISTRO C330 - INFORMAÇÕES COMPLEMENTARES DAS OPERAÇÕES DE SAÍDA DE MERCADORIAS SUJEITAS À SUBSTITUIÇÃO TRIBUTÁRIA (CÓDIGO 02)
//³REGISTRO C310 - DOCUMENTOS CANCELADOS(MODELO 02)³
SPEDRegs(cAlias,{aRegC300,aRegC310,{aRegC320,1},aRegC321,aRegC330})

//Zera variaveis para desalocar memoria
aSizeZero(@aRegC300)
aSizeZero(@aRegC310)
aSizeZero(@aRegC320)
aSizeZero(@aRegC321)
aSizeZero(@aRegC330)


//³Gravacao da hierarquia dos registros tipo C400   ³
GrRegDep(cAlias,aRegC400,aRegC405, .F. , 405, Nil, Nil, !lTop, .T. )
GrRegDep(cAlias,aRegC405,aRegC410, .T.,NIL,.F., , , .T. )
GrRegDep(cAlias,aRegC405,aRegC420, .T. , 420 ,,,.F., .T. )
GrRegDep(cAlias,aRegC420,aRegC425, .T., , , , , .T.)
GrRegDep(cAlias,aRegC425,aRegC430, .T., , , , , .T.)
//Somente grava aqui no TRB os registros C460 e C470 caso nao seja ambiente TOP, pois em ambiente Top Connect jah foram carregados dentro de sua funcao de processamento em MultiThread
If !lTop
	GrRegDep(cAlias,aRegC405,aRegC460, .T.,,,,.F., .T.)
	GrRegDep(cAlias,aRegC460,aRegC470, .T., , , , , .T.)
	GrRegDep(cAlias,aRegC470,aRegC480, .T., , , , , .T.)
EndIf
GrRegDep(cAlias,aRegC405,aRegC490, .T., , , , , .T.)
GrRegDep(cAlias,aRegC400,aRegC495, .T., , , , , .T.)

//Zera variaveis para desalocar memoria
aSizeZero(@aRegC400)
aSizeZero(@aRegC405)
aSizeZero(@aRegC410)
aSizeZero(@aRegC420)
aSizeZero(@aRegC425)
aSizeZero(@aRegC430)
aSizeZero(@aRegC460)
aSizeZero(@aRegC470)
aSizeZero(@aRegC480)
aSizeZero(@aRegC490)
aSizeZero(@aRegC495)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//|                              GRAVACAO DOS REGISTROS :                                  |
//|                                                                                        |
//³REGISTRO C600 - CONSOLIDACAO DIARIA DE NOTAS FISCAIS/CONTA DE ENERGIA ELETRICA          |
//|                (MODELO 06), NOTA FISCAL/CONTA DE FORNECIMENTO D'AGUA CANALIZADA        |
//|                (CODIGO 29) E NOTA FISCAL/CONTA DE FORNECIMENTO DE GAS (CODIGO 28)      |
//|                                                                                        |
//³REGISTRO C601 - DOCUMENTOS CANCELADOS - CONSOLIDACAO DIARIA DE NOTAS FISCAIS/CONTA DE   |
//|                ENERGIA ELETRICA (MODELO 06), NOTA FISCAL/CONTA DE FORNECIMENTO D'AGUA  |
//|                CANALIZADA (CODIGO 29) E NOTA FISCAL/CONTA DE FORNECIMENTO DE GAS       |
//|                (CODIGO 28)                                                             |
//|                                                                                        |
//³REGISTRO C610 - ITENS DO DOCUMENTO CONSOLIDADO (NOTAS FISCAIS/CONTA DE ENERGIA ELETRICA |
//|                (MODELO 06), NOTA FISCAL/CONTA DE FORNECIMENTO D'AGUA CANALIZADA        |
//|                (CODIGO 29) E NOTA FISCAL/CONTA DE FORNECIMENTO DE GAS (CODIGO 28)      |
//|                                                                                        |
//³REGISTRO C690 - REGISTRO ANALITICO  DOS DOCUMENTOS (NOTAS FISCAIS/CONTA DE ENERGIA ELE- |
//|                TRICA (MODELO 06), NOTA FISCAL/CONTA DE FORNECIMENTO D'AGUA CANALIZADA  |
//|                (CODIGO 29) E NOTA FISCAL/CONTA DE FORNECIMENTO DE GAS (CODIGO 28)      |
//|                                                                                        |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
GrRegDep(cAlias, aRegC600, aRegC601)
GrRegDep(cAlias, aRegC600, aRegC610, .T.)
GrRegDep(cAlias, aRegC600, aRegC690, .T.)
//Zera variaveis para desalocar memoria
aSizeZero(@aRegC600)
aSizeZero(@aRegC601)
aSizeZero(@aRegC610)
aSizeZero(@aRegC690)

//Gravacao do REGISTRO C700, C790 e C791
If Len(aRegC790)>0
	SPEDRegs(cAlias,{aRegC700,aRegC790,aRegC791})
EndIf	

//Zera variaveis para desalocar memoria
aSizeZero(@aRegC700)
aSizeZero(@aRegC790)
aSizeZero(@aRegC791)

//Gravacao do REGISTRO C800, C810, C815, C850, C860, C890, C895, C897
If Len(aRegC800)>0
	GrRegDep(cAlias,aRegC800,aRegC810, .F. , , Nil, Nil, , .T. )
	If Len(aRegC815)>0 .And. Len(aRegC810)>0
		GrRegDep(cAlias,aRegC810,aRegC815, .T., , , , , .T. )
	Endif
	GrRegDep(cAlias,aRegC800,aRegC850, .T. , , , , , .T. )
EndIf	

If Len(aRegC860)>0
	GrRegDep(cAlias,aRegC860,aRegC870, .F. , , Nil, Nil, , .T. )
	If Len(aRegC880)>0 .And. Len(aRegC870)>0
		GrRegDep(cAlias,aRegC870,aRegC880, .T., , , , , .T. )
	Endif	
	GrRegDep(cAlias,aRegC860,aRegC890, .T. , , , , , .T. )
	
	If Len(aRegC895) > 0
		GrRegDep(cAlias, aRegC890, aRegC895, .T. , , , , , .T. )
		GrRegDep(cAlias, aRegC895, aRegC897,  .T. , , , , , .T. )
	Endif
EndIf

//Zera variaveis para desalocar memoria
aSizeZero(@aRegC800)
aSizeZero(@aRegC810)
aSizeZero(@aRegC815)
aSizeZero(@aRegC850)
aSizeZero(@aRegC860)
aSizeZero(@aRegC870)
aSizeZero(@aRegC880)
aSizeZero(@aRegC890)    
aSizeZero(@aRegC895)
aSizeZero(@aRegC897)

//³Gravacao do REGISTRO D300, D301 e D310  ³
GrRegDep(cAlias,aRegD300,aRegD301)
GrRegDep(cAlias,aRegD300,aRegD310,.T.)

aSizeZero(@aRegD300)
aSizeZero(@aRegD301)
aSizeZero(@aRegD310)

//³Gravacao do REGISTRO D695, D696 e D697  ³
If Len(aRegD695)>0
	SPEDRegs(cAlias,{aRegD695,aRegD696,aRegD697})
EndIf

//Zera variaveis para desalocar memoria
aSizeZero(@aRegD695)
aSizeZero(@aRegD696)
aSizeZero(@aRegD697)

//³GRAVACAO REGISTRO D600 - CONSOLIDACAO DE NOTA FISCAL DE SERVICO DE COMUNICACAO (MODELO 21)|
//|                  E NOTA FISCAL DE SERVICO DE TELECOMUNICACAO (MODELO 22)                 ³
//³GRAVACAO REGISTRO D610 - ITENS CONSOLIDADO DE NOTA FISCAL DE SERVICO DE COMUNICACAO       |
//|                     (MODELO 21) E NOTA FISCAL DE SERVICO DE TELECOMUNICACAO (MODELO 22)  ³
aSort(aRegD610,,,{|aX, aY| Str( aX[1],20 )+PadL( aX[3],10 )<Str( aY[1],20 )+PadL( aY[3],10 )})	//Ordenando o array filho pelo indice+item
GrRegDep(cAlias,aRegD600,aRegD610)
GrRegDep(cAlias,aRegD600,aRegD690,.T.)
//Zera variaveis para desalocar memoria
aSizeZero(@aRegD600)
aSizeZero(@aRegD610)
aSizeZero(@aRegD690)

//³Gravação do Registro 1250/1255/1300/1310/1320/1350/1360/1370³
SPEDRegs(cAlias,{aReg1250,aReg1255})
SPEDRegs(cAlias,{aReg1300,aReg1310,aReg1320})
SPEDRegs(cAlias,{aReg1350,aReg1360,{aReg1370,1}})
//Zera variaveis para desalocar memoria
aSizeZero(@aReg1250)
aSizeZero(@aReg1255)
aSizeZero(@aReg1300)
aSizeZero(@aReg1310)
aSizeZero(@aReg1320)
aSizeZero(@aReg1350)
aSizeZero(@aReg1360)
aSizeZero(@aReg1370)

//³Gravacao do REGISTRO 1400 - INFORMACOES SOBRE VALORES AGREGADOS³
If GetApoInfo("SPEDXFUN.PRW")[4] >= CTOD("31/03/2016") 
	If "1" $ aWizard[4,10] .And. Month(CTOD(Substr(aWizard[1,2],7,2)+"/"+Substr(aWizard[1,2],5,2)+"/"+Substr(aWizard[1,2],1,4))) == 12
		Reg1400Ano(@aReg1400,cProd,cAliasSFT,cAliasSF4,@lGr2001400,cMVEstado,aWizard)
	Endif
Endif
If aExistBloc[30]
	aReg1400 := ExecBlock("SPED1400",.F.,.F.,{dDataDe,dDataAte,cFilDe,cFilAte,aLisFil,aReg1400})
	If Valtype(aReg1400) == "A"
		For nX := 1 to Len(aReg1400)
			If aReg1400[nX][4]>0
				GrvRegTrS (cAlias,,{aReg1400[nX]})
			Endif
		Next nX
	Endif
Else
	For nX := 1 to Len(aReg1400)
		If aReg1400[nX][4]>0
			GrvRegTrS (cAlias,,{aReg1400[nX]})
		Endif
	Next nX
Endif
//Zera variaveis para desalocar memoria
aSizeZero(@aReg1400)

// Gravacao dos registros D350 e filhos - GTP
If Len(aRegD350) > 0
	SPEDRegs(cAlias,{aRegD350,aRegD355,aRegD360,{aRegD365,2},{aRegD390,2},{aRegD370,4}})
EndIf

aSizeZero(@aRegD350)
aSizeZero(@aRegD355)
aSizeZero(@aRegD360)
aSizeZero(@aRegD365)
aSizeZero(@aRegD370)
aSizeZero(@aRegD390)

If Len(aRegD400) > 0
	SPEDRegs(cAlias,{aRegD400,aRegD410,{aRegD420,1},{aRegD411,2}})
EndIf

aSizeZero(@aRegD400)
aSizeZero(@aRegD410)
aSizeZero(@aRegD411)
aSizeZero(@aRegD420)

//---Gravacao dos registros - Bloco B---//
If Len(aRegB350) > 0
	GrvRegTrS(cAlias,,aRegB350)
EndIf
If Len(aRegB420) > 0
	GrvRegTrS(cAlias,,aRegB420)
EndIf
If Len(aRegB440) > 0
	GrvRegTrS(cAlias,,aRegB440)
EndIf
If Len(aRegB460) > 0
	GrvRegTrS(cAlias,,aRegB460)
EndIf
If Len(aRegB470) > 0
	GrvRegTrS(cAlias,,aRegB470)
EndIf
If Len(aRegB500) > 0
	SPEDRegs(cAlias,{aRegB500,aRegB510})	
EndIf

aSizeZero(@aRegB020)
aSizeZero(@aRegB025)
aSizeZero(@aRegB030)
aSizeZero(@aRegB035)
aSizeZero(@aRegB350)
aSizeZero(@aRegB420)
aSizeZero(@aRegB440)
//---FIM Gravacao dos registros - Bloco B---//

//³Chamada para o PE SPEDREGD, que pode ser utilizado para manipular o arquivo de ³
//³  trabalho gerado pela rotina                                                  ³
If aExistBloc[09] 
	Execblock("SPEDREGD", .F., .F., {cAlias,aLisFil})
EndIf

//³Gravacao dos Totais Das Operacoes com Cartao de Credito E/OU Debito ³
If "S"$aReg1010[1][8]
	If cVersao >= "016"
		GrReg1601(cAlias,aReg1601,dDataDe,dDataAte,@aReg0150,aWizard,lCmpA1U)
	Else
		GrReg1600(cAlias,aReg1600,dDataDe,dDataAte,@aReg0150,aWizard)
	Endif
Endif
//Zera variaveis para desalocar memoria
aSizeZero(@aReg0150)
aSizeZero(@aReg1600)
aSizeZero(@aReg1601)

If lBuild	
	FreeObj(oHash0200)
	oHash0200 := NIL

	FreeObj(oHashC800)
	oHashC800 := NIL

	FreeObj(oHashC850)
	oHashC850 := NIL

	FreeObj(oHashC860)
	oHashC860 := NIL

	FreeObj(oHashC870)
	oHashC870 := NIL

	FreeObj(oHashC890)
	oHashC890 := NIL

	FreeObj(oHash0210)
	oHash0210 := NIL

	FreeObj(oHash0150)
	oHash0150 := NIL

	FreeObj(oHashINFP)
	oHashINFP := NIL

	FreeObj(oHashTMSM)
	oHashTMSM := NIL	
	
EndIf

If lRefazInd //Refaz o indice, devido novos registros terem sido incluidos no TRB atraves de MultiThread (REG C460 e C470)
	SPDGerTrb(0,aArq,@cAlias, , @oTempTab,@oBulkTMP)
Else
	//Descarrega todos os dados a serem inseridos na tabela temporaria no banco para preparacao da Gravacao dos indicadores de movimento dos registros
	SPDFlshINS() //Força COMMIT dos registros na tabela temporaria	
EndIf

conout('	Inicio Gravacao dos indicadores de movimento dos registros' + ' - ' + DToC(Date()) + " - " + Time())
//³Gravacao dos indicadores de movimento dos registros ³
SpdGrIndM(cAlias,aWizard)
conout('	Final Gravacao dos indicadores de movimento dos registros' + ' - ' + DToC(Date()) + " - " + Time())

If lBuild // Só libero o Hash oHHierarq após todas as possiveis gravações na TRB
	FreeObj(oHHierarq)
	oHHierarq := NIL

	FreeObj(oHHBloco0)
	oHHBloco0 := Nil

	FreeObj(oHHBlocoB)
	oHHBlocoB := Nil

	FreeObj(oHHBlocoC)
	oHHBlocoC := Nil

	FreeObj(oHHBlocoD)
	oHHBlocoD := Nil

	FreeObj(oHHBlocoE)
	oHHBlocoE := Nil

	FreeObj(oHHBlocoG)
	oHHBlocoG := Nil

	FreeObj(oHHBlocoH)
	oHHBlocoH := Nil

	FreeObj(oHHBlocoK)
	oHHBlocoK := Nil

	FreeObj(oHHBloco1)
	oHHBloco1 := Nil

	FreeObj(oHHBloco9)
	oHHBloco9 := Nil

	FreeObj(oJRetCda)
	oJRetCda := Nil

	FreeObj(oPosItXML)
	oPosItXML := Nil

	FreeObj(oNfOrItXml)
	oNfOrItXml := Nil

EndIf

aSizeZero(@aStruCDA)

//³Funcao responsavel geracao meio-magnetico com base no TRB³
If !lJob
	oSay:cCaption := (STR0008) //"Gerando arquivo texto"
	ProcessMessages()
EndIf
SPDGerTrb(0,aArq,@cAlias, , @oTempTab,@oBulkTMP)//REstaurar indices

conout('	Inicio Execucao ORGTXT' + ' - ' + DToC(Date()) + " - " + Time())
OrgTxt(cAlias,cFileDest,,@lEnd,lTop,@nRetCpy)
conout('	Final Execucao ORGTXT' +  ' - ' + DToC(Date()) + " - " + Time())

//³Funcao de fechamento do TRB criado³
SPDGerTrb(2,@aArq,@cAlias, , @oTempTab,@oBulkTMP)	

ConOut("FIM PRSPED: " + DToC(Date()) + " - " + Time())

cDtHoraFim :=  DToC(Date()) + "-" + Time() 
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Tratamento para avisar ao usuario um dos possiveis erros quanto ao registro E210 que serah mais comum conforme regra     ³
//³  definida na geracao do arquivo magnetico.                                                                              ³
//³                                                                                                                         ³
//³Para as notas fiscais de entrada tipo devolucao, apos retorno da SEFAZ e analise das regras do layout e validacao do PVA,³
//³  chegou-se a seguinte conclusao:                                                                                        ³
//³                                                                                                                         ³
//³Para as notas fiscais de entrada tipo devolucao, o valor de ICMS/ST somente deverah ser considerado nos registro C100,   ³
//³  C170, C190 e E210, quando o contribuinte tiver IE no estado emitente do documento (FT_ESTADO estah contido no          ³
//³  SUBTRIB), caso contrario deverah levar ZERO nos respectivos campos, pois a NF original, a de saida, teve o ICMS/ST     ³
//³  recolhido antecipadamente, nao tendo como compensar o credito. Quando houver IE no estado do emitente, segue o fluxo   ³
//³  normal, pois como o valor do ICMS/ST serah recolhido via Auracao, terah com compensar o debito pelo credito.           ³
//³                                                                                                                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lLogCfop
	xMagHelpFis("Atenção...",cAlertCfop,cSolucCfop)
EndIf

conout('Final de processamento da rotina' + ' - ' + DToC(Date()) + " - " + Time())

If (File(cFileDest) .OR. nRetCpy == 0 )
	nRetType := GetRemoteType( @cLib )
	ConOut(clib) 

	If !lNotaC350 .Or. !lNotaC300
		MsgInfo(STR0032+; //"Existe(m) Nota(s) Fiscai(s) com numeração maior do que a permitida pelo " 
		        STR0033+; //"layout para geração dos registros C300 e C350, serão consideradas apenas os últimos "
		        STR0034)  //"6 dígitos para geração destes registros!"
	EndIf

	If !lNotaD300
		MsgInfo(STR0032+;
		        STR0035+; //"layout para geração dos registros D300 e D301, serão consideradas apenas os últimos"
		        STR0034)
	EndIf
    IF	nRetType == 5 //"HTML" $ cLib
		MsgInfo(OemToAnsi(STR0001+" "+STR0002)) //"Arquivo gerado com sucesso!"
	ELSE
		MsgInfo(OemToAnsi(STR0001+cFileDest+STR0002) + PULALINHA + PULALINHA + "Início: " + cDtHoraIni + PULALINHA+ "Término: " + cDtHoraFim) //"Arquivo "###" gerado com sucesso!"
	ENDIF
Else
	MsgAlert(OemToAnsi(STR0003)) //"Não foi possível gerar o arquivo!"
EndIf

Return (.T.)
/*
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³Reg0000   | Autor ³Gustavo G. Rueda              ³ Data ³03.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡ao ³ABERTURA DO ARQUIVO DIGITAL E IDENTIFICACAO DO CONTRIBUINTE        ³±±
±±³          ³- Geracao do Registro 0000 e gravacao do mesmo                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ExpL1 := Reg0000(aWizard,cAlias,dDataDe,dDataAte)                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³aWizard -> informacoes preenchidas no Wizard                       ³±±
±±³          ³cAlias -> Alias do TRB que recebera as informacoes                 ³±±
±±³          ³dDataDe -> Data incial do periodo de apuracao.                     ³±±
±±³          ³dDataAte -> Data final do periodo de apuracao.                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1 - Sempre .T.                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGAFIS - SPEDFISCAL                                              ³±±
±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
*/
Static Function Reg0000(aWizard, cAlias, dDataDe, dDataAte)
Local	aReg	:= {}
Local	lRet	:= .T.
Local	nPos	:=	0

aAdd(aReg, {})
nPos	:=	Len (aReg)
aAdd (aReg[nPos], "0000")																														//01 - REG
aAdd (aReg[nPos], GetSPDVer(dDataDe))																														//02 - COD_VER
aAdd (aReg[nPos], SubStr (aWizard[2][1], 1, 1))				    	    																		//03 - COD_FIN
aAdd (aReg[nPos], dDataDe)										   																				//04 - DT_INI
aAdd (aReg[nPos], dDataAte)										   																				//05 - DT_FIM
aAdd (aReg[nPos], SM0->M0_NOMECOM)																												//06 - NOME
aAdd (aReg[nPos], SPEDConType(SPEDVldIE(Iif (RetPessoa(SM0->M0_CGC) == "J", SM0->M0_CGC, ""))))													//07 - CNPJ
aAdd (aReg[nPos], SPEDConType(SPEDVldIE(Iif (RetPessoa(SM0->M0_CGC) == "F", SM0->M0_CGC, ""))))													//08 - CPF
aAdd (aReg[nPos], SM0->M0_ESTENT)																												//09 - UF
aAdd (aReg[nPos], SPEDConType(SPEDVldIE(SM0->M0_INSC,.F.,.F.)))																					//10 - IE
aAdd (aReg[nPos], Iif (Upper(SM0->M0_ESTENT) == "EX","",Iif(Len(Alltrim(SM0->M0_CODMUN))<=5,UfCodIBGE(SM0->M0_ESTENT),"")+SM0->M0_CODMUN))		//11 - COD_MUN
aAdd (aReg[nPos], SPEDConType(SM0->M0_INSCM))																									//12 - IM
aAdd (aReg[nPos], SPEDConType(SM0->M0_INS_SUF))																									//13 - SUFRAMA
aAdd (aReg[nPos], SubStr (aWizard[2][4], 1, 1))																									//14 - IND_PERFIL
aAdd (aReg[nPos], SubStr (aWizard[2][5], 1, 1))																									//15 - IND_ATIV

GrvRegTrS(cAlias,, aReg)
Return (lRet)
/*
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³Reg0005   | Autor ³Gustavo G. Rueda              ³ Data ³03.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡ao ³DADOS COMPLEMENTARES DO CONTRIBUINTE                               ³±±
±±³          ³- Geracao do Registro 0000 e gravacao do mesmo                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ExpL1 := Reg0005 (aWizard, cAlias)                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³aWizard -> informacoes preenchidas no Wizard                       ³±±
±±³          ³cAlias -> Alias do TRB que recebera as informacoes                 ³±±
±±³          ³aSM0 -> Array contem informacoes da Tabela SM0 e XX8               ³±±
±±³          ³lIsBlind -> Determina se a conexao efetuada com o Protheus nao 	 ³±±
±±³          ³			  possui interface com o usuário.               		 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1 - Sempre .T.                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGAFIS - SPEDFISCAL                                              ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
*/
Static Function Reg0005 (aWizard, cAlias, aSM0, lIsBlind)
Local	aReg		:=	{}
Local	lRet		:=	.T.
Local	nPos		:=	0
Local	cTel		:=	""
Local	cFax		:=	""
Local 	lUsaXX8		:=	aSPDSX6[MV_USAXX8] //Parametro define se as informacoes da empresa virao do XX8
Local	cNomeFant	:=	""
Local	cRetPE		:=	""

If Len(SM0->M0_CODFIL) > 2
	If lUsaXX8	//Tabela XX8
		aEval(aSM0,{|x| cNomeFant := Iif(x[SM0_GRPEMP]==cEmpAnt .And. x[SM0_CODFIL]==cFilAnt .And. x[SM0_USEROK], x[SM0_NOMRED], cNomeFant)})	
	Else
		cNomeFant := SM0->M0_FILIAL
	EndIf
Else
	cNomeFant := SM0->M0_NOME
EndIf

If aExistBloc[25]
	//-- PE usado para alterar campo 02-FANTASIA
	cRetPE := ExecBlock("SPEDFANT",.F.,.F.)
	If  ValType(cRetPE) == "C"
		cNomeFant := cRetPE
	EndIf
EndIf

aAdd(aReg, {})
nPos	:=	Len(aReg)
aAdd (aReg[nPos], "0005")																										//01 - REG
aAdd (aReg[nPos], cNomeFant)																									//02 - FANTASIA
aAdd (aReg[nPos], SPEDConType(SM0->M0_CEPENT))																				  	//03 - CEP
aAdd (aReg[nPos], SPEDConType(FisGetEnd(SM0->M0_ENDENT,SM0->M0_ESTENT)[1]))				 									//04 - END
aAdd (aReg[nPos], Iif(!Empty(FisGetEnd(SM0->M0_ENDENT,SM0->M0_ESTENT)[2]),FisGetEnd(SM0->M0_ENDENT,SM0->M0_ESTENT)[3],"SN"))	//05 - NUM
aAdd (aReg[nPos], SPEDConType(Iif(!Empty(SM0->M0_COMPENT),SM0->M0_COMPENT,FisGetEnd(SM0->M0_ENDENT,SM0->M0_ESTENT)[4]))	)	//06 - COMPL
aAdd (aReg[nPos], SPEDConType(SM0->M0_BAIRENT))																					//07 - BAIRRO

cTel := SPEDConType(SPEDVldIE(SM0->M0_TEL)) // Tira espaços e caracteres especiais
cFax := SPEDConType(SPEDVldIE(SM0->M0_FAX)) // Tira espaços e caracteres especiais

aAdd (aReg[nPos], Right(cTel,11))				 						//08 - FONE
aAdd (aReg[nPos], Right(cFax,11))			  							//09 - FAX
aAdd (aReg[nPos], aWizard[2][7])			 							//10 - EMAIL

GrvRegTrS (cAlias,, aReg)
Return (lRet)
/*
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³Reg0015   | Autor ³Gustavo G. Rueda              ³ Data ³03.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡ao ³0015 - DADOS DO CONTRIBUINTE SUBSTITUTO                            ³±±
±±³          ³- Geracao do Registro 0015.                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ExpA1 := Reg0015(cMVSUBTRIB,cAlias)                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cMVSUBTRIB -> Conteudo do parametro MV_SUBTRIB                     ³±±
±±³          ³cAlias -> Alias do TRB que recebera as informacoes                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpA1 - Array com a estrutura do registro                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGAFIS - SPEDFISCAL                                              ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
*/
Static Function Reg0015(cMVSUBTRIB,cAlias,lExtratTAF)
Local	nPosI		:=	0
Local	nPosF		:=	0
Local	nPosY		:=	0
Local	nX			:=	0
Local	aUf			:=	UfCodIBGE("",.F.)
Local	aReg0015	:=	{}
                                              
Default lExtratTAF := .F.

cMVSUBTRIB+=GetSubTrib("",.T.) //Pega IE de difal

For nX := 1 to len(aUf)
	//³REGISTRO 0015 - DADOS DO CONTRIBUINTE SUBSTITUTO³	
	If At (aUf[nX][1], cMVSUBTRIB)>0	//Se tiver inscricao no estado
		If (aScan (aReg0015, {|aX| aX[2]==aUf[nX][1]})==0)
			nPosI	:=	At (aUf[nX][1], cMVSUBTRIB)+2
			nPosF	:=	At ("/", SubStr (cMVSUBTRIB, nPosI))-1
			nPosF	:=	IIf(nPosF<=0,len(cMVSUBTRIB),nPosF)
			cStrValid:= SubStr(cMVSUBTRIB, nPosI, nPosF)
			//Tratamento para clientes onde se utiliza o CNPJ ao invés da Inscrição Estadual para o recolhimento do DIFAL
			If "CNPJ" $ cStrValid
				Loop
			EndIf
			aAdd(aReg0015, {})
			nPosY	:=	Len (aReg0015)
			aAdd (aReg0015[nPosY], "0015")								//01 - REG
			aAdd (aReg0015[nPosY], aUf[nX][1])							//02 - UF_ST
			aAdd (aReg0015[nPosY], cStrValid)							//03 - IE_ST
		EndIf
	EndIf
Next

If !lExtratTAF
	GrvRegTrS(cAlias,,aReg0015)
EndIf

Return aReg0015
/*
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³Reg0100   | Autor ³Gustavo G. Rueda              ³ Data ³03.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡ao ³DADOS DO CONTABILISTA                                              ³±±
±±³          ³- Geracao do Registro 0100 e gravacao do mesmo                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ExpL1 := Reg0100(aWizard,cAlias, dDataDe, dDataAte)                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³aWizard -> informacoes preenchidas no Wizard                       ³±±
±±³          ³cAlias -> Alias do TRB que recebera as informacoes                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1 - Sempre .T.                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGAFIS - SPEDFISCAL                                              ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
*/
Static Function Reg0100(aWizard,cAlias, dDataDe, dDataAte)
Local	aReg		:=	{}
Local	lRet		:=	.T.
Local	nPos		:=	0
Local 	cCNPJ		:= ""     
Local 	lInclui		:= .F.
Local	cAliasCVB	:=	"CVB"

If (!Empty(aWizard[3][1]) .And. !Empty(aWizard[3][7])) .Or. !(AliasIndic("CVB"))
// se o nome e o endereco estiver informado na wizard, continuo a pegar as informacoes da wizard.
	aAdd (aReg, {})
	nPos	:=	Len (aReg)
	aAdd (aReg[nPos], "0100")					//01 - REG
	aAdd (aReg[nPos], aWizard[3][1])			//02 - NOME
	aAdd (aReg[nPos], aWizard[3][3])			//03 - CPF
	aAdd (aReg[nPos], aWizard[3][4])			//04 - CRC
	aAdd (aReg[nPos], aWizard[3][2])			//05 - CNPJ
	aAdd (aReg[nPos], aWizard[3][5])			//06 - CEP
	aAdd (aReg[nPos], aWizard[3][7])			//07 - END
	aAdd (aReg[nPos], aWizard[3][8])			//08 - NUM
	aAdd (aReg[nPos], aWizard[3][9])			//09 - COMPL
	aAdd (aReg[nPos], aWizard[3][10])			//10 - BAIRRO
	aAdd (aReg[nPos], aWizard[3][11])			//11 - FONE
	aAdd (aReg[nPos], aWizard[3][12])			//12 - FAX
	aAdd (aReg[nPos], aWizard[3][13])			//13 - EMAIL
	aAdd (aReg[nPos], aWizard[3][6])			//14 - COD_MUN
Else
	lInclui := .F.
	If !Empty(aWizard[3][3]) .And. aSPDSX3[FP_CVB_CPF]
		// se o CPF estiver informado, mas sem o nome e endereco, pesquiso na tabela CVB - contabilista pelo num. documento.
		lInclui := SPEDFFiltro(1,"CVB",@cAliasCVB,{DToS(dDataDe),DToS(dDataAte),aWizard[3][3],""})
	ElseIf !Empty(aWizard[3][2]) .Or. (!Empty(aWizard[3][3]) .And. !aSPDSX3[FP_CVB_CPF])
		// se o CNPJ estiver informado, mas sem o nome e endereco, pesquiso na tabela CVB - contabilista pelo num. documento.
		cCNPJ := Iif(!Empty(aWizard[3][2]), aWizard[3][2], aWizard[3][3])	 
		cCNPJ := Padr(SubStr(cCNPJ,1,TamSx3("A2_CGC")[1]),TamSx3("A2_CGC")[1])
		lInclui := SPEDFFiltro(1,"CVB",@cAliasCVB,{DToS(dDataDe),DToS(dDataAte),"",cCNPJ})
	Else
		// senao pego o primeiro contabilista informado para a filial corrente.
		lInclui := SPEDFFiltro(1,"CVB",@cAliasCVB,{DToS(dDataDe),DToS(dDataAte),"",""})
	Endif	
    
	If lInclui
		aAdd (aReg, {})
		nPos	:=	Len (aReg)
		aAdd (aReg[nPos], "0100")				   																				//01 - REG
		aAdd (aReg[nPos], (cAliasCVB)->CVB_NOME )																						//02 - NOME
		aAdd (aReg[nPos], Iif(aSPDSX3[FP_CVB_CPF],Alltrim((cAliasCVB)->CVB_CPF),Iif(Len(Alltrim((cAliasCVB)->CVB_CGC))<14,Alltrim((cAliasCVB)->CVB_CGC),"")))	//03 - CPF
		aAdd (aReg[nPos], SPEDConType((cAliasCVB)->CVB_CRC))																				//04 - CRC
		aAdd (aReg[nPos], SPEDConType(Iif(Len(Alltrim((cAliasCVB)->CVB_CGC))>11,Alltrim((cAliasCVB)->CVB_CGC),"")))								//05 - CNPJ
		aAdd (aReg[nPos], SPEDConType((cAliasCVB)->CVB_CEP)) 											   									//06 - CEP
		aAdd (aReg[nPos], SPEDConType(FisGetEnd((cAliasCVB)->CVB_END,(cAliasCVB)->CVB_UF)[1]))						 							//07 - END
		aAdd (aReg[nPos], Iif(!Empty(FisGetEnd((cAliasCVB)->CVB_END,(cAliasCVB)->CVB_UF)[2]),FisGetEnd((cAliasCVB)->CVB_END,(cAliasCVB)->CVB_UF)[3],"SN"))	//08 - NUM
		aAdd (aReg[nPos], SPEDConType((cAliasCVB)->CVB_COMPL))											   								//09 - COMPL
		aAdd (aReg[nPos], SPEDConType((cAliasCVB)->CVB_BAIRRO))																			//10 - BAIRRO
		aAdd (aReg[nPos], SPEDConType((cAliasCVB)->CVB_TEL))																				//11 - FONE
		aAdd (aReg[nPos], SPEDConType((cAliasCVB)->CVB_FAX))																				//12 - FAX
		aAdd (aReg[nPos], (cAliasCVB)->CVB_EMAIL)																						//13 - EMAIL
		aAdd (aReg[nPos], "")																					   				//14 - COD_MUN
		If aSPDSX3[FP_CVB_CODMUN]
			aReg[nPos][14] := IIF( Len(Alltrim((cAliasCVB)->CVB_CODMUN)) <= 5 , UfCodIBGE((cAliasCVB)->CVB_UF) + Alltrim((cAliasCVB)->CVB_CODMUN) , Alltrim((cAliasCVB)->CVB_CODMUN) )
		EndIf
		SPEDFFiltro(2,,cAliasCVB)
	Endif     
Endif

GrvRegTrS(cAlias,,aReg)

Return (lRet)

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³Reg0190   ³ Autor ³Gustavo G. Rueda       ³ Data ³22.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³            REGISTRO 0190 - UNIDADES DE MEDIDA              ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao do Registro 0190 e gravacao do mesmo              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³1(1 por arquivo)                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nil                                                         ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
*/
Static Function Reg0190(cAlias,cUnid,aReg0190)
Local	nPos	 	:=	0

//³REGISTRO 0190 - UNIDADES DE MEDIDA              ³
If aScan(aReg0190, {|aX| aX[2]==cUnid})==0 .And. SPEDSeek("SAH",,aSPDFil[PFIL_SAH]+cUnid)
	aAdd(aReg0190, {})
	nPos	:=	Len (aReg0190)
	aAdd (aReg0190[nPos], "0190")						//01 - REG
	aAdd (aReg0190[nPos], cUnid)						//02 - UNI
	aAdd (aReg0190[nPos], SAH->AH_DESCPO)				//03 - DESCR
	
	GrvRegTrS(cAlias,,{aReg0190[nPos]})
EndIf

Return
/*
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³SFRG0200  | Autor ³Gustavo G. Rueda              ³ Data ³03.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡ao ³TABELA DE IDENTIFICACAO DO ITEM                                    ³±±
±±³          ³                                                                   ³±±
±±³          ³- Geracao dos Registros 0190, 0200, 205 e 0220                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ExpL1 :=SFRG0200(cAlias,aReg0200,aReg0190,dDataDe,dDataAte,aProd,; ³±±
±±³          ³                 cProd,aReg0220,cAliasSB1,cUnid)                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cAlias -> Alias do TRB que recebera as informacoes                 ³±±
±±³          ³aReg0200 -> Array com as informacoes a sere retornadads por        ³±±
±±³          ³ referencia para gerar o registro 0200                             ³±±
±±³          ³aReg0190 -> Array com as informacoes a sere retornadads por        ³±±
±±³          ³ referencia para gerar o registro 0190                             ³±±
±±³          ³dDataDe  -> Data inicial do processamento do SPED Fiscal           ³±±
±±³          ³dDataAte -> Data final do processamento do SPED Fiscal             ³±±
±±³          ³aProd    -> Array com as informacoes de produtos alimentadas       ³±±
±±³          ³ por PE                                                            ³±±
±±³          ³cProd    -> Codigo do produto formatado pela rotian                ³±±
±±³          ³aReg0220 -> Array com as informacoes a sere retornadads por        ³±±
±±³          ³ referencia para gerar o registro 0220                             ³±±
±±³          ³cAliasSB1-> Pode ser o proprio SB1 ou um alias gerado por uma query³±±
±±³          ³cUnid    -> Unidade de medida do item contemplando PE              ³±±
±±³          ³cMVDTINCB1-> Conteudo do parametro MV_DTINCB1 que determina o campo³±±
±±³          ³             da tabela SB1 ou uma chamada para um RDMAKE para      ³±±
±±³          ³             retornar a data de inclusao do produto                ³±±
±±³          ³lSpdFis02 -> Ponto de entrada SPDFIS02                             ³±±
±±³          ³nFatorPe -> Fator de conversão retornado pelo ponto de entrada	    ³±±
±±³          ³             SPDFIS02											        ³±±      
±±³          ³cMvEstado -> UF do MV_ESTADO 									        ³±±
±±³          ³cPRDPRIB5 -> Campo da tabela SB5 que indica Produto primario	    ³±±
±±³          ³cAliasSB5-> Pode ser o proprio SB5 ou um alias gerado por uma query³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1 - Sempre .T.                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGAFIS - SPEDFISCAL                                              ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
*/
Function SFRG0200(cAlias,aReg0200,aReg0190,dDataDe,dDataAte,aProd,cProd,aReg0220,cAliasSB1,cUnid,cMVDTINCB1,lSPDFIS02,nFatorPe,cMVEstado,cPRDPRIB5,cAliasSB5,cALiasCD6,lAchouCD6,aSegUnid,cAliasSFT,lAchouSB1,aCmpsSF9,lGera0210, cCodK230,cAli0210, aReg0210,aWizard,lAchouSFT,cTpCv,lExtFisxTaf,lProcXml)

Local	aHist		:= {}
Local	aHistCod	:= {}
Local	aMod		:= {}
Local	aSped0205	:= {}

Local	cCodIss		:= ''
Local	cDescProd	:= ''
Local	cCodBarra	:= ''
//Local	nTamBar		:= ''
Local	cCmpDTINCB1	:= ''
Local	cSegUnid	:= ''
Local	cTpConv		:= ''
Local	cAliasIt	:= ''
Local	cProdCDN	:= ''
Local	cChave		:= ''
Local	cTpPrd		:= ''
Local	cTipo		:= '99'
Local	cTipo00		:= iif(Empty(aSPDSX6[MV_BLKTP00]),"ME",aSPDSX6[MV_BLKTP00]) // 00 - Mercadoria para Revenda
Local	cTipo01		:= iif(Empty(aSPDSX6[MV_BLKTP01]),"MP",aSPDSX6[MV_BLKTP01]) // 01 - Materia-prima
Local	cTipo02		:= iif(Empty(aSPDSX6[MV_BLKTP02]),"EM",aSPDSX6[MV_BLKTP02]) // 02 - Embalagem
Local	cTipo03		:= iif(Empty(aSPDSX6[MV_BLKTP03]),"PP",aSPDSX6[MV_BLKTP03]) // 03 - Produto em Processo
Local	cTipo04		:= iif(Empty(aSPDSX6[MV_BLKTP04]),"PA",aSPDSX6[MV_BLKTP04]) // 04 - Produto Acabado
Local	cTipo05		:= iif(Empty(aSPDSX6[MV_BLKTP05]),"SP",aSPDSX6[MV_BLKTP05]) // 05 - SubProduto
Local	cTipo06		:= iif(Empty(aSPDSX6[MV_BLKTP06]),"PI",aSPDSX6[MV_BLKTP06]) // 06 - Produto Intermediario
Local	cTipo07		:= iif(Empty(aSPDSX6[MV_BLKTP07]),"MC",aSPDSX6[MV_BLKTP07]) // 07 - Material de Uso e Consumo
Local	cTipo08		:= iif(Empty(aSPDSX6[MV_BLKTP08]),"AI",aSPDSX6[MV_BLKTP08]) // 08 - Ativo Imobilizado
Local	cTipo09		:= iif(Empty(aSPDSX6[MV_BLKTP09]),"SV",aSPDSX6[MV_BLKTP09]) // 09 - Serviços
Local	cTipo10		:= iif(Empty(aSPDSX6[MV_BLKTP10]),"OI",aSPDSX6[MV_BLKTP10]) // 10 - Outros insumos              )

Local	aTipo		:=	{ {cTipo00,"00"},;
						  {cTipo01,"01"},;
						  {cTipo02,"02"},;
						  {cTipo03,"03"},;
						  {cTipo04,"04"},;
						  {cTipo05,"05"},;
						  {cTipo06,"06"},;
						  {cTipo07,"07"},;
						  {cTipo08,"08"},;
						  {cTipo09,"09"},;
						  {cTipo10,"10"} }

Local	dDataFinal	:= ctod("  /  /  ")
Local	dDataInici	:= ctod("  /  /  ")
Local	dDataCont	:= ctod("01/01/2000")
Local 	dDatCadPr	:= ctod("  /  /  ") //Data cadastrada no campo referente ao parâmetro MV_DTINCB1

Local	lRet		:= 	.T.
Local	lHistTab	:= 	aSPDSX6[MV_HISTTAB] .And. aSPDSX2[AI_AIF]

Local	lGer0220	:=	aSPDSX6[MV_GER0220]//parâmetro (MV_GER0220), informa se deve gerar o registro 0220 do SpedFiscal.

Local	nAlqProd	:= 	0
Local	nPos		:= 	0
Local	nPos0205	:= 	0
Local	nPos0206	:= 	0
Local	nPos0210	:= 	0
Local	nPos0220	:= 	0
Local	nX			:= 	0
Local	nFldPrdPri	:= 	0
Local	nConv		:= 	0
Local	nTipo		:= 	1
Local	nICMPAD 	:= 	aSPDSX6[MV_ICMPAD]

Local	lProdPrim	:= .f.
Local	lProcSegUn	:= .f.
Local	lSegUnid	:= valtype(cAliasSB1)== "C" .AND. (cAliasSB1)->(FieldPos("B1_SEGUM"))>0 .AND. (cAliasSB1)->(FieldPos("B1_TIPCONV"))>0 .AND. (cAliasSB1)->(FieldPos("B1_CONV"))>0
Local 	lTemAIF		:= .F.
Local	cFilSB1		:= cFilAnt
Local 	nP0210		:= 0 //Posição pai 0210
Local 	nF02010		:= 0 //osição filho 0210
Local	cCodItem	:= ""
Local	nQtdComp	:= 0
Local	nPerda		:= 0

DEFAULT aSegUnid	:= {}
DEFAULT aReg0210	:= {}
DEFAULT aWizard		:= {} 
DEFAULT aProd		:= {"","","","","","","","","","","",""}
DEFAULT cAliasSFT	:= ''
DEFAULT cCodK230	:= ''
DEFAULT cAli0210	:= ''
DEFAULT cTpCv		:= ''
DEFAULT cAliasSB1	:= "SB1"
DEFAULT cAliasSB5	:= "SB5"
DEFAULT cAliasCD6	:= "CD6"
DEFAULT cMVEstado 	:= aSPDSX6[MV_ESTADO]
DEFAULT cUnid		:= (cAliasSB1)->B1_UM
DEFAULT cPRDPRIB5	:= Alltrim(aSPDSX6[MV_PRDPRI])
DEFAULT cProd		:= (cAliasSB1)->B1_COD+ Iif(lConcFil,cFilAnt,"")
DEFAULT cMVDTINCB1	:= IIF(AllTrim(aSPDSX6[MV_DTINCB1]) != "", AllTrim(aSPDSX6[MV_DTINCB1]),"B1_DATREF")
DEFAULT dDataDe		:= Date()
DEFAULT dDataAte	:= Date()

DEFAULT lAchouSB1	:=	.t.
DEFAULT lAchouCD6	:=	.f.
DEFAULT lSPDFIS02	:=	.f.
DEFAULT lGera0210	:=	.f.
DEFAULT lAchouSFT	:=	.f.
DEFAULT lExtFisxTaf :=	.f.
DEFAULT lProcXml	:=  .F.

If lHistTab
	DbSelectArea("AIF")
	AIF->(dbsetorder(2))
	lTemAIF := AIF->(MsSeek(aSPDFil[PFIL_AIF]+aSPDFil[PFIL_SB1]+"SB1"+PadR(cProd, TamSX3("AIF_CODPRO")[1])))
EndIf

If (cAliasSB1)->(FieldPos("FT_CFOP")) > 0
	cAliasIt := IIf (Substr((cAliasSB1)->FT_CFOP,1,1)>="5", "SD2", "SD1")
EndIf

//Verifica existencia do campo indicado no parametro MV_PRDPRI
nFldPrdPri := Iif( Empty(cPRDPRIB5), 0, (cAliasSB5)->(FieldPos(cPRDPRIB5)) )

If lProcXml
	cSegUnid	:= (cAliasSFT)->DKA_UMXML
	nConv		:= (cAliasSFT)->DKA_FATOR
	cTpConv		:= "M"
	lProcSegUn	:= .T.
ElseIF lSegUnid // Se está com alias da SB1 irá preencher as variáveis
	cSegUnid	:= (cAliasSB1)->B1_SEGUM
	nConv		:= (cAliasSB1)->B1_CONV
	cTpConv		:= (cAliasSB1)->B1_TIPCONV
	lProcSegUn	:= .T.
ElseIF Len(aSegUnid) > 0  //Se não está com alias da SB1 então irá verificar se as informações estão no array.
	cSegUnid	:= aSegUnid[1]
	nConv		:= aSegUnid[2]
	cTpConv		:= aSegUnid[3]
	lProcSegUn	:= .T.	
EndIF

/* Se existir o ponto de entrada SPDFIS02, nao devo gravar no registro 0200 a segunda unidade de medida (Que o PE retornou), e sim a primeira.
O registro 0190 deve ser gerado para as 2 unidades de medida.    */

If lSPDFIS02
	//REGISTRO 0190 - UNIDADES DE MEDIDA 
	Reg0190(cAlias,(cAliasSB1)->B1_UM,@aReg0190)	
Else
	Reg0190(cAlias,cUnid,@aReg0190)
Endif

//REGISTRO 0200 - TABELA DE IDENTIFICACAO DO ITEM 
//Verifico a existencia do produto para evitar duplicidade
IF lBuild
    cChave := cProd
    nPos   := FisFindHash(oHash0200, cChave)
Else
    nPos := aScan(aReg0200,{|aX| aX[2]==cProd})
EndIf

If (nPos == 0)
	//Ponto de entrada para o usuario relacionar tipos de produto criados com o codigo da tabela de tipos do ATO COTEPE 09/2008 (layout SPED Fiscal)
	If aExistBloc[10]
		aTipo := ExecBlock("SPDFIS001", .F., .F., {aTipo,cAliasSB1})
	EndIf
	//Obtendo o tipo de item para montar o campo do registro
	cTpPrd := RetFldProd((cAliasSB1)->B1_COD,"B1_TIPO",cAliasSB1)
	Iif(Empty(cTpPrd),cTpPrd:=(cAliasSB1)->B1_TIPO,)
	For nTipo := 1 To Len(aTipo)
		If cTpPrd $ aTipo[nTipo][1]
			cTipo := aTipo[nTipo][2]
			Exit
		EndIf
	Next nTipo

	aAdd(aReg0200,{})
	nPos	:=	Len (aReg0200)
	aAdd(aReg0200[nPos], "0200")																	//01 - REG
	aAdd(aReg0200[nPos], cProd)	    																//02 - COD_ITEM

	//³Tratamento para pegar a informacao valida do cadastro dentro do prazo de geracao do spedifscal³
	If lHistTab .And. dDataDe <> NIL .And. lTemAIF
		aMod := MsConHist("SB1","","",dDataDe,,Substr(cProd,1,TamSx3("B1_COD")[1]))
	EndIf
	cContCampo := If(lAchouSB1,RetCmpHist(cAliasSB1+"->B1_DESC",aMod,dDataAte,lHistTab),If(!Empty(aCmpsSF9[26]),aCmpsSF9[26],RetCmpHist(cAliasSB1+"->B1_DESC",aMod,dDataAte,lHistTab)))
	cCodBarra := GeraCodBar(cAliasSB1,cAliasSB5, aProd,aReg0200,Nil)

	aAdd (aReg0200[nPos], Iif(!Empty(aProd[2]),aProd[2],cContCampo))								//03 - DESCR_ITEM	
	aAdd (aReg0200[nPos], cCodBarra)																//04 - COD_BARRA
	aAdd (aReg0200[nPos], "")																		//05 - COD_ANT_IETM
	If lSPDFIS02
		aAdd (aReg0200[nPos], (cAliasSB1)->B1_UM)													//06 - UNI_INV
	Else
		aAdd (aReg0200[nPos], cUnid)																//06 - UNI_INV
	EndIf
	aAdd (aReg0200[nPos], Iif(!Empty(aProd[6]),aProd[6],cTipo))									//07 - TIPO_ITEM
	If Len(aWizard)>0 .And.;
		( (!lExtFisxTaf .And. !aSPDSX6[MV_LEVANCM] .And. SubStr(aWizard[2][5], 1, 1) == "0") .Or. (lExtFisxTaf .and. SubStr(aWizard[1][15], 1, 1) == "0") ) .And. (Iif(!Empty(aProd[6]), aProd[6] $ "07|08|09|10|99", cTipo $ "07|08|09|10|99" ))
		aAdd (aReg0200[nPos], "")																	//08 - COD_NCM
	ElseIf lAchouSFT//Validação para gerar informado do produto a partir de nota fora do período gerado no bloco G130
		aAdd (aReg0200[nPos], Iif(!Empty(aProd[7]),aProd[7],SFT->FT_POSIPI))						//08 - COD_NCM
	ElseIf (cAliasSB1)->(FieldPos("FT_POSIPI")) > 0
		aAdd (aReg0200[nPos], Iif(!Empty(aProd[7]),aProd[7],(cAliasSB1)->FT_POSIPI))				//08 - COD_NCM
	Else
		aAdd (aReg0200[nPos], Iif(!Empty(aProd[7]),aProd[7],(cAliasSB1)->B1_POSIPI))				//08 - COD_NCM
	EndIf	
	aAdd (aReg0200[nPos], Iif(!Empty(aProd[8]),aProd[8],(cAliasSB1)->B1_EX_NCM))					//09 - EX_IPI

	//Ponto de Entrada
	If !Empty(aProd[9])
		aAdd (aReg0200[nPos],aProd[9])																//10 - COD_GEN

	//Verifico se trata-se de um servico
	Elseif Empty((cAliasSB1)->B1_CODISS)

		/*Verifico se utiliza o parametro MV_PRDPRI
		Este paramentro indica se eh referente a um produto primario, conforme guia pratico, o preenchimento deste campo é obrigatorio apenas para produtos primarios */
		If nFldPrdPri <> 0
			lProdPrim	:=	!((cAliasSB5)->(FieldGet(nFldPrdPri)) $ "N")
			If lAchouSFT//Validação para gerar informado do produto a partir de nota fora do período gerado no bloco G130
				aAdd (aReg0200[nPos],Iif(lProdPrim,Left(SFT->FT_POSIPI,2),""))						//10 - COD_GEN			
			Elseif (cAliasSB1)->(FieldPos("FT_POSIPI")) > 0
				aAdd (aReg0200[nPos],Iif(lProdPrim,Left((cAliasSB1)->FT_POSIPI,2),""))				//10 - COD_GEN				
			Else
				aAdd (aReg0200[nPos],Iif(lProdPrim,Left((cAliasSB1)->B1_POSIPI,2),""))				//10 - COD_GEN
			EndIf
		ElseIf lAchouSFT
			aAdd (aReg0200[nPos],Left(SFT->FT_POSIPI,2))											//10 - COD_GEN
		Elseif (cAliasSB1)->(FieldPos("FT_POSIPI")) > 0
			aAdd (aReg0200[nPos],Left((cAliasSB1)->FT_POSIPI,2))									//10 - COD_GEN
		Else
			aAdd (aReg0200[nPos],Left((cAliasSB1)->B1_POSIPI,2))									//10 - COD_GEN
		EndIf			

	//Para servico, utilizo sempre "00"
	Else
		aAdd (aReg0200[nPos],"00")															  		//10 - COD_GEN
	Endif

	/* Obtendo o codigo do ISS atraves do cadastro da tabela CDN. Este codigo devera estar conforme LC 116/03
	Tratamento para considerar também mais de um Cod LST por Cod ISS, conforme a legislação existe a possibilidade de ser n / n */
	cCodIss := Iif(!Empty(aProd[10]),SubStr (aProd[10], 1, 4),SubStr ((cAliasSB1)->B1_CODISS, 1, 5))
	cProdCDN := Alltrim((cAliasSB1)->B1_COD)
	If aSPDSX2[AI_CDN]
		If CDN->(MsSeek(aSPDFil[PFIL_CDN]+PadR(cCodIss,8)+cProdCDN))
			cCodIss := SubStr (CDN->CDN_CODLST, 1, 4)
		Elseif CDN->(MsSeek(aSPDFil[PFIL_CDN]+PadR(cCodIss,8)))
			cCodIss := SubStr (CDN->CDN_CODLST, 1, 4)
		EndIf
	EndIf

	//Retira os pontos do cadastro
	cCodIss := StrTran(cCodIss,".","")	

	IF(LEN(ALLTRIM(cCodIss))<4 .AND. !EMPTY (ALLTRIM(cCodIss)) )
		cCodIss := "0" + cCodIss
	ENDIF

	If !Empty(cCodIss)
		IF ddatade >= ctod('01/01/2015') //a partir de 2015 o formato do código lst deverá ser NN.NN
			//Coloco ponto na terceita posição do código de serviço
			cCodIss	:= SubStr(cCodIss,1,2) + '.' + SubStr(cCodIss,3,2)
		EndIF
	EndIF
	
	aAdd (aReg0200[nPos], cCodIss)																	//11 - COD_LST
	
	//³Tratamento para obter a aliquota interna do produto³
	If ValType(aProd[11]) == "N"
		nAlqProd := aProd[11]

	ElseIf (cAliasSB1)->B1_PICM>0
		If cMVEstado=="RJ"
			nAlqProd := (cAliasSB1)->B1_PICM+(cAliasSB1)->B1_FECP
		Else
			nAlqProd := (cAliasSB1)->B1_PICM
		EndIf
	Else
		If cMVEstado=="RJ"
			nAlqProd := nICMPAD+(cAliasSB1)->B1_FECP
		Else
			nAlqProd := nICMPAD
		EndIf
	EndIf
	aAdd(aReg0200[nPos], nAlqProd)																	//12 - ALIQ_ICM
	
	IF cVersao >= "011"
		If(aSPDSX3[FP_B1_CEST])
			aAdd(aReg0200[nPos],Iif(len(aProd)>=12,Iif(!Empty(aProd[12]),aProd[12],(cAliasSB1)->B1_CEST),(cAliasSB1)->B1_CEST))
		Else
			aAdd(aReg0200[nPos], '')                                                      			//13 - CEST
		Endif
	EndIf

	IF lBuild
	   FisAddHash(oHash0200, cChave, nPos) 
	EndIf

	//REGISTRO 0205 - ALTERACOES DO ITEM
	If dDataDe<>Nil
		
		// Conforme manual o, caso não tenha ocorrido movimentação no período da alteração do item, deverá ser informada no primeiro período em que houver movimentação do item 
		If lTemAIF
			aHist := MsConHist("SB1","","",MonthSub(ddatade,aSPDSX6[MV_205HIST]),dDataAte,Substr(cProd,1,TamSx3("B1_COD")[1]))
		EndIf

		//Exclui alteracoes que nao sejam de "B1_DESC"
		nX := 1
		While nX <= Len(aHist)
			If Alltrim(aHist[nX][1])<>"B1_DESC"
				If Alltrim(aHist[nX][1])=="B1_CODANT"
					aadd(aHistCod,aHist[nx])
				Endif	
				aDel(aHist, nX)
				aSize(aHist, Len(aHist) - 1)
				nX := 0
			ElseIf cAliasIt $ "SD1/SD2"
				DbSelectArea(cAliasIt)
				If cAliasIt $ "SD1"
					(cAliasIt)->(DbSetOrder(2)) //filial + Produto
				Else
					(cAliasIt)->(DbSetOrder(1)) //filial + produto
				EndIF
				If ((cAliasIt)->(DbSeek(xFilial(cAliasIt)+Substr(cProd,1,TamSx3("B1_COD")[1]))))
					cCampData	:= SubStr (cAliasIt,2,2)+"_EMISSAO"
					cCampCod	:= SubStr (cAliasIt,2,2)+"_COD"
					While !(cAliasIt)->(Eof()) .AND. ((cAliasIt)->&cCampData>= aHist[nX][3]) .AND. ((cAliasIt)->&cCampData<= dDataAte) .And. (cAliasIt)->&cCampCod == Substr(cProd,1,TamSx3("B1_COD")[1])
						If (cAliasIt)->&cCampCod == Substr(cProd,1,TamSx3("B1_COD")[1]) .And. !((cAliasIt)->&cCampData >= dDataDe)
							aHist := {}
							Exit
						EndIf
						(cAliasIt)->(dbSkip())
					EndDo
				EndIf
			EndIf
			nX++
		EndDo

		If aExistBloc[20]
			aSped0205 := Execblock("SPED0205", .F., .F., {dDataDe,dDataAte,Substr(cProd,1,TamSx3("B1_COD")[1])})
			//Ira verificar se o retorno do ponto de entrada tem todas as informacoes necessarias
			If ValType(aSped0205[1]) <> "A"
				If Len(aSped0205) >= 4
					aAdd(aReg0205, {})
					nPos0205	:=	Len(aReg0205)
					aAdd(aReg0205[nPos0205], nPos)										//00-Relacionamento com o PAI
					aAdd(aReg0205[nPos0205], "0205")									//01 - REG
					aAdd(aReg0205[nPos0205], aSped0205[1])								//02 - DESCR_ANT_ITEM
					aAdd(aReg0205[nPos0205], aSped0205[2])								//03 - DT_INI
					aAdd(aReg0205[nPos0205], aSped0205[3])								//04 - DT_FIM
					If cVersao >= "003"
						aAdd(aReg0205[nPos0205], aSped0205[4])
					EndIf
				EndIf
			Else
				For nX := 1 To Len(aSped0205)
					If Len(aSped0205[nX]) >= 4
						aAdd(aReg0205, {})
						nPos0205	:=	Len(aReg0205)
						aAdd(aReg0205[nPos0205], nPos)									//00-Relacionamento com o PAI
						aAdd(aReg0205[nPos0205], "0205")								//01 - REG
						aAdd(aReg0205[nPos0205], aSped0205[nX][1])						//02 - DESCR_ANT_ITEM
						aAdd(aReg0205[nPos0205], aSped0205[nX][2])						//03 - DT_INI
						aAdd(aReg0205[nPos0205], aSped0205[nX][3])						//04 - DT_FIM
						If cVersao >= "003"
							aAdd(aReg0205[nPos0205], aSped0205[nX][4])					//05 - COD_ANT_ITEM - LAYOUT 2010
						EndIf
					EndIf
				Next nX
			EndIf
		EndIf

		//Verificando se a função MsConHist retornou pelo menos um array
		If Len(aHist) > 0 .Or. Len(aHistCod) > 0

			//Exclui alteracoes de "B1_DESC" que sejam do mesmo dia com horarios menores, deixa a ultima
			nY := 1
			While nY <= Len(aHist)
				For nX := 1 To Len(aHist)
					If Len(aHist)>1 .And. nX<=Len(aHist)
						If nX > 1 .And. nX<Len(aHist)
							If (aHist[nX][3]=aHist[nX-1][3]) .And. (aHist[nX][4]>=aHist[nX-1][4])
								aDel(aHist, nX-1)
								aSize(aHist, Len(aHist) - 1)
								nX := 0
							ElseIf (aHist[nX][3]=aHist[nX+1][3]) .And. (aHist[nX][4]<=aHist[nX+1][4])
								aDel(aHist, nX+1)
								aSize(aHist, Len(aHist) - 1)
								nX := 0
							EndIf
						ElseIf nX > 1 .And. nX=Len(aHist)
							If (aHist[nX][3]=aHist[nX-1][3]) .And. (aHist[nX][4]>=aHist[nX-1][4])
								aDel(aHist, nX-1)
								aSize(aHist, Len(aHist) - 1)
								nX := 0
							EndIf
						EndIf
					Else
						Exit
					EndIf
				Next nX
				nY++
			Enddo
			
			cCmpDTINCB1 := cAliasSB1 + "->" +cMVDTINCB1 //Campo configurado no parametro MV_DTINCB1
			dDatCadPr	:= &(cCmpDTINCB1) //Data do campo configurado no parametro MV_DTINCB1

			If Valtype(dDatCadPr) == "C"
				dDatCadPr	:= StoD(dDatCadPr)
			EndIf

			//Passando para um array auxiliar os arrays que são do campo B1_DESC, para ordenar corretamente por DATA e HORA de alteração
			For nX := 1 To Len(aHist)
				//Atribuindo a variavel cDescProd o valor da 'DESCRIçãO ANTERIOR DO PRODUTO' da ultima alteração
				cDescProd := aHist[nX][2]

				//Atribuindo a ultima data de alteração a variavel dDataFinal
					
					dDataFinal := aHist[nX][3]-1
				
				If nX==1
					dDataInici := &(cCmpDTINCB1)
					If Empty(dDataInici)
						dDataInici := aHist[nX][3]
					Endif
				Else
					//Atribuindo a penultima data de alteração a variavel dDataInici independente se houve alteracao ou não no mesmo dia
					dDataInici := aHist[nX-1][3]

					/*Este tratamento abaixo foi efetuado para tratar alteracoes de produto validas por um dia. Neste caso, leva a data fim como sendo a data contida no historico
					Devido a restricoes no layout */
					If nX = Len(aHist) .And. dDataFinal = dDataInici
						dDataFinal := aHist[nX][3]
					EndIf
				Endif
						
				If Valtype(dDataInici) != Valtype(dDataFinal) .And. !Empty(dDataInici)
					dDataInici := IIF(Valtype(dDataInici) == "C" .And. Valtype(dDataFinal) == "D", StoD(dDataInici)  ,dDataInici )
				EndIf

				/* Tratamento na geracao do registro 0205 - Alteracao do Item quando um item for alterado na data final do arquivo do Sped Fiscal
				Este tratamento abaixo de <= foi efetuado para tratar alteracoes de produto validas por um dia. Neste caso, o registro e gerado com data devido a restricoes no layout */
				If dDataFinal <= dDataAte .And. Alltrim(aHist[nX][1])$"B1_DESC"
					If dDataInici <= dDataFinal .And. dDataFinal <> dDatCadPr 
						aAdd(aReg0205, {})
						nPos0205	:=	Len(aReg0205)
						aAdd(aReg0205[nPos0205], nPos)														//00-Relacionamento com o PAI
						aAdd(aReg0205[nPos0205], "0205")													//01 - REG
						aAdd(aReg0205[nPos0205], cDescProd)													//02 - DESCR_ANT_ITEM
						IF dDataInici < dDataCont
							aAdd(aReg0205[nPos0205], dDataCont)												//03 - DT_INI
						Else
							aAdd(aReg0205[nPos0205], dDataInici)											//03 - DT_INI
						EndIF
						aAdd(aReg0205[nPos0205], dDataFinal)												//04 - DT_FIM
						If cVersao >= "003"
							//Se a versão for inferior a 008 deverá preencher CODANT, pois PVA aceita somente um registro 0205
							IF cVersao < "008"
								aAdd(aReg0205[nPos0205], (cAliasSB1)->B1_CODANT)							//05 - COD_ANT_ITEM - LAYOUT 2010
							Else
								//A partir da versão 008 o PVA aceita dois registros 0205, então não deverá informar neste registro CODANT
								//pois o PVA não aceita mais o CODANT e DescProd no mesmo 0205. CODANT será informado em outro registro 0205 abaixo.
								aAdd(aReg0205[nPos0205], '')												//05 - COD_ANT_ITEM - LAYOUT 2010
							EndIF
						EndIf
					Endif
				Endif									
													
			Next nX			
			
			For nX := 1 To Len(aHistCod)
				
				
				If nx == 1
					dDataInici 	:= &(cCmpDTINCB1)
				Else
				    dDataInici	:= aHistCod[nX-1][3]
				Endif
				dDataFinal := aHistCod[1][3]

				If Valtype(dDataInici) != Valtype(dDataFinal) .And. !Empty(dDataInici)
					dDataInici := IIF(Valtype(dDataInici) == "C" .And. Valtype(dDataFinal) == "D", StoD(dDataInici)  ,dDataInici )
				EndIf

				If cVersao >= "008" .AND. !Empty(Alltrim((cAliasSB1)->B1_CODANT))
				
					aAdd(aReg0205, {})
					nPos0205	:=	Len(aReg0205)
					aAdd(aReg0205[nPos0205], nPos)														//00-Relacionamento com o PAI
					aAdd(aReg0205[nPos0205], "0205")													//01 - REG
					aAdd(aReg0205[nPos0205], '')														//02 - DESCR_ANT_ITEM
					IF dDataInici < dDataCont
						aAdd(aReg0205[nPos0205], dDataCont)												//03 - DT_INI
					Else
						aAdd(aReg0205[nPos0205], dDataInici)											//03 - DT_INI
					EndIF
					aAdd(aReg0205[nPos0205], dDataFinal)												//04 - DT_FIM
					aAdd(aReg0205[nPos0205], (cAliasSB1)->B1_CODANT)									//05 - COD_ANT_ITEM - LAYOUT 2010
																		
				EndIF					
			
			Next nx
								
		EndIf
		//³REGISTRO 0206 - CODIGO DE PRODUTO CONFORME TABELA PUBLICADA PELA ANP (COMBUSTIVEIS)  ³
		If lAchouCD6 .AND. aScan (aReg0206, {|aX| aX[2]==AllTrim((cALiasCD6)->CD6_CODANP)}) == 0
			aAdd(aReg0206, {})
			nPos0206 := Len(aReg0206)
			aAdd(aReg0206[nPos0206], nPos)	
			aAdd (aReg0206[nPos0206], "0206")															//01 - REG
			aAdd (aReg0206[nPos0206], AllTrim((cALiasCD6)->CD6_CODANP))									//02 - COD_COMB
		EndIF
	EndIf
EndIf

//Registro 0210 //BLOCO K
If lGera0210

	//Verifica se hashmap com cópia das informações da tabela 0210 foi criado e se existe produto na cCodK230
	If lBuild .And. ValType(oHMBK02010) <> "U" .AND. !Empty(cCodK230)
	   
	   	//Procura insumos vinculados ao produto cCodK230
		nP0210	:= FisFindHash(oHMBK02010, cCodK230)

		//Se encontrou insumos então percorrerá todos para gerar 0210
		If nP0210 > 0

			/* Posições do aBK02010		
			aBK02010[1] = COD_I_COMP
			aBK02010[2] = QTD_COMP
			aBK02010[3] = PERDA
			*/
			
			//Laço em todos os insumos
			For nF02010	:=1 to Len(aBK02010[nP0210][2])

				//Obtem as informações	
				cCodItem	:= aBK02010[nP0210][2][nF02010][1]
				nQtdComp	:= aBK02010[nP0210][2][nF02010][2]
				nPerda		:= aBK02010[nP0210][2][nF02010][3]

				cChave	 := cValToChar(nPos) + cCodItem + Iif(lConcFil,cFilSB1,"")
				nPos0210 := FisFindHash(oHash0210, cChave)

				If nPos0210 == 0					
					//Adiciona novo registro no array do 0210
					Add0210(@aReg0210, nPos, lConcFil, cFilSB1, cCodItem, nQtdComp, nPerda)
					
					//Atualiza também o hashmap
					If lBuild
						FisAddHash(oHash0210,cChave,Len(aReg0210))
					EndIf   

				EndIf
		 	
			Next nF02010 
		EndIF		
		
	ELSE	 
		
		//Mantenho o processamento antigo caso a build não seja compatível com hashmap
		(cAli0210)->(DbGoTop ())
		Do While !(cAli0210)->(Eof ())
			
			If cCodK230 == (cAli0210)->COD_ITEM
			
				// Se build superior a "7.00.131227A" faz a busca no HashMap para ganho de performance.
				If lBuild
					cChave	 := cValToChar(nPos) + (cAli0210)->COD_I_COMP + Iif(lConcFil,cFilSB1,"")
					nPos0210 := FisFindHash(oHash0210, cChave)
				Else
					nPos0210 := aScan(aReg0210,{|aX|aX[1] == nPos .And. aX[3] == (cAli0210)->COD_I_COMP + Iif(lConcFil,cFilSB1,"")})
				EndIf    	
				
				If nPos0210 == 0					
					//Adiciona novo registro no array do 0210
					Add0210(@aReg0210, nPos, lConcFil, cFilSB1, (cAli0210)->COD_I_COMP, (cAli0210)->QTD_COMP, (cAli0210)->PERDA)

					If lBuild
						FisAddHash(oHash0210,cChave,Len(aReg0210))
					EndIf            
				EndIf
				
			EndIf
			
			(cAli0210)->(DbSkip())
		EndDo


	EndIF
	
EndiF

//REGISTRO 0220 - FATORES DE CONVERSAO DAS UNIDADES
If 	(lSPDFIS02) .And. !Empty(cUnid) .And. aReg0220<>Nil .And.;
		aScan(aReg0220,{|aX| aX[1]==nPos .And. aX[3]==cUnid})==0 .AND. !lProcXml

	If cUnid <> (cAliasSB1)->B1_UM
		aAdd(aReg0220, {})
		nPos0220	:=	Len (aReg0220)
		aAdd (aReg0220[nPos0220], nPos)															//00-Relacionamento com o PAI
		aAdd (aReg0220[nPos0220], "0220")														//01 - REG				
		aAdd (aReg0220[nPos0220], cUnid) 							                            //02 - UNID_CONV
		If nFatorPe > 0
			If (! Empty(cTpCv) .and. cTpCv == "D") .Or. SB1->B1_TIPCONV == "D"
				aAdd (aReg0220[nPos0220], {(1/nFatorPe), 6} )									//03 - FAT_CONV
			Else
				aAdd (aReg0220[nPos0220], {nFatorPe, 6} )										//03 - FAT_CONV
			EndIf
		Else
			If cTpConv == "D"
				aAdd (aReg0220[nPos0220], {(1/nConv), 6} )						//03 - FAT_CONV
			Else
				aAdd (aReg0220[nPos0220], {nConv, 6} )							//03 - FAT_CONV
			EndIf
		EndIF
		If cVersao >= '016'
			cCodBarra := RetCodBarPE(cAliasSFT, cAliasSB1)
			If Empty(Alltrim(cCodBarra))
				cCodBarra := GeraCodBar(cAliasSB1,cAliasSB5, aProd,Nil,aReg0220)
			EndIf
			aAdd(aReg0220[nPos0220], cCodBarra)													//04 - COD_BARRA
		EndIf
		
		Reg0190(cAlias,cUnid,@aReg0190)
		
	EndIf
ElseIF ((lGer0220 .And. lProcSegUn) .Or. lProcXml) .AND. !Empty(cSegUnid) .AND. cSegUnid <> cUnid .And. aReg0220<>Nil .And.;
		aScan(aReg0220,{|aX| aX[1]==nPos .And. aX[3]==cSegUnid})==0

	aAdd(aReg0220, {})
	nPos0220	:=	Len (aReg0220)
	aAdd (aReg0220[nPos0220], nPos)															//00-Relacionamento com o PAI
	aAdd (aReg0220[nPos0220], "0220")														//01 - REG				
	aAdd (aReg0220[nPos0220], cSegUnid)														//02 - UNID_CONV				
	If cTpConv == "D"
		aAdd (aReg0220[nPos0220], {(1/nConv), 6} )											//03 - FAT_CONV
	Else
		aAdd (aReg0220[nPos0220], {nConv, 6} )												//03 - FAT_CONV
	EndIf
	If cVersao >= '016'
		cCodBarra := RetCodBarPE(cAliasSFT, cAliasSB1)
		If Empty(Alltrim(cCodBarra))
			cCodBarra := GeraCodBar(cAliasSB1,cAliasSB5, aProd,Nil,aReg0220)
		Endif
		aAdd (aReg0220[nPos0220], cCodBarra)												//04 - COD_BARRA
	Endif
	Reg0190(cAlias,cSegUnid,@aReg0190)
EndIf

Return (lRet)

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³Reg0400   ³ Autor ³Gustavo G. Rueda       ³ Data ³04.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function Reg0400(cCodNat,aReg0400,cDescNat)

Local	lRet	:=	.T.
Local	nPos	:=	aScan (aReg0400, {|aX| aX[2]==cCodNat})

If (nPos==0)
	aAdd (aReg0400, {})
	nPos	:=	Len (aReg0400)
	aAdd (aReg0400[nPos], "0400")			//01-  REG
	aAdd (aReg0400[nPos], cCodNat)			//02 - COD_NAT
	aAdd (aReg0400[nPos], cDescNat)			//03 - DESCR_NAT
EndIf

Return (lRet)
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³Reg0450   ³ Autor ³Gustavo G. Rueda       ³ Data ³11.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±³          ³        TABELA DE INFORMACAO COMPLEMENTAR/OBSERVACAO        ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao e gravacao do Registro 0450                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com as observacoes do documeto referen-³±±
±±³          ³ ciado                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³2(varios por arquivo)                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T.                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³aInfCompl -> Array com as informacoes complementares do     ³±±
±±³          ³             documento. [1]=codigo e [2]=descricao          ³±±
±±³          |aReg0450  -> Array de estrutura do registro 0450 a ser gra- ³±±
±±³          ³             vado no final do processamento da rotina       ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function Reg0450(aInfCompl,aReg0450)

Local	nPos		:=	0

//Gravacao do REGISTRO 0450
If Len(aInfCompl)==2 .And. !Empty(aInfCompl[1]) .And. aScan(aReg0450,{|aX|aX[2]==aInfCompl[1]})==0
	//Tratamento para quando a descricao do lancamento nao for passada
	If (aInfCompl[2]==Nil  .Or. Empty(aInfCompl[2])) .And. CCE->(MsSeek(aSPDFil[PFIL_CCE]+aInfCompl[1]))
		aInfCompl[2]	:=	CCE->CCE_DESCR
	EndIf

	aAdd(aReg0450, {})
	nPos	:=	Len (aReg0450)
	aAdd (aReg0450[nPos], "0450")			   		//01 - REG
	aAdd (aReg0450[nPos], aInfCompl[1])       		//02 - COD_INF
	aAdd (aReg0450[nPos], aInfCompl[2]) 			//03 - TXT
EndIf                                          	

Return
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³Reg0460   ³ Autor ³Gustavo G. Rueda       ³ Data ³10.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±³          ³        TABELA DE INFORMACAO COMPLEMENTAR/OBSERVACAO        ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao e gravacao do Registro 0460                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com as observacoes do documeto referen-³±±
±±³          ³ ciado                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³2(varios por arquivo)                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nil                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³aReg0460 -> Array com a estrutura do registro 0460 a ser    ³±±
±±³          ³ gravado no TRB no final do processamento da rotina         ³±±
±±³          ³aObs     -> Array contendo o codigo da obs[1] e a observacao³±±
±±³          ³ em si[2]                                                   ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function Reg0460(aReg0460,aObs)

Local	nPos		:=	0

//Gravacao do REGISTRO 0460
If Len(aObs)==2 .And. aScan(aReg0460,{|aX| Alltrim(aX[2])==Alltrim(aObs[1])})==0
	aAdd(aReg0460, {})
	nPos	:=	Len (aReg0460)
	aAdd (aReg0460[nPos], "0460")					//01- REG			
	aAdd (aReg0460[nPos], aObs[1])					//02- COD_OBS
	aAdd (aReg0460[nPos], aObs[2])                 	//03- TXT
EndIf

Return

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³RegC100   ³ Autor ³Gustavo G. Rueda       ³ Data ³14.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±³          ³               NOTA FISCAL (MODELO 01 E 04)                 ³±±
±±³          ³                                                            ³±±
±±³          ³Geracao e gravacao do Registro C100                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com as informacoes de todos os docu-   ³±±
±±³          ³ mentos fiscais processados.                                ³±±
±±³          ³Somente sera gravado os documentos fiscais modelo 01 e 04   ³±±
±±³          ³ nos outros casos, sera utilizdo para gerar outros registros³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³2                                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nil                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cEntSai -> Flag de indicacao do documento fiscal, 1=Entrada/³±±
±±³          ³ 2=Saida.                                                   ³±±
±±³          ³aPartDoc -> Array com todas as informacoes do Cliente/Forne-³±±
±±³          ³ cedor.                                                     ³±±
±±³          ³cEspecie -> Modelo do documento fiscal                      ³±±
±±³          ³cAlias -> Alias do TRB que recebera as informacoes          ³±±
±±³          ³nRelac -> Flag de relacionamento com os sub-registros       ³±±
±±³          ³aCmpAntSFT -> Informacoes de cabecalho do documento fiscal  ³±±
±±³          ³aTotaliza -> Totalizacao de valores da tabela SFT do docu-  ³±±
±±³          ³ mento fiscal do processamento atual no while               ³±±
±±³          ³aRegC100 -> Informacoes sobre todos documentos fiscais pro- ³±±
±±³          ³ cessados no while da funcao principal.                     ³±±
±±³          ³cSituaDoc -> Situacao do documento fiscal conforme funcao   ³±±
±±³          ³ SPEDSitDoc                                                 ³±±
±±³          ³lGrava0150 -> Flag para indicar se deve gerar 0150          ³±±
±±³          ³aParcTit -> Array com os titulos gerados para o documento   ³±±
±±³          ³lPisZero -> Indica se zera o valor do Pis                   ³±±   
±±³          ³lCofZero -> Indica se zera o valor do Cofins                ³±±   
±±³          ³cVesao -> numero da versao do leiaute                       ³±±   
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function RegC100(cEntSai,aPartDoc,cEspecie,cAlias,nRelac,aCmpAntSFT,aTotaliza,aRegC100,cSituaDoc,lGrava0150,aParcTit,lPisZero,lCofZero,cVersao,aWizard,lOperGar,cSitDocInf,aPartSM0)

Local   aSpedC100   := {}
Local	cSerie		:= ""
Local	nPos		:=	0
Local	nX			:=	0
Local	lMod65		:= cEspecie=="65"

// MV_VLCTBZL -> Indique os CFOP's que terao os seus Valores contabeis Zerados no Livros de Entrada e Saida. - 16/10/2017 - Vitor Ribeiro (vitor.e@totvs.com.br)
Local	lVLCTBZL	:= AllTrim(aCmpAntSFT[9]) $ aSPDSX6[MV_VLCTBZL]

Default	aParcTit	:=	{}	
Default aWizard		:= {}
Default cSitDocInf	:= ""
Default aPartSM0	:= {}

cSerie	:= SpedSerie(aCmpAntSFT[2],cEspecie)

//Tratamento para evitar duplicidade no registro
If aScan(aRegC100,{|aX| aX[7]==cSerie .And. aX[8]==aCmpAntSFT[1] .And. aX[10]==aCmpAntSFT[6]})==0
	//Inicio da montagem do registro
	aAdd(aRegC100, {})
	nPos	:=	Len (aRegC100)
	aAdd (aRegC100[nPos], "C100")					   														//01 - REG
	aAdd (aRegC100[nPos], Str(Val(cEntSai)-1,1)) 	   														//02 - IND_OPER
	aAdd (aRegC100[nPos], aCmpAntSFT[26])																	//03 - IND_EMIT
	aAdd (aRegC100[nPos], "")																				//04 - COD_PART
	aAdd (aRegC100[nPos], cEspecie)   							 											//05 - COD_MOD
	aAdd (aRegC100[nPos], Iif(cSitDocInf$"08",cSitDocInf,cSituaDoc))  										//06 - COD_SIT
	aAdd (aRegC100[nPos], cSerie)																			//07 - SER
	aAdd (aRegC100[nPos], aCmpAntSFT[1])  			   														//08 - NUM_DOC
		
	//Obtem a chave da NF-e
	If cEspecie$"55#65" 
		If aCmpAntSFT[6] >= CToD("01/01/2011")                    											// LayOut posterior a 01/01/2011 leva ChaveNFE
			aAdd (aRegC100[nPos], aCmpAntSFT[25])			 												//09 - CHV_NFE
		EndIf
		If aCmpAntSFT[6] < CToD("01/01/2011") .And. cSituaDoc=="02#03"     									// LayOut anterior a 01/01/2011 e cancelado nao leva ChaveNFE    	
			aAdd (aRegC100[nPos], "")	
		EndIf	
		If aCmpAntSFT[6] < CToD("01/01/2011") .And. cSituaDoc<>"02#03"    									// LayOut anterior a 01/01/2011 nao cancelado leva ChaveNFE    	
			aAdd (aRegC100[nPos], aCmpAntSFT[25])
		EndIf	
	Else
		aAdd (aRegC100[nPos], "")						  													//09 - CHV_NFE
	EndIf

	//Tratamento para documentos cancelados, onde o menual diz que somente alguns campos devem ser informadoes
	If cSituaDoc$"02#04#05#03"
		For nx := 10 to 29
			aAdd (aRegC100[nPos], "") 																		//10 - N INFORMAR PARA DOC CANCELADO
		Next 
		If cSitDocInf$"08"
			aRegC100[nPos,10]	:= aCmpAntSFT[6]
			If Len(aPartSM0) > 0
				aRegC100[nPos,4]	:= Iif(lMod65,"",aPartSM0[1])										//04 - COD_PART	- FORMULÁRIO PRÓPRIO E F1_DEVMERC = S
			Else
				aRegC100[nPos,4]	:= Iif(lMod65,"",aPartDoc[1])										//04 - COD_PART
			EndIf
		Endif 		
	Else
		If Len(aPartSM0) > 0
			aRegC100[nPos,4]	:= Iif(lMod65,"",aPartSM0[1])											//04 - COD_PART	- FORMULÁRIO PRÓPRIO E F1_DEVMERC = S
		Else
			aRegC100[nPos,4]	:= Iif(lMod65,"",aPartDoc[1])											//04 - COD_PART		
		EndIf

		//Tratamento para Escrituração extemporânea de documento complementar
		If aRegC100[nPos][6]$"01#07" .And. aRegC100[nPos][2] = "1"
			aAdd (aRegC100[nPos], Iif(!Empty(aCmpAntSFT[41]),aCmpAntSFT[41],aCmpAntSFT[6]))					//10 - DT_DOC
		Else
			aAdd (aRegC100[nPos], aCmpAntSFT[6])															//10 - DT_DOC
		Endif
		
		aAdd (aRegC100[nPos], Iif(!Empty(aCmpAntSFT[41]),aCmpAntSFT[41],aCmpAntSFT[5])) 					//11 - DT_E_S
		
		If lVLCTBZL
			aAdd (aRegC100[nPos], 0)					 													//12 - VL_DOC
		Else
			aAdd (aRegC100[nPos], aTotaliza[1])																//12 - VL_DOC
		EndIf
		
		//Tratamento para gerar a condicao de pagamento da NF
		If Len(aParcTit)==0
			aAdd (aRegC100[nPos], Iif(cVersao >= "006","2","9"))											//13 - IND_PAGTO - SEM PAGAMENTO
		ElseIf Len(aParcTit)>1
			aAdd (aRegC100[nPos], "1")	  						  											//13 - IND_PAGTO - A PRAZO
		ElseIf Len(aParcTit)==1 .And. aCmpAntSFT[6]==aParcTit[1,7]
			aAdd (aRegC100[nPos], "0")																		//13 - IND_PAGTO - A VISTA			
		Else
			aAdd (aRegC100[nPos], "1")	  						  											//13 - IND_PAGTO - A PRAZO - campo é obrigatorio e nao pode ser levado em branco
		EndIf
		aAdd (aRegC100[nPos], aTotaliza[9])																	//14 - VL_DESC
		aAdd (aRegC100[nPos], aTotaliza[26])																//15 - VL_ABAT_NT
		//Tratamento para o valor da mercadoria quando a nota for Compl. ICMS/IPI
		If cSituaDoc$"08" .Or. ( aCmpAntSFT[20] $ "IP" ) .Or. lVLCTBZL		
			aAdd (aRegC100[nPos], 0)																		//16 - VL_MERC
		Else
			aAdd (aRegC100[nPos], aTotaliza[10])															//16 - VL_MERC
		Endif
		aAdd (aRegC100[nPos], aCmpAntSFT[21])																//17 - IND_FRT
		aAdd (aRegC100[nPos], aTotaliza[11])																//18 - VL_FRT 		-	FT_FRETE
		aAdd (aRegC100[nPos], aTotaliza[12])																//19 - VL_SEG		-	FT_SEGURO
		aAdd (aRegC100[nPos], aTotaliza[13])																//20 - VL_OUT_DA	-	FT_DESPESA
		aAdd (aRegC100[nPos], aTotaliza[2])					   												//21 - VL_BC_ICMS	-	FT_BASEICM
		aAdd (aRegC100[nPos], aTotaliza[3])					   												//22 - VL_ICMS		-	FT_VALICM
		aAdd (aRegC100[nPos], Iif(lMod65,"",aTotaliza[4]))													//23 - VL_BC_ICMS_ST-	FT_BASERET
		aAdd (aRegC100[nPos], Iif(lMod65,"",aTotaliza[5]))													//24 - VL_ICMS_ST	-	FT_ICMSRET
		aAdd (aRegC100[nPos], Iif(lMod65,"",aTotaliza[6]))													//25 - VL_IPI		-	FT_VALIPI
		aAdd (aRegC100[nPos], Iif(lMod65,"",Iif("1"$aWizard[1][15],aTotaliza[19],"")))						//26 - VL_PIS		-	FT_VALPIS
		aAdd (aRegC100[nPos], Iif(lMod65,"",Iif("1"$aWizard[1][15],aTotaliza[20],"")))						//27 - VL_COFINS	-	FT_VALCOF
		aAdd (aRegC100[nPos], Iif(lMod65,"",Iif("1"$aWizard[1][15],aTotaliza[21],"")))						//28 - VL_PIS_ST	-	FT_VALPS3
		aAdd (aRegC100[nPos], Iif(lMod65,"",Iif("1"$aWizard[1][15],aTotaliza[22],"")))						//29 - VL_COF_ST	-	FT_VALCF3
		//Ponto de entrada para os campos 13(IND_PAGTO) e 17(IND_FRT)
		If aExistBloc[11]
		   	aSpedC100 := ExecBlock("SPDFIS05",.F.,.F.,{"SFT",aCmpAntSFT,aRegC100}) 	
			aRegC100[nPos][13] := aSpedC100[01]
			aRegC100[nPos][17] := aSpedC100[02]
			If Len(aSpedC100) > 2
				aRegC100[nPos][03] := aSpedC100[03]
			Endif			
		Endif
	EndIf
	If cEspecie$"01#1B#04#55#65" 
		GrvRegTrS(cAlias,RetRD(nRelac),aRegC100)
		lGrava0150 := (!(cSituaDoc$"02#04#05#03") .and. !(cEspecie == "65"))  .Or. (cSituaDoc$"02#03" .And. cSitDocInf$"08")
	EndIf
EndIf
Return
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³RegC110   ³ Autor ³Gustavo G. Rueda       ³ Data ³14.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±³          ³           INFO COMPLEMENTAR DA NOTA FISCAL                 ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao e gravacao do Registro c110                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com o embasamento legal para tais      ³±±
±±³          ³ observacoes (NAO EH NECESSARIAMENTE OBRIGATORIO            ³±±
±±³          ³ PARA CADA 0450)                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³3(1:N) Para cada C100                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³aInfCompl -> Array com o registro do CDT                    ³±±
±±³          ³aRegC110  -> Array de estrutura do registro C110            ³±±
±±³          ³nPosC110  -> Posicao do array para relacionamento com os    ³±±
±±³          ³             registros filhos                               ³±±
±±³          ³aReg0450  -> Array de estrutura do registro 0450            ³±±
±±³          ³cAliasCDT -> Alias da tabela CDT				              ³±±
±±³          ³lTop  	-> Indica se eh ambiente top connect	          ³±±
±±³          ³aSpdInfC  -> Conteudo do PE SPDPISIC				          ³±±
±±³          ³aCmpAntSFT-> Campos da tabela SFT com informacoes do        ³±±
±±³          ³             documento em processamento                     ³±±
±±³          ³nMVSPDIFC -> Configuracao do parametro MV_SPDIFC	          ³±±
±±³          ³lCmpDscComp-> FieldPos do campo CDT_DCCOMP		          ³±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function RegC110(aInfCompl,aRegC110,nPosC110,aReg0450,cAliasCDT,lTop,aSpdInfC,aCmpAntSFT,nMVSPDIFC,lCmpDscComp,cOrigem,lRegEspPr)				    

Local	aInfSit		:= 	{"CANNFE",STR0036}
Local	cCDTChv		:= 	""
Local	cTxtCompl	:= 	""
Local	lSeekCCE	:=	.F.
Local	lSeekCDC	:=	.F.

Default	aSpdInfC	:= {}
Default	cAliasCDT 	:= ""
Default	cOrigem		:= ""
Default	lTop		:= .F.
Default lRegEspPr   := .F. 
Default	lCmpDscComp	:= aSPDSX3[FP_CDT_DCCOMP]
Default	nMVSPDIFC	:= aSPDSX6[MV_SPDIFC]

/* Gera C110 para registros que conte'm apenas INFORMACAO COMPLEMENTAR 
Crédito presumido Paraná - Art. 69. Para a apropriação do crédito presumido, de que trata o Anexo III */
If lRegEspPr
	aInfSit[1]	:=	"CRP"+right(alltrim(aCmpAntSFT[1]),3)	//NF	
	aInfSit[2]	:=	Formula(aCmpAntSFT[47])		//Obs
 	// Adiciona o registro C110 a ser gerado 
	aAdd(aRegC110, {})
	nPosC110 :=	Len (aRegC110)
	aAdd(aRegC110[nPosC110], "C110")			//01 - REG
	aAdd(aRegC110[nPosC110], aInfSit[1])		//02 - COD_INF
	aAdd(aRegC110[nPosC110], aInfSit[2])		//03 - TXT_COMPL   

	//aAdd(aRegC110[nPosC110], GetRelacPr()+"C110"+strzero(nPosC110,nTTRBITEM))		//04 - Posição de Hierarquia   
	aAdd(aRegC110[nPosC110], RetRD(GetRelacPr())+strzero(nPosC110,nTamFT_IT * 11))		//04 - Posição de Hierarquia   
	//REGISTRO 0450 - TABELA DE INFORMACAO COMPLEMENTAR/OBSERVACAO
	Reg0450(aInfSit,@aReg0450)
Endif

// Gera C110 a partir do Ponto de Entrada SPDPISIC	
If Len(aSpdInfC) > 0

 	// Adiciona o registro C110 a ser gerado 
	aAdd(aRegC110, {})
	nPosC110 :=	Len (aRegC110)
	aAdd (aRegC110[nPosC110], "C110")			//01 - REG
	aAdd (aRegC110[nPosC110], aSpdInfC[1])		//02 - COD_INF
	aAdd (aRegC110[nPosC110], aSpdInfC[2])		//03 - TXT_COMPL   

	//aAdd (aRegC110[nPosC110], GetRelacPr()+"C110"+strzero(nPosC110,nTTRBITEM))		//04 - Posição de Hierarquia
	aAdd(aRegC110[nPosC110], RetRD(GetRelacPr())+strzero(nPosC110,nTamFT_IT * 11))		//04 - Posição de Hierarquia
	/*REGISTRO 0450 - TABELA DE INFORMACAO COMPLEMENTAR/OBSERVACAO 
	Atribui os valores do array aReg0450 para efetuar a gravacao no final do processamento da rotina. */
	
	Reg0450(aSpdInfC,@aReg0450)	

ElseIf cSitDocInf$"08"

 	// Adiciona o registro C110 a ser gerado 
	aAdd(aRegC110, {})
	nPosC110 :=	Len (aRegC110)
	aAdd (aRegC110[nPosC110], "C110")			//01 - REG
	aAdd (aRegC110[nPosC110], aInfSit[1])		//02 - COD_INF
	aAdd (aRegC110[nPosC110], aInfSit[2])		//03 - TXT_COMPL   

	//aAdd (aRegC110[nPosC110], GetRelacPr()+"C110"+strzero(nPosC110,nTTRBITEM))		//04 - Posição de Hierarquia
	aAdd(aRegC110[nPosC110], RetRD(GetRelacPr())+strzero(nPosC110,nTamFT_IT * 11))		//04 - Posição de Hierarquia

	/*REGISTRO 0450 - TABELA DE INFORMACAO COMPLEMENTAR/OBSERVACAO
	Atribui os valores do array aReg0450 para efetuar a gravacao no final do processamento da rotina.  */
	Reg0450(aInfSit,@aReg0450)
	
ElseIf !Empty(cAliasCDT)                     
	cCDTChv := (cAliasCDT)->(CDT_FILIAL+CDT_TPMOV+CDT_DOC+CDT_SERIE+CDT_CLIFOR+CDT_LOJA) 
	While !(cAliasCDT)->(Eof())  .AND. ((cAliasCDT)->(CDT_FILIAL+CDT_TPMOV+CDT_DOC+CDT_SERIE+CDT_CLIFOR+CDT_LOJA)==cCDTChv)
		// Verifica se a informacao complementar ja foi encontrada nos outros complementos
		If !(cAliasCDT)->(Empty(CDT_IFCOMP))  .And. (aScan(aRegC110,{|aX| aX[2]==(cAliasCDT)->CDT_IFCOMP}))==0
			lSeekCCE	:=	CCE->(MsSeek(aSPDFil[PFIL_CCE]+(cAliasCDT)->CDT_IFCOMP))
			lSeekCDC	:=	CDC->(MsSeek(aSPDFil[PFIL_CDC]+(cAliasCDT)->CDT_TPMOV+(cAliasCDT)->CDT_DOC+(cAliasCDT)->CDT_SERIE+(cAliasCDT)->CDT_CLIFOR+(cAliasCDT)->CDT_LOJA))
					
			//Composicao do Campo 03 - TXT_COMPL
			
			cTxtCompl	:=	""
			Do Case
				//Descricao similar a do registro 0450
				Case nMVSPDIFC == 0 .And. lSeekCCE
					cTxtCompl	:=	CCE->CCE_DESCR					
				//Verifica Descricao Complementar a partir da tabela CDT (CDT_DCCOMP)
				Case nMVSPDIFC == 1 .Or. nMVSPDIFC == 3
					If	lCmpDscComp .And. !Empty((cAliasCDT)->CDT_DCCOMP)
						cTxtCompl	:=	(cAliasCDT)->CDT_DCCOMP
					ElseIf lSeekCDC .And. !Empty(CDC->CDC_DCCOMP)
						cTxtCompl	:=	CDC->CDC_DCCOMP
					EndIf
				//a posicao 44 do array aCmpAntSFT possui conte	udo do campo _MENNOTA (cabecalho da NF - F1 ou F2)
				Case nMVSPDIFC == 2 .And. aCmpAntSFT <> Nil .And. aCmpAntSFT[44] <> Nil .And. !Empty(aCmpAntSFT[44])
					cTxtCompl	:=	aCmpAntSFT[44]	
			EndCase
			//Composicao do array a InfCompl    
			aInfCompl	:=	{(cAliasCDT)->CDT_IFCOMP, Iif( lSeekCCE , CCE->CCE_DESCR , ""  ) }       			
			
			// Adiciona o registro C110 a ser gerado 
			aAdd(aRegC110, {})
			nPosC110 :=	Len (aRegC110)
			aAdd (aRegC110[nPosC110], "C110")											//01 - REG
			aAdd (aRegC110[nPosC110], aInfCompl[1])            							//02 - COD_INF
			aAdd (aRegC110[nPosC110], cTxtCompl)										//03 - TXT_COMPL   
			
			//aAdd (aRegC110[nPosC110], GetRelacPr()+"C110"+strzero(nPosC110,nTTRBITEM))		//04 - Posição de Hierarquia
			aAdd(aRegC110[nPosC110], RetRD(GetRelacPr())+strzero(nPosC110,nTamFT_IT * 11))		//04 - Posição de Hierarquia

			/*REGISTRO 0450 - TABELA DE INFORMACAO COMPLEMENTAR/OBSERVACAO 
			Atribui os valores do array aReg0450 para efetuar a gravacao no final do processamento da rotina. */
			Reg0450(aInfCompl,@aReg0450)   
		EndIf
		(cAliasCDT)->(DbSkip()) 
	Enddo   

Else 

	If Len(aInfCompl)==2 .And. !Empty(aInfCompl[1])
		
			//Tratamento para quando a descricao do lancamento nao for passada
	 Do Case
	    //Tratamento implemtado através do chamado TSCFIU, caso a RegC110 seja invocada sem os parammetros necessários, preciso validar se as condições para respeitar o parâmetro MV_SPDIFC são atendidas.		   
		Case nMVSPDIFC == 0 .And. CCE->(MsSeek(aSPDFil[PFIL_CCE]+aInfCompl[1]))				
				cTxtCompl := CCE->CCE_DESCR
		Case nMVSPDIFC == 1 .Or. nMVSPDIFC == 3				
			If lCmpDscComp .And. CDT->(MsSeek(aSPDFil[PFIL_CDT]+aCmpAntSFT[43]+aCmpAntSFT[1]+aCmpAntSFT[2]+aCmpAntSFT[3]+aCmpAntSFT[4])) .And. !Empty(CDT->CDT_DCCOMP)
				cTxtCompl := CDT->CDT_DCCOMP
			ElseIf CDC->(MsSeek(aSPDFil[PFIL_CDC]+aCmpAntSFT[43]+aCmpAntSFT[1]+aCmpAntSFT[2]+aCmpAntSFT[3]+aCmpAntSFT[4]))
				cTxtCompl := CDC->CDC_DCCOMP
			ElseIf !Empty(aInfCompl[1]) .And. CCE->(MsSeek(aSPDFil[PFIL_CCE]+aInfCompl[1])) .And. !Empty(CCE->CCE_DESCR)
				cTxtCompl := CCE->CCE_DESCR				
			EndIf
		Case nMVSPDIFC == 2 .And. aCmpAntSFT <> Nil .And. aCmpAntSFT[44] <> Nil .And. !Empty(aCmpAntSFT[44])
				cTxtCompl := aCmpAntSFT[44]
		EndCase	
		
			//Tratamento para quando a descricao do lancamento nao for passada
			If (aInfCompl[2]==Nil  .Or. Empty(aInfCompl[2])) .And. CCE->(MsSeek(aSPDFil[PFIL_CCE]+aInfCompl[1]))
				aInfCompl[2] :=	CCE->CCE_DESCR
			EndIf 
			//Tratamento para retornar o nPos do C110 para amarrar aos outros registros
			If (nPosC110 := aScan(aRegC110,{|aX| aX[2]==aInfCompl[1]}))==0
				aAdd(aRegC110, {})
				nPosC110 :=	Len (aRegC110)
			aAdd (aRegC110[nPosC110], "C110")												//01 - REG
			aAdd (aRegC110[nPosC110], aInfCompl[1])            								//02 - COD_INF
			aAdd (aRegC110[nPosC110], Iif(Empty(cTxtCompl),aInfCompl[2],cTxtCompl))			//03 - TXT_COMPL
			//aAdd (aRegC110[nPosC110], GetRelacPr()+"C110"+strzero(nPosC110,nTTRBITEM))	//04 - Posição de Hierarquia
			aAdd(aRegC110[nPosC110], RetRD(GetRelacPr())+strzero(nPosC110,nTamFT_IT * 11))	//04 - Posição de Hierarquia
			EndIf
	EndIf    
EndIf
 
Return
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³RegC111   ³ Autor ³Gustavo G. Rueda       ³ Data ³14.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±³          ³                     NORMA REFERENCIADA                     ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao e gravacao do Registro 0450, C110 e C111          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com o embasamento legal para tais      ³±±
±±³          ³ observacoes                                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³4(1:N) Para cada C110                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nil                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cAliasCDG-> Alias da tabela CDG filtrada (query ou indregua)³±±
±±³          ³aRegC110 -> Array com a estrutura do C110 gerado ateh o     ³±±
±±³          ³            momento.                                        ³±±
±±³          ³aReg0450 -> Array com a estrutura do 0450 gerado ateh o     ³±±
±±³          ³            momento.                                        ³±±
±±³          ³aRegC111 -> Array com a estrutura do registro a ser gravado ³±±
±±³          ³lTop     -> Flag de indicacao de ambiente TOP ou DBF        ³±± 
±±³          ³aCmpAntSFT-> Campos da tabela SFT com informacoes do        ³±±
±±³          ³             documento em processamento                     ³±± 
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function RegC111(cAliasCDG,aRegC110,aReg0450,aRegC111,lTop,aCmpAntSFT,cSitDocInf,cProtocolo)

Local	aInfCompl	:=	{}
Local 	aInfSit		:= {"CANNFE",STR0036}
Local 	cCDGChv		:= (cAliasCDG)->(CDG_FILIAL+CDG_TPMOV+CDG_DOC+CDG_SERIE+CDG_CLIFOR+CDG_LOJA)   
Local	nPosC111	:=	1
Local	nPosC110	:=	1

Default cSitDocInf := ""       
Default cProtocolo  := "" 
 
//Esta tabela jah estah filtrada, QUERY ou INDREGUA
While !(cAliasCDG)->(Eof()) .AND. ( (cAliasCDG)->(CDG_FILIAL+CDG_TPMOV+CDG_DOC+CDG_SERIE+CDG_CLIFOR+CDG_LOJA)==cCDGChv)

	//³Processo o mesmo codigo de OBS da CDT e da CDG³
	If !(cAliasCDG)->(Empty(CDG_IFCOMP))

		//³Tratamento para evitar duplicidade no registro C110³
		If (nPosC110 := aScan(aRegC110,{|aX|aX[2]==(cAliasCDG)->CDG_IFCOMP}))==0
			
			//DBF/ADS nao tem JOIN, preciso fazer o SEEK, e a funcao Reg0450 faz automaticamente quando a descricao estah com NIL 
			aInfCompl	:=	{(cAliasCDG)->CDG_IFCOMP,}
			
			/*REGISTRO C110 - INFORMACAO COMPLEMENTAR DA NOTA FISCAL (CODIGO 01, 04 E 55)
			Funcao que gera a estrutura dos registros acima e os grava no final do processamento do documento fiscal  */  
			RegC110(@aInfCompl,@aRegC110,@nPosC110,,,,,aCmpAntSFT)			

			/*REGISTRO 0450 - TABELA DE INFORMACAO COMPLEMENTAR/OBSERVACAO 
			Atribui os valores do array aReg0450 para efetuar a gravacao no final do processamento da rotina.  */
			Reg0450(aInfCompl,@aReg0450)
		EndIf
		//Verifica se jah nao foi adicionado antes
		If (nPosC111 := aScan(aRegC111,{|aX| aX[1]==nPosC110 .And. aX[3]==(cAliasCDG)->CDG_PROCES}))==0
			aAdd(aRegC111, {})
			nPosC111 := Len(aRegC111)
			aAdd (aRegC111[nPosC111], nPosC110)						//Relacionamento com o registro pai
			aAdd (aRegC111[nPosC111], "C111")			 			//01 - REG
			aAdd (aRegC111[nPosC111], (cAliasCDG)->CDG_PROCES)		//02 - NUM_PROC
			aAdd (aRegC111[nPosC111], (cAliasCDG)->CDG_TPPROC)		//03 - IND_PROC		
			
			//aAdd (aRegC111[nPosC111], GetRelacPr()+"C110"+strzero(nPosC110,nTTRBITEM)+"C111"+strzero(nPosC111,nTTRBITEM))		//04 - Posição de Hierarquia   
			aAdd (aRegC111[nPosC111], RetRD(GetRelacPr())+strzero(nPosC110,nTamFT_IT * 11))		//04 - Posição de Hierarquia   
		EndIf
	Endif
	(cAliasCDG)->(DbSkip())	
End
If cSitDocInf$"08"		
		/* REGISTRO C110 - INFORMACAO COMPLEMENTAR DA NOTA FISCAL (CODIGO 01, 04 E 55) 
		Funcao que gera a estrutura dos registros acima e os grava no final do processamento do documento fiscal */
		If (nPosC110 := aScan(aRegC110,{|aX|aX[2]==cProtocolo}))==0
			RegC110(aInfSit,@aRegC110,@nPosC110,@aReg0450,,,,aCmpAntSFT)			 
			/*REGISTRO 0450 - TABELA DE INFORMACAO COMPLEMENTAR/OBSERVACAO 
			Atribui os valores do array aReg0450 para efetuar a gravacao no final do processamento da rotina. */
			Reg0450(aInfSit,@aReg0450)
		Endif
		
		If (nPosC111 := aScan(aRegC111,{|aX| aX[1]==nPosC110 .And. aX[3]==cProtocolo}))==0
			aAdd(aRegC111, {})
			nPosC111 := Len(aRegC111)
			aAdd (aRegC111[nPosC111], nPosC110)						//Relacionamento com o registro pai
			aAdd (aRegC111[nPosC111], "C111")			 			//01 - REG
			aAdd (aRegC111[nPosC111], cProtocolo)					//02 - NUM_PROC
			aAdd (aRegC111[nPosC111], "9")							//03 - IND_PROC		
			
			//aAdd (aRegC111[nPosC111], GetRelacPr()+"C110"+strzero(nPosC110,nTTRBITEM)+"C111"+strzero(nPosC111,nTTRBITEM))		//04 - Posição de Hierarquia   
			aAdd (aRegC111[nPosC111], RetRD(GetRelacPr())+strzero(nPosC110,nTamFT_IT * 11))		//04 - Posição de Hierarquia   

		EndIf
Endif

Return
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³RegC112   ³ Autor ³Gustavo G. Rueda       ³ Data ³14.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±³          ³           DOCUMENTO DE ARRECADACAO REFERENCIADO            ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao e gravacao do Registro 0450, C110 e C112          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com todas as guias de recolhimento com ³±±
±±³          ³ a data de referencia no periodo apurado.                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³4(1:N) para cada Registro C110                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nil                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cAliasCDC-> Alias da tabela CDC filtrada (query ou indregua)³±±
±±³          ³aRegC110 -> Array com a estrutura do C110 gerado ateh o     ³±±
±±³          ³            momento.                                        ³±±
±±³          ³lTop     -> Flag de ambiente TOP(.t.) ou DBF                ³±±
±±³          ³aReg0450 -> Array com a estrutura do 0450 gerado ateh o     ³±±
±±³          ³            momento.                                        ³±±
±±³          ³aRegC112 -> Array com a estrutura do registro a ser gravado ³±±
±±³          ³aIcmPago -> Array com as GNREs de ICMSST para gerar o       ³±±
±±³          ³            registro E250                                   ³±±
±±³          ³aCmpAntSFT-> Campos da tabela SFT com informacoes do        ³±±
±±³          ³             documento em processamento                     ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function RegC112(cAliasCDC,aRegC110,lTop,aReg0450,aRegC112,aIcmPago,aCmpAntSFT)

Local	aInfCompl	:= 	{}
Local 	cCDCChv		:= 	""
Local	cAliasSF6	:=	"SF6"
Local	nPosC112	:=	1
Local	nPosC110	:=	1 
Local	nMVSPDIFC	:=	aSPDSX6[MV_SPDIFC]

cCDCChv :=  (cAliasCDC)->(CDC_FILIAL+CDC_TPMOV+CDC_DOC+CDC_SERIE+CDC_CLIFOR+CDC_LOJA) 
//Esta tabela jah estah filtrada, QUERY ou INDREGUA
While !(cAliasCDC)->(Eof()) .AND. ( (cAliasCDC)->(CDC_FILIAL+CDC_TPMOV+CDC_DOC+CDC_SERIE+CDC_CLIFOR+CDC_LOJA)==cCDCChv)

	//Processo o mesmo codigo de OBS da CDT e da CDG
	If !(cAliasCDC)->(Empty(CDC_IFCOMP))
		//Tratamento para evitar duplicidade no registro C110
		If (nPosC110 := aScan(aRegC110,{|aX|aX[2]==(cAliasCDC)->CDC_IFCOMP}))==0
			
			//DBF/ADS nao tem JOIN, preciso fazer o SEEK, e a funcao Reg0450 faz automaticamente quando a descricao estah com NIL 
			aInfCompl	:=	{(cAliasCDC)->CDC_IFCOMP,If((cAliasCDC)->(FieldPos("CDC_DCCOMP"))>0,(cAliasCDC)->CDC_DCCOMP,"")}
			
			/*REGISTRO C110 - INFORMACAO COMPLEMENTAR DA NOTA FISCAL (CODIGO 01, 04 E 55)
			Funcao que gera a estrutura dos registros acima e os grava no final do processamento do documento fiscal */
			RegC110(@aInfCompl,@aRegC110,@nPosC110,@aReg0450,,,,aCmpAntSFT,nMVSPDIFC,,"CDC")			
			
			/*REGISTRO 0450 - TABELA DE INFORMACAO COMPLEMENTAR/OBSERVACAO
			Atribui os valores do array aReg0450 para efetuar a gravacao no final do processamento da rotina. */
			aInfCompl	:=	{(cAliasCDC)->CDC_IFCOMP,}	//tratamento para que o registro 0450 seja gerado a partir da CCE
			Reg0450(aInfCompl,@aReg0450)
		EndIf
		//³verifica se jah nao foi adicionado antes³
		If (nPosC112 := aScan(aRegC112,{|aX| aX[1]==nPosC110 .And. aX[4]==(cAliasCDC)->CDC_UF .And. aX[5]==(cAliasCDC)->CDC_GUIA}))==0
			//³Para TOP nao preciso dar SEEK, pois jah estah no JOIN³
			If SpedSeek( cAliasSF6,1,aSPDFil[PFIL_SF6]+(cAliasCDC)->(CDC_UF+CDC_GUIA))
				aAdd(aRegC112, {})
				nPosC112 := Len(aRegC112)
				aAdd (aRegC112[nPosC112], nPosC110)											//Relacionamento com o registro pai
				aAdd (aRegC112[nPosC112], "C112")											//01 - REG
				If (cAliasSF6)->F6_TIPOIMP=="0"
					aAdd (aRegC112[nPosC112], "0")											//02 - COD_DA - Uso 0 quando for uma guia estadual. Exemplo ES=DUA (documento unico de arrecadacao)
				Else
					aAdd (aRegC112[nPosC112], "1")											//02 - COD_DA
				EndIf
				aAdd (aRegC112[nPosC112], (cAliasCDC)->CDC_UF)								//03 - UF
				aAdd (aRegC112[nPosC112], (cAliasCDC)->CDC_GUIA)							//04 - NUM_DA
					If aSPDSX3[FP_F6_AUTENT]
						aAdd (aRegC112[nPosC112],(cAliasSF6)->F6_AUTENT)		    		//05 - COD_AUT
					Else
						aAdd (aRegC112[nPosC112],"")						    			//05 - COD_AUT
					EndIf
				aAdd (aRegC112[nPosC112], (cAliasSF6)->F6_VALOR)							//06 - VL_DA
				aAdd (aRegC112[nPosC112], (cAliasSF6)->F6_DTVENC)							//07 - DT_VCTO
					If aSPDSX3[FP_F6_DTPAGTO] .And. !Empty((cAliasSF6)->F6_DTPAGTO)
						aAdd (aRegC112[nPosC112], (cAliasSF6)->F6_DTPAGTO)					//08 - DT_PGTO
					Else
						aAdd (aRegC112[nPosC112], (cAliasSF6)->F6_DTVENC)					//08 - DT_PGTO
					EndIf

				//aAdd (aRegC112[nPosC112], GetRelacPr()+"C110"+strzero(nPosC110,nTTRBITEM)+"C112"+strzero(nPosC112,nTTRBITEM))		//09 - Posição de Hierarquia   
				aAdd (aRegC112[nPosC112], RetRD(GetRelacPr())+strzero(nPosC110,nTamFT_IT * 11))		//09 - Posição de Hierarquia   
			EndIf
		EndIf
	Endif
	
	/*Tratamento para adicionar em um array as GNREs de ICMS/ST geradas por documento fiscal para gerar depois
	as respectivas informacoes no registro E250 */
	SpdGnreDoc(@aIcmPago, cAliasSF6, cAliasCDC)
	
	(cAliasCDC)->(DbSkip())
Enddo
Return
/*±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³RegC113   ³ Autor ³Gustavo G. Rueda       ³ Data ³14.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±³          ³               DOCUMENTO FISCAL REFERENCIADO                ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao e gravacao do Registro 0450, C110 e C113          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com as informacoes de todos os docu-   ³±±
±±³          ³ mentos fiscais processados.                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³4(1:N) Para cada Registro C110                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nil                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cAlias   -> Alias da tabela de trabalho da rotina           ³±±
±±³          ³cAliasCDD-> Alias da tabela CDD filtrada (query ou indregua)³±±
±±³          ³aRegC110 -> Array com a estrutura do C110 gerado ateh o     ³±±
±±³          ³            momento.                                        ³±±
±±³          ³aReg0450 -> Array com a estrutura do 0450 gerado ateh o     ³±±
±±³          ³            momento.                                        ³±±
±±³          ³cEntSai -> Flag de indicacao do documento fiscal, 1=Entrada/³±±
±±³          ³ 2=Saida.                                                   ³±±
±±³          ³aCmpAntSFT-> Campos da tabela SFT com informacoes do        ³±±
±±³          ³             documento em processamento                     ³±±
±±³          ³aReg0150  -> Array com as informacoes do participante       ³±±
±±³          ³aRegC113 -> Array com a estrutura do registro a ser gravado ³±±
±±³          ³aWizard  -> Array com as informacoes do wizard da rotina    ³±±
±±³          ³lTop     -> Flag de indicacao de ambiente TOP ou DBF        ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function RegC113(cAlias,cAliasCDD,aRegC110,aReg0450,cEntSai,aCmpAntSFT,aReg0150,aRegC113,aWizard,lTop, cTipoNf)

Local	aInfCompl	:=	{}
Local	aPartDoc	:=	{}
Local	aAreaSF1	:=	SF1->(GetArea ())
Local	aAreaSA1	:=	SA1->(GetArea ())
Local	aAreaSF2	:=	SF2->(GetArea ())
Local	aAreaSA2	:=	SA2->(GetArea ())
Local	cIndEmit 	:=	''
Local	cIndOper 	:=	''
Local	cCodMod  	:=	''
Local  	cCodPArt	:= 	''
Local 	cCDDChv		:= (cAliasCDD)->(CDD_FILIAL+CDD_TPMOV+CDD_DOC+CDD_SERIE+CDD_CLIFOR+CDD_LOJA)
Local	dDtEmiss 	:=	CToD ("//")     
Local	lRet   		:=	.T.
Local	nPos		:=	0
Local	nPosC110	:=	1
Local	aTesCdd		:= {}
Local   cICMSAdj	:= aSPDSX6[MV_ICMSADJ] 

DbSelectArea("SF4")
SF4->(dbSetOrder(1))

// Trecho inserido para trazer a TES do itens para efetuar a mesma verificação do documento referenciado do fonte de Complemento (MATA926), 
//com isso ira verificar todas as possibilidades e gravar o registro C113 corretamente 
If (cAliasCDD)->CDD_TPMOV == "S"
	DbSelectArea("SD2")
	SD2->(DbSetOrder(3))
	SD2->(DbSeek(aSPDFil[PFIL_SD2]+(cAliasCDD)->(CDD_DOC+CDD_SERIE+CDD_CLIFOR+CDD_LOJA)))
	
	While !(Eof()) .And. (cAliasCDD)->(CDD_DOC+CDD_SERIE+CDD_CLIFOR+CDD_LOJA) == SD2->D2_DOC+SD2->D2_SERIE+SD2->D2_CLIENTE+SD2->D2_LOJA

		If SF4->(DbSeek(aSPDFil[PFIL_SF4]+SD2->D2_TES))
			aAdd(aTesCdd, {SD2->D2_TES,SF4->F4_PODER3})
		EndIf 

		SD2->(DbSkip())
	EndDo

ElseIf (cAliasCDD)->CDD_TPMOV == "E"

	DbSelectArea("SD1")
	SD1->(DbSetOrder(1))
	SD1->(DbSeek(aSPDFil[PFIL_SD1]+(cAliasCDD)->(CDD_DOC+CDD_SERIE+CDD_CLIFOR+CDD_LOJA)))
	
	While !(Eof()) .And. (cAliasCDD)->(CDD_DOC+CDD_SERIE+CDD_CLIFOR+CDD_LOJA) == SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA

		If SF4->(DbSeek(aSPDFil[PFIL_SF4]+SD1->D1_TES))
			aAdd(aTesCdd, {SD1->D1_TES,SF4->F4_PODER3})
		EndIf 

		SD1->(DbSkip())
	EndDo

EndIf 


//Esta tabela jah estah filtrada, QUERY ou INDREGUA
While !(cAliasCDD)->(Eof())  .AND. ((cAliasCDD)->(CDD_FILIAL+CDD_TPMOV+CDD_DOC+CDD_SERIE+CDD_CLIFOR+CDD_LOJA)==cCDDChv)
	//Processo o mesmo codigo de OBS da CDT e da CDG	
	If !(cAliasCDD)->(Empty(CDD_IFCOMP))
		Do Case			
			Case aCmpAntSFT[20] $ " DB"									// NORMAL, BENEFICIAMENTO DEVOLUÇÃO
				If cEntSai =='1' 																							//ENTRADA
					If aCmpAntSFT[20] $ 'DB' .Or. (aCmpAntSFT[20] $ ' ' .And. (aScan (aTesCdd, {|X| X[2]== "D" }) > 0) )																				// DEVOLUÇÃO BENEFICIAMENTO
						If !SF2->(MsSeek(aSPDFil[PFIL_SF2]+(cAliasCDD)->(CDD_DOCREF+CDD_SERREF+CDD_PARREF+CDD_LOJREF)))
							lRet := .F.
						Else
							cIndEmit := Iif(SF2->F2_FORMUL=="N","1","0")
							cIndOper := Iif(cIndEmit == "1","0","1")
							cCodMod  := aModNot(SF2->F2_ESPECIE)
							dDtEmiss := SF2->F2_EMISSAO	
							cCodPArt		:= SF2->F2_CLIENTE+SF2->F2_LOJA					
							If cCodMod == '65' 
								/*Caso for devolução de venda de NFCE, então irei considerar o participante do documento de devolução
								pois pode ser diferente do participante do documento de venda para este modelo de documento. */
								cCodPArt		:= aCmpAntSFT[3]+aCmpAntSFT[4]
							EndIF							
							If SF2->F2_TIPO $ 'DB'
								If SA2->(MsSeek (aSPDFil[PFIL_SA2]+ cCodPArt))
									aPartDoc :=	InfPartDoc ("SA2")
										/*GRAVACAO REGISTRO 0150 - TABELA DE CADASTRO DE PARTICIPANTES
										GRAVACAO REGISTRO 0175 - ALTERACAO DA TABELA DE CADASTRO DE PARTICIPANTE*/
									SDPF150175(@aReg0150,aPartDoc,cAlias,aWizard,aExistBloc)
								Else
									lRet := .F.
								EndIf
							Else	
								If SA1->(MsSeek (aSPDFil[PFIL_SA1]+ cCodPArt))
									aPartDoc :=	InfPartDoc ("SA1")
										/*GRAVACAO REGISTRO 0150 - TABELA DE CADASTRO DE PARTICIPANTES
										GRAVACAO REGISTRO 0175 - ALTERACAO DA TABELA DE CADASTRO DE PARTICIPANTE*/
									SDPF150175(@aReg0150,aPartDoc,cAlias,aWizard,aExistBloc)
								Else
									lRet := .F.
								EndIf		
							EndIf	

						Endif
					Else
						IF aSPDSX3[FP_CDD_ENTSAI] .and. (cAliasCDD)->CDD_ENTSAI ='2'
							If !SF2->(MsSeek(aSPDFil[PFIL_SF2]+(cAliasCDD)->(CDD_DOCREF+CDD_SERREF+CDD_PARREF+CDD_LOJREF)))
								lRet := .F.
							Else
								cIndEmit := Iif(SF2->F2_FORMUL<>"N","0","1")
								cIndOper := Iif(cIndEmit == "1","0","1")
								cCodMod  := aModNot(SF2->F2_ESPECIE)
								dDtEmiss := SF2->F2_EMISSAO
								cCodPArt := SF2->F2_CLIENTE+SF2->F2_LOJA

								If cCodMod == '65' 									
									cCodPArt		:= aCmpAntSFT[3]+aCmpAntSFT[4]
								EndIF
								If SF2->F2_TIPO $ 'DB'
									If SA2->(MsSeek (aSPDFil[PFIL_SA2]+ cCodPArt))
										aPartDoc :=	InfPartDoc ("SA2")											
										SDPF150175(@aReg0150,aPartDoc,cAlias,aWizard,aExistBloc)
									Else
										lRet := .F.
									EndIf
								Else	
									If SA1->(MsSeek (aSPDFil[PFIL_SA1]+ cCodPArt))
										aPartDoc :=	InfPartDoc ("SA1")											
										SDPF150175(@aReg0150,aPartDoc,cAlias,aWizard,aExistBloc)
									Else
										lRet := .F.
									EndIf		
								EndIf								
							Endif
						Else
							If !SF1->(MsSeek(aSPDFil[PFIL_SF1]+(cAliasCDD)->(CDD_DOCREF+CDD_SERREF+CDD_PARREF+CDD_LOJREF))) 
								lRet := .F.
							Else
								cIndEmit := Iif(SF1->F1_FORMUL=="S","0","1")
								cIndOper := "0"
								cCodMod  := aModNot(SF1->F1_ESPECIE)
								dDtEmiss := SF1->F1_EMISSAO
								If SF1->F1_TIPO $ 'DB'
									If SA1->(MsSeek (aSPDFil[PFIL_SA1]+(cAliasCDD)->(CDD_CLIFOR)+(cAliasCDD)->(CDD_LOJA)))
										If SF1->F1_FORMUL=="S"
											aPartDoc :=	InfPartDoc ("SM0")
										Else
											aPartDoc :=	InfPartDoc ("SA1")
										Endif										
										SDPF150175(@aReg0150,aPartDoc,cAlias,aWizard,aExistBloc)
									Else
										lRet := .F.
									EndIf
								Else
									If SA2->(MsSeek (aSPDFil[PFIL_SA2]+(cAliasCDD)->(CDD_CLIFOR)+(cAliasCDD)->(CDD_LOJA)))
										If SF1->F1_FORMUL=="S"
											aPartDoc :=	InfPartDoc ("SM0")
										Else
											aPartDoc :=	InfPartDoc ("SA2")
										Endif										
										SDPF150175(@aReg0150,aPartDoc,cAlias,aWizard,aExistBloc)
									Else
										lRet := .F.
									EndIf							
								ENDIf								
							EndIf
						Endif
					EndIf
				ElseIf cEntSai =='2'																						//SAÍDA
					If aCmpAntSFT[20] $ 'DB'  .Or. (aCmpAntSFT[20] $ ' ' .And. (aScan (aTesCdd, {|X| X[2]== "D" }) > 0) )																					// DEVOLUÇÃO BENEFICIAMENTO
						If !SF1->(MsSeek(aSPDFil[PFIL_SF1]+(cAliasCDD)->(CDD_DOCREF+CDD_SERREF+CDD_PARREF+CDD_LOJREF)))

							//Tratativa para complemento de saída quando a nota é de beneficiamento.
							If aCmpAntSFT[20] $ 'D' .And. !SF2->(MsSeek(aSPDFil[PFIL_SF2]+(cAliasCDD)->(CDD_DOCREF+CDD_SERREF+CDD_PARREF+CDD_LOJREF)))
								lRet := .F.
							ElseIf aCmpAntSFT[20] $ 'B' .And. SF2->(MsSeek(aSPDFil[PFIL_SF2]+(cAliasCDD)->(CDD_DOCREF+CDD_SERREF+CDD_PARREF+CDD_LOJREF)))
								cIndEmit := Iif(SF2->F2_FORMUL<>"N","0","1")
								cIndOper := Iif(cIndEmit == "1","0","1")
								cCodMod  := aModNot(SF2->F2_ESPECIE)
								dDtEmiss := SF2->F2_EMISSAO		

								If SA1->(MsSeek(aSPDFil[PFIL_SA1]+SF2->F2_CLIENTE+SF2->F2_LOJA))
									aPartDoc :=	InfPartDoc("SA1")
									/*GRAVACAO REGISTRO 0150 - TABELA DE CADASTRO DE PARTICIPANTES 
									GRAVACAO REGISTRO 0175 - ALTERACAO DA TABELA DE CADASTRO DE PARTICIPANTE */
									SDPF150175(@aReg0150,aPartDoc,cAlias,aWizard,aExistBloc)
								Else
									lRet := .F.
								EndIf	
							Else
								lRet := .F.					
							Endif

						Else
							cIndEmit := Iif(SF1->F1_FORMUL=="S","0","1")
							cIndOper := "0"
							cCodMod  := aModNot(SF1->F1_ESPECIE)
							dDtEmiss := SF1->F1_EMISSAO
							If SF1->F1_TIPO $ 'DB'
								If SA1->(MsSeek (aSPDFil[PFIL_SA1]+(cAliasCDD)->(CDD_CLIFOR)+(cAliasCDD)->(CDD_LOJA)))
									If SF1->F1_FORMUL=="S"
										aPartDoc :=	InfPartDoc ("SM0")
									Else
										aPartDoc :=	InfPartDoc ("SA1")
									Endif
									/*GRAVACAO REGISTRO 0150 - TABELA DE CADASTRO DE PARTICIPANTES
									GRAVACAO REGISTRO 0175 - ALTERACAO DA TABELA DE CADASTRO DE PARTICIPANTE */								
									SDPF150175(@aReg0150,aPartDoc,cAlias,aWizard,aExistBloc)
								Else
									lRet := .F.
								EndIf
							Else
								If SA2->(MsSeek (aSPDFil[PFIL_SA2]+(cAliasCDD)->(CDD_CLIFOR)+(cAliasCDD)->(CDD_LOJA)))
									If SF1->F1_FORMUL=="S"
										aPartDoc :=	InfPartDoc ("SM0")
									Else
										aPartDoc :=	InfPartDoc ("SA2")
									Endif
									/*GRAVACAO REGISTRO 0150 - TABELA DE CADASTRO DE PARTICIPANTES
									GRAVACAO REGISTRO 0175 - ALTERACAO DA TABELA DE CADASTRO DE PARTICIPANTE */								
									SDPF150175(@aReg0150,aPartDoc,cAlias,aWizard,aExistBloc)
								Else
									lRet := .F.
								EndIf							
							ENDIf

						EndIf
					Else																									//NORMAL	
						IF aSPDSX3[FP_CDD_ENTSAI] .and. (cAliasCDD)->CDD_ENTSAI ='1'
							If !SF1->(MsSeek(aSPDFil[PFIL_SF1]+(cAliasCDD)->(CDD_DOCREF+CDD_SERREF+CDD_PARREF+CDD_LOJREF)))
								lRet := .F.
							Else
								cIndEmit := Iif(SF1->F1_FORMUL=="S","0","1")
								cIndOper := "0"
								cCodMod  := aModNot(SF1->F1_ESPECIE)
								dDtEmiss := SF1->F1_EMISSAO
								If SF1->F1_TIPO $ 'DB'
									If SA1->(MsSeek (aSPDFil[PFIL_SA1]+(cAliasCDD)->(CDD_PARREF)+(cAliasCDD)->(CDD_LOJREF)))
										If SF1->F1_FORMUL=="S"
											aPartDoc :=	InfPartDoc ("SM0")
										Else
											aPartDoc :=	InfPartDoc ("SA1")
										Endif										
										SDPF150175(@aReg0150,aPartDoc,cAlias,aWizard,aExistBloc)
									Else
										lRet := .F.
									EndIf
								Else
									If SA2->(MsSeek (aSPDFil[PFIL_SA2]+(cAliasCDD)->(CDD_PARREF)+(cAliasCDD)->(CDD_LOJREF)))
										If SF1->F1_FORMUL=="S"
											aPartDoc :=	InfPartDoc ("SM0")
										Else
											aPartDoc :=	InfPartDoc ("SA2")
										Endif										
										SDPF150175(@aReg0150,aPartDoc,cAlias,aWizard,aExistBloc)
									Else
										lRet := .F.
									EndIf							
								ENDIf									
							EndIf
						Else
							If !SF2->(MsSeek(aSPDFil[PFIL_SF2]+(cAliasCDD)->(CDD_DOCREF+CDD_SERREF+CDD_PARREF+CDD_LOJREF)))
								lRet := .F.
							Else
								cIndEmit := Iif(SF2->F2_FORMUL<>"N","0","1")
								cIndOper := Iif(cIndEmit == "1","0","1")
								cCodMod  := aModNot(SF2->F2_ESPECIE)
								dDtEmiss := SF2->F2_EMISSAO		
								cCodPArt := SF2->F2_CLIENTE+SF2->F2_LOJA

								If cCodMod == '65' 									
									cCodPArt		:= aCmpAntSFT[3]+aCmpAntSFT[4]
								EndIF
								If SF2->F2_TIPO $ 'DB'
									If SA2->(MsSeek (aSPDFil[PFIL_SA2]+ cCodPArt))
										aPartDoc :=	InfPartDoc ("SA2")											
										SDPF150175(@aReg0150,aPartDoc,cAlias,aWizard,aExistBloc)
									Else
										lRet := .F.
									EndIf
								Else	
									If SA1->(MsSeek (aSPDFil[PFIL_SA1]+ cCodPArt))
										aPartDoc :=	InfPartDoc ("SA1")											
										SDPF150175(@aReg0150,aPartDoc,cAlias,aWizard,aExistBloc)
									Else
										lRet := .F.
									EndIf		
								EndIf							
							Endif
						Endif
					EndIf
				EndIf
			Case aCmpAntSFT[20] $('IPC')
			 																						//COMPLEMENTO
				If cEntSai =='1' 																							//ENTRADA
						If !SF1->(MsSeek(aSPDFil[PFIL_SF1]+(cAliasCDD)->(CDD_DOCREF+CDD_SERREF+CDD_PARREF+CDD_LOJREF)))
							lRet := .F.
						Else
							cIndEmit := Iif(SF1->F1_FORMUL=="S","0","1")
							cIndOper := "0"
							cCodMod  := aModNot(SF1->F1_ESPECIE)
							dDtEmiss := SF1->F1_EMISSAO
							/* Tratamento para ICMS ADJUDICADO*/
							If !Empty(cICMSAdj) .And. Alltrim(aCmpAntSFT[9])$cICMSAdj .And. SA2->(MsSeek (aSPDFil[PFIL_SA2]+(cAliasCDD)->(CDD_PARREF)+(cAliasCDD)->(CDD_LOJREF))) //Para o ICMS Adjudicado é preciso pegar o CDD_PARREF(nota que está sendo referencida)
								aPartDoc :=	InfPartDoc("SA2")
								SDPF150175(@aReg0150,aPartDoc,cAlias,aWizard,aExistBloc)
							ElseIf SA2->(MsSeek (aSPDFil[PFIL_SA2]+(cAliasCDD)->(CDD_CLIFOR)+(cAliasCDD)->(CDD_LOJA)))
								If SF1->F1_FORMUL=="S"
									aPartDoc :=	InfPartDoc("SM0")
								Else
									aPartDoc :=	InfPartDoc("SA2")
								Endif
								/*GRAVACAO REGISTRO 0150 - TABELA DE CADASTRO DE PARTICIPANTES
								GRAVACAO REGISTRO 0175 - ALTERACAO DA TABELA DE CADASTRO DE PARTICIPANTE */								
								SDPF150175(@aReg0150,aPartDoc,cAlias,aWizard,aExistBloc)
							Else
								lRet := .F.
							EndIf
						EndIf
				ElseIf cEntSai =='2' 																						//SAÍDA
					If !SF2->(MsSeek(aSPDFil[PFIL_SF2]+(cAliasCDD)->(CDD_DOCREF+CDD_SERREF+CDD_PARREF+CDD_LOJREF)))
						lRet := .F.
					Else
						cIndEmit := Iif(SF2->F2_FORMUL=="N","1","0")
						cIndOper := Iif(cIndEmit == "1","0","1")
						cCodMod  := aModNot(SF2->F2_ESPECIE)
						dDtEmiss := SF2->F2_EMISSAO		
						//Armazeno código participante documento original
						cCodPArt		:= SF2->F2_CLIENTE+SF2->F2_LOJA					
						If SA1->(MsSeek (aSPDFil[PFIL_SA1]+ cCodPArt))
							aPartDoc :=	InfPartDoc ("SA1")
							/*GRAVACAO REGISTRO 0150 - TABELA DE CADASTRO DE PARTICIPANTES
							GRAVACAO REGISTRO 0175 - ALTERACAO DA TABELA DE CADASTRO DE PARTICIPANTE*/
							SDPF150175(@aReg0150,aPartDoc,cAlias,aWizard,aExistBloc)
						Else
							lRet := .F.
						EndIf			
					Endif
				EndIf			
		EndCase
		// Nao preciso verificar a existencia antes de incluir, pois a chave unica da tabela ja nao permite repetir o cadastro		
		If lRet
			
			//Tratamento para evitar duplicidade no registro C110
			
			If (nPosC110 := aScan(aRegC110,{|aX|aX[2]==(cAliasCDD)->CDD_IFCOMP}))==0
				
				//DBF/ADS nao tem JOIN, preciso fazer o SEEK, e a funcao Reg0450
				//faz automaticamente quando a descricao estah com NIL
				
				aInfCompl	:=	{(cAliasCDD)->CDD_IFCOMP,}
				
				//REGISTRO C110 - INFORMACAO COMPLEMENTAR DA NOTA FISCAL (CODIGO 01, 04 E 55)
				//Funca que gera a estrutura dos registros acima e os grava no final do processamento do
				// documento fiscal
				
				RegC110(@aInfCompl,@aRegC110,@nPosC110,,,,,aCmpAntSFT)				
				
				//REGISTRO 0450 - TABELA DE INFORMACAO COMPLEMENTAR/OBSERVACAO
				//Atribui os valores do array aReg0450 para efetuar a gravacao no final do processamento
				// da rotina.

				Reg0450(aInfCompl,@aReg0450)
			EndIf
			aAdd(aRegC113, {})
			nPos	:=	Len (aRegC113)
			aAdd (aRegC113[nPos], nPosC110)															//Relacionamento com o registro pai
			aAdd (aRegC113[nPos], "C113")	 	   													//01 - REG
			aAdd (aRegC113[nPos], cIndOper)															//02 - IND_OPER	
			aAdd (aRegC113[nPos], cIndEmit)	 				   										//03 - IND_EMIT
			aAdd (aRegC113[nPos], Iif(Len(aPartDoc)>=1,aPartDoc[1],""))								//04 - COD_PART
			aAdd (aRegC113[nPos], cCodMod)		 													//05 - COD_MOD
			aAdd (aRegC113[nPos], (cAliasCDD)->CDD_SERREF)	 										//06 - SER
			aAdd (aRegC113[nPos], "")				 												//07 - SUB
			aAdd (aRegC113[nPos], (cAliasCDD)->CDD_DOCREF) 											//08 - NUM_DOC
			aAdd (aRegC113[nPos], dDtEmiss)	 			   											//09 - DT_DOC 
			IF cVersao >= "011"				
				aAdd (aRegC113[nPos], Iif(aSPDSX3[FP_CDD_CHVNFE],(cAliasCDD)->CDD_CHVNFE,'')) 		//10 - CHV_DOCe
			Endif

			//aAdd (aRegC113[nPos], GetRelacPr()+"C110"+strzero(nPosC110,nTTRBITEM)+"C113"+strzero(nPos,nTTRBITEM))		//11 - Posição de Hierarquia   
			aAdd (aRegC113[nPos], RetRD(GetRelacPr())+strzero(nPosC110,nTamFT_IT * 11))		//11 - Posição de Hierarquia   

		EndIf
    EndIf
	(cAliasCDD)->(dbSkip())
End
RestArea(aAreaSF1)
RestArea(aAreaSF2)
RestArea(aAreaSA1)
RestArea(aAreaSA2)

Return(lRet)
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³RegC114   ³ Autor ³Gustavo G. Rueda       ³ Data ³14.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±³          ³                CUPOM FISCAL REFERENCIADO                   ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao e gravacao do Registro 0450, C110 e C114          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com as informacoes de todos os docu-   ³±±
±±³          ³ mentos fiscais processados.                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³4(1:N) Para cada Registro C110                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nil                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cAliasCDE-> Alias da tabela CDE filtrada (query ou indregua)³±±
±±³          ³aRegC110 -> Array com a estrutura do C110 gerado ateh o     ³±±
±±³          ³            momento.                                        ³±±
±±³          ³aReg0450 -> Array com a estrutura do 0450 gerado ateh o     ³±±
±±³          ³            momento.                                        ³±±
±±³          ³aCmpAntSFT-> Campos da tabela SFT com informacoes do        ³±±
±±³          ³             documento em processamento                     ³±±
±±³          ³aRegC114 -> Array com a estrutura do registro a ser gravado ³±±
±±³          ³lSemCDE  -> Quando nao tiver CDE (.T.), deve processar uma  ³±±
±±³          ³            unica vez e fazer o mesmo fluxo como se tivesse,³±± 
±±³          ³            pois eh um tratamento para quando houver        ³±±
±±³          ³            integracao com o SIGALOJA, com isso nao exigimos³±± 
±±³          ³            uma amarracao via complemento, uso a integracao ³±±
±±³          ³            direto                                          ³±±
±±³          ³cNFCupom -> Conteudo do campo F2_NFCUPOM                    ³±±
±±³          ³lTop     -> Flag de indicacao de ambiente TOP ou DBF        ³±±  
±±³          ³cEntSai -> Flag de indicacao do documento fiscal, 1=Entrada/³±±
±±³          ³2=Saida.  												  ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function RegC114(cAliasCDE,aRegC110,aReg0450,aCmpAntSFT,aRegC114,cCodCompl,cNFCupom,lTop,cEntSai)

Local	aInfCompl	:=	{}
Local	aAreaSF2	:=	SF2->(GetArea())
Local	cSerCp		:=	""
Local	cCupom		:=	""
Local	cEspecCp	:=	""
Local	dDtCupom	:=	""
Local   cECFFAB     := 	""
Local   cECFCX		:= 	""
Local   cCPREF		:= 	""
Local   cPdv        := 	""
Local	cDescCompl	:=	Nil    
Local	lRet   		:=	.T.
Local 	cCDEChv		:= (cAliasCDE)->(CDE_FILIAL+CDE_TPMOV+CDE_DOC+CDE_SERIE+CDE_CLIFOR+CDE_LOJA)
Local	lProcUma	:=	Iif(cCodCompl==Nil,.F.,Iif(Empty(cCodCompl),.F.,.T.))	//Irah processar quando houver CDE ou quando houver pelo menos 1 codigo (cCodCompl<>"")
Local	nPos		:=	0
Local	nPosC110	:=	1

Default	cCodCompl	:=	""
Default	cNFCupom	:=	""

cSerCp				:=	Padr(SubStr(cNFCupom,1,TamSx3("F2_SERIE")[1]),TamSx3("F2_SERIE")[1])
cCupom				:=	Padr(SubStr(cNFCupom,TamSx3("F2_SERIE")[1]+1,TamSx3("F2_DOC")[1]+TamSx3("F2_SERIE")[1]),TamSx3("F2_DOC")[1])

//Esta tabela jah estah filtrada, QUERY ou INDREGUA
While ( !(cAliasCDE)->(Eof()) .AND. ((cAliasCDE)->(CDE_FILIAL+CDE_TPMOV+CDE_DOC+CDE_SERIE+CDE_CLIFOR+CDE_LOJA)==cCDEChv)   ) .Or. lProcUma

	cCodCompl	:=	Iif(!lProcUma,(cAliasCDE)->CDE_IFCOMP,cCodCompl)    

	//Processo o mesmo codigo de OBS da CDT e da CDG
	If !Empty(cCodCompl)
		
		//Posiciona no cupom de origem
		If cEntSai == "1" .And. aCmpAntSFT[20]$"DB"		
			cCupom	:=	aCmpAntSFT[38]
			cSerCp	:=	aCmpAntSFT[39]        
		/*Tratamento para quando nao tiver SIGALOJA, ae o complemento éfeito manualemten no documento. 
		Se tiver SIGALOJA, o campo NFCUPOM vai estar preenchido */
        ElseIf Empty(cNFCupom)
			cCupom	:=	(cAliasCDE)->CDE_CPREF
			cSerCp	:=	(cAliasCDE)->CDE_SERREF										
        EndIF
		cCPREF		:= cCupom
		If !SF2->(MsSeek(aSPDFil[PFIL_SF2]+cCupom+cSerCp))
			lRet 		:= 	.F.
		Else
			//FT_PDV somente estarah alimentado quando se referir a nota fiscais de saida geradas pelo SIGALOJA.
           If !Empty(SF2->F2_PDV) .AND. AllTrim(SF2->F2_ESPECIE)$"CF|ECF"           
              cEspecCp	:=	"2D"
           Else          
              cEspecCp 	:= 	aModNot(SF2->F2_ESPECIE)
           Endif
              dDtCupom 	:= 	SF2->F2_EMISSAO
              cPdv 		:= 	SF2->F2_PDV
		Endif

        If lRet .And. cEspecCp <> "59"
			/*Se tiver PDV relacionado ao documento fiscal e o mesmo existir na tabela SFI,
			utilizo os dados da mesma, caso contrario, utilizo os dados do complemento */
		    If !Empty(cPdv) .And. SFI->(MsSeek(aSPDFil[PFIL_SFI]+Iif(SFI->(IndexOrd())==1,Dtos(dDtCupom)+cPdv,cPdv+Dtos(dDtCupom))))
		    	
		    	cECFFAB     := SFI->FI_SERPDV
				cECFCX		:= SFI->FI_PDV
			Else 
				cECFFAB     := (cAliasCDE)->CDE_ECFFAB
				cECFCX		:= (cAliasCDE)->CDE_ECFCX
			EndIf
			//Tratamento para evitar duplicidade no registro C110
			If (nPosC110 := aScan(aRegC110,{|aX|aX[2]==cCodCompl}))==0
				aInfCompl	:=	{cCodCompl,cDescCompl}
				/* REGISTRO C110 - INFORMACAO COMPLEMENTAR DA NOTA FISCAL (CODIGO 01, 04 E 55) 
				Funcao que gera a estrutura dos registros acima e os grava no final do processamento do documento fiscal */
				RegC110(@aInfCompl,@aRegC110,@nPosC110,,,,,aCmpAntSFT)		
				
				/*REGISTRO 0450 - TABELA DE INFORMACAO COMPLEMENTAR/OBSERVACAO 
				 Atribui os valores do array aReg0450 para efetuar a gravacao no final do processamento da rotina.*/
				Reg0450(aInfCompl,@aReg0450)
			EndIf	
			//verifica se jah nao foi adicionado antes
			If (nPos := aScan(aRegC114,{|aX| aX[1]==nPosC110 .And. aX[3]==cEspecCp .And. aX[4]==cECFFAB .And. aX[5]==Right(AllTrim(cECFCX),3) .And. aX[6]==cCPREF .And. aX[7]==dDtCupom}))==0	
				aAdd(aRegC114, {})
				nPos	:=	Len(aRegC114)
				aAdd (aRegC114[nPos], nPosC110)							//Relacionamento com o registro pai
				aAdd (aRegC114[nPos], "C114")	 	   					//01 - REG
				aAdd (aRegC114[nPos], cEspecCp)							//02 - COD_MOD
				aAdd (aRegC114[nPos], cECFFAB)							//03 - ECF_FAB
				aAdd (aRegC114[nPos], Right(AllTrim(cECFCX),3))			//04 - ECF_CX
				aAdd (aRegC114[nPos], cCPREF)			 				//05 - NUM_DOC
				aAdd (aRegC114[nPos], dDtCupom)	 						//06 - DT_DOC

				//aAdd (aRegC114[nPos], GetRelacPr()+"C110"+strzero(nPosC110,nTTRBITEM)+"C114"+strzero(nPos,nTTRBITEM))		//07 - Posição de Hierarquia   
				aAdd (aRegC114[nPos], RetRD(GetRelacPr())+strzero(nPosC110,nTamFT_IT * 11))		//07 - Posição de Hierarquia   

			EndIf
		EndIf
    EndIf
	/* Quando for para processar somente uma vez, deve fazer o mesmo fluxo como se tivesse, pois eh um tratamento para quando houver integracao com o 
	  SIGALOJA, com isso nao exigimos uma amarracao via complemento, uso a integracao direto */
    If lProcUma
    	Exit
    EndIf
    (cAliasCDE)->(dbSkip())
End
RestArea(aAreaSF2)
Return
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³RegC115   ³ Autor ³Gustavo G. Rueda       ³ Data ³14.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±³          ³               LOCAL DE COLETA/ENTREGA                      ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao e gravacao do Registro 0450, C110 e C115          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com as informacoes de todos os docu-   ³±±
±±³          ³ mentos fiscais processados.                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³4(1:N) Para cada Registro C110                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nil                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cAliasCDF-> Alias da tabela CDE filtrada (query ou indregua)³±±
±±³          ³aRegC110 -> Array com a estrutura do C110 gerado ateh o     ³±±
±±³          ³            momento.                                        ³±±
±±³          ³aReg0450 -> Array com a estrutura do 0450 gerado ateh o     ³±±
±±³          ³            momento.                                        ³±±
±±³          ³aCmpAntSFT-> Campos da tabela SFT com informacoes do        ³±±
±±³          ³             documento em processamento                     ³±±
±±³          ³aRegC115 -> Array com a estrutura do registro a ser gravado ³±±
±±³          ³lTop     -> Flag de indicacao de ambiente TOP ou DBF        ³±±  
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function RegC115(cAliasCDF,aRegC110,aReg0450,aCmpAntSFT,aRegC115,lTop)

Local	aInfCompl	:=	{}
Local	aAreaSA1	:=	SA1->(GetArea())
Local	aAreaSA2	:=	SA2->(GetArea())
Local	cCnpjCol	:=	""
Local	cIeCol		:=	""
Local	cCpfCol		:=	""
Local	cMunCol		:=	""
Local	cCnpjEnt	:=	""
Local	cIeEnt		:=	""
Local	cCpfEnt		:=	""
Local	cMunEnt		:=	""
Local	cChaveCol	:=	""
Local	cChaveEnt	:=	""
Local 	cCDFChv		:= (cAliasCDF)->(CDF_FILIAL+CDF_TPMOV+CDF_DOC+CDF_SERIE+CDF_CLIFOR+CDF_LOJA)
Local	nPos		:=	0
Local	nPosC110	:=	1
                                                                    
//Esta tabela jah estah filtrada, QUERY ou INDREGUA
While !(cAliasCDF)->(Eof())   .AND. ( (cAliasCDF)->(CDF_FILIAL+CDF_TPMOV+CDF_DOC+CDF_SERIE+CDF_CLIFOR+CDF_LOJA)==cCDFChv)
	//Processo o mesmo codigo de OBS da CDT e da CDG
	If !(cAliasCDF)->(Empty(CDF_IFCOMP))

		//Dados da   coleta
		cChaveCol	:=	(cAliasCDF)->(CDF_COLETA+CDF_LOJCOL)
		cChaveCol	:=	Iif(Empty(cChaveCol),aCmpAntSFT[3]+aCmpAntSFT[4],cChaveCol)
		//Dados da entrega
		cChaveEnt	:=	(cAliasCDF)->(CDF_ENTREG+CDF_LOJENT)
		cChaveEnt	:=	Iif(Empty(cChaveEnt),aCmpAntSFT[3]+aCmpAntSFT[4],cChaveEnt)

		If aCmpAntSFT[20]$"DB"
			If SA2->(MsSeek(aSPDFil[PFIL_SA2]+cChaveCol)) .AND. !Empty((cAliasCDF)->(CDF_COLETA))
				If Len (AllTrim(SA2->A2_CGC))>=14
					cCnpjCol	:=	SA2->A2_CGC
				Else
					cCpfCol		:=	SA2->A2_CGC
				EndIf
				cIeCol			:=	SPEDConType(SPEDVldIE(SA2->A2_INSCR))
				cMunCol			:=	Iif(Upper(SA2->A2_EST)=="EX","9999999",IIF(Len(SA2->A2_COD_MUN)<=5,UfCodIBGE(SA2->A2_EST),"")+SA2->A2_COD_MUN)
			EndIf

			If SA2->(MsSeek(aSPDFil[PFIL_SA2]+cChaveEnt))
				If Len (AllTrim (SA2->A2_CGC))>=14
					cCnpjEnt	:=	SA2->A2_CGC
				Else
					cCpfEnt		:=	SA2->A2_CGC
				EndIf
				cIeEnt			:=	SPEDConType(SPEDVldIE(SA2->A2_INSCR))
				cMunEnt			:=	Iif(Upper(SA2->A2_EST) == "EX","9999999",IIF(Len(SA2->A2_COD_MUN)<=5,UfCodIBGE(SA2->A2_EST),"")+SA2->A2_COD_MUN)
			EndIf

		Else
			If SA1->(MsSeek(aSPDFil[PFIL_SA1]+cChaveCol)) .AND. !Empty((cAliasCDF)->(CDF_COLETA))
				If Len (AllTrim (SA1->A1_CGC))>=14
					cCnpjCol	:=	SA1->A1_CGC
				Else
					cCpfCol		:=	SA1->A1_CGC
				EndIf
				cIeCol			:=	SPEDConType(SPEDVldIE(SA1->A1_INSCR))
				cMunCol			:=	Iif(Upper(SA1->A1_EST)=="EX","9999999",IIF(Len(SA1->A1_COD_MUN)<=5,UfCodIBGE(SA1->A1_EST),"")+SA1->A1_COD_MUN)
			EndIf
			//
			If SA1->(MsSeek(aSPDFil[PFIL_SA1]+cChaveEnt))
				If Len (AllTrim (SA1->A1_CGC))>=14
					cCnpjEnt	:=	SA1->A1_CGC
				Else
					cCpfEnt		:=	SA1->A1_CGC
				EndIf
				cIeEnt			:=	SPEDConType(SPEDVldIE(SA1->A1_INSCR))
				cMunEnt			:=	Iif(Upper(SA1->A1_EST) == "EX","9999999",IIF(Len(SA1->A1_COD_MUN)<=5,UfCodIBGE(SA1->A1_EST),"")+SA1->A1_COD_MUN)
			EndIf
		EndIf
		//Tratamento para evitar duplicidade no registro C110
		If (nPosC110 := aScan(aRegC110,{|aX|aX[2]==(cAliasCDF)->CDF_IFCOMP}))==0
			
			/* DBF/ADS nao tem JOIN, preciso fazer o SEEK, e a funcao Reg0450 faz automaticamente quando a descricao estah com NIL  */
			aInfCompl	:=	{(cAliasCDF)->CDF_IFCOMP,}
			
			/* REGISTRO C110 - INFORMACAO COMPLEMENTAR DA NOTA FISCAL (CODIGO 01, 04 E 55) 
			 Funcao que gera a estrutura dos registros acima e os grava no final do processamento do  documento fiscal */
			RegC110(@aInfCompl,@aRegC110,@nPosC110,,,,,aCmpAntSFT)	
			
			/*REGISTRO 0450 - TABELA DE INFORMACAO COMPLEMENTAR/OBSERVACAO
			 Atribui os valores do array aReg0450 para efetuar a gravacao no final do processamento da rotina. */
			Reg0450(aInfCompl,@aReg0450)
		EndIf	
		
		// Nao preciso verificar a existencia antes de incluir, pois a chave unica da tabela ja nao permite repetir o cadastro 
		
		aAdd(aRegC115, {})
		nPos	:=	Len (aRegC115)
		aAdd (aRegC115[nPos], nPosC110)			            	//Relacionamento com o registro pai
		aAdd (aRegC115[nPos], "C115")	 	   					//01 - REG
		aAdd (aRegC115[nPos], (cAliasCDF)->CDF_TPTRAN)			//02 - IND_CARGA
		aAdd (aRegC115[nPos], cCnpjCol)		   					//03 - CNPJ_COL
		aAdd (aRegC115[nPos], cIeCol)			 				//04 - IE_COL
		aAdd (aRegC115[nPos], cCpfCol)							//05 - CPF_COL
		aAdd (aRegC115[nPos], cMunCol)			 				//06 - COD_MUN_COL
		aAdd (aRegC115[nPos], cCnpjEnt)	 			   			//07 - CNPJ_ENTG
		aAdd (aRegC115[nPos], cIeEnt)			 				//08 - IE_ENTG
		aAdd (aRegC115[nPos], cCpfEnt)	 						//09 - CPF_ENTG
		aAdd (aRegC115[nPos], cMunEnt)	 						//10 - COD_MUN_ENTG

		//aAdd (aRegC115[nPos], GetRelacPr()+"C110"+strzero(nPosC110,nTTRBITEM)+"C115"+strzero(nPos,nTTRBITEM))		//11 - Posição de Hierarquia   
		aAdd (aRegC115[nPos], RetRD(GetRelacPr())+strzero(nPosC110,nTamFT_IT * 11))		//11 - Posição de Hierarquia   
    EndIf           
    
    (cAliasCDF)->(dbSkip())
End

RestArea(aAreaSA1)
RestArea(aAreaSA2)
Return
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³RegC116   ³ Autor ³Gustavo G. Rueda       ³ Data ³14.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±³          ³      CUPOM FISCAL ELETRÔNICO REFERENCIADO                  ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao e gravacao do Registro 0450, C110 e C116          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com as informacoes de todos os docu-   ³±±
±±³          ³ mentos fiscais processados.                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³4(1:N) Para cada Registro C110                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nil                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cAliasCDE-> Alias da tabela CDE filtrada (query ou indregua)³±±
±±³          ³aRegC110 -> Array com a estrutura do C110 gerado ateh o     ³±±
±±³          ³            momento.                                        ³±±
±±³          ³aReg0450 -> Array com a estrutura do 0450 gerado ateh o     ³±±
±±³          ³            momento.                                        ³±±
±±³          ³aCmpAntSFT-> Campos da tabela SFT com informacoes do        ³±±
±±³          ³             documento em processamento                     ³±±
±±³          ³aRegC114 -> Array com a estrutura do registro a ser gravado ³±±
±±³          ³lSemCDE  -> Quando nao tiver CDE (.T.), deve processar uma  ³±±
±±³          ³            unica vez e fazer o mesmo fluxo como se tivesse,³±± 
±±³          ³            pois eh um tratamento para quando houver        ³±±
±±³          ³            integracao com o SIGALOJA, com isso nao exigimos³±± 
±±³          ³            uma amarracao via complemento, uso a integracao ³±±
±±³          ³            direto                                          ³±±
±±³          ³cNFCupom -> Conteudo do campo F2_NFCUPOM                    ³±±
±±³          ³lTop     -> Flag de indicacao de ambiente TOP ou DBF        ³±±  
±±³          ³cEntSai -> Flag de indicacao do documento fiscal, 1=Entrada/³±±
±±³          ³2=Saida.  												  ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function RegC116(cAliasCDE,aRegC110,aReg0450,aCmpAntSFT,aRegC116,cCodCompl,cNFCupom,lTop,cEntSai)

Local	aInfCompl	:=	{}
Local	aAreaSF2	:=	SF2->(GetArea())
Local	cSerCp		:=	""
Local	cCupom		:=	""
Local	cEspecCp	:=	""
Local	dDtCupom	:=	""
Local   cECFFAB     := 	""
Local   cECFCX		:= 	""
Local   cCPREF		:= 	""
Local   cPdv        := 	""
Local 	cCDEChv		:= (cAliasCDE)->(CDE_FILIAL+CDE_TPMOV+CDE_DOC+CDE_SERIE+CDE_CLIFOR+CDE_LOJA)
Local	cDescCompl	:=	Nil 
Local	lRet   		:=	.T.
Local	lProcUma	:=	Iif(cCodCompl==Nil,.F.,Iif(Empty(cCodCompl),.F.,.T.))	//Irah processar quando houver CDE ou quando houver pelo menos 1 codigo (cCodCompl<>"")
Local	nPos		:=	0
Local	nPosC110	:=	1
Default	cCodCompl	:=	""
Default	cNFCupom	:=	""


cSerCp		:=	Padr(SubStr(cNFCupom,1,TamSx3("F2_SERIE")[1]),TamSx3("F2_SERIE")[1])
cCupom		:=	Padr(SubStr(cNFCupom,TamSx3("F2_SERIE")[1]+1,TamSx3("F2_DOC")[1]+TamSx3("F2_SERIE")[1]),TamSx3("F2_DOC")[1])

While ( !(cAliasCDE)->(Eof()) .AND. ((cAliasCDE)->(CDE_FILIAL+CDE_TPMOV+CDE_DOC+CDE_SERIE+CDE_CLIFOR+CDE_LOJA)==cCDEChv)   ) .Or. lProcUma
	cCodCompl	:=	Iif(!lProcUma,(cAliasCDE)->CDE_IFCOMP,cCodCompl)    
	
	//Processo o mesmo codigo de OBS da CDT e da CDG
	If !Empty(cCodCompl)

	cCupom	:=	(cAliasCDE)->CDE_CPREF
			cSerCp	:=	(cAliasCDE)->CDE_SERREF 		
		/* Tratamento para quando nao tiver SIGALOJA, ae o complemento e feito manualemten no documento. 
		  Se tiver SIGALOJA, o campo NFCUPOM vai estar preenchido  */
		If Empty(cNFCupom) //deveria entrar quando fosse saida
			cCupom	:=	(cAliasCDE)->CDE_CPREF
			cSerCp	:=	(cAliasCDE)->CDE_SERREF
	    EndIF
		
		cCPREF		:= cCupom

		If !SF2->(MsSeek(aSPDFil[PFIL_SF2]+cCupom+cSerCp))
			lRet 		:= 	.F.
		Else
		    //FT_PDV somente estarah alimentado quando se referir a nota fiscais de saida geradas pelo SIGALOJA.
           If !Empty(SF2->F2_PDV) .AND. AllTrim(SF2->F2_ESPECIE)$"SATCE"
              cEspecCp	:=	"59"
           Else          
              cEspecCp 	:= 	aModNot(SF2->F2_ESPECIE)
           Endif
              dDtCupom 	:= 	SF2->F2_EMISSAO
              cPdv 		:= 	SF2->F2_PDV
		Endif
		
        If lRet .And. cEspecCp == "59"
			/* Se tiver PDV relacionado ao documento fiscal e o mesmo existir na tabela SFI, utilizo os dados da mesma, caso contrario, utilizo os dados do complemento */
		    If !Empty(cPdv) .And. SFI->(MsSeek(aSPDFil[PFIL_SFI]+Iif(SFI->(IndexOrd())==1,Dtos(dDtCupom)+cPdv,cPdv+Dtos(dDtCupom))))
		    	cECFFAB     := SFI->FI_SERPDV
				cECFCX		:= SFI->FI_PDV
			Else 
				cECFFAB     := (cAliasCDE)->CDE_ECFFAB
				cECFCX		:= (cAliasCDE)->CDE_ECFCX
			EndIf
			
			//Tratamento para evitar duplicidade no registro C110
			If (nPosC110 := aScan(aRegC110,{|aX|aX[2]==cCodCompl}))==0
				aInfCompl	:=	{cCodCompl,cDescCompl}
				
				/*REGISTRO C110 - INFORMACAO COMPLEMENTAR DA NOTA FISCAL (CODIGO 01, 04 E 55) 
				Funcao que gera a estrutura dos registros acima e os grava no final do processamento do documento fiscal   */ 
				RegC110(@aInfCompl,@aRegC110,@nPosC110,,,,,aCmpAntSFT)	
				
				/*REGISTRO 0450 - TABELA DE INFORMACAO COMPLEMENTAR/OBSERVACAO 
				 Atribui os valores do array aReg0450 para efetuar a gravacao no final do processamento  da rotina. */
				Reg0450(aInfCompl,@aReg0450)
			EndIf	
			//verifica se jah nao foi adicionado antes
			nPos := Ascan(aRegC116, {|x| x[4]==SF2->F2_SERSAT .And. x[6]==(cAliasCDE)->CDE_CPREF .And. x[7]==SF2->F2_EMISSAO})
			If nPos == 0
				aAdd(aRegC116, {})
				nPos	:=	Len(aRegC116)				
				aAdd (aRegC116[nPos], nPosC110)					//Relacionamento com o registro pai
				aAdd (aRegC116[nPos], "C116")	 	   			//01 - REG
				aAdd (aRegC116[nPos], "59")						//02 - COD_MOD
				aAdd (aRegC116[nPos], SF2->F2_SERSAT)			//03 - NR_SAT
				aAdd (aRegC116[nPos], SF2->F2_CHVNFE)			//04 - CHV_CFE
				aAdd (aRegC116[nPos], (cAliasCDE)->CDE_CPREF)	//05 - NUM_CFE
				aAdd (aRegC116[nPos], SF2->F2_EMISSAO)			//06 - DT_DOC 
				
				//aAdd (aRegC116[nPos], GetRelacPr()+"C110"+strzero(nPosC110,nTTRBITEM)+"C116"+strzero(nPos,nTTRBITEM))		//07 - Posição de Hierarquia   
				aAdd (aRegC116[nPos], RetRD(GetRelacPr())+strzero(nPosC110,nTamFT_IT * 11))		//07 - Posição de Hierarquia   
			EndIf
		EndIf
    EndIf
    If lProcUma
    	Exit
    EndIf	
    (cAliasCDE)->(dbSkip())	
End

RestArea(aAreaSF2)
Return
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³RegC120   ³ Autor ³Gustavo G. Rueda       ³ Data ³15.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±³          ³  DECLARACAO/BASE DE CALCULO DE IMPORTACAO (MODELO 01 e 04) ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao e gravacao do Registro C120                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com as informacoes de D.I. dos documen-³±±
±±³          ³ tos fiscais processados.                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³3(1:1) Para cada Registro C100                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nil                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cAlias    -> Alias do TRB que recebera as informacoes       ³±±
±±³          ³nRelac    -> Flag de relacionamento com os sub-registros    ³±±
±±³          ³cAliasCD5 -> Alias jah filtrado da tabela CD5, Indregua ou  ³±±
±±³          ³             query                                          ³±±
±±³          ³lSigaEIC  -> Flag de tratamento via SIGAEIC                 ³±±
±±³          ³aAvImport -> Informacoes de importacao vindas do SIGAEIC    ³±±
±±³          ³             para o documento fiscal em processamento       ³±±
±±³          ³lAchouCD5 -> Flag de seek da tabela CD5                     ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function RegC120(cAlias,nRelac,cAliasCD5,lSigaEIC,aAvImport,lAchouCD5, aWizard)
	
Local	aRegC120	:=	{}
Local	cAcDraw		:=	""
Local	cDocImp		:=	""     
Local 	cCD5Chv		:=  ""
Local	nPos		:=	0
Local	lAcDraw		:=	aSPDSX3[FP_CD5_ACDRAW]

Default	aWizard		:= {}

//Tratamento para quando houver integracao com o SIGAEIC
If lSigaEIC .And. Len(aAvImport)>0	//Se houver elementos, sempre serah nestas dimensoes
	aAdd(aRegC120, {})
	nPos	:=	Len (aRegC120)
	aAdd (aRegC120[nPos], "C120")	 						//01 - REG	
	aAdd (aRegC120[nPos], aAvImport[1,2,1,2,1])			//02 - COD_DOC_IMP    
	aAdd (aRegC120[nPos], aAvImport[1,2,2,2,1])			//03 - NUM_DOC_IMP
	aAdd (aRegC120[nPos], Iif("1"$aWizard[1][15],aAvImport[1,2,3,2,1],0))	//04 - PIS_IMP
	aAdd (aRegC120[nPos], Iif("1"$aWizard[1][15],aAvImport[1,2,4,2,1],0))	//05 - COF_IMP
	aAdd (aRegC120[nPos], "")								//06 - NUM_ACDRAW - LAYOUT 2010

/*Se NAO houver integracao com o SIGAEIC, a tabela CD5 jah estah posicionada, senao NAO entraria na funcao  */

ElseIf lAchouCD5
	cCD5Chv := (cAliasCD5)->(CD5_FILIAL+CD5_DOC+CD5_SERIE+CD5_FORNEC+CD5_LOJA)
	While !(cAliasCD5)->(Eof()) .AND. ( (cAliasCD5)->(CD5_FILIAL+CD5_DOC+CD5_SERIE+CD5_FORNEC+CD5_LOJA)==cCD5Chv)	
		
		If ( ! EMPTY((cAliasCD5)->CD5_TPIMP) .OR. ! EMPTY((cAliasCD5)->CD5_DOCIMP) )
			cAcDraw	:=	Iif(lAcDraw,(cAliasCD5)->CD5_ACDRAW	,"")
			cDocImp	:=	(cAliasCD5)->CD5_DOCIMP
		
			/*Nao podem ser informados para um mesmo documento fiscal, dois ou mais registros
			com o mesmo conteudo no campo NUM_DOC_IMP e NUM_ACDRAW */
			If (nPos := aScan(aRegC120, {|aZ| aZ[6] == cAcDraw .And. aZ[3] == cDocImp})) == 0
				aAdd(aRegC120, {})
				nPos	:=	Len (aRegC120)
				aAdd (aRegC120[nPos], "C120")	 														//01 - REG	
				aAdd (aRegC120[nPos], (cAliasCD5)->CD5_TPIMP)											//02 - COD_DOC_IMP
				aAdd (aRegC120[nPos], (cAliasCD5)->CD5_DOCIMP)											//03 - NUM_DOC_IMP
				aAdd (aRegC120[nPos], Iif((cAliasCD5)->CD5_VLPIS>0,(cAliasCD5)->CD5_VLPIS,0))			//04 - PIS_IMP
				aAdd (aRegC120[nPos], Iif((cAliasCD5)->CD5_VLCOF>0,(cAliasCD5)->CD5_VLCOF,0))			//05 - COF_IMP
				If cVersao >= "003"
					If lAcDraw
						aAdd (aRegC120[nPos], (cAliasCD5)->CD5_ACDRAW)									//06 - NUM_ACDRAW - LAYOUT 2010
					Else
						aAdd (aRegC120[nPos], "")														//06 - NUM_ACDRAW - LAYOUT 2010
					EndIf
				EndIf
			Else
				aRegC120[nPos][4]	+=	(cAliasCD5)->CD5_VLPIS											//04 - PIS_IMP
				aRegC120[nPos][5]	+=	(cAliasCD5)->CD5_VLCOF											//05 - COF_IMP	
			Endif
		Endif

		(cAliasCD5)->(DbSkip())
	End

EndIf

//GrvRegTrS(cAlias,nRelac,aRegC120)
GrvRegTrS(cAlias,GetRelaGrv(nRelac, 10),aRegC120) 

Return
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³RegC130   ³ Autor ³Gustavo G. Rueda       ³ Data ³04.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±³          ³                  ISS - IR - INSS (MODELO 01 E 04)          ³±±
±±³          ³- Geracao e gravacao do Registro C130                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com as informacoes de ISS/IRRF/PREV dos³±±
±±³          ³ documentos fiscais processados.                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³3(1:1) Para cada Registro C100                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nil                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cAliasSFT-> Alias da tabela SFT posicionada                 ³±±
±±³          ³aRegC130 -> Informacoes sobre ISS/IRRF/PREV para o documento³±±
±±³          ³ fiscal processado no while da funcao principal.            ³±±
±±³          ³lIss     -> Identifica se o item em processamento eh servico³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function RegC130(cAliasSFT,aRegC130,lIss)

If lIss
	aRegC130[2]	+=	(cAliasSFT)->FT_VALCONT			  			//02 - VL_SERV_NT
	aRegC130[3]	+=	(cAliasSFT)->FT_BASEICM						//03 - VL_BC_ISS
	aRegC130[4]	+=	(cAliasSFT)->FT_VALICM			 			//04 - VL_ISS
EndIf
aRegC130[5]	+=	(cAliasSFT)->FT_BASEIRR			  				//05 - VL_BC_IRRF
aRegC130[6]	+=	(cAliasSFT)->FT_VALIRR		   					//06 - VL_IRRF
aRegC130[7]	+=	(cAliasSFT)->FT_BASEINS		   					//07 - VL_BC_PREV
aRegC130[8]	+=	(cAliasSFT)->FT_VALINS		  					//08 - VL_PREV
		
Return
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³C140C141  ³ Autor ³Gustavo G. Rueda       ³ Data ³15.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±³          ³             C140 - FATURA (MODELO 01 e 04)                 ³±±
±±³          ³         C141 - VENCIMENTO FATURA (MODELO 01 e 04)          ³±±
±±³          ³- Geracao e gravacao do Registro C140 e C141                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com as informacoes dos titulos e seus  ³±±
±±³          ³ vencimentos para cada documento fiscal processado.         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³C140 - 3(1:N) Para cada Registro C100                       ³±±
±±³          ³C141 - 4(1:N) Para cada Registro C140                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nil                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cAlias -> Alias do TRB que recebera as informacoes          ³±±
±±³          ³nRelac -> Flag de relacionamento com os sub-registros       ³±±
±±³          ³aRegC100 -> Array contendo o cabecalho da nota fiscal modelo³±±
±±³          ³ 01 e 04.                                                   ³±±
±±³          ³aParcTit -> Array contendo as parcelas financeiras do       ³±±
±±³          ³ documento fiscal                                           ³±±
±±³          ³cEntSai -> Identifica ENTRADA=1/SAIDA=2                     ³±±
±±³          ³aCmpAntSFT -> Campos da tabela SFT por documento fiscal     ³±±     
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function C140C141(cAlias,nRelac,aRegC100,aParcTit,cEntSai,aCmpAntSFT)

Local	aReg		:=	{}
Local	aReg2		:=	{}
Local	nVlTit		:=	0
Local	nX			:=	0
Local	nPos		:=	0
Local	nPosC141	:=	0

//Tratamento de verificacao da condicao de pagamento. Para pagamento a vista nao pode haver fatura

If aRegC100[1][13]!="0"

	If aExistBloc[19]
		aParcTit := ExecBlock("SPDFIS09", .F., .F.,{cEntSai,{aCmpAntSFT[1],aCmpAntSFT[2],aCmpAntSFT[3],aCmpAntSFT[4],aCmpAntSFT[27]}}) 	
	EndIF

	aParcTit	:=	aSort (aParcTit,,,{|x, y| x[4]<y[4]})

	//Obtendo o valor total dos titulos lancados para o documento, todas as parcelas
	aEval (aParcTit, {|x| nVlTit += x[6]})

	For nX := 1 To Len (aParcTit)
		
		//REGISTRO C140 - COMPLEMENTO DO DOCUMENTO - FATURA 
		//Somente a primeira vez para utilizar as informacoes do titulo.
		If nX==1
			aReg	:=	{}
			aAdd(aReg, {})
			nPos	:=	Len (aReg)
			aAdd (aReg[nPos], "C140")						  		//01 - REG
			aAdd (aReg[nPos], aRegC100[1][3])						//02 - IND_EMIT

			If (AllTrim (aParcTit[nX][1])$"BOL#DP#NF")				//03 - IND_TIT
				aAdd (aReg[nPos], "00")

			ElseIf (AllTrim (aParcTit[nX][1])$"CH")  				//03 - IND_TIT
				aAdd (aReg[nPos], "01")

			ElseIf (AllTrim (aParcTit[nX][1])$"NP")  				//03 - IND_TIT
				aAdd (aReg[nPos], "02")                	

			ElseIf (AllTrim (aParcTit[nX][1])$"RC")  				//03 - IND_TIT
				aAdd (aReg[nPos], "03")

			Else
				aAdd (aReg[nPos], "99")								//03 - IND_TIT
			EndIf

			If "99"$aReg[nPos,3]
				If Empty( aParcTit[nX][2] )
					aAdd (aReg[nPos], "Titulo de Nota Fiscal")		//04 - DESC_TIT
				Else                                            	
					aAdd (aReg[nPos], aParcTit[nX][2 ])				//04 - DESC_TIT
				EndIf
			Else
				aAdd (aReg[nPos], "")								//04 - DESC_TIT
			EndIf

			aAdd (aReg[nPos], aParcTit[nX][3])						//05 - NUM_TIT
			aAdd (aReg[nPos], Alltrim(STR(Len (aParcTit))))			//06 - QTD_PARC
			aAdd (aReg[nPos], nVlTit)		   						//07 - VL_TIT
		EndIf
		
		//REGISTRO C141 - VENCIMENTO DA FATURA
		aAdd(aReg2, {})
		nPosC141	:=	Len (aReg2)
		aAdd (aReg2[nPosC141], nPos)				  				//00 - Relacionamento
		aAdd (aReg2[nPosC141], "C141")				  				//01 - REG
		aAdd (aReg2[nPosC141], Alltrim(STR(nX)) )					//02 - NUM_PARC
		aAdd (aReg2[nPosC141], aParcTit[nX][5])						//03 - DT_VECTO
		aAdd (aReg2[nPosC141], aParcTit[nX][6])						//04 - VL_PARC
	Next nX
	
	GrRegDep(cAlias,aReg,aReg2,,,,nRelac,.F.)

EndIf
Return
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³RegC160   ³ Autor ³Gustavo G. Rueda       ³ Data ³15.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³    REGISTRO C160 - VOLUMES TRANSPORTADOS (CODIGO 01 E 04)   ³±±
±±³          ³                  EXCETO COMBUSTIVEIS                       ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao e gravacao do Registro C160                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com as informacoes dos volumes dos     ³±±
±±³          ³ documentos fiscais processados.                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³3(1:1) Para cada Registro C100                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nil                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cAlias -> Alias do TRB que recebera as informacoes          ³±±
±±³          ³nRelac -> Flag de relacionamento com os sub-registros       ³±±
±±³          ³aReg0150 -> Array com a estrutura do registro 0150          ³±±
±±³          ³aWizard  -> Array com as informacoes do wizard da rotina    ³±±
±±³          ³aCmpAntSFT-> Campos do documento em processamento           ³±±
±±³          ³lCadParti-> Flag que identifica a existencia do PE SPDFIS06 ³±±
±±³          |aHistSA4 -> Array com os historicos de alteracoes do SA4    ³±±
±±³          |lAchouDA3-> Flag de posicionamento da tabela DA3            ³±±
±±³          |cAliasSA4-> Alias da tabela SA4                             ³±±
±±³          |aF2EspVol-> Campos de Especie/Volume para gerar o registro  ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function RegC160(cAlias,nRelac,aReg0150,aWizard,aCmpAntSFT,lCadParti,aHistSA4,lAchouDA3,cAliasSA4,aF2EspVol)

Local	aReg   		:=	{}
Local	aPartDoc	:=	{}
Local	cCodPart	:=	""
Local	cUfId		:=	""
Local	cVeicId		:=	""
Local   nVolume     := 	0  
Local	nX			:=	0

//Acumulo a quantidade de volumes do documento fiscal

For nX := 1 To Len(aF2EspVol)
	If ValType(aF2EspVol[nX,4])<>'U'
		nVolume	+=	aF2EspVol[nX,4]
	EndIf	
Next nX

If !Empty(aCmpAntSFT[30])	//Conteudo do campos F2_TRANSP
	aPartDoc	:=	InfPartDoc("SA4",SToD(aWizard[1][1]),SToD(aWizard[1][2]),cAliasSA4,lCadParti,aHistSA4)

	/*GRAVACAO REGISTRO 0150 - TABELA DE CADASTRO DE PARTICIPANTES 
	GRAVACAO REGISTRO 0175 - ALTERACAO DA TABELA DE CADASTRO DE PARTICIPANTE */
	SDPF150175(@aReg0150,aPartDoc,cAlias,aWizard,aExistBloc)

	cCodPart	:=	aPartDoc[1]
EndIf

//Para veiculos do exterior, a placa e a UF nao devem ser informadas

If lAchouDA3 .And. DA3->DA3_ESTPLA<>"EX"  
	cUfId	:= Alltrim(DA3->DA3_ESTPLA)
	cVeicId := SubStr(StrTran(DA3->DA3_PLACA,"-",""),1,7)
	
ElseIf !lAchouDA3
	If !Empty(aCmpAntSFT[33]) .And. DA3->(MsSeek(aSPDFil[PFIL_DA3]+aCmpAntSFT[33])) .And.  DA3->DA3_ESTPLA<>"EX"  
		cUfId	:= Alltrim(DA3->DA3_ESTPLA)
		cVeicId := SubStr(StrTran(DA3->DA3_PLACA,"-",""),1,7)
	
	ElseIf !Empty(aCmpAntSFT[34]) .And. DA3->(MsSeek(aSPDFil[PFIL_DA3]+aCmpAntSFT[34])) .And. DA3->DA3_ESTPLA<>"EX"  
		cUfId	:= Alltrim(DA3->DA3_ESTPLA)
		cVeicId := SubStr(StrTran(DA3->DA3_PLACA,"-",""),1,7)
			
	ElseIf !Empty(aCmpAntSFT[35]) .And. DA3->(MsSeek(aSPDFil[PFIL_DA3]+aCmpAntSFT[35])) .And. DA3->DA3_ESTPLA<>"EX"
		cUfId	:= Alltrim(DA3->DA3_ESTPLA)
		cVeicId := SubStr(StrTran(DA3->DA3_PLACA,"-",""),1,7)

	Else  
		cUfId	:= ""  
		cVeicId := ""  
	Endif
EndIf
    
//Montagem e gravacao do registro
aAdd (aReg, {})
nPos	:=	Len (aReg)
aAdd (aReg[nPos], "C160")	 							//01 - REG
aAdd (aReg[nPos], cCodPart)								//02 - COD_PART
aAdd (aReg[nPos], cUfId + cVeicId)						//03 - VEIC_ID
aAdd (aReg[nPos], {nVolume,0}) 	                    	//04 - QTD_VOL
aAdd (aReg[nPos], aCmpAntSFT[31])						//05 - PESO_BRT
aAdd (aReg[nPos], aCmpAntSFT[32])						//06 - PESO_LIQ

//Para declaracoes superiores a 2008, deve-se informar um campo a mais conforme layout

If Year(SToD(aWizard[1][1]))>=2009
	aReg[nPos][03] := cVeicId							//03 - VEIC_ID
	aAdd (aReg[nPos], cUfId)							//07 - UF_ID
EndIf

//GrvRegTrS(cAlias,nRelac,aReg)
GrvRegTrS(cAlias,GetRelaGrv(nRelac, 7),aReg) 

Return
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³RegC165   ³ Autor ³Gustavo G. Rueda       ³ Data ³15.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±³          ³           DOCUMENTO DE ARRECADACAO REFERENCIADO            ³±±
±±³          ³                                                            ³±±
±±³Descri‡…o ³Geracao da estrutura do Registro C165                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com todas as guias de recolhimento com ³±±
±±³          ³ a data de referencia no periodo apurado.                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³3(1:N) para cada Registro C100                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nil                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³aRegC165-> Array com a estrutura do registro C165           ³±±
±±³          ³aPTransp-> Informacoes da transportadora do documento fiscal³±±
±±³          ³cAliasSFT-> Alias da tabela SFT em processamento            ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function RegC165(aRegC165,aPTransp,cAliasSFT,cAliasCD6)

Local	nPos		:=	0
Local 	aAreaCD6 	:= (cAliasCD6)->(GetArea())
Local 	cChv 		:= (cAliasSFT)->(FT_TIPOMOV+FT_SERIE+FT_NFISCAL+FT_CLIEFOR+FT_LOJA+FT_ITEM+FT_PRODUTO)

While !(cAliasCD6)->(Eof()) .And.;
	aSPDFil[PFIL_CD6] + cChv == (cAliasCD6)->(CD6_FILIAL+CD6_TPMOV+CD6_SERIE+CD6_DOC+CD6_CLIFOR+CD6_LOJA+CD6_ITEM+CD6_COD)
    
	//Tratamento para evitar duplicidade no registro
	If aScan(aRegC165,{|aX|aX[2]==aPTransp[1] .And. aX[3]==(cAliasCD6)->CD6_PLACA})==0
		aAdd(aRegC165, {})
		nPos	:=	Len (aRegC165)
		aAdd (aRegC165[nPos], "C165")											//01 - REG
		aAdd (aRegC165[nPos], aPTransp[1])										//02 - COD_PART
		aAdd (aRegC165[nPos], (cAliasCD6)->CD6_PLACA)									//03 - VEIC_ID
		aAdd (aRegC165[nPos], (cAliasCD6)->CD6_SEFAZ)									//04 - COD_AUT
		aAdd (aRegC165[nPos], (cAliasCD6)->CD6_PASSE)									//05 - NR_PASSE
		aAdd (aRegC165[nPos], Alltrim((cAliasCD6)->CD6_HORA)+"00")						//06 - HORA
		aAdd (aRegC165[nPos], {(cAliasCD6)->CD6_TEMP,1})								//07 - TEMPER
		aAdd (aRegC165[nPos], STR((cAliasCD6)->CD6_VOLUME))								//08 - QTD_VOL
		aAdd (aRegC165[nPos], (cAliasCD6)->CD6_PBRUTO)									//09 - PESO_BRT
		aAdd (aRegC165[nPos], (cAliasCD6)->CD6_PLIQUI)									//10 - PESO_LIQ
		aAdd (aRegC165[nPos], (cAliasCD6)->CD6_MOTOR)									//11 - NOM_MOT
		aAdd (aRegC165[nPos], (cAliasCD6)->CD6_CPFMOT)									//12 - CPF
		aAdd (aRegC165[nPos], IIF(aSPDSX3[FP_CD6_UFPLAC],(cAliasCD6)->CD6_UFPLAC,"")) 	//13 - UF_ID
	EndIf
		
	(cAliasCD6)->(dbSkip())
End

RestArea(aAreaCD6)

Return
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³RegC170   ³ Autor ³Gustavo G. Rueda       ³ Data ³04.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±³          ³         ITENS DO DOCUMENTO (MODELO 01 E 04)                ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao e gravacao do Registro C170                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com a informacao de cada item do docu- ³±±
±±³          ³ mento fiscal processado no while da funcao principal.      ³±±
±±³          ³Somente sera gravado os documentos fiscais modelo 01 e 04   ³±±
±±³          ³ nos outros casos, sera utilizdo para gerar outros registros³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³3(1:N) Para cada Registro C100                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T.                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cAlias    -> Alias do TRB que recebera as informacoes       ³±±
±±³          ³nRelac    -> Flag de relacionamento com os sub-registros    ³±±
±±³          ³nItem     -> Contador do item para cada documento fiscal.   ³±±
±±³          ³aRegC170  -> Informacoes sobre os itens do documento fiscal ³±±
±±³          ³ processado no while da funcao principal.                   ³±±
±±³          ³cEspecie  -> Modelo do documento fiscal                     ³±±
±±³          ³cAliasSFT -> Alias da tabela SFT posicionada                ³±±
±±³          ³cAlsSD    -> Alias da tabela SD? posicionada                |±±
±±³          |lIss      -> Indica se o documento incide ISS.              ³±±
±±³          |aClasFis  -> Classificacao fiscal do ICMS.                  ³±±
±±³          |lAchouSF4 -> Indicador do SEEK na tabela SF4.               ³±±
±±³          |nApurIPI  -> Identificador de Apuracao de IPI no periodo    ³±±
±±³          |cSituaDoc -> Situacao do documento fiscal                   ³±±
±±³          |cUnid     -> Unidade de medida do item em processamento     ³±±
±±³          |cProd     -> Codigo de produto do item emm processamento    ³±±
±±³          |aCmpAntSFT-> Campos da tabela SFT a serem utilizados        ³±±
±±³          |nValST    -> Valor da substituicao tributaria conforme calcu³±±
±±³          |             lado na apuracao de icms/st, jah considerando o³±±
±±³          |             CREDST.                                        ³±±
±±³          |dDataAte  -> Data final de processamento do periodo         ³±±
±±³          |aWizard   -> Array com as informacoes do wizard             ³±±
±±³          |cAliasSF4 -> Alias da tabela SF4, pode ser alias de query   ³±±
±±³          |cAliasSB1 -> Alias da tabela Sb1, pode ser alias de query   ³±±
±±³          |AHistSB1  -> Array com o historico de alteracoes do produto,³±±
±±³          |             caso esteja habilitado                         ³±±
±±³          |nQtde     -> Quantidade do item. Esta quantidade pode ser o ³±±
±±³          |             proprio FT_QUANT ou o retorno do PE SPDFIS0,   ³±±
±±³          |             onde pode ser atribuido a quantidade na segunda³±± 
±±³          |             UM.                                            ³±±
±±³          ³lPisZero  -> Indica se zera o valor do Pis                  ³±±   
±±³          ³lCofZero  -> Indica se zera o valor do Cofins               ³±±
±±³          ³lAchouCD0  -> Indica que existe registro de Ressarcimento   ³±±
±±³          ³cMvEstado  -> Conteudo do parametro MV_ESTADO               ³±±
±±³          ³lAchouCD1  -> Indica que existe registro de Natureza da Oper³±±  
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function RegC170(cAlias,nRelac,nItem,aRegC170,cEspecie,cAliasSFT,lIss,aClasFis,lAchouSF4,nApurIPI,cSituaDoc,cUnid,;
						cProd,aCmpAntSFT,nValST,dDataAte,aWizard,cAliasSF4,cAliasSB1,AHistSB1,nQtde,lPisZero,lCofZero,lAchouCD0,;
						cMvEstado,cCodNat,cPerfil,lOperGar, lResF3FT, cAliasSD1,lGeraC177B,nAbatNT,oPosItXML,lProcXml,nContXml,lComplXml)

Local	cContCtb	:= RetCOD_CTA(cAliasSFT, "C170")
Local	lRet		:=	.F.
Local	lMVUFICSEP	:= cMvEstado$aSPDSX6[MV_UFICSEP]
Local	lVLCTBZL	:= .F.
Local	nCampos		:=	Iif(cVersao >='013',38,37)
Local	nPos		:=	0
Local	nQuant 		:=	0
Local	nPisPauta 	:= 	0
Local	nQtdBPis  	:= 	0
Local	nBasePis 	:= 	0
Local	nAliqPis  	:= 	0
Local	nCofPauta 	:= 	0
Local	nQtdBCof  	:= 	0
Local	nBaseCof  	:= 	0
Local	nAliqCof  	:= 	0
Local	nMV_SPEDQTD	:=	aSPDSX6[MV_SPEDQTD]	//Parametro utilizado para definir o tratamento da quantidade quando a mesma for ZERO
Local	cMVUFBsSt	:=	aSPDSX6[MV_UFBSST]		// Define os estados a serem utilizados para CAT nº 3/2015
Local   lgeraC180	:= lRegCompST .and. !Empty((cAliasSFT)->CII_ITEM) .AND. (cAliasSFT)->FT_TIPOMOV == 'E' .And. (!aSPDSX3[FP_CII_SPED] .Or. (cAliasSFT)->CII_SPED != '2') 
Local   aArea		:= {}
LOcal   cItemOri	:= ''
Local   cRegIt		:= ""
Local   aItXML		:= {}
Local   lExcXml		:= .F.

Default	cAliasSF4	:=	"SF4"
Default	cAliasSB1	:=	"SB1"  
Default	dDataAte	:=	CToD ("//")   
Default lResF3FT	:= .F.
Default	lGeraC177B	:= .F.
Default	nAbatNT		:= 0
Default oPosItXML	:= Nil
Default lProcXml    := .F.
Default lComplXml   := .F.

// MV_VLCTBZL -> Indique os CFOP's que terao os seus Valores contabeis Zerados no Livros de Entrada e Saida. - 16/10/2017 - Vitor Ribeiro (vitor.e@totvs.com.br)
lVLCTBZL := AllTrim((cAliasSFT)->FT_CFOP) $ aSPDSX6[MV_VLCTBZL]

//Tratamento realizado para caso o parâmetro esteja vazio ou zerado. Esse parâmetro existe justamente para informar um valor diferente de zero quando o campo FT_QUANT estiver zerado.
If nMV_SPEDQTD == 0
	nMV_SPEDQTD := 1
EndIf

//Montando array com a estrutura do registro C170
aAdd(aRegC170, Array(nCampos))

If lProcXml
	
	cRegIt := "C170" + (cAliasSFT)->DKA_ITXML 
	
	If oPosItXML == Nil
		oPosItXML := JsonObject():New()
	Endif
	
	aItXML := oPosItXML[cRegIt] 
	nQuant := (cAliasSFT)->DKA_QTDXML
	If !ValType(aItXML) == "A"
		lExcXml := .T.
	Else
		lExcXml := .F.
	Endif
Else	
	//A quantidade do item nao pode ser ZERO, o validador acusa erro
	nQuant := nQtde 	
Endif

//A quantidade do item nao pode ser ZERO, o validador acusa erro
If nQuant==0
	nQuant := nMV_SPEDQTD
EndIf

nPos	:=	Len (aRegC170)

aRegC170[nPos][1] := "C170"		   					  			  																					//01 - REG
aRegC170[nPos][2] := Iif(Empty(cRegIt), AllTrim(Str(nItem)), AllTrim(Str(Val( (cAliasSFT)->DKA_ITXML) )) )																//02 - NUM_ITEM
aRegC170[nPos][3] := cProd								  																							//03 - COD_ITEM

If aExistBloc[01] 
	aRegC170[nPos][5] := {nQuant,5}	                     																	 //05 - QTD
Else
	aRegC170[nPos][5] := Iif(Empty(cRegIt), {Iif((cAliasSFT)->FT_QUANT == 0, nMV_SPEDQTD, (cAliasSFT)->FT_QUANT),5}, {(cAliasSFT)->DKA_QTDXML,5}) //05 - QTD
EndIf

aRegC170[nPos][6] := Iif(Empty(cRegIt), cUnid, Alltrim((cAliasSFT)->DKA_UMXML))											            				//06 - UNID	

If lVLCTBZL
	aRegC170[nPos][7] := 0
Else
	aRegC170[nPos][7] := (cAliasSFT)->FT_TOTAL + Iif( (cAliasSFT)->FT_TIPO <> "D", (cAliasSFT)->FT_DESCZFR, 0 )	+ Iif(Empty(cRegIt) .Or. lExcXml , 0, aItXML[nPos][7])   //07 - VL_ITEM

	If (cAliasSFT)->FT_TIPOMOV == "E" .And. (!(cAliasSF4)->F4_LFIPI$"T" .Or. (cAliasSFT)->FT_CREDST $ "3|4" ) .And. !(cAliasSFT)->FT_TIPO$"DB"
		If !(cAliasSF4)->F4_LFIPI$"T" .And. !(cAliasSF4)->F4_IPI$"R" 
			aRegC170[nPos][7]	+= (cAliasSD1)->D1_VALIPI
		EndIf
		If (cAliasSFT)->FT_CREDST $ "3|4" .And. !(cAliasSFT)->FT_ANTICMS == "1"
			aRegC170[nPos][7]	+= 	RetStSpd(lResF3FT, cAliasSFT )
		Endif
	EndIf
EndIf

//Tratamento para as notas de complementos
If ((cAliasSFT)->FT_TIPO$"IPC")
	//Para Notas Fiscais de complemento de IPI/ICMS o campo referente ao valor do item deve ser zero.
	If ((cAliasSFT)->FT_TIPO$"IP")
		aRegC170[nPos][7] := 0							   				 																			//07 - VL_ITEM
	EndIf
	
	aRegC170[nPos][9] := "1"
Else
	//Tratamento movimentacao fisica sem movimentacao de estoque
	If lAchouSF4 .And. ((cAliasSF4)->F4_MOVFIS=="N" .Or. Empty((cAliasSF4)->F4_MOVFIS))
		aRegC170[nPos][9] := "1"																											//09 - IND_MOV
	Else
		aRegC170[nPos][9] := "0"																											//09 - IND_MOV
	EndIf
EndIf
//Codigo de CST para SIMPLES NACIONAL
aRegC170[nPos][10] := aClasFis[1]  																												//10 - CST
If aCmpAntSFT[36]$"1S"	//A2_SIMPNAC
	If aSPDSX3[FP_FT_CSOSN] .And. !Empty((cAliasSFT)->FT_CSOSN)
		aRegC170[nPos][10] := (cAliasSFT)->FT_CSOSN																								//10 - CST	
	ElseIf !Empty((cAliasSF4)->F4_CSOSN)
		aRegC170[nPos][10] := (cAliasSF4)->F4_CSOSN																								//10 - CST
	Endif		
EndIf
aRegC170[nPos][11] := (cAliasSFT)->FT_CFOP  			   				  																		//11 - CFOP   
aRegC170[nPos][13] 	:= 0
aRegC170[nPos][15]	:= 0
If !(cSituaDoc$"02#03#04#05")
	
	If lComplXml .And. !lProcXml // Nota complementar busca a descrição do item do xml da nota origem vinculada
		aRegC170[nPos][4]	:= NfOrItXml(1, (cAliasSFT)->FT_NFORI, (cAliasSFT)->FT_SERORI, (cAliasSFT)->FT_CLIEFOR, (cAliasSFT)->FT_LOJA, (cAliasSFT)->FT_ITEMORI) 	           //04 - DESCR_COMPL
		If Empty(aRegC170[nPos][4]) // Caso não tenha uma nota origem por Item Xml, de um periodo que não processou Item Xml.
			aRegC170[nPos][4] := RetCmpHist(cAliasSB1+"->B1_DESC",AHistSB1,aCmpAntSFT[5])
		EndIf
	Else
		aRegC170[nPos][4]	:= Iif(Empty(cRegIt), RetCmpHist(cAliasSB1+"->B1_DESC",AHistSB1,aCmpAntSFT[5]), (cAliasSFT)->DKA_DESCFO)	           //04 - DESCR_COMPL
	EndIf

	//Ponto de Entrada para alterar a descrição do produto 
	If aExistBloc[12] .AND. !lProcXml
	
		aRegC170[nPos][4] := ExecBlock("SPDFIS04", .F., .F., {(cAliasSFT)->FT_FILIAL,;
							(cAliasSFT)->FT_TIPOMOV,;
							(cAliasSFT)->FT_SERIE,;
							(cAliasSFT)->FT_NFISCAL,;
							(cAliasSFT)->FT_CLIEFOR,;
							(cAliasSFT)->FT_LOJA,;
							(cAliasSFT)->FT_ITEM,;
							(cAliasSFT)->FT_PRODUTO})
	EndIf
	
	If  (cAliasSFT)->FT_TIPO == "D" .And. (cAliasSFT)->FT_TIPOMOV == 'E' .And. (cAliasSFT)->FT_DESCONT > 0 .And. (cAliasSFT)->FT_DESCZFR > 0  
		aRegC170[nPos][8] 	:= 	(CAliasSFT)-> FT_DESCONT - (cAliasSFT)->FT_DESCZFR	+ Iif(Empty(cRegIt) .Or. lExcXml , 0, aItXML[nPos][8])    //08 - VL_DESC_I
	Else
		aRegC170[nPos][8] 	:= 	(cAliasSFT)->FT_DESCONT + Iif(Empty(cRegIt) .Or. lExcXml , 0, aItXML[nPos][8])
	Endif	
	aRegC170[nPos][12] 	:= 	cCodNat																												//12 - COD_NAT
	aRegC170[nPos][13] 	:= 	IIf(lIss,0,(cAliasSFT)->FT_BASEICM)	+ Iif(Empty(cRegIt) .Or. lExcXml , 0, aItXML[nPos][13])						//13 - VL_BC_ICMS_I
	//Quando o documento nao tiver aliquota e for algum documento complementar, devo utilizar a aliquota do original. ³
	//³Somente nas situacoes em que o CST seja 00,20,30 e 70 conforme manual                                           ³
	If (cAliasSFT)->(!lIss .And. FT_ALIQICM==0 .And. Substr(FT_CLASFIS,2,2)$"00#10#20#70" .And. !Empty(FT_NFORI+FT_SERORI))		

		If Empty(cItemOri := (cAliasSFT)->(FT_ITEMORI))
			cItemOri := IIF((cAliasSFT)->(FT_TIPOMOV) == 'S', (cAliasSFT)->D2_ITEMORI, (cAliasSFT)->D1_ITEMORI)
		Endif	

		If !Empty(cItemOri) 
			aArea		:= SFT->(GetArea())
				If SPEDSeek("SFT", 1, aSPDFil[PFIL_SFT] + (cAliasSFT)->(FT_TIPOMOV + FT_SERORI + FT_NFORI + FT_CLIEFOR + FT_LOJA + Alltrim(cItemOri) ))
					aRegC170[nPos][14] := IIf(lIss, 0, SFT->FT_ALIQICM - SFT->(IIF(!lMVUFICSEP.Or.Left(FT_CFOP,1)<>'5'.Or.FT_TIPO$"BD".Or.FT_VALFECP==0,0,FT_ALQFECP)))		//14 - ALIQ_ICMS
				EndIf	
			RestArea(aArea)
		EndIf	
		
	Else
		aRegC170[nPos][14] := IIf(lIss,0,(cAliasSFT)->FT_ALIQICM-(cAliasSFT)->(IIF(!lMVUFICSEP.Or.Left(FT_CFOP,1)<>'5'.Or.FT_TIPO$"BD".Or.FT_VALFECP==0,0,FT_ALQFECP)))	//14 - ALIQ_ICMS
	EndIf	                                                                	
	aRegC170[nPos][15] := IIf(lIss,0,(cAliasSFT)->FT_VALICM-(cAliasSFT)->(IIF(!lMVUFICSEP.Or.Left(FT_CFOP,1)<>'5'.Or.FT_TIPO$"BD",0,FT_VALFECP))) + Iif(Empty(cRegIt) .Or. lExcXml , 0, aItXML[nPos][15])	//15 - VL_ICMS_I
   	aRegC170[nPos][16] := IIf( (  nValST > 0) .OR. ((cAliasSFT)->FT_BASERET > 0  .AND. (cAliasSFT)->FT_CREDST <> "4"  ).OR. ( (cAliasSFT)->FT_CREDST <> "4" .AND. (cAliasSFT)->FT_ESTADO $ cMVUFBsSt ) ,(cAliasSFT)->FT_BASERET,0) //16 - VL_BC_ST_I	
	aRegC170[nPos][17] := IIf(nValST==0 ,0,(cAliasSFT)->FT_ALIQSOL)																				//17 - ALIQ_ST
	aRegC170[nPos][18] := nValST-(cAliasSFT)->(IIF(!lMVUFICSEP.Or.Left(FT_CFOP,1)<>'5'.Or.FT_TIPO$"BD",0,FT_VFECPST)) + Iif(Empty(cRegIt) .Or. lExcXml , 0, aItXML[nPos][18])	//18 - VL_ST_I
	
	If (cAliasSFT)->FT_VALIPI>0
		aRegC170[nPos][19] := STR(nApurIPI,1)						 				  															//19 - IND_APUR
	Else
		aRegC170[nPos][19] := ""																												//19 - IND_APUR
	EndIf
	
	aRegC170[nPos][20] := Iif("0"$aWizard[2][5],aClasFis[2],"")	 																				//20 - CST_IPI
	aRegC170[nPos][21] := "" 																													//21 - COD_ENQ
	aRegC170[nPos][22] := Iif(!(cAliasSF4)->F4_LFIPI$"T" .And. (cAliasSF4)->F4_IPI$"R",0,(cAliasSFT)->FT_BASEIPI) + Iif(Empty(cRegIt) .Or. lExcXml , 0, aItXML[nPos][22]) //22 - VL_BC_IPI
	aRegC170[nPos][23] := Iif(!(cAliasSF4)->F4_LFIPI$"T" .And. (cAliasSF4)->F4_IPI$"R",0,(cAliasSFT)->FT_ALIQIPI) 								//23 - ALIQ_IPI
	If (cAliasSFT)->FT_TIPOMOV == "E" 
		If !(cAliasSFT)->FT_TIPO$"DB"
			aRegC170[nPos][24] := Iif((cAliasSF4)->F4_LFIPI$"T",(cAliasSD1)->D1_VALIPI,0) + Iif(Empty(cRegIt) .Or. lExcXml , 0, aItXML[nPos][24])			//24 - VL_IPI
		Else
			aRegC170[nPos][24] := (cAliasSFT)->FT_VALIPI + Iif(Empty(cRegIt) .Or. lExcXml , 0, aItXML[nPos][24])
		Endif
	ElseIf (cAliasSFT)->FT_TIPOMOV == "S"
	    aRegC170[nPos][24] := Iif(!(cAliasSF4)->F4_LFIPI$"T" .And. (cAliasSF4)->F4_IPI$"R",0,(cAliasSFT)->FT_VALIPI) //Totaliza o valor de IPI do documento. Exc.: comercio não atacadista
	EndIf
	aRegC170[nPos][25] := Iif("1"$aWizard[1][15],aClasFis[3],"")	  																			//25 - CST_PIS
	
	//Tratamento para o PIS
	If (cAliasSFT)->FT_VALPIS > 0
		
		//Verifica se o valor de PIS é de PAUTA
		If (cAliasSFT)->FT_PAUTPIS > 0
			nPisPauta := (cAliasSFT)->FT_PAUTPIS
			nQtdBPis  := Iif(Empty(cRegIt), nQtde, nQuant)

		ElseIf (cAliasSB1)->B1_VLR_PIS>0
			nPisPauta := (cAliasSB1)->B1_VLR_PIS
			nQtdBPis  := Iif(Empty(cRegIt), nQtde, nQuant)

		Else
			nBasePis  := (cAliasSFT)->FT_BASEPIS
			nAliqPis  := (cAliasSFT)->FT_ALIQPIS
		EndIf
	EndIf
	
	aRegC170[nPos][26] := Iif("1"$aWizard[1][15],Iif(lOperGar,0,nBasePis) + Iif(Empty(cRegIt) .Or. lExcXml , 0, aItXML[nPos][26]),"")    	//26 - VL_BC_PIS
	aRegC170[nPos][27] := Iif("1"$aWizard[1][15],Iif(lPisZero .Or. lOperGar,0,nAliqPis),"")													//27 - ALIQ_PIS
	aRegC170[nPos][28] := Iif("1"$aWizard[1][15],IIf(lOperGar,0,nQtdBPis),"")					 											//28 - QUANT_BC_PIS
	aRegC170[nPos][29] := Iif("1"$aWizard[1][15],Iif(lPisZero .or. lOperGar,0,nPisPauta),"")												//29 - ALIQ_PIS - Reais
	aRegC170[nPos][30] := Iif("1"$aWizard[1][15],Iif(lPisZero .or. lOperGar,0,(cAliasSFT)->FT_VALPIS) + Iif(Empty(cRegIt) .Or. lExcXml , 0, aItXML[nPos][30]),"")	//30 - VL_PIS
	aRegC170[nPos][31] := Iif("1"$aWizard[1][15],aClasFis[4],"")			 						  										//31 - CST_COFINS
	//Tratamento para COFINS 
	If (cAliasSFT)->FT_VALCOF>0
		//Verifica se o valor de COFINS é de PAUTA
		If (cAliasSFT)->FT_PAUTCOF>0
			nCofPauta := (cAliasSFT)->FT_PAUTCOF
			nQtdBCof  := Iif(Empty(cRegIt), nQtde, nQuant)				
		ElseIf (cAliasSB1)->B1_VLR_COF>0
			nCofPauta := (cAliasSB1)->B1_VLR_COF
			nQtdBCof  := Iif(Empty(cRegIt), nQtde, nQuant)
		Else
			nBaseCof  := (cAliasSFT)->FT_BASECOF
			nAliqCof  := (cAliasSFT)->FT_ALIQCOF - (cAliasSFT)->FT_MALQCOF
		EndIf
	EndIf	
	aRegC170[nPos][32] := Iif("1"$aWizard[1][15],IIf(lOperGar,0,nBaseCof) + Iif(Empty(cRegIt) .Or. lExcXml , 0, aItXML[nPos][32]) ,"")		//32 - VL_BC_COFINS
	aRegC170[nPos][33] := Iif("1"$aWizard[1][15],Iif(lCofZero .Or. lOperGar,0,nAliqCof),"")													//33 - ALIQ_COFINS
	aRegC170[nPos][34] := Iif("1"$aWizard[1][15],IIf(lOperGar,0,nQtdBCof),"")					 											//34 - QUANT_BC_COFINS
	aRegC170[nPos][35] := Iif("1"$aWizard[1][15],Iif(lCofZero .Or. lOperGar,0,nCofPauta),"")												//35 - ALIQ_COFINS - Reais
	aRegC170[nPos][36] := Iif("1"$aWizard[1][15],Iif(lCofZero .Or. lOperGar,0,(cAliasSFT)->FT_VALCOF-(cAliasSFT)->FT_MVALCOF)+ Iif(Empty(cRegIt) .Or. lExcXml , 0, aItXML[nPos][36]) ,"") //36 - VL_COFINS
	aRegC170[nPos][37] := Iif(!Empty(cContCtb),cContCtb,(cAliasSFT)->FT_CONTA)																//37 - COD_CTA	
	
	IF cVersao >= "013"
		aRegC170[nPos][38] := Iif(nAbatNT > 0,nAbatNT,0) + Iif(Empty(cRegIt) .Or. lExcXml , 0, aItXML[nPos][38] )										//38 - VL_ABAT_NT
	Endif
	
EndIf

//Verifica se gera REGISTRO C177: COMPLEMENTO DE ITEM - OUTRAS INFORMAÇÕES (código 01, 55) - (VÁLIDO A PARTIR DE 01/01/2019)
IF cVersao >= "013" .And. aSPDSX3[FP_FT_INFITEM] .And. cEspecie$"01#55"
	lGeraC177B := !Empty((cAliasSFT)->FT_INFITEM)
Endif	

//PARA NF-e de emissao propria nao deve gerar C170 (nesse caso o CHVNFE estara preenchido)
If !lProcXml .Or. Empty(cRegIt) .Or. (nContXml == (cAliasSFT)->DKA_MAXIT)
	If !cSituaDoc$"02#03#04#05" .And. (cEspecie$"01#1B#04" .Or. (cEspecie$"55" .And. (aCmpAntSFT[26]=="1" .Or. lAchouCD0 .Or. lGeraC177B .or. lgeraC180))) .And. cPerfil <> "C"
		nRelac := GetRelaGrv(nRelac, 5) 
		GrvRegTrS(cAlias,nRelac,aRegC170,nItem,,IIf(cVersao <= "003",.F.,.T.))
		lRet := .T.
	EndIf
ElseIf lProcXml .And. !Empty(cRegIt)
	oPosItXML[cRegIt] := aRegC170
	aRegC170 := {{"",;  //01 - REG
				  "",;  //02 - NUM_ITEM
				  "",;  //03 - COD_ITEM
				  "",;  //04 - DESCR_COMPL
				   0,;  //05 - QTD
				  "",;  //06 - UNID
				   0,;  //07 - VL_ITEM 
				   0,;  //08 - VL_DESC
				  "",;  //09 - IND_MOV
  aRegC170[nPos][10],;  //10 - CST_ICMS 
  aRegC170[nPos][11],;  //11 - CFOP
				  '',;  //12 - COD_NAT
 				   0,;  //13 - VL_BC_ICMS
  aRegC170[nPos][14],;  //14 - ALIQ_ICMS
				   0,;  //15 - VL_ICMS
				   0,;  //16 - VL_BC_ICMS_ST
				   0,;  //17 - ALIQ_ST 
				   0,;  //18 - VL_ICMS_ST
				  "",;  //19 - IND_APUR
				  "",;  //20 - CST_IPI 
				  "",;  //21 - COD_ENQ
				   0,;  //22 - VL_BC_IPI
				   0,;  //23 - ALIQ_IPI
				   0,;  //24 - VL_IPI
				  "",;  //25 - CST_PIS
				   0,;  //26 - VL_BC_PIS
				   0,;  //27 - ALIQ_PIS
				   0,;  //28 - QUANT_BC_PIS
				   0,;  //29 - ALIQ_PIS
				   0,;  //30 - VL_PIS
				  "",;  //31 - CST_COFINS
				   0,;  //32 - VL_BC_COFINS
				   0,;  //33 - ALIQ_COFINS
				   0,;  //34 - QUANT_BC_COFINS
				   0,;  //35 - ALIQ_COFINS
				   0,;  //36 - VL_COFINS
				  "",;  //37 - COD_CTA 
				   0}}  //38 - VL_ABAT_NT 
Endif
Return(lRet)
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³RegC171   ³ Autor ³Gustavo G. Rueda       ³ Data ³04.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±³          ³              ARMAZENAMENTO DE COMBUSTIVEIS                 ³±±
±±³          ³                                                            ³±±
±±³Descri‡…o ³Geracao e gravacao do Registro C171                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com todas as guias de recolhimento com ³±±
±±³          ³ a data de referencia no periodo apurado.                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³3(1:N) para cada Registro 450                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T.                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cAlias -> Alias do TRB que recebera as informacoes          ³±±
±±³          ³nRelac -> Flag de relacionamento com os sub-registro        ³±±
±±³          ³nItem -> Flag de relacionamento com os sub-registro         ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function RegC171(cAlias,nRelac,nItem,cAliasSFT,cAliasCD6, oRegC171, lGerouC170)

Local	aRegC171	:=	{}
Local 	aAreaCD6 	:= (cAliasCD6)-> (GetArea ())
Local 	cCD6Chv		:= (cAliasCD6)->(CD6_FILIAL+CD6_TPMOV+CD6_SERIE+CD6_DOC+CD6_CLIFOR+CD6_LOJA+CD6_ITEM+CD6_COD)
Local	lRet		:=	.T.
Local	nPos		:=	0
Local	nI          :=  1
Local	cTanque		:= ""                               

//Como o layout permite mais de um TANQUE por item, deve-se fazer este WHILE
While !(cAliasCD6)->(Eof()) .AND. ((cAliasCD6)->(CD6_FILIAL+CD6_TPMOV+CD6_SERIE+CD6_DOC+CD6_CLIFOR+CD6_LOJA+CD6_ITEM+CD6_COD)==cCD6Chv)

	cTanque := (cALiasCD6)->CD6_TANQUE

	If (!Empty(cTanque) .And. !oRegC171:hasProperty(cTanque))

		aAdd(aRegC171, {})
		nPos := Len(aRegC171)
		aAdd(aRegC171[nPos], "C171")								//01 - REG
		aAdd(aRegC171[nPos], cTanque)		 						//02 - NUM_TANQUE
		aAdd(aRegC171[nPos], {(cALiasCD6)->CD6_VOLUME, 3})			//03 - QTDE

		oRegC171[cTanque] := aRegC171
	Else		
		nPos := Len(oRegC171[cTanque])
		oRegC171[cTanque][nPos][3][1] += (cALiasCD6)->CD6_VOLUME
	EndIf
		
	(cALiasCD6)->(dbSkip())
End

If lGerouC170
	aChaves := oRegC171:GetNames()
	For nI:=1 to len(aChaves)
		GrvRegTrS(cAlias,nRelac,oRegC171[aChaves[nI]], nI)
		oRegC171:DelName(aChaves[nI])
	Next
Endif
RestArea(aAreaCD6)

Return (lRet)
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³RegC172   ³ Autor ³Gustavo G. Rueda       ³ Data ³04.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±³          ³              OPERACOES COM ISS (MODELO 01)                 ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao e gravacao do Registro C172                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com a informacao de ISS do Livro Fiscal³±±
±±³          ³ por item SFT posicionado no momento.                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³4(1:1) Para cada Registro C170                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T.                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cAlias -> Alias do TRB que recebera as informacoes          ³±±
±±³          ³nRelac -> Flag de relacionamento com os sub-registros       ³±±
±±³          ³cAliasSFT -> Alias da tabela SFT posicionada                ³±±
±±³          ³nItem -> Contador do item para cada documento fiscal.       ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function RegC172(cAliasSFT,cAlias,nRelac,nItem)

Local	aRegC172	:=	{}
Local	lRet   		:=	.T.
Local	nPos		:=	0

aAdd(aRegC172, {})
nPos := Len (aRegC172)
aAdd (aRegC172[nPos], "C172" )	 	   		   		//01 - REG 
aAdd (aRegC172[nPos], (cAliasSFT)->FT_BASEICM )		//02 - VL_BC_ISS_I
aAdd (aRegC172[nPos], (cAliasSFT)->FT_ALIQICM )		//03 - ALIQ_ISS
aAdd (aRegC172[nPos], (cAliasSFT)->FT_VALICM  )		//04 - VL_ISS_I

GrvRegTrS(cAlias,nRelac,aRegC172,nItem)	
Return (lRet)
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³RegC173   ³ Autor ³Gustavo G. Rueda       ³ Data ³04.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±³          ³           OPERACOES COM MEDICAMENTOS (MODELO 01)           ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao e gravacao do Registro C173                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³da funcao GrvRegTrS com a informacao do lote do produto(SB8)³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³4(1:1) Para cada Registro C170                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T.                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cAlias -> Alias do TRB que recebera as informacoes          ³±±
±±³          ³nRelac -> Flag de relacionamento com os sub-registros       ³±±
±±³          ³nItem -> Contador do item para cada documento fiscal.  	  ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function RegC173(cAlias,nRelac,nItem,lAchouF0A,oRegC173,lGerouC170)

Local	aReg		:=	{}
Local	lRet		:=	.T.
Local	nPos		:=	0
Local 	nI			:=  1

aAdd(aReg, {})
nPos	:=	Len (aReg)
	aAdd (aReg[nPos], "C173") //01 - REG

If lAchouF0A								
	aAdd (aReg[nPos], F0A->F0A_LOTE )						//02 - LOTE_MED
	aAdd (aReg[nPos], STR(F0A->F0A_QTDLOT))					//03 - QTD_ITEM
	aAdd (aReg[nPos], F0A->F0A_FABRIC )						//04 - DT_FAB
	aAdd (aReg[nPos], F0A->F0A_VALID )						//05 - DT_VAL
Else
	aAdd (aReg[nPos], CD7->CD7_LOTE )						//02 - LOTE_MED
	aAdd (aReg[nPos], STR(CD7->CD7_QTDLOT))					//03 - QTD_ITEM
	aAdd (aReg[nPos], CD7->CD7_FABRIC )						//04 - DT_FAB
	aAdd (aReg[nPos], CD7->CD7_VALID )						//05 - DT_VAL
Endif

	aAdd (aReg[nPos], CD7->CD7_REFBAS )						//06 - IND_MED
	aAdd (aReg[nPos], CD7->CD7_TPPROD )						//07 - TP_PROD
	aAdd (aReg[nPos], CD7->CD7_PRECO)						//08 - VL_TAB_MAX


oRegC173[cValToChar(nItem)] := aReg
If lGerouC170
	aChaves := oRegC173:GetNames()
	For nI:=1 to len(aChaves)
		GrvRegTrS(cAlias,nRelac,oRegC173[aChaves[nI]], nI)
		oRegC173:DelName(aChaves[nI])
	Next
Endif


Return (lRet)
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³RegC174   ³ Autor ³Gustavo G. Rueda       ³ Data ³04.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±³          ³          OPERACOES COM ARMAS DE FOGO (MODELO 01)           ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao e gravacao do Registro C174                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com a informacao de cada complemento   ³±±
±±³          ³ de produto (SB5) posicionado no momento.                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³4(1:1) Para cada Registro C170                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T.                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cAlias -> Alias do TRB que recebera as informacoes          ³±±
±±³          ³nRelac -> Flag de relacionamento com os sub-registros       ³±±
±±³          ³nItem -> Contador do item para cada documento fiscal.       ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function RegC174(cAlias,nRelac,nItem)

Local	aReg		:=	{}
Local	lRet		:=	.T.
Local	nPos		:=	0

aAdd(aReg, {})
nPos	:=	Len (aReg)
aAdd (aReg[nPos], "C174")											//01 - REG
aAdd (aReg[nPos], CD8->CD8_TPARMA)									//02 - IND_ARM
aAdd (aReg[nPos], CD8->CD8_NUMARM)									//03 - NUM_ARM
aAdd (aReg[nPos], CD8->CD8_DESCR)									//04 - DESCR_COMPL

GrvRegTrS(cAlias,nRelac,aReg,nItem)
Return (lRet)
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³RegC175   ³ Autor ³Gustavo G. Rueda       ³ Data ³04.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±³          ³          OPERACOES COM VEICULOS NOVOS (MODELO 01)          ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao e gravacao do Registro C175                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com a informacao de cada complemento   ³±±
±±³          ³ de produto (SB5) posicionado no momento.                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³4(1:1) Para cada Registro C170                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T.                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cAlias -> Alias do TRB que recebera as informacoes          ³±±
±±³          ³nRelac -> Flag de relacionamento com os sub-registros       ³±±
±±³          ³nItem -> Contador do item para cada documento fiscal.       ³±±
±±³          ³aPartDoc -> Informacoes sobre o participante do documento.  |±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function RegC175(cAlias,nRelac,nItem,aPartDoc,oRegC175,lGerouC170)

Local	aReg		:=	{}
Local	nPos		:=	0
Local   nI := 0

aAdd(aReg, {})
nPos	:=	Len (aReg)
aAdd (aReg[nPos], "C175")										//01 - REG
aAdd (aReg[nPos], CD9->CD9_TPOPER)								//02 - IND_VEIC_OPER
aAdd (aReg[nPos], aPartDoc[4])									//03 - CNPJ
aAdd (aReg[nPos], aPartDoc[13])									//04 - UF
aAdd (aReg[nPos], CD9->CD9_CHASSI)								//05 - CHASSI_VEIC

oRegC175[cValToChar(nItem)] := aReg
If lGerouC170
	aChaves := oRegC175:GetNames()
	For nI:=1 to len(aChaves)
		GrvRegTrS(cAlias,nRelac,oRegC175[aChaves[nI]], nI)
		oRegC175:DelName(aChaves[nI])
	Next
Endif


Return
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³RegC176   ³ Autor ³Gustavo G. Rueda       ³ Data ³28.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±³          ³                        RESSARCIMENTO                       ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao e gravacao do Registro C176                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com a informacao de ISS do Livro Fiscal³±±
±±³          ³ por item SFT posicionado no momento.                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³4(1:1) Para cada Registro C176                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nil                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cAlias    -> Alias do TRB que recebera as informacoes       ³±±
±±³          ³nRelac    -> Flag de relacionamento com os sub-registros    ³±±
±±³          ³nItem     -> Contador do item para cada documento fiscal.   ³±±
±±³          ³aCmpAntSFT-> Campos de cabecalho da tabela SFT              ³±±     
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function RegC176(cAlias,nRelac,nItem,aCmpAntSFT,aReg0150,aWizard,lCmpCD0,cNitem)

Local 	aRegC176 	:= 	{}
Local	aPartDoc	:=	{}
Local	aAreaSA2	:=	SA2->(GetArea())
Local   cChav		:=	CD0->(CD0_FILIAL+CD0_TPMOV+CD0_DOC+CD0_SERIE+CD0_CLIFOR+CD0_LOJA)
Local 	nPos 		:= 	0

default cNitem		:= ""

	While !CD0->(Eof()) .and. cChav == CD0->(CD0_FILIAL+CD0_TPMOV+CD0_DOC+CD0_SERIE+CD0_CLIFOR+CD0_LOJA)
		If CD0->CD0_EMISSAO<=aCmpAntSFT[5] .And. cNitem == CD0->CD0_ITEM
		
			
			//³GRAVACAO - REGISTRO 0150
			If SA2->(MsSeek(aSPDFil[PFIL_SA2]+CD0->(CD0_FORNE+CD0_LOJENT)))
				aPartDoc :=	InfPartDoc("SA2")
			EndIf

			//DSERFIS1-29000: Em caso de importação com ST e formulário próprio, um registro 0150 com os dados da
			//empresa deve ser criado
			If SPEDSeek("SF1", 1, aSPDFil[PFIL_SF1]+CD0->(CD0_DOCENT+CD0_SERENT+CD0_FORNE+CD0_LOJENT)) ;
				.And. SF1->F1_TIPO$"N" .And. SF1->F1_FORMUL == "S" .And. SA2->A2_CODPAIS <> "01058"
				aPartDoc :=	InfPartDoc("SM0")
			EndIf
				
			//³GRAVACAO REGISTRO 0150 - TABELA DE CADASTRO DE PARTICIPANTES
			//³GRAVACAO REGISTRO 0175 - ALTERACAO DA TABELA DE CADASTRO DE PARTICIPANTE
			SDPF150175(@aReg0150,aPartDoc,cAlias,aWizard,aExistBloc)
					
		
			//³GRAVACAO REGISTRO C176 - RESSARCIMENTO
			aAdd(aRegC176, {})
			nPos	:=	Len (aRegC176)
			aAdd (aRegC176[nPos], "C176")      				 			//01-REG
			aAdd (aRegC176[nPos], AModNot(CD0->CD0_ESPECIE)) 			//02-COD_MOD_ULT_E
			aAdd (aRegC176[nPos], CD0->CD0_DOCENT) 			 			//03-NUM_DOC_ULT_E
			aAdd (aRegC176[nPos], CD0->CD0_SERENT)	 		 			//04-SER_ULT_E
			aAdd (aRegC176[nPos], CD0->CD0_EMISSAO)			 			//05-DT_ULT_E
			aAdd (aRegC176[nPos], Iif(Len(aPartDoc)>0,aPartDoc[1],""))	//06-COD_PART_ULT_E
		   	aAdd (aRegC176[nPos], {CD0->CD0_QUANT,3})		 			//07-QUANT_ULT_E - quantidade da ultima entrada
			aAdd (aRegC176[nPos], {CD0->CD0_VUNIT,3})	   	 			//08-VL_UNIT_ULT_E
			aAdd (aRegC176[nPos], {CD0->CD0_VALBST,3})		 			//09-VL_UNIT_BC_ST			
			
			If cVersao >= "011"			
				If lCmpCD0 // Verifica se campos existem
					//³GRAVACAO - REGISTRO 0150 - 21 COD_PART_NFE_RET
					IF !Empty(CD0->CD0_PANFRT) .And. !Empty(CD0->CD0_LJPANF)
						If SA2->(MsSeek(aSPDFil[PFIL_SA2]+CD0->(CD0_PANFRT+CD0_LJPANF)))
							aPartDoc :=	InfPartDoc("SA2")
							SDPF150175(@aReg0150,aPartDoc,cAlias,aWizard,aExistBloc)
						EndIf
					Else
						aPartDoc	:=	{}
					Endif
					
					aAdd (aRegC176[nPos], CD0->CD0_CHVNFE)				//10-CHAVE_NFE_ULT_E				
					aAdd (aRegC176[nPos], CD0->CD0_ITENFE)				//11-NUM_ITEM_ULT_E				
					aAdd (aRegC176[nPos], Iif(CD0->CD0_VLUNOP > 0,CD0->CD0_VLUNOP,''))		//12-VL_UNIT_BC_ICMS_ULT_E
					aAdd (aRegC176[nPos], Iif(CD0->CD0_PICMSE > 0,CD0->CD0_PICMSE,''))		//13-ALIQ_ICMS_ULT_E
					aAdd (aRegC176[nPos], Iif(CD0->CD0_BSULMT > 0,CD0->CD0_BSULMT,''))		//14-VL_UNIT_LIMITE_BC_ICMS_ULT_E
					aAdd (aRegC176[nPos], Iif(CD0->CD0_VLUNCR > 0,{CD0->CD0_VLUNCR,3},'')) 	//15-VL_UNIT_ICMS_ULT_E
					aAdd (aRegC176[nPos], Iif(CD0->CD0_ALQSTE > 0,CD0->CD0_ALQSTE,''))		//16-ALIQ_ST_ULT_E
					aAdd (aRegC176[nPos], Iif(CD0->CD0_VLUNRE > 0,{CD0->CD0_VLUNRE,3},''))	//17-VL_UNIT_RES
					aAdd (aRegC176[nPos], CD0->CD0_RESPRE)				//18-COD_RESP_RET 	
					aAdd (aRegC176[nPos], CD0->CD0_MOTRES)				//19-COD_MOT_RES				
					aAdd (aRegC176[nPos], CD0->CD0_CHNFRT)				//20-CHAVE_NFE_RET				
					aAdd (aRegC176[nPos], Iif(Len(aPartDoc)>0,aPartDoc[1],""))				//21-COD_PART_NFE_RET							
					aAdd (aRegC176[nPos], CD0->CD0_SRNFRT)				//22-SER_NFE_RET				
					aAdd (aRegC176[nPos], CD0->CD0_NRNFRT)				//23-NUM_NFE_RET				
					aAdd (aRegC176[nPos], CD0->CD0_ITNFRT)				//24-ITEM_NFE_RET				
					aAdd (aRegC176[nPos], CD0->CD0_CODDA)				//25-COD_DA				
					aAdd (aRegC176[nPos], CD0->CD0_NUMDA)				//26-NUM_DA	
					If cVersao >= "013"
						If aSPDSX3[FP_CD0_FCPST]
							aAdd (aRegC176[nPos], CD0->CD0_FCPST)			//27-VL_UNIT_RES_FCP_ST
						Else
							aAdd (aRegC176[nPos], 0)
						Endif
					Endif
				Else
					aAdd (aRegC176[nPos], '')							//10-CHAVE_NFE_ULT_E				
					aAdd (aRegC176[nPos], '')							//11-NUM_ITEM_ULT_E				
					aAdd (aRegC176[nPos], 0)							//12-VL_UNIT_BC_ICMS_ULT_E				
					aAdd (aRegC176[nPos], 0)							//13-ALIQ_ICMS_ULT_E	
					aAdd (aRegC176[nPos], 0)							//14-VL_UNIT_LIMITE_BC_ICMS_ULT_E 				
					aAdd (aRegC176[nPos], 0)							//15-VL_UNIT_ICMS_ULT_E
					aAdd (aRegC176[nPos], 0)							//16-ALIQ_ST_ULT_E 								 				
					aAdd (aRegC176[nPos], 0)							//17-VL_UNIT_RES
					aAdd (aRegC176[nPos], '')							//18-COD_RESP_RET 	
					aAdd (aRegC176[nPos], '')							//19-COD_MOT_RES				
					aAdd (aRegC176[nPos], '')							//20-CHAVE_NFE_RET				
					aAdd (aRegC176[nPos], '')							//21-COD_PART_NFE_RET							
					aAdd (aRegC176[nPos], '')							//22-SER_NFE_RET				
					aAdd (aRegC176[nPos], '')							//23-NUM_NFE_RET				
					aAdd (aRegC176[nPos], '')							//24-ITEM_NFE_RET				
					aAdd (aRegC176[nPos], '')							//25-COD_DA				
					aAdd (aRegC176[nPos], '')							//26-NUM_DA	
					If cVersao >= "013"
						aAdd (aRegC176[nPos], 0)						//27-VL_UNIT_RES_FCP_ST
					Endif
				Endif	
			Endif

			RestArea(aAreaSA2)
		EndIf
		CD0->(DbSkip())
	EndDo
	//Ordenando Array pela emissao da ultima entrada e número de documento
	aRegC176 := aSort(aRegC176,,,{|x,y| x[5] < y[5] })	
	GrvRegTrS(cAlias,nRelac,aRegC176,nItem)			
Return
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³RegC177   ³ Autor ³Gustavo G. Rueda       ³ Data ³04.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±³          ³          OPERACOES COM SELO DE CONTROLE DE IPI             ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao e gravacao do Registro C177                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com a informacao de ISS do Livro Fiscal³±±
±±³          ³ por item SFT posicionado no momento.                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³4(1:1) Para cada Registro C177                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T.                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cAlias    -> Alias do TRB que recebera as informacoes       ³±±
±±³          ³nRelac    -> Flag de relacionamento com os sub-registros    ³±±
±±³          ³cAliasSFT -> Alias da tabela SFT posicionada                ³±±
±±³          ³nItem     -> Contador do item para cada documento fiscal.   ³±±
±±³          ³cAliasSB1 -> Alias da tabela SB1, podendo ser query         ³±±
±±³          ³aRegC170  -> Informacoes do registro C170                   ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function RegC177A(cAlias,nRelac,cAliasSFT,nItem,cAliasSB1,aRegC170)

Local	aReg		:=	{}
Local	lRet   		:=	.T.
Local	nPos		:=	0

aAdd(aReg, {})
nPos	:=	Len (aReg)
aAdd (aReg[nPos], "C177")	 	   	   					//01 - REG
aAdd (aReg[nPos], (cAliasSB1)->B1_CLASSE)				//02 - COD_SELO_IPI
aAdd (aReg[nPos], aRegC170[Len(aRegC170),5])	   		//03 - QT_SELO_IPI

GrvRegTrS(cAlias,nRelac,aReg,nItem)
Return (lRet)

//-------------------------------------------------------------------
/*/{Protheus.doc} RegC177B
REGISTRO C177: COMPLEMENTO DE ITEM - OUTRAS INFORMAÇÕES (código 01, 55) -(VÁLIDO A PARTIR DE 01/01/2019)

Este registro deverá ser apresentado somente pelos contribuintes obrigados por legislação específica de cada UF, com o
objetivo de agregar informações adicionais ao item, de acordo com tabela a ser publicada pela UF.

O código informado deve constar na tabela 5.6 – Tabela de Informações Adicionais dos Itens do Documento Fiscal.

@author Rafael dos Santos
@since 24.10.2018
@version 1.0
/*/
//-------------------------------------------------------------------
Static Function RegC177B(cAlias,nRelac,cAliasSFT,nItem)
Local	aReg		:=	{}
Local	lRet   		:=	.T.
Local	nPos		:=	0

aAdd(aReg, {})
nPos	:=	Len (aReg)
aAdd (aReg[nPos], "C177")	 	   	   					//01 - REG
aAdd (aReg[nPos], (cAliasSFT)->FT_INFITEM)				//02 - COD_INF_ITEM

GrvRegTrS(cAlias,nRelac,aReg,nItem)
Return (lRet)
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³RegC178   ³ Autor ³Gustavo G. Rueda       ³ Data ³04.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±³          ³ PRODUTOS SUJEITOS A TRIBUTACAO DE IPI POR UNIDADE OU QTD   ³±±
±±³          ³                                                            ³±±
±±³Descri‡…o ³Geracao e gravacao do Registro C178                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com todas as guias de recolhimento com ³±±
±±³          ³ a data de referencia no periodo apurado.                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³3(1:N) para cada Registro 450                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T.                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cAlias   -> Alias do TRB que recebera as informacoes        ³±±
±±³          ³nRelac   -> Flag de relacionamento com os sub-registro      ³±±
±±³          ³nItem    -> Flag de relacionamento com os sub-registro      ³±±
±±³          ³cAliasSB1-> Alias da tabela SB1, podendo ser query          ³±±
±±³          ³aRegC170  -> Informacoes do registro C170                   ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function RegC178(cAlias,cAliasSFT,nRelac,nItem,cAliasSB1,aRegC170)

Local	aRegC178	:=	{}
Local	lRet		:=	.T.
Local	nPos		:=	0
Local	nPauta		:=	0

If (cAliasSFT)->FT_PAUTIPI>0
	nPauta	:=	(cAliasSFT)->FT_PAUTIPI
ElseIf !Empty((cAliasSB1)->B1_TAB_IPI) .And. (cAliasSB1)->B1_VLR_IPI>0
	nPauta	:=	(cAliasSB1)->B1_VLR_IPI
EndIf				

aAdd(aRegC178, {})
nPos	:=	Len (aRegC178)
aAdd (aRegC178[nPos], "C178")							//01 - REG
aAdd (aRegC178[nPos], (cAliasSB1)->B1_TAB_IPI)			//02 - CL_ENQ
aAdd (aRegC178[nPos], nPauta)							//03 - VL_UNID
aAdd (aRegC178[nPos], {aRegC170[Len(aRegC170),5,1],3})	//04 - QUANT_PAD

GrvRegTrS(cAlias,nRelac,aRegC178,nItem)	
Return (lRet)
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³RegC190   ³ Autor ³Gustavo G. Rueda       ³ Data ³04.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±³          ³      REGISTRO ANALITICO DO DOCUMENTO (MODELO 01, 04 e 55)  ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao do Registro C190                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com as informacoes contidas no array   ³±±
±±³          ³ aRegC170(Itens) aglutinados CFOP, CST e ALIQ.              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³3(1:N) Para cada Registro C100                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T.                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³aRegC170  -> Informacoes dos Itens do documento fiscal      ³±±
±±³          ³cAliasSFT -> Alias da tabela SFT posicionada no momento     ³±±
±±³          ³aRegC190  -> Array contendo as informacoes aglutinadas do   ³±±
±±³          ³ do documento fiscal para posterior geracao na funcao prin- ³±±
±±³          ³ cipal.                                                     |±±
±±³          ³cSituaDoc -> Situacao do documento fiscal                   |±±
±±³          ³aLanCda   -> Lancamentos do documento fiscal - CDA		  |±±
±±³          ³nRedBSICM -> Valor de reducao da base de calculo do ICMS    |±±
±±³          ³cAliasSF4-> Informa qual o alias da tabela SF4, podendo ser ³±±
±±³          ³            query                                           ³±±
±±³          ³cMVCFC195 -> CFOP's que nao vao gerar C195			      |±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function RegC190(aRegC170,cAliasSFT,aRegC190,cSituaDoc,aLanCda,nRedBSICM,cAliasSF4,cMVCFC195,cSitDocInf,cEspecie,aRegC191,aWizard)
	
	Local   lConsumo	:= .F.
	Local	lAtvPerm	:= .F.
	Local 	lRedBSICM	:=	cSituaDoc$"00/01/06" .AND. substr(aRegC170[1][10],2,2)$'20/70'
	Local	nPos		:=	0
	Local	nPosIt		:=	0
	Local	nPos191		:=	0
	Local	nVlFcpRet	:=  0
	Local	nVlFcpOP	:=  0
	Local	nVlFcpST	:=  0
	
	//Identificacao de material de uso e consumo
	If Substr(Alltrim((cAliasSFT)->FT_CFOP),2,3)$"97 " .Or.;
		(Substr(Alltrim((cAliasSFT)->FT_CFOP),2,3)$"556" .And. Substr(Alltrim((cAliasSFT)->FT_CLASFIS),2,2)<>"40") 
    	lConsumo := .t.             
	EndIf

	//Identificacao de ativo permanente
	If Substr(Alltrim((cAliasSFT)->FT_CFOP),2,3)$"91 " .Or. Substr(Alltrim((cAliasSFT)->FT_CFOP),2,3)$"551"
    	 lAtvPerm := .t.
	EndIf
	
	If (nPos := aScan (aRegC190, {|aX| aX[2]==aRegC170[1][10] .And. aX[3]==aRegC170[1][11] .And. aX[4]==aRegC170[1][14]}) ) == 0
		aAdd(aRegC190, {})
		nPos	:=	Len(aRegC190)
		aAdd (aRegC190[nPos], "C190")	 	   										//01 - REG
		aAdd (aRegC190[nPos], aRegC170[1][10])										//02 - CST
		aAdd (aRegC190[nPos], aRegC170[1][11])										//03 - CFOP
		aAdd (aRegC190[nPos], aRegC170[1][14])										//04 - ALIQ_ICMS
		aAdd (aRegC190[nPos], 0)		 		 									//05 - VL_OPR
		aAdd (aRegC190[nPos], 0)													//06 - VL_BC_ICMS
		aAdd (aRegC190[nPos], 0)	 		  										//07 - VL_ICMS
		aAdd (aRegC190[nPos], 0)	 												//08 - VL_BC_ICMS_ST
		aAdd (aRegC190[nPos], 0)	 		  										//09 - VL_ICMS_ST
		aAdd (aRegC190[nPos], 0)  			  										//10 - VL_RED_BC
		aAdd (aRegC190[nPos], 0)	 												//11 - VL_IPI

		If cVersao >= "003"
			aAdd (aRegC190[nPos], "") 		  										//12 - COD_OBS - LAYOUT 2010
			/*Quando este array estiver com conteudo, jah terah de todos os itens,
			 neste caso, preciso obter somente o lancamento do referido item */
			If Len(aLanCDA)>0 .And. (nPosIt := aScan(aLanCDA,{|aX|aX[14]==(cAliasSFT)->FT_ITEM}))>0
				If aSPDSX6[MV_ESTADO] == "SC" //PORTARIA SEF Nº 287/2011
					aRegC190[nPos][12]  :=  ""
				Else
					aRegC190[nPos][12]  :=  aLanCDA[nPosIt,7]
				EndIf
			Elseif Empty(aRegC190[nPos][12])
				If !Empty((cAliasSF4)->F4_CODOBSE) .And. !(Alltrim((cAliasSFT)->FT_CFOP)$cMVCFC195)
			   		aRegC190[nPos][12] := (cAliasSF4)->F4_CODOBSE
		   		EndIf 
		   	EndIf					
  		EndIf
		aAdd (aRegC190[nPos], RetRD(GetRelacPr())+strzero(nPos,nTamFT_IT * 2))		//13 - Posição de Hierarquia  		
	EndIf
	
	If !cSituaDoc$"02#03#04#05"
		// MV_VLCTBZL -> Indique os CFOP's que terao os seus Valores contabeis Zerados no Livros de Entrada e Saida. - 16/10/2017 - Vitor Ribeiro (vitor.e@totvs.com.br) 
		If !(AllTrim((cAliasSFT)->FT_CFOP) $ aSPDSX6[MV_VLCTBZL])
			aRegC190[nPos][5]	+=	(cAliasSFT)->FT_VALCONT	 		  				//05 - VL_OPR
		EndIf
		aRegC190[nPos][6]		+=	aRegC170[1][13]					  				//06 - VL_BC_ICMS
		aRegC190[nPos][7]		+=	aRegC170[1][15]					  				//07 - VL_ICMS
		aRegC190[nPos][8]		+=	aRegC170[1][16]			  		  				//08 - VL_BC_ICMS_ST
		aRegC190[nPos][9]		+=	aRegC170[1][18]			  		  				//09 - VL_ICMS_ST
		aRegC190[nPos][10]		+=	Iif(nRedBSICM < 0, 0 ,iif(lRedBSICM,nRedBSICM,0))	//10 - VL_RED_BC - Validacao utilizada para casos em que a reducao de base eh maior do que 100%				
		aRegC190[nPos][11]		+=	aRegC170[1][24]				   						//11 - VL_IPI

		nVlFcpOP  := Iif(aRegC190[nPos][7] > 0,(cAliasSFT)->FT_VALFECP,0)
		nVlFcpST  := Iif(aRegC190[nPos][9] > 0,(cAliasSFT)->FT_VFECPST,0)
		nVlFcpRet := Iif(aSPDSX3[FP_FT_VFCPANT],(cAliasSFT)->FT_VFCPANT,0)
	

		//REGISTRO C191: INFORMAÇÕES DO FUNDO DE COMBATE À POBREZA – FCP – NA NFe (CÓDIGO 55)		
		If aWizard[1][23]=="1-Sim" .and. cVersao >= "013" .and. cEspecie $ Iif(cVersao >= "014","55|65","55")
			If (nVlFcpOP+nVlFcpST+nVlFcpRet) > 0
				IF (nPos191 := aScan (aRegC191, {|aX| aX[1]==nPos}) ) == 0
					aAdd(aRegC191, {})
					nPos191	:=	Len(aRegC191)
					aAdd (aRegC191[nPos191], nPos)	 		//Relação com Registro C190 Pai
					aAdd (aRegC191[nPos191], "C191")		//01 - REG
					aAdd (aRegC191[nPos191], nVlFcpOP)		//02 - VL_FCP_OP
					aAdd (aRegC191[nPos191], nVlFcpST)		//03 - VL_FCP_ST
					aAdd (aRegC191[nPos191], nVlFcpRet)		//04 - VL_FCP_RET
					aAdd (aRegC191[nPos191], RetRD(GetRelacPr())+strzero(nPos,nTamFT_IT * 2))		//5 - Posição de Hierarquia  		
				Else
					aRegC191[nPos191][3]	+=	nVlFcpOP	//02 - VL_FCP_OP
					aRegC191[nPos191][4]	+=	nVlFcpST	//03 - VL_FCP_ST
					aRegC191[nPos191][5]	+=	nVlFcpRet	//04 - VL_FCP_RET
				Endif
			Endif
		Endif
	Endif
	
Return
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³Programa  ³C195C197  ³ Autor ³Gustavo G. Rueda       ³ Data ³15.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³     REGISTRO C195 - OBSERVACOES DO LANCAMENTO FISCAL       ³±±
±±³          ³                    (CODIGO 01 E 55)                        ³±±
±±³          ³REGISTRO C197 - OUTRAS OBRIGACOES TRIBUTARIAS, AJUSTES E    ³±±
±±³          ³                INFORMACOES DE VALORES                      ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao e gravacao dos Registros C195 e C197              ³±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com o embasamento legal para tais      ³±±
±±³          ³ observacoes                                                ³±±
±±³Nivel Hier³3(1:N) Para cada C100                                       ³±±
±±³          ³4(1:N) Para cada C195                                       ³±±
±±³Retorno   ³Nil                                                         ³±±
±±³Parametros³cAlias -> Alias do TRB que recebera as informacoes          ³±±
±±³          ³nRelac -> Flag de relacionamento com os sub-registros       ³±±
±±³          ³aLanCDA-> Array com os lancamentos da tabela CDA            ³±±
±±³          ³aReg0460-> Array com a estrutura do registro 0460           ³±±
±±³          ³aCmpAntSFT-> Campos da tabela SFT do documento em           ³±±
±±³          ³             processamento                                  ³±±
±±³          ³cEspecie-> Especie do document fiscal                       ³±±
±±³          ³aC195aux-> Array auxiliar com o codigo da observacao do     ³±±
±±			 ³lancamento fiscal (F4_CODOBSE)           					  ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function C195C197( cAlias, nRelac, aLanCDA, aReg0460, aCmpAntSFT, cEspecie, aC195aux, cMVEstado, aReg0200, aReg0190, aReg0220, dDataDe, dDataAte,cMVSPDTC95, aWizard  )

Local	nPos		:=	0
Local	nX			:=	0
Local	nPosC195	:=	0
Local	aRegC195	:=	{}
Local	aRegC197	:=	{}
Local	cCodItem	:=	""
Local 	aSpdInfo	:= 	{}
Local 	cEntSai		:=	Iif ("E"$aCmpAntSFT[43], "1", "2")
Local	lShowVlBC   := .T.
Local	lShowAliq   := .T.
Local	lShowVlIC   := .T.
Local	lShowVlOut  := .T.
Local	lSomaVlOut	:= .T.

Default aC195aux 	:=	{}
Default cMVSPDTC95 	:= "1"
DEFAULT aWizard		:= 	{}

//Processando lancamentos do documento fiscal relacionados no CDA
For nX := 1 to len(aLanCDA)

	// -------------------------------------------------------------------------------------------------------
	// A validacao para modelo 55(NFe) de Emissao propria foi retirada da funcao C195C197() - esta validacao
	// fazia com que o campo 04 - COD_ITEM do Registro C197 ficasse em branco - pois segundo o Guia Pratico
	// quando se enquadrar nesta situacao, o campo 04 deve ser gerado e o item deve gerar um registro 0200 para
	// este produto.
	//
	// Campo 04 - Preenchimento: deve ser informado se o ajuste/benefício for relacionado ao produto. Porém, quando não
	// houver registro C170, como NF-e de emissão própria, o COD_ITEM deverá ser informado no registro 0200.
	// -------------------------------------------------------------------------------------------------------
	cCodItem	:=	aLanCDA[nX,13]

	//³Para lançamentos com código RO10000012, no registro C197 não deverá preencher o campo COT_ITEM, ³
	//³conforme item 1, 3, 6, 7 e 8 do anexo da instrução normativa 005/12 para o Estado de Rondoônia. ³
	IF aLanCDA[nX,1] $ "RO10000012/RO10000006/RO10000007/RO10000003/RO40000001/RO40000002/RO99990009/RO99990016/RO99990017/RO99990068/RO99990165/RO99990195/RO99990166/RO99990170/RO99990183/RO99990175/RO99990021/RO99990130/RO99990022/RO99990037/RO99990086/RO99990116/RO20000002/RO99990078/RO99990083"
		cCodItem	:=	""
	EndIF

	If !aLanCDA[nX,24]  // Legado
		lShowVlBC   := .T.
		lShowAliq   := .T.
		lShowVlOut  := .T.
		lShowVlIC   := .T.
		lSomaVlOut  := .T.

		IF aLanCDA[nX,1] $ "SP90090104/SP90090278"
			cCodItem	:=	""
			lShowVlBC   := .F.
			lShowAliq   := Iif(aLanCDA[nX,1] == "SP90090104" .And. aLanCDA[nX,5] == 0 .And. aLanCDA[nX,6] == 0, .T., .F.)
			lShowVlOut  := Iif(aLanCDA[nX,1] == "SP90090104", .T., .F.)
		Elseif aLanCDA[nX,1] $ "SP90090106"
			// Define que não será somado valor por se tratar de % do IVA-ST
			lSomaVlOut  := .F.	
		EndIF
		
		IF aLanCDA[nX,1] $ "RJ90980000/RJ90980001" 
			lShowVlIC   := .F.
			lShowVlBC   := .F.
			lShowAliq   := .F.
		EndIF

		IF aLanCDA[nX,1] $ "GO40000029" 
			lShowVlBC   := .F.
			lShowAliq   := .F.
			lShowVlOut  := .F.
		EndIF

		//³AQUISIÇÃO, EM OUTRA UNIDADE DA FEDERAÇÃO, DE BENS OU MERCADORIAS DESTINADOS AO USO, CONSUMO OU ATIVO FIXO (INCISO VI   ³
		//³DO ART. 5º DA LEI N. 1.810/1997), POR CONTRIBUINTE SUJEITO À APURAÇÃO E PAGAMENTO DO ICMS, NA MODALIDADE DE DIFERENCIAL³
		//³DE ALÍQUOTA, NO PRAZO ESTABELECIDO NO CALENDÁRIO FISCAL OU NO MOMENTO DA ENTRADA EM TERRITÓRIO ESTADUAL.               ³
		//³GOVERNO DO ESTADO DE MATO GROSSO DO SUL - CÓDIGO DE AJUSTE MS70000001 / MS40000001  									  ³	
		//³ http://www.efd.ms.gov.br/index.php?inside=1&tp=3&comp=&show=4728 - DIFAL												  ³
		If cMVEstado$"MS" .And. aLanCDA[nX,1]$"MS70000001/MS40000001" 
			aLanCDA[nX][4] := aLanCDA[nX][4] - aCmpAntSFT[11] 
		Endif

	Endif
	
	//³Geracao do REGISTRO C195 ³
	If (nPosC195 := aScan(aRegC195,{|aX| aX[2]==aLanCDA[nX][07]})) == 0

		aAdd(aRegC195, {})
		nPosC195	:=	Len (aRegC195)
		aAdd (aRegC195[nPosC195], "C195")		 	   					//01 - REG
		aAdd (aRegC195[nPosC195], aLanCDA[nX][07])						//02 - COD_OBS
		aAdd (aRegC195[nPosC195], If(AllTrim(cMVSPDTC95) <> "4",aLanCDA[nX][17], " "))	//03 - TXT_COMPL		
		aAdd (aRegC195[nPosC195], RetRD(GetRelacPr())+strzero(nPosC195,nTamFT_IT))		//04 - Posição de Hierarquia
			
		//³REGISTRO 0460 - TABELA DE OBSERVACOES DO LANCAMENTO FISCAL      ³
		Reg0460(@aReg0460,{aRegC195[nPosC195][2],aLanCDA[nX][20]})

	EndIf

	If !aLanCDA[nX,24] // Legado (Código de lançamento vindo da TES)
		If aLanCDA[nX,1]$"SP90090104/SP90090278"
			nPos := aScan(aRegC197,{|x| x[1] == nPosC195 .And. x[3]==aLanCDA[nX,1] .And. x[4]==aLanCDA[nX][2] })
		Else
			nPos := aScan(aRegC197,{|x| x[1] == nPosC195 .And. x[5]==cCodItem .And. x[3]==aLanCDA[nX,1] })
		EndIf
	Else
		//Estrutura do configurador
		If aLanCDA[nX,23] == "01"
			nPos := aScan(aRegC197,{|x| x[1] == nPosC195 .And. x[3]==aLanCDA[nX,1] })
		ElseIf aLanCDA[nX,23] == "02"
			nPos := aScan(aRegC197,{|x| x[1] == nPosC195 .And. x[3]==aLanCDA[nX,1] .And. x[4]==aLanCDA[nX][2] })
		Elseif aLanCDA[nX,23] == "03"
			nPos := aScan(aRegC197,{|x| x[1] == nPosC195 .And. x[5]==cCodItem .And. x[3]==aLanCDA[nX,1] })
		Else
			nPos := aScan(aRegC197,{|x| x[1] == nPosC195 .And. x[5]==cCodItem .And. x[3]==aLanCDA[nX,1] })
		Endif	
	Endif
	//³Geracao do REGISTRO C197 ³
	If nPos == 0
		aAdd(aRegC197, {})
		nPos	:=	Len (aRegC197)
		aAdd (aRegC197[nPos], nPosC195)									//01 - RELACIONAMENTO COM C195 (PAI)
		aAdd (aRegC197[nPos], "C197")	   								//02 - REG
		aAdd (aRegC197[nPos], aLanCDA[nX,1])				       		//03 - COD_AJ
		aAdd (aRegC197[nPos], aLanCDA[nX][2])					   		//04 - DESCR_COMPL_AJ
		aAdd (aRegC197[nPos], cCodItem)									//05 - COD_ITEM
		aAdd (aRegC197[nPos], Iif(!aLanCDA[nX,24], Iif(lShowVlBC, aLanCDA[nX][3], ''), aLanCDA[nX][3]))		//06 - VL_BC_ICMS
		aAdd (aRegC197[nPos], Iif(!aLanCDA[nX,24], Iif(lShowAliq, aLanCDA[nX][4], ''), aLanCDA[nX][4]))	 	//07 - ALIQ_ICMS
		aAdd (aRegC197[nPos], Iif(!aLanCDA[nX,24], Iif(lShowVlIC, aLanCDA[nX][5], ''), aLanCDA[nX][5]))		//08 - VL_ICMS
		aAdd (aRegC197[nPos], Iif(!aLanCDA[nX,24], Iif(lShowVlOut, aLanCDA[nX][6], ''), aLanCDA[nX][6]))	//09 - VL_OUTROS
		aAdd (aRegC197[nPos], RetRD(GetRelacPr())+strzero(nPosC195,nTamFT_IT))
	Else
		aRegC197[nPos][6]	+= Iif(!aLanCDA[nX,24], Iif(lShowVlBC, aLanCDA[nX][3], Iif( ValType(aRegC197[nPos][6]) == "C", "", 0.00)), aLanCDA[nX][3])	//06 - VL_BC_ICMS
		aRegC197[nPos][8]	+= Iif(!aLanCDA[nX,24], Iif(lShowVlIC, aLanCDA[nX][5], Iif( ValType(aRegC197[nPos][8]) == "C", "", 0.00)), aLanCDA[nX][5])	//08 - VL_ICMS
		aRegC197[nPos][9]	+= Iif(!aLanCDA[nX,24], Iif(lShowVlOut .And. lSomaVlOut, aLanCDA[nX][6], Iif( ValType(aRegC197[nPos][9]) == "C", "", 0.00)) , aLanCDA[nX][6])	//09 - VL_OUTROS
	EndIf    
	//³Tratamento para que os itens utilizados seja gerados no 0200³
	If !Empty( cCodItem ) .And.  aScan ( aReg0200, { |aX| aX[2] == cCodItem }) == 0
		SPEDSeek("SB1",,aSPDFil[PFIL_SB1]+cCodItem)
		SFRG0200( cAlias, @aReg0200, @aReg0190, dDataDe, dDataAte, ,cCodItem , @aReg0220,,,,,,,,,,,,,,,,,,,aWizard  )
	EndIf	

Next        

If !aExistBloc[23] 
	//³Geracao do REGISTRO C195 ³
	For nX := 1 To Len(aC195aux)  
		If (nPos195 := aScan(aRegC195,{|aX| aX[2]==aC195aux[nX][1]}))==0
			aAdd(aRegC195, {})
			nPos195	:=	Len (aRegC195)
			aAdd (aRegC195[nPos195], "C195")		 	   					//01 - REG
			aAdd (aRegC195[nPos195], aC195aux[nX][1])						//02 - COD_OBS
			aAdd (aRegC195[nPos195], aC195aux[nX][3])		   				//03 - TXT_COMPL
			aAdd (aRegC195[nPos195], RetRD(GetRelacPr())+strzero(nPos195,nTamFT_IT))		//04 - Posição de Hierarquia
			
			//³REGISTRO 0460 - TABELA DE OBSERVACOES DO LANCAMENTO FISCAL      ³
			Reg0460(@aReg0460,{aC195aux[nX][1],aC195aux[nX][4]})
		Endif			
	Next nX

Else

	// Geração do registro C195 e 0460 apartir do PE SPDPINFO //
	aSpdInfo	:=	ExecBlock("SPDPINFO",.F.,.F.,{	aCmpAntSFT[1],; 		//FT_NFISCAL
														aCmpAntSFT[2],; 	//FT_SERIE
														aCmpAntSFT[3],; 	//FT_CLIEFOR
														aCmpAntSFT[4],; 	//FT_LOJA
														aCmpAntSFT[5],;		//FT_ENTRADA
														cEntSai})			//Entrada/Saida
	//Geracao do REGISTRO C195 
	For nX := 1 To Len(aSpdInfo)  
		If (nPos195 := aScan(aRegC195,{|aX| aX[2]==aSpdInfo[nX][1]}))==0
			aAdd(aRegC195, {})
			nPos195	:=	Len (aRegC195)
			aAdd (aRegC195[nPos195], "C195")		 	   					//01 - REG
			aAdd (aRegC195[nPos195], aSpdInfo[nX][1])		 				//02 - COD_OBS
			aAdd (aRegC195[nPos195], aSpdInfo[nX][2])		   				//03 - TXT_COMPL
			aAdd (aRegC195[nPos195], RetRD(GetRelacPr())+strzero(nPos195,nTamFT_IT))		//04 - Posição de Hierarquia
			
			
			
			//REGISTRO 0460 - TABELA DE OBSERVCOES DO LANCAMENTO FISCAL  
			Reg0460(@aReg0460,aSpdInfo[nX])
		Endif			
	Next nX
Endif

//GrRegDep(cAlias,aRegC195,aRegC197,,,,nRelac)
GrRegDep(cAlias, aRegC195, aRegC197,,,,,,.T.,.T.)

Return
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³RegC300   | Autor ³Gustavo G. Rueda 			   ³ Data ³09.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡ao ³Funcao que efetua a criaca do array responsavel pela geracao do    ³±±
±±³          ³ registro C300 - RESUMO DIARIO DAS NOTAS FISCAIS DE VENDA A        ³±±
±±³          ³ CONSUMIDOR FINAL (CODIGO 02). Este array eh gravado no arquivo de ³±±
±±³          ³ trabalho do SPED Fiscal no final do processamento da rotina.      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ExpL1 := RegC300(cSituaDoc,cEspecie,aRegC300,cAliasSFT)            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cPar1 - Variavel que possui o status do documento fiscal           ³±±
±±³          ³cPar2 - Variavel que possui a especie do documento fiscal          ³±±
±±³          ³aPar3 - Variavel array com as informacoes para geracao do registro ³±±
±±³          ³cPar4 - Alias da tabela SFT em processamento                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpN1 - Posicao de gravacao do registro para relacionamento com    ³±±
±±³          ³        seus registros filhos, C310, C320 e C321.                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGAFIS - SPEDFISCAL                                              ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function RegC300(cSituaDoc,cEspecie,aRegC300,cAliasSFT,lNotaC300,aWizard)

Local cNotaC300	:= ""
Local cContCtb	:= RetCOD_CTA(cAliasSFT, "C300")
Local nPosC300	:= 0

Default aWizard	:= {}

If Len(AllTrim((cAliasSFT)->FT_NFISCAL)) > 6 .And.  Val(Left(AllTrim((cAliasSFT)->FT_NFISCAL),Len(AllTrim((cAliasSFT)->FT_NFISCAL))-6)) > 0
	lNotaC300   := .F.
EndIf
cNotaC300   := Right(AllTrim((cAliasSFT)->FT_NFISCAL),6)

//REGISTRO C300 - RESUMO DIARIO DAS NOTAS FISCAIS DE VENDA A CONSUMIDOR(MODELO 02)

If (nPosC300 := aScan(aRegC300,{|aX| aX[2]==cEspecie .And. aX[3]==(cAliasSFT)->FT_SERIE .And. aX[7]==(cAliasSFT)->FT_ENTRADA}))==0
	aAdd(aRegC300, {})
	nPosC300	:=	Len (aRegC300)
	aAdd (aRegC300[nPosC300], "C300")	 	   		   									//01 - REG
	aAdd (aRegC300[nPosC300], cEspecie)		  											//02 - COD_MOD
	aAdd (aRegC300[nPosC300], (cAliasSFT)->FT_SERIE)									//03 - SER
	aAdd (aRegC300[nPosC300], "")														//04 - SUB
	aAdd (aRegC300[nPosC300], cNotaC300)												//05 - NUM_DOC_INI
	aAdd (aRegC300[nPosC300], cNotaC300)		   										//06 - NUM_DOC_FIN
	aAdd (aRegC300[nPosC300], (cAliasSFT)->FT_ENTRADA)									//07 - DT_DOC
	aAdd (aRegC300[nPosC300], 0)														//08 - VL_DOC
	aAdd (aRegC300[nPosC300], 0)														//09 - VL_PIS
	aAdd (aRegC300[nPosC300], 0)														//10 - VL_COFINS
	aAdd (aRegC300[nPosC300], Iif(!Empty(cContCtb),cContCtb,(cAliasSFT)->FT_CONTA))		//11 - COD_CTA
EndIf

//Range de Numero de Documentos
If cNotaC300 < aRegC300[nPosC300][5]
	aRegC300[nPosC300][5]	:=	cNotaC300												//05 - NUM_DOC_INI
EndIf

If (cNotaC300 > aRegC300[nPosC300][6])
	aRegC300[nPosC300][6]	:=	cNotaC300												//06 - NUM_DOC_FIN
EndIf

If !cSituaDoc$"02#03"	//02=Situacao de cancelada
	aRegC300[nPosC300][8]	+=	(cAliasSFT)->FT_VALCONT									//08 - VL_DOC - valor líquido acumulado do item, já considerado o valor do desconto incondicional.
	aRegC300[nPosC300][9]	+=	Iif("1"$aWizard[1][15],(cAliasSFT)->FT_VALPIS,0)		//09 - VL_PIS
	aRegC300[nPosC300][10]	+=	Iif("1"$aWizard[1][15],(cAliasSFT)->FT_VALCOF,0)		//10 - VL_COFINS
EndIf

Return nPosC300
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³RegC310   | Autor ³Gustavo G. Rueda 			   ³ Data ³09.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡ao ³Funcao que efetua a criaca do array responsavel pela geracao do    ³±±
±±³          ³ registro C310 - DOCUMENTOS CANCELADOS DE NOTAS FISCAIS DE VENDA A ³±±
±±³          ³ CONSUMIDOR FINAL (CODIGO 02). Este array eh gravado no arquivo de ³±±
±±³          ³ trabalho do SPED Fiscal no final do processamento da rotina.      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³RegC310(nPosC300,aRegC310,cAliasSFT)   			                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³nPar1 - Variavel que possui a posicao de relacionamento com o C300 ³±±
±±³          ³aPar2 - Variavel array com as informacoes para geracao do registro ³±±
±±³          ³cPar3 - Alias da tabela SFT em processamento                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nil                                                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGAFIS - SPEDFISCAL                                              ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function RegC310(nPosC300,aRegC310,cAliasSFT)

Local 	cNFiscal  	:= Right(AllTrim((cAliasSFT)->FT_NFISCAL),6)
Local	nPosC310	:=	0     

If aScan(aRegC310,{|aX| aX[1]==nPosC300 .And. aX[3]==cNFiscal})==0
	aAdd(aRegC310, {})
	nPosC310	:=	Len (aRegC310)
	aAdd (aRegC310[nPosC310], nPosC300)	 	   			//CHAVE PARA RELACIONAMENTO COM REGISRO PAI
	aAdd (aRegC310[nPosC310], "C310")					//01 - REG
	aAdd (aRegC310[nPosC310], cNFiscal)					//02 - NUM_DOC_CANC
EndIf
Return
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³C320C321  | Autor ³Gustavo G. Rueda 			   ³ Data ³09.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡ao ³Funcao que efetua a criaca do array responsavel pela geracao do    ³±±
±±³          ³ registro C320 - REGISTRO ANALITIDO DO RESUMO DIARIO DAS NOTAS     ³±±
±±³          ³ FISCAIS DE VENDA A CONSUMIDOR FINAL (CODIGO 02) e registro C321 - ³±±
±±³          ³ ITENS DO RESUMO DIARIO DOS DOCUMENTOS (CODIGO 02). Este array eh  ³±±
±±³          ³ gravado no arquivo de trabalho do SPED Fiscal no final do         ³±±
±±³          ³ processamento da rotina.                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³C320C321(nPosC300,cSituaDoc,aRegC170,aRegC320,aRegC321,cAliasSFT,  ³±±
±±³						cAliasSF4)												 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³nPar1 - Variavel que possui a posicao de relacionamento com o C300 ³±±
±±³          ³aPar2 - Variavel array com as informacoes jah processadas e armaze-³±±
±±³          ³        nadas anteriormente, assim fica uma unica origem           ³±±
±±³          ³aPar3 - Variavel array com as informacoes para geracao do registro ³±±
±±³          ³aPar4 - Variavel array com as informacoes para geracao do registro ³±±
±±³          ³cPar5 - Alias da tabela SFT em processamento                       ³±±
±±³          ³aPar6 - array com os lancamentos do documento fiscal               ³±±
±±³          ³nPar7 - Valor de reducao da base de calculo do ICMS                |±±
±±³          ³cPar8 -> Alias da tabela SF4 em processamento   					 ³±±
±±³          ³aPar9 -> Array com lancamentos de documento nao amarrados ao C197  ³±±
±±³          ³aPar10-> Array com a estrutura do 0460 gerado ateh o momento.      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nil                                                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGAFIS - SPEDFISCAL                                              ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function C320C321(nPosC300,aRegC170,aRegC320,aRegC321,cAliasSFT,aLanCDA,nRedBSICM,cAliasSF4,aLancFis,aReg0460,aWizard,cPerfil,aRegC330)

Local	nPosC320	:=	0
Local	nPosC321	:=	0	

Default aWizard		:= {}
//REGISTRO C320 - REGISTRO ANALITICO DO RESUMO DIARIO DAS NOTAS FISCAIS DE VENDA A CONSUMIDOR 
If (nPosC320 := aScan(aRegC320,{|aX| aX[1]==nPosC300 .And. aX[3]==aRegC170[1][10] .And. aX[4]==aRegC170[1][11] .And. aX[5]==aRegC170[1][14]}))==0
	aAdd(aRegC320, {})
	nPosC320	:=	Len (aRegC320)
	aAdd (aRegC320[nPosC320], nPosC300)	 	   						//CHAVE PARA RELACIONAMENTO COM REGISRO PAI		
	aAdd (aRegC320[nPosC320], "C320")	 	   						//01 - REG
	aAdd (aRegC320[nPosC320], aRegC170[1][10])						//02 - CST_ICM
	aAdd (aRegC320[nPosC320], aRegC170[1][11])						//03 - CFOP
	aAdd (aRegC320[nPosC320], aRegC170[1][14])						//04 - ALIQ_ICM
	aAdd (aRegC320[nPosC320], 0 )									//05 - VL_OPR
	aAdd (aRegC320[nPosC320], 0 )									//06 - VL_BC_ICM
	aAdd (aRegC320[nPosC320], 0 )									//07 - VL_ICMS
	aAdd (aRegC320[nPosC320], 0 )									//08 - VL_RED_BC
	aAdd (aRegC320[nPosC320], "")						

	//Se houver lancamento fiscal nao amarrado ao C197, devo prioriza-lo
	If Len(aLancFis)>=1
   		aRegC320[nPosC320,10] := aLancFis[1,1]

		//REGISTRO 0460 - TABELA DE OBSERVACOES DO LANCAMENTO FISCAL
   		Reg0460(@aReg0460,{aLancFis[1,1],aLancFis[1,2]})

	//Quando este array estiver com conteudo, jah terah de todos os itens,
	// neste caso, preciso obter somente o lancamento do referido item  
	ElseIf Len(aLanCDA)>0 .And. (nPosIt := aScan(aLanCDA,{|aX|aX[14]==(cAliasSFT)->FT_ITEM}))>0
		aRegC320[nPosC320,10]  :=  aLanCDA[nPosIt,7]				//09 - COD_OBS

	EndIf
EndIf
aRegC320[nPosC320][6]		+=	(cAliasSFT)->FT_VALCONT				//05 - VL_OPR - Valor total acumulado das operações correspondentes à combinação de CST_ICMS, CFOP e alíquota do ICMS, incluídas as despesas acessórias e acréscimos. 
aRegC320[nPosC320][7]		+=	aRegC170[1][13]						//06 - VL_BC_ICMS
aRegC320[nPosC320][8]		+=	aRegC170[1][15]						//07 - VL_ICMS
aRegC320[nPosC320][9]		+=	nRedBSICM							//08 - VL_RED_BC

//REGISTRO C321 - ITENS DO RESUMO DIARIO DOS DOCUMENTOS(MODELO 02)  
If  !cPerfil$"C"
	If (nPosC321 := aScan(aRegC321,{|aX| aX[1]==nPosC320 .And. aX[3]==aRegC170[1][3]}))==0  
		aAdd(aRegC321, {})
		nPosC321	:=	Len (aRegC321)
		aAdd (aRegC321[nPosC321], nPosC320)	 	   									//CHAVE PARA RELACIONAMENTO COM REGISRO PAI
		aAdd (aRegC321[nPosC321], "C321")	 	   									//01 - REG
		aAdd (aRegC321[nPosC321], aRegC170[1][3])									//02 - COD_ITEM
		aAdd (aRegC321[nPosC321], {0,3})											//03 - QTD
		aAdd (aRegC321[nPosC321], aRegC170[1][6])									//04 - UNID
		aAdd (aRegC321[nPosC321], 0)												//05 - VL_ITEM
		aAdd (aRegC321[nPosC321], 0)												//06 - VL_DESC
		aAdd (aRegC321[nPosC321], 0)												//07 - VL_BC_ICMS
		aAdd (aRegC321[nPosC321], 0)					   							//08 - VL_ICMS
		aAdd (aRegC321[nPosC321], 0)					   							//09 - VL_PIS
		aAdd (aRegC321[nPosC321], 0)					   							//10 - VL_COFINS
		// REGISTRO C330: INFORMAÇÕES COMPLEMENTARES DAS OPERAÇÕES DE SAÍDA DE MERCADORIAS SUJEITAS À SUBSTITUIÇÃO TRIBUTÁRIA (CÓDIGO 02)
		// Somente quando o registor é novo		
		RegApurST("C330",@aRegC330,cAliasSFT,,,,nPosC321)
		

	EndIf
	aRegC321[nPosC321][4][1]	+=	aRegC170[1][5][1]	   							//04 - QTD
	aRegC321[nPosC321][6]		+=	(cAliasSFT)->FT_VALCONT							//05 - VL_ITEM // FT_VALCONT -  valor líquido acumulado do item, já considerado o valor do desconto incondicional.
	aRegC321[nPosC321][7]		+=	aRegC170[1][8]		  							//06 - VL_DESC
	aRegC321[nPosC321][8]		+=	aRegC170[1][13]		   							//07 - VL_BC_ICMS
	aRegC321[nPosC321][9]		+=	aRegC170[1][15]		  							//08 - VL_ICMS
	aRegC321[nPosC321][10]		+=	IIf("1"$aWizard[1][15],aRegC170[1][30],0)		//09 - VL_PIS	
	aRegC321[nPosC321][11]		+=	IIf("1"$aWizard[1][15],aRegC170[1][36],0)		//10 - VL_COFINS
EndIf
Return
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³C350C390  ³ Autor ³Gustavo G. rueda       ³ Data ³09.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±³          ³       NOTA FISCAL DE VENDA A CONSUMIDOR (CODIGO 02)        ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao e gravacao do Registro C350                       ³±±
±±³          ³- gravacao do Registro C390                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com as informacoe contidas no array    ³±±
±±³          ³ aRegC100.                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³2(varios por arquivo)                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cPar1 - Alias do arquivo de trabalho                        ³±±
±±³          ³nPar2 - Variavel de controle de relacionamento de documentos³±±
±±³          ³aPar3 - Variavel array com as informacoes jah processadas e ³±±
±±³          ³        armazenadas anteriormente, assim fica uma unica ori-³±±
±±³          ³        para as informacoes do cabecalho do documento       ³±±
±±³          ³aPar4 - Variavel array com as informacoes do participante   ³±±
±±³          ³cPar5 - Alias da tabela SFT em processamento                ³±±
±±³          ³aPar6 - Variavel array com as informacoes processadas ante- ³±±
±±³          ³        para a geracado do registro neste momento, junto com³±±
±±³          ³lPar7 - Variavel que indica se existem notas fiscais com    ³±±
±±³          ³		  mais de 6 caracteres no arquivo do Sped             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nil                                                         ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function C350C390(cAlias,nRelac,aRegC100,aPartDoc,cAliasSFT,aRegC390,lNotaC350,aWizard,aCmpAntSFT)

Local	aRegC350	:=	{}  
Local   cNotaC350   := 	""
Local	cContCtb	:= 	RetCOD_CTA(cAliasSFT, "C350",aCmpAntSFT)
Local	nPos		:=	0

Default aWizard		:= {}

If Len(AllTrim(aRegC100[1][8]))>6 .And.;
    Val(Left(AllTrim(aRegC100[1][8]),Len(AllTrim(aRegC100[1][8]))-6))>0
	lNotaC350   := .F.
EndIf
cNotaC350   := Right(AllTrim(aRegC100[1][8]),6)

aAdd(aRegC350, {})
nPos	:=	Len (aRegC350)
aAdd (aRegC350[nPos], "C350")	 	   										//01 - REG
aAdd (aRegC350[nPos], aRegC100[1][7])	   									//02 - SER
aAdd (aRegC350[nPos], "")													//03 - SUB
aAdd (aRegC350[nPos], cNotaC350)		   									//04 - NUM_DOC
aAdd (aRegC350[nPos], aRegC100[1][10])	   									//05 - DT_DOC
aAdd (aRegC350[nPos], Iif(Empty(aPartDoc[04]),aPartDoc[05],aPartDoc[04]))	//06 - CPF_CNPJ
aAdd (aRegC350[nPos], aRegC100[1][16])	   									//07 - VL_MERC
aAdd (aRegC350[nPos], aRegC100[1][12])	   									//08 - VL_DOC
aAdd (aRegC350[nPos], aRegC100[1][14])	   									//09 - VL_DESC
aAdd (aRegC350[nPos], Iif("1"$aWizard[1][15],aRegC100[1][26],0))			//10 - VL_PIS
aAdd (aRegC350[nPos], Iif("1"$aWizard[1][15],aRegC100[1][27],0))	   		//11 - VL_COFINS
aAdd (aRegC350[nPos], Iif(!Empty(cContCtb),cContCtb,(cAliasSFT)->FT_CONTA ))//12 - COD_CTA

//Gravacao das informacoes dos registros respeitando o relacionamento de documentos (RelacDoc)  
GrvRegTrS (cAlias, RetRD(nRelac), aRegC350)
GrvRegTrS (cAlias, nRelac, aRegC390)

Return
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³RegC370   ³ Autor ³Gustavo G. Rueda       ³ Data ³09.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±³          ³               ITENS DO DOCUMENTO (CODIGO 02)               ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao e gravacao do Registro C370                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com as informacoe contidas no array    ³±±
±±³          ³ aRegC170 para o Modelo 06.                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³3(1:N) Para cada C350                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T.                                                         ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function RegC370(cAlias, nRelac, aRegC170, nItem, cAliasSFT)

Local	aRegC370	:=	{}
Local	lRet   		:=	.T.
Local	nPos		:=	0

aAdd(aRegC370, {})
nPos	:=	Len (aRegC370)
aAdd (aRegC370[nPos], "C370")	 	   					//01 - REG
aAdd (aRegC370[nPos], aRegC170[1][2])	   				//02 - NUM_ITEM
aAdd (aRegC370[nPos], aRegC170[1][3])	   				//03 - COD_ITEM
aAdd (aRegC370[nPos], aRegC170[1][5][1])				//04 - QTD
aAdd (aRegC370[nPos], aRegC170[1][6])	   				//05 - UNID
aAdd (aRegC370[nPos], aRegC170[1][7])	   				//06 - VL_ITEM
aAdd (aRegC370[nPos], aRegC170[1][8])	   				//07 - VL_DESC

//GrvRegTrS(cAlias,nRelac,aRegC370,nItem)
GrvRegTrS(cAlias,GetRelaGrv(nRelac, 2),aRegC370,nItem) 
//³REGISTRO C380: INFORMAÇÕES COMPLEMENTARES DAS OPERAÇÕES DE SAÍDA DE MERCADORIAS SUJEITAS À SUBSTITUIÇÃO TRIBUTÁRIA (CÓDIGO 02)
//|Funcao independente, gera a estrutura e jah grava, nao precisa retornar nada|
//RegApurST("C380",,cAliasSFT,cAlias,nRelac,nItem,)
RegApurST("C380",,cAliasSFT,cAlias,GetRelaGrv(nRelac, 2),nItem,)

								
Return (lRet)
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³RegC390   ³ Autor ³Gustavo G. Rueda       ³ Data ³09.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±³          ³         REGISTRO ANALITICO DO DOCUMENTO (MODELO 02)        ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao do Registro C390                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com as informacoes contidas no array   ³±±
±±³          ³ aRegC170(Itens) aglutinados CFOP, CST e ALIQ.              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³3(1:N) Para cada Registro C350                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T.                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³aRegC170  -> Informacoes dos Itens do documento fiscal      ³±±
±±³          ³cAliasSFT -> Alias da tabela posicionada no momento         ³±±
±±³          ³aRegC390  -> Array contendo as informacoes aglutinadas do   ³±±
±±³          ³ do documento fiscal para posterior geracao na funcao prin- ³±±
±±³          ³ cipal.                                                     |±±
±±³          ³cSituaDoc -> Situacao do documento fiscal                   |±± 
±±³          ³aLanCDA - array com os lancamentos do documento fiscal      ³±±
±±³          ³nRedBSICM -> Valor de reducao da base de calculo do ICMS    |±±
±±³          ³cAliasSF4-> Informa qual o alias da tabela SF4, podendo ser ³±±
±±³          ³            query                                           ³±±
±±³          ³aLancFis-> Array com lancamentos de documento nao amarrados³±±
±±³          ³            ao C197                                         ³±±
±±³          ³aReg0460  -> Array com a estrutura do 0460 gerado ateh o    ³±±
±±³          ³            momento.                                        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function RegC390(aRegC170,cAliasSFT,aRegC390,cSituaDoc,aLanCDA,nRedBSICM,cAliasSF4,aLancFis,aReg0460)

Local	lRet   		:=	.T.
Local	nPos		:=	0

If (nPos := aScan (aRegC390, {|aX| aX[2]==aRegC170[1][10] .And. aX[3]==aRegC170[1][11] .And. aX[4]==aRegC170[1][14]}) ) == 0
	aAdd(aRegC390, {})
	nPos	:=	Len (aRegC390)
	aAdd (aRegC390[nPos], "C390")	 	   		 				//01 - REG
	aAdd (aRegC390[nPos], aRegC170[1][10])		 				//02 - CST
	aAdd (aRegC390[nPos], aRegC170[1][11])						//03 - CFOP
	aAdd (aRegC390[nPos], aRegC170[1][14])						//04 - ALIQ_ICMS
	aAdd (aRegC390[nPos], 0)	 		   						//05 - VL_OPR
	aAdd (aRegC390[nPos], 0)					   				//06 - VL_BC_ICMS
	aAdd (aRegC390[nPos], 0)	 		  		 				//07 - VL_ICMS
	aAdd (aRegC390[nPos], 0)	 		  		 				//08 - VL_RED_BC
	aAdd (aRegC390[nPos], "")	 				 				//09 - CODOBS
	
	
	//Se houver lancamento fiscal nao amarrado ao C197, devo prioriza-lo
	If Len(aLancFis)>=1
		aRegC390[nPos,9]	:=	aLancFis[1,1]
		
		//REGISTRO 0460 - TABELA DE OBSERVACOES DO LANCAMENTO FISCAL
	
   		Reg0460(@aReg0460,{aLancFis[1,1],aLancFis[1,2]})
	
	//Quando este array estiver com conteudo, jah terah de todos os itens, neste caso, preciso obter somente o lancamento do referido item 
	ElseIf Len(aLanCDA)>0 .And. (nPosIt := aScan(aLanCDA,{|aX|aX[14]==(cAliasSFT)->FT_ITEM}))>0
		aRegC390[nPos,9]  :=  aLanCDA[nPosIt,7]
	EndIf     
EndIf

// Campos totalizados 
If !(cSituaDoc$"02#03#04#05")    
	aRegC390[nPos][5] 	+= (cAliasSFT)->FT_VALCONT 		 		//05 - VL_OPR
	aRegC390[nPos][6]	+=	aRegC170[1][13]		 				//06 - VL_BC_ICMS
	aRegC390[nPos][7]	+=	aRegC170[1][15]	   					//07 - VL_ICMS
	aRegC390[nPos][8]	+=	nRedBSICM							//08 - VL_RED_BC
Endif

Return (lRet)
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³RegC400   ³ Autor ³ Vendas e CRM          ³ Data ³ 29/01/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Efetua a carga dos dados dos registros C400                ³±±
±±³          ³ REGISTRO C400 - EQUIPAMENTO ECF                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGAFIS                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/		
Function RegC400(	aRegC400, cIMPFISC, cSERPDV, cPDV,;
					nPos400, cHierarq )

Local lRet   	:= .T.
Local nPos		:= 0
Local cEntSai   := "S"//C400 so gera para saidas
	
	//Preenchimento do registro C400   
	//Validacao para nao repetir ECF com o mesmo numero de serie
	If Len(aRegC400) == 0 .OR. (Ascan(aRegC400, {|x| x[4] == cSERPDV}) == 0)
		aAdd(aRegC400, {})
		nPos :=	Len (aRegC400)
		
		aAdd (aRegC400[nPos], "C400"					)	 	//00 - REG
		aAdd (aRegC400[nPos], "2D"						)	 	//02 - COD_MOD
		aAdd (aRegC400[nPos], Left(cIMPFISC,20)			)	 	//03 - ECF_MOD
		aAdd (aRegC400[nPos], cSERPDV					)	 	//04 - ECF_FAB
		aAdd (aRegC400[nPos], Right(cPDV,3)				)	 	//05 - ECF_CX 

		cHierarq := cFilAnt + cEntSai + "C400" + StrZero(nPos, nTTRBITEM, 0)
		
		aAdd (aRegC400[nPos], cHierarq )		        //06 - Posicao de Hierarquia, utilizada para organizacao dos registros	
	Else
		nPos := Ascan(aRegC400, {|x| x[4] == cSERPDV})		
		cHierarq := cFilAnt + cEntSai + "C400" + StrZero(nPos, nTTRBITEM, 0)
	EndIf 

	

	nPos400 := nPos

Return(lRet) 
 
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³RegC405   ³ Autor ³ Vendas e CRM          ³ Data ³ 29/01/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Efetua a carga dos dados dos registros C405                ³±±
±±³			 ³ REGISTRO C405 - REDUCAO Z                                  ³±±         
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGAFIS                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/		
Function RegC405(	aRegC405 	, nRegPai , dDtMovto	, cCRO		,;
					cNUMREDZ 	, cNUMFIM , nGTFINAL	, nVALCON	,;
					nPos405 	, nValDesc, nValCanc	, cHierarq )

Local lRet   	:= .T.
Local nPos		:= 0
Local nNumFim	:= 0   

DEFAULT nValDesc := 0
DEFAULT nValCanc := 0

	//Preenchimento do registro 405
	aAdd(aRegC405, {})
	nPos :=	Len (aRegC405) 

	aAdd (aRegC405[nPos], nRegPai		)										//00 - RELACIONAMENTO COM O CABECALHO C625
	aAdd (aRegC405[nPos], "C405"		) 	   									//01 - REG
	aAdd (aRegC405[nPos], dDtMovto		)	 									//02 - DT_DOC
	aAdd (aRegC405[nPos], cCRO   		) 	   									//03 - CRO
	aAdd (aRegC405[nPos], cNUMREDZ		)	 									//04 - CRZ

	nNumFim := Val(cNUMFIM)+1
	aAdd (aRegC405[nPos], StrZero(nNumFim,Len(AllTrim(Str(nNumFim))))) 	   		//05 - NUM_COO_FIN
	aAdd (aRegC405[nPos], nGTFINAL		)	 									//06 - GT_FIN
	aAdd (aRegC405[nPos], nVALCON+nValDesc+nValCanc ) 							//07 - VL_BRT

	cHierarq :=  cHierarq + "C405" + StrZero(nPos, nTTRBITEM, 0)
	
	aAdd (aRegC405[nPos], cHierarq )											//08 - Posicao de Hierarquia, utilizada para organizacao dos registros

	nPos405 := nPos         

Return lRet
                   
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³RegC410   ³ Autor ³ Vendas e CRM          ³ Data ³ 29/01/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Efetua a carga dos dados dos registros C410                ³±±
±±³          ³ REGISTRO C410 - PIS E COFINS TOTALIZADOS NO DIA            ³±±     
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGAFIS                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/		
Function RegC410(	aRegC410	, nRegPai , nTotCof 		, nTotPis ,;
					dDtMovim	, cPDV    , lUsaQuery		, cHierarq )

Local aAreaLoc	:= {}
Local aAreaSF2	:= {}
Local lRet   	:= .T.
Local nPos		:= 	0

DEFAULT cPDV    := ""
DEFAULT dDtMovim:= CToD("  /  /  ")
DEFAULT nTotPis	:= 0
DEFAULT nTotCof	:= 0

If !lUsaQuery .AND. (nTotPis + nTotCof) = 0
	aAreaLoc	:= GetArea()
	aAreaSF2	:= SF2->(GetArea())
	DbSelectArea ("SF2")
	DbSetOrder (3) //F2_FILIAL + F2_ECF + DTOS(F2_EMISSAO) + F2_PDV + F2_SERIE+F2_MAPA+F2_DOC
	MsSeek (aSPDFil[PFIL_SF2] + "S" + DtoS(dDtMovim) + cPDV, .T.)
	
	Do While !SF2->(Eof ()) .AND. SF2->F2_ECF == 'S' .AND.;
			dDtMovim == SF2->F2_EMISSAO .AND. cPDV == SF2->F2_PDV  
			
		nTotPis += SF2->F2_VALPIS	  		//02 - VL_PIS
		nTotCof += SF2->F2_VALCOFI  		//03 - VL_COFINS

		SF2->(dbSkip())
	EndDo
	
	RestArea(aAreaLoc) 
	RestArea(aAreaSF2)
EndIf

If nTotPis > 0 .OR. nTotCof > 0
	//Preenchimento do registro 410 
	aAdd (aRegC410, {})
	nPos := Len(aRegC410)    
	
	aAdd (aRegC410[nPos], nRegPai) 	//posicao do registro pai para gerar relacionamento
	aAdd (aRegC410[nPos], "C410")
	aAdd (aRegC410[nPos], nTotPis)	//02 - VL_PIS
	aAdd (aRegC410[nPos], nTotCof) 	//03 - VL_COFINS		
	
	aAdd (aRegC410[nPos], cHierarq + "C410" + StrZero(nPos, nTTRBITEM, 0) )				//04 - Posicao de Hierarquia, utilizada para organizacao dos registros	
EndIf	

Return(lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³RegC420   ³ Autor ³ Vendas e CRM          ³ Data ³ 29/01/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Efetua a carga dos dados dos registros C420                ³±±
±±³          ³ REGISTRO C420 - TOTALIZADORES PARCIAIS DA REDUCAO Z        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGAFIS                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function RegC420 (	aRegC420, 	nRegPai, cCRO, cNUMREDZ,;
					aTotaliz, 	aPos420, cHierarq )

Local lRet	:= .T.
Local nPos	:= 0
Local nI	:= 0

aPos420	 := {}
//Preenchimento do registro 420
For nI:=1 to Len(aTotaliz) 

	aAdd(aRegC420, {})
	nPos := Len (aRegC420)
	
	aAdd (aRegC420[nPos], nRegPai			)	//00 - RELACIONA COM O REGISTRO PAI
	aAdd (aRegC420[nPos], "C420"			)  	//01 - REG

	aAdd (aRegC420[nPos], aTotaliz[nI][1]	)  	//02 - COD_TOT_PAR		
	aAdd (aRegC420[nPos], aTotaliz[nI][2]	)	//03 - VLR_ACUM_TOT

	aAdd (aRegC420[nPos], aTotaliz[nI][3]	)  	//04 - NR_TOT
	aAdd (aRegC420[nPos], ""				)	//05 - DESCR_NR_TOT	  
	
	aAdd (aPos420, { nPos , aTotaliz[nI][1]})	// Posicao do registro + codigo da tributacao

	aAdd (aRegC420[nPos], cHierarq + "C420" + StrZero(nPos, nTTRBITEM, 0) )				//07 - Posicao de Hierarquia, utilizada para organizacao dos registros	


	
Next nI      

Return(lRet)
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³RegC425   ³ Autor ³ Vendas e CRM          ³ Data ³ 29/01/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Efetua a carga dos dados dos registros C425                ³±±
±±³          ³ REGISTRO C425 - RESUMO DE ITENS DO MOVIMENTO DIARIO        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGAFIS                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/		
Static Function RegC425(aRegC425 , aProdB1  , dDtMovim , cPdv,;
						aLinhaPai, cAlias   , aReg0200 , aReg0190,;
						aReg0220 , lGer490  , aRegC490 , nPos405, ;
						 dDataDe , dDataAte , aWizard  , nQuantD, lUsaQuery, cHierarq )

Local lRet 		:= .F.   				// Retorno Logico
Local nPosAux	:= 0					// Posicao Auxiliar
Local nPos		:= 0     				// Posicao atual
Local aAreaLoc	:= GetArea()  			// Guarda a area local
Local aAreaSFT	:= SFT->(GetArea ())    // Guarda a Area do SFT
Local aAreaSD2	:= SD2->(GetArea ())    // Guarda a Area do SD2
Local aAreaSF2	:= SF2->(GetArea ())	// Guarda a Area do SF2
Local nX		:= 0                    // Contador do For
Local cSitTrib 	:= ""					// Retorno da situação tributaria do produto
Local cSitSFT 	:= ""					// Retorno da situação tributaria do produto
Local cAliqIcm	:= ""					// Aliquota de ICMS
Local cTemp		:= GetNextAlias()		// Pega o proximo Alias Disponivel
Local nPosLin	:= 0					// Posicao da Linha do registro pai
Local cFilB1	:= cFilAnt     	// Filial do SB1
Local cProd		:= ""
Local cUnid		:= ""
Local aProd 	:= {"","","","","","","","","","",""}

DEFAULT aLinhaPai 	:= {}  
DEFAULT lGer490		:= .F.
DEFAULT aRegC490	:= {}
DEFAULT nPos405		:= 0		
DEFAULT dDataDe 	:= dDtMovim
DEFAULT dDataAte	:= dDtMovim
DEFAULT aWizard		:= {}

If lUsaQuery
	lGer490 := .T.
	BeginSql alias cTemp
	SELECT SFT.FT_PRODUTO ,
       SUM(FT_VALICM) FT_VALICM , SUM(FT_VALCONT) FT_VALCONT , SUM(FT_VALPIS) FT_VALPIS , 
       SUM(FT_VALCOF) FT_VALCOF ,SUM(FT_QUANT) FT_QUANT      , SUM(FT_BASEICM) FT_BASEICM,
       SD2.D2_SITTRIB
				
		FROM %table:SFT% SFT  , %table:SD2% SD2 
		WHERE   SFT.FT_FILIAL   = %xfilial:SFT%  		AND
				SFT.FT_TIPOMOV  = 'S'   				AND
				SFT.FT_ENTRADA  = %exp:DTOS(dDtMovim)% AND
				SFT.FT_PDV      = %exp:cPdv%			AND 
				(SFT.FT_ESPECIE	= 'CF'				OR SFT.FT_ESPECIE	= 'ECF') AND
				SFT.FT_DTCANC	= ' '					AND
                SFT.%notDel%       						AND
   				SFT.FT_FILIAL   = SD2.D2_FILIAL   		AND 
			    SFT.FT_PDV      = SD2.D2_PDV     		AND 
			    SFT.FT_NFISCAL	= SD2.D2_DOC        	AND
                SFT.FT_SERIE	= SD2.D2_SERIE			AND	
                SFT.FT_ITEM 	= SD2.D2_ITEM			AND
   				SD2.%notDel%
   				                        
   	     GROUP BY FT_PRODUTO,FT_FILIAL,FT_TIPOMOV,SD2.D2_SITTRIB        	 
         ORDER BY FT_FILIAL       
	EndSql
    
	While !(cTemp)->(Eof ())
		cSitTrib := (cTemp)->D2_SITTRIB
	   	nPosLin 	:= Ascan(aLinhaPai,{|x| AllTrim(x[2]) == AllTrim(cSitTrib) })
		
		If nPosLin > 0 
			cProd	:= (cTemp)->FT_PRODUTO+Iif(lConcFil,cFilB1,"")
			If aExistBloc[05]
				aProd := Execblock("SPEDPROD", .F., .F., {cTemp,"C425"})
				If Len(aProd)>=11
					cProd 	:= 	aProd[1]
				Else
					aProd := {"","","","","","","","","","","",""}
				EndIf
			EndIf			
			//³Preenchimento do registro 425    ³
		  		aAdd(aRegC425, {})        
				nPos :=	Len (aRegC425)
		
				aAdd (aRegC425[nPos], aLinhaPai[nPosLin][1]						) 		//00 - POSICAO DO REG. PAI
				aAdd (aRegC425[nPos], "C425"		 								) 	//01 - REG
				aAdd (aRegC425[nPos], cProd							       	    	) 	//02 - COD_ITEM
				aAdd (aRegC425[nPos], {(cTemp)->FT_QUANT , nQuantD }           	) 		//03 - QTD
				aAdd (aRegC425[nPos], RetUMProd(@aProdB1,(cTemp)->FT_PRODUTO)[1]	)  	//04 - UNID
				aAdd (aRegC425[nPos], (cTemp)->FT_VALCONT 							)	//05 - VL_ITEM  	
				aAdd (aRegC425[nPos], Iif("1"$aWizard[1][15],(cTemp)->FT_VALPIS,0))  	//06 - VL_PIS
				aAdd (aRegC425[nPos], Iif("1"$aWizard[1][15],(cTemp)->FT_VALCOF,0)) 	//07 - VL_COFINS 

				aAdd (aRegC425[nPos], cHierarq + "C420" + StrZero(aLinhaPai[nPosLin][1], nTTRBITEM, 0) + "C425" + StrZero(nPos,nTTRBITEM, 0) )				//08 - Posicao de Hierarquia, utilizada para organizacao dos registros		

			If aScan (aReg0200, {|aX| aX[2]==cProd}) == 0
				SFRG0200(cAlias, @aReg0200, @aReg0190, dDataDe, dDataAte, ,cProd ,@aReg0220,,,,,,,,,,,,,,,,,,,aWizard)
			EndIf
	
			lRet := .T.
		EndIf
		
		(cTemp)->(dbSkip())
	End
	
	DbSelectArea(cTemp)
	(cTemp)->(DbCloseArea())
Else
	For nX:=1 to Len(aLinhaPai) 
		DbSelectArea("SFT")
		DbSetOrder(2)   //FT_FILIAL+FT_TIPOMOV+DTOS(FT_ENTRADA)+FT_SERIE+FT_NFISCAL+FT_CLIEFOR+FT_LOJA+FT_ITEM+FT_PRODUTO
		MsSeek(aSPDFil[PFIL_SFT]+"S"+DtoS(dDtMovim), .T.)
			
		While !SFT->(Eof ()) .AND. aSPDFil[PFIL_SFT] == SFT->FT_FILIAL .AND.;
			SFT->FT_TIPOMOV == "S" .AND. dDtMovim = SFT->FT_EMISSAO 
		
			If cPdv == SFT->FT_PDV .AND. (AllTrim(SFT->FT_ESPECIE)$"CF|NF") .AND. Empty(SFT->FT_DTCANC)   
	
				DbSelectArea("SD2")			         
				DbSetOrder(3)		// D2_DOC+D2_SERIE+D2_CLIENTE+D2_LOJA+D2_COD+D2_ITEM
				If MsSeek(aSPDFil[PFIL_SD2]+SFT->FT_NFISCAL+SFT->FT_SERIE+SFT->FT_CLIEFOR+SFT->FT_LOJA+SFT->FT_PRODUTO+AllTrim(SFT->FT_ITEM))
			        
			        cSitTrib 	    := LjSitTrib("SD2")    // Verifica a situacao tributaria
			        
			        If cSitTrib $ aLinhaPai[nX][2] .AND. cSitTrib <> "N"
						//³No caso de Tributado , tem que ser da mesma aliquota ³
				        If "T" $ cSitTrib 
				        	cAliqIcm:=AllTrim(Str(SFT->FT_ALIQICM))
					        cSitSFT := StrTran(cAliqIcm,".","") 
					        If Len(cSitSFT) == 1 .OR. Len(SubStr(cAliqIcm,1,At(".",cAliqIcm)-1)) == 1
								cSitSFT := "0"+cSitSFT
					        EndIf
					        cSitSFT := PadR( cSitSFT ,4,"0")
					        If cSitSFT <> SubStr(aLinhaPai[nX][2],2,5)
			        			SFT->(DbSkip())
			        			Loop
			        		EndIf	
			            EndIf	
						//³Preenchimento do registro 425    ³
						cProd	:= SFT->FT_PRODUTO+Iif(lConcFil,cFilAnt,"") 
						If aExistBloc[05]
							aProd := Execblock("SPEDPROD", .F., .F., {"SFT","C425"})
							If Len(aProd)>=11
								cProd 	:= 	aProd[1]
								cUnid	:=	aProd[5]
							Else
								aProd := {"","","","","","","","","","","",""}
							EndIf
						EndIf
						
						nPosAux := Ascan(aRegC425, {|x| x[3] == cProd .AND. x[1] == aLinhaPai[nX][1]})
										
						If nPosAux ==  0			
							aAdd(aRegC425, {})        
							nPos :=	Len (aRegC425)
				
							aAdd (aRegC425[nPos], aLinhaPai[nX][1]						)	 	   	//00 - POSICAO DO REG. PAI
							aAdd (aRegC425[nPos], "C425"		 						)	 	   	//01 - REG
							aAdd (aRegC425[nPos], cProd		)	 	   								//02 - COD_ITEM
							aAdd (aRegC425[nPos], {SFT->FT_QUANT, nQuantD }			)	 	   		//03 - QTD
							aAdd (aRegC425[nPos], RetUMProd(@aProdB1, SFT->FT_PRODUTO)	)	 	   	//04 - UNID
							aAdd (aRegC425[nPos], SFT->FT_VALCONT 						)			//05 - VL_ITEM  	
							aAdd (aRegC425[nPos], Iif("1"$aWizard[1][15],SFT->FT_VALPIS,0)	)	 	//06 - VL_PIS
							aAdd (aRegC425[nPos], Iif("1"$aWizard[1][15],SFT->FT_VALCOF,0)	)	 	//07 - VL_COFINS 							

							aAdd (aRegC425[nPos], cHierarq + "C420" + StrZero(aLinhaPai[nX][1], nTTRBITEM, 0) + "C425" + StrZero(nPos, nTTRBITEM, 0) )				//08 - Posicao de Hierarquia, utilizada para organizacao dos registros		
						Else 
							aRegC425[nPosAux][4][1] += SFT->FT_QUANT			   					//03 - QTD			
							aRegC425[nPosAux][6]    += SFT->FT_VALCONT 								//05 - VL_ITEM
							aRegC425[nPosAux][7]	+= IIf("1"$aWizard[1][15],SFT->FT_VALPIS,0)		//06 - VL_PIS
							aRegC425[nPosAux][8]	+= IIf("1"$aWizard[1][15],SFT->FT_VALCOF,0)		//07 - VL_COFINS
						EndIf
						
						If aScan (aReg0200, {|aX| aX[2]==SFT->FT_PRODUTO+Iif(lConcFil,cFilAnt,"")}) == 0
							SFRG0200(cAlias, @aReg0200, @aReg0190, dDataDe, dDataAte, , ,@aReg0220,,,,,,,,,,,,,,,,,,,aWizard)
						EndIf
			
						lRet := .T.
					EndIf
				EndIf		
			EndIf
			SFT->(dbSkip())
		End
		//Preenchimento do registro 425  para o caso de Nao Tributado 
		If "N" $ aLinhaPai[nX][2]
			LjNaoTrib(aLinhaPai[nX] , dDtMovim 	, cPdv 		, @aProdB1 ,;
						cAlias 		, @aReg0200	, @aReg0190	, @aReg0220,;
						@aRegC425 	, dDataDe   , dDataAte  , aWizard, cHierarq)
		EndIf	
			
	Next nX
EndIf	
	
RestArea(aAreaLoc)
RestArea(aAreaSFT)	
RestArea(aAreaSD2)
RestArea(aAreaSF2)

Return(lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³RegC460470³ Autor ³ Vendas e CRM          ³ Data ³ 29/01/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Efetua a carga dos dados dos registros C460 e C470         ³±±
±±³          ³ REGISTRO C460 - DOCUMENTO FISCAL EMITIDO POR ECF           ³±±
±±³          ³ REGISTRO C470 - ITENS DO DOCUMENTO FISCAL EMITIDO POR ECF  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGAFIS                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/		
Static Function RegC460470(	aRegC460, aRegC470  , dDtMovim , cPdv,;
							aProdB1 , cCOO      , nLinhaPai, cAlias,;
							aReg0200, aReg0190  , aReg0220 , lGer490,;
							aRegC490, dDataDe   , dDataAte , aWizard,;
							nQuantD , lUsaQuery , cHierarq)

Local lRet 		:= .T.   
Local nPosAux	:= 0
Local nPos460	:= 0
Local nPosPai	:= 0     
Local aAreaLoc	:= GetArea()
Local aClasFis	:= {"","","",""}
Local cSituaDoc	:= ""
Local aAreaSFT	:= SFT->(GetArea ())
Local cFilSB1   := cFilAnt
Local nQtCanc  	:= 0
Local cSFTTemp	:= GetNextAlias()			// Pega o proximo Alias Disponivel
Local cProdUN	:= ""
Local nAliqSFT	:= 0
Local nBCIcms	:= 0
Local cProdSft	:= ""
Local aDadosProd:= {}
Local cSitTrib	:= ""
Local lCancSft  := .T.
Local aInfPart  := {"","","","",""}
Local cCpfCNPJ	:= ""
Local cProd		:= ""
Local aProd		:= {}
Local lAchouSF3 := .F.

DEFAULT dDataDe := dDtMovim
DEFAULT dDataAte := dDtMovim
DEFAULT aWizard	 := {}

If lUsaQuery
	lGer490 := .T.
	BeginSql alias cSFTTemp
		SELECT 	SFT.FT_NFISCAL 	, SFT.FT_EMISSAO , SFT.FT_VALCONT, SFT.FT_VALPIS  , SFT.FT_VALCOF  ,
				SFT.FT_VALCONT 	, SFT.FT_QUANT 	 , SFT.FT_ITEM	 , SFT.FT_PRODUTO , SFT.FT_PRCUNIT ,
				SFT.FT_CFOP 	, SFT.FT_ALIQICM , SFT.FT_LOJA	 , SFT.FT_CLIEFOR , SFT.FT_TIPO    ,
				SFT.FT_CLASFIS  , SFT.FT_CTIPI 	 , SFT.FT_TIPOMOV, SFT.FT_DTCANC  , SFT.FT_BASEICM ,
				SFT.FT_VALICM 	, SFT.FT_FORMUL	 , SFT.FT_ESPECIE, SFT.FT_SERIE	  , SD2.D2_SITTRIB ,
				SFT.FT_ENTRADA  , SFT.FT_CSTPIS  , SFT.FT_CSTCOF , SFT.FT_RGESPST , SFT.FT_FILIAL  ,
				SFT.FT_NORESP   , SF4.F4_RGESPCI  ,
				(SELECT SUM(LX_QTDE)
				 FROM  %table:SLX% SLX
				 WHERE 	SLX.LX_FILIAL 	= SFT.FT_FILIAL  AND
						SLX.LX_PDV 		= SFT.FT_PDV 	 AND
						SLX.LX_CUPOM 	= SFT.FT_NFISCAL AND
						SLX.LX_SERIE 	= SFT.FT_SERIE 	 AND
						SLX.LX_DTMOVTO	= SFT.FT_EMISSAO AND
						SLX.LX_PRODUTO  = SFT.FT_PRODUTO AND
						SLX.LX_ITEM		= SFT.FT_ITEM    AND
						SLX.%notDel% ) AS LX_QTDCANC
		FROM %table:SFT% SFT 
		LEFT JOIN %table:SD2% SD2 ON
				SD2.D2_FILIAL = %xfilial:SD2%	AND
				SFT.FT_PDV      = SD2.D2_PDV	AND
				SFT.FT_NFISCAL	= SD2.D2_DOC	AND
				SFT.FT_SERIE    = SD2.D2_SERIE	AND
				SFT.FT_ITEM     = SD2.D2_ITEM	AND
				SD2.%notDel%
		LEFT JOIN %table:SF4% SF4 ON
				SF4.F4_FILIAL = %xfilial:SF4%	AND
				SF4.F4_CODIGO = SFT.FT_TES		AND
				SF4.%notDel%
		WHERE   SFT.FT_FILIAL   = %xfilial:SFT%			AND
				SFT.FT_TIPOMOV  = 'S'					AND
				SFT.FT_ENTRADA  = %exp:DTOS(dDtMovim)%  AND
				SFT.FT_PDV      = %exp:cPdv%			AND 
				(SFT.FT_ESPECIE	= 'CF' OR SFT.FT_ESPECIE= 'ECF') AND
				SFT.%notDel%
	EndSql
	
	While !(cSFTTemp)->(Eof ())
	
		nPosAux := Ascan(aRegC460, {|x| x[5] == (cSFTTemp)->FT_NFISCAL .AND. x[1] == nLinhaPai})  //SFT->FT_NFISCAL
		lCancSft := Empty(AllTrim((cSFTTemp)->FT_DTCANC))	
			
		If nPosAux ==  0			
			If SA1->(MsSeek(aSPDFil[PFIL_SA1] + (cSFTTemp)->FT_CLIEFOR + (cSFTTemp)->FT_LOJA)) 
				aInfPart := InfPartDoc("SA1")
				cCpfCNPJ := IIf(Empty(aInfPart[4]),aInfPart[5],aInfPart[4])
				If LJAnalisaLEG(58)[1] 				// Para a Nota Fiscal Gaucha pega os dados do cupom
					DbSelectArea("SL1")
					DbSetOrder(2) 					//L1_FILIAL + L1_SERIE + L1_DOC 
					If MsSeek(aSPDFil[PFIL_SL1]+(cSFTTemp)->FT_SERIE+(cSFTTemp)->FT_NFISCAL) 
						cCpfCNPJ := AllTrim(SL1->L1_CGCCLI)
					EndIf
				EndIf
			EndIf			

			lAchouSF3 := SPEDSeek("SF3",,aSPDFil[PFIL_SF3]+(cSFTTemp)->(FT_ENTRADA+FT_NFISCAL+FT_SERIE+FT_CLIEFOR+FT_LOJA+FT_CFOP+STR(FT_ALIQICM,5,2)))

			//Preenchimento do registro 460
			cSituaDoc := SPEDSitDoc(,cSFTTemp,,,,,,,,,,,,lAchouSF3)
			
			aAdd(aRegC460, {})        
			nPos460 :=	Len (aRegC460)      
			
			aAdd (aRegC460[nPos460], nLinhaPai		 				)	 	   						//00 - RELACIONAMENT0 COM REGISTRO PAI
			aAdd (aRegC460[nPos460], "C460"		 					)	 	   						//01 - REG
			aAdd (aRegC460[nPos460], "2D"		 					)	 	   						//02 - COD_MOD
			aAdd (aRegC460[nPos460], cSituaDoc						)	 	   						//03 - COD_SIT
			aAdd (aRegC460[nPos460], (cSFTTemp)->FT_NFISCAL			)	 	   						//04 - NUM_DOC
			If lCancSft
				aAdd (aRegC460[nPos460], StoD((cSFTTemp)->FT_EMISSAO)	)	 						//05 - DT_DOC
				aAdd (aRegC460[nPos460], (cSFTTemp)->FT_VALCONT		    ) 	    					//06 - VL_DOC
				aAdd (aRegC460[nPos460], Iif("1"$aWizard[1][15],(cSFTTemp)->FT_VALPIS,0))			//07 - VL_PIS
				aAdd (aRegC460[nPos460], Iif("1"$aWizard[1][15],(cSFTTemp)->FT_VALCOF,0))			//08 - VL_COFINS
				aAdd (aRegC460[nPos460], cCpfCNPJ						)							//09 - CPF_CNPJ
				aAdd (aRegC460[nPos460], aInfPart[2]					)	   						//10 - NOM_ADQ
			Else 
				aAdd (aRegC460[nPos460], ""  	)	 	   											//05 - DT_DOC
				aAdd (aRegC460[nPos460], ""		) 	     											//06 - VL_DOC
				aAdd (aRegC460[nPos460], ""		)	 	   											//07 - VL_PIS
				aAdd (aRegC460[nPos460], ""		)	 	   											//08 - VL_COFINS
				aAdd (aRegC460[nPos460], ""	    )	 	   											//09 - CPF_CNPJ
				aAdd (aRegC460[nPos460], ""  	)	 	   											//10 - NOM_ADQ 	
			EndIf

			aAdd (aRegC460[nPos460], cHierarq + "C460" + StrZero(nPos460, nTTRBITEM, 0) )		//11 - Posicao de Hierarquia, utilizada para organizacao dos registros	
		Else 
			If lCancSft
				aRegC460[nPosAux][7] += (cSFTTemp)->FT_VALCONT										//05 - VL_DOC
				aRegC460[nPosAux][8] += Iif("1"$aWizard[1][15],(cSFTTemp)->FT_VALPIS,0)				//06 - VL_PIS
				aRegC460[nPosAux][9] += Iif("1"$aWizard[1][15],(cSFTTemp)->FT_VALCOF,0)				//07 - VL_COFINS
			EndIf
		EndIf

		nQtCanc  := (cSFTTemp)->LX_QTDCANC
		cProdSft := (cSFTTemp)->FT_PRODUTO
				
		cSitTrib :=	(cSFTTemp)->D2_SITTRIB		
		If ("T" $ cSitTrib)
			If Len(cSitTrib) > 4
				nAliqSFT := Val(SubStr(cSitTrib,2,2)+"."+SubStr(cSitTrib,4,Len(cSitTrib)))
			Else
				nAliqSFT := Val(SubStr(cSitTrib,2,Len(cSitTrib)))
			EndIf		
			nBCIcms	 := (cSFTTemp)->FT_VALCONT		
		ElseIf ("S" $ cSitTrib)
			nAliqSFT := 0
			nBCIcms	 :=	0
		Else 
			nAliqSFT := (cSFTTemp)->FT_ALIQICM	
			nBCIcms	 :=	(cSFTTemp)->FT_BASEICM
		EndIf

		nPosPai  := If(nPosAux == 0, nPos460, nPosAux)
		If lCancSft
			
			aDadosProd	:= RetUMProd(@aProdB1, cProdSft)
			cProdUN		:= aDadosProd[1]
			
			aClasFis := SPDRetCCST (cSFTTemp,.F.)
			cProd	:= SB1->B1_COD + Iif(lConcFil,cFilSB1,"")
			If aExistBloc[05]
				aProd := Execblock("SPEDPROD", .F., .F., {"SB1","C470"})
				If Len(aProd)>=11
					cProd 	:= 	aProd[1]
				Else
					aProd := {"","","","","","","","","","","",""}
				EndIf
			EndIf			
			
			//Preenchimento do registro 470 
			RegC470 (@aRegC470			, cProd			, (cSFTTemp)->FT_QUANT	, (cSFTTemp)->FT_VALCONT,;
					 (cSFTTemp)->FT_CFOP, nAliqSFT		, (cSFTTemp)->FT_VALPIS	, (cSFTTemp)->FT_VALCOF ,;
					 aClasFis[1]		, nQtCanc		, @aProdB1				, nPosPai		 		,;
					 cFilSB1			, cProdUN		, aWizard  				, nQuantD				, cHierarq)
					 
			If AScan(aReg0200, {|aX| aX[2]==cProd}) == 0
				SFRG0200(cAlias, @aReg0200, @aReg0190, dDataDe, dDataAte, , cProd, @aReg0220,,,,,,,,,,,,,,,,,,,aWizard)
			EndIf	
		EndIf	
		(cSFTTemp)->(dbSkip())
	End	   
	
	DbSelectArea(cSFTTemp)
	(cSFTTemp)->( DbCloseArea())
Else

	DbSelectArea("SFT")
	DbSetOrder(2)   //FT_FILIAL+FT_TIPOMOV+DTOS(FT_ENTRADA)+FT_SERIE+FT_NFISCAL+FT_CLIEFOR+FT_LOJA+FT_ITEM+FT_PRODUTO
	MsSeek(aSPDFil[PFIL_SFT]+"S"+DtoS(dDtMovim), .T.)
	
	While !SFT->(Eof ()) .AND. aSPDFil[PFIL_SFT] == SFT->FT_FILIAL .AND. SFT->FT_TIPOMOV == "S" .AND. dDtMovim = SFT->FT_EMISSAO
		//³Somente para cupom e que nao tenha sido cancelado ³
		If cPdv == SFT->FT_PDV .AND. (AllTrim(SFT->FT_ESPECIE)$"CF|NF") .AND. Empty(SFT->FT_DTCANC)

			nPosAux := Ascan(aRegC460, {|x| x[5] == SFT->FT_NFISCAL .AND. x[1] == nLinhaPai})
			
			If nPosAux ==  0			
				If SA1->(MsSeek(aSPDFil[PFIL_SA1] + SFT->FT_CLIEFOR + SFT->FT_LOJA)) 
					aInfPart := InfPartDoc("SA1")
				EndIf			

				lAchouSF3 := SPEDSeek("SF3",,aSPDFil[PFIL_SF3]+SFT->(DtoS(FT_ENTRADA)+FT_NFISCAL+FT_SERIE+FT_CLIEFOR+FT_LOJA+FT_CFOP+STR(FT_ALIQICM,5,2)))
			
				//³Preenchimento do registro 460  ³

				cSituaDoc := SPEDSitDoc(,"SFT",,,,,,,,,,,, lAchouSF3)
				
				aAdd(aRegC460, {})        
				nPos460 :=	Len (aRegC460)      
				
				aAdd (aRegC460[nPos460], nLinhaPai		 			)	 	   			 //00 - RELACIONAMENT0 COM REGISTRO PAI
				aAdd (aRegC460[nPos460], "C460"		 				)	 	   			 //01 - REG
				aAdd (aRegC460[nPos460], "2D"		 				)	 	   	         //02 - COD_MOD
				aAdd (aRegC460[nPos460], cSituaDoc					)	 	   	         //03 - COD_SIT
				aAdd (aRegC460[nPos460], SFT->FT_NFISCAL			)	 	   	         //04 - NUM_DOC
				aAdd (aRegC460[nPos460], SFT->FT_EMISSAO			)	 	   	         //05 - DT_DOC
				aAdd (aRegC460[nPos460], SFT->FT_VALCONT			)	 	   	         //06 - VL_DOC
				aAdd (aRegC460[nPos460], Iif("1"$aWizard[1][15],SFT->FT_VALPIS,0))	 	 //07 - VL_PIS
				aAdd (aRegC460[nPos460], Iif("1"$aWizard[1][15],SFT->FT_VALCOF,0))	 	 //08 - VL_COFINS
				aAdd (aRegC460[nPos460], IIf(Empty(aInfPart[4]),aInfPart[5],aInfPart[4]))//09 - CPF_CNPJ
				aAdd (aRegC460[nPos460], aInfPart[2]				)	 	   	         //10 - NOM_ADQ

				aAdd (aRegC460[nPos460], cHierarq + "C460" + StrZero(nPos460, nTTRBITEM, 0) )		//11 - Posicao de Hierarquia, utilizada para organizacao dos registros	
			Else 
				aRegC460[nPosAux][7] += SFT->FT_VALCONT					 	   			//05 - VL_DOC
				aRegC460[nPosAux][8] += Iif("1"$aWizard[1][15],SFT->FT_VALPIS,0)		//06 - VL_PIS
				aRegC460[nPosAux][9] += Iif("1"$aWizard[1][15],SFT->FT_VALCOF,0)		//07 - VL_COFINS
			EndIf
			       
			aClasFis := SPDRetCCST ("SFT",.F.)
			
			cProdSft    := SFT->FT_PRODUTO
		    aDadosProd	:= RetUMProd(@aProdB1, cProdSft)
		    cProdUN		:= aDadosProd[1]
						
			nQtCanc := QtdeCanc(SFT->FT_PDV, SFT->FT_NFISCAL, SFT->FT_SERIE, SFT->FT_EMISSAO)   
			
			nPosPai := If(nPosAux == 0, nPos460, nPosAux)
			
			cProd	:= SB1->B1_COD+ Iif(lConcFil,cFilAnt,"") 
			If aExistBloc[05]
				aProd := Execblock("SPEDPROD", .F., .F., {"SB1","C470"})
				If Len(aProd)>=11
					cProd 	:= 	aProd[1]
				Else
					aProd := {"","","","","","","","","","","",""}
				EndIf
			EndIf			
						
			//³Preenchimento do registro 470  ³
			RegC470 (@aRegC470   , 	cProd 			, SFT->FT_QUANT ,	SFT->FT_VALCONT,;
					 SFT->FT_CFOP, 	SFT->FT_ALIQICM             , SFT->FT_VALPIS,	SFT->FT_VALCOF ,;
					 aClasFis[1] , 	nQtCanc                     , @aProdB1      ,	nPosPai        ,;
					 cFilSB1	 , cProdUN						, aWizard 		, 	nQuantD		   , cHierarq ) 
					 
			If aScan (aReg0200, {|aX| aX[2]==cProd}) == 0
				SFRG0200(cAlias, @aReg0200, @aReg0190, dDataDe, dDataAte,,cProd, @aReg0220,,,,,,,,,,,,,,,,,,,aWizard)
			EndIf
		EndIf     
		
		SFT->(dbSkip())
	End  
EndIf

RestArea(aAreaLoc)	
RestArea(aAreaSFT)

Return(lRet)


/*
³Fun‡…o    ³RegC470   ³ Autor ³ Vendas e CRM          ³ Data ³ 29/01/09 ³

³Descri‡…o ³ Efetua a carga dos dados dos registros C470                ³
³          ³ REGISTRO C470 - ITENS DO DOCUMENTO FISCAL EMITIDO POR ECF  ³

³ Uso      ³ SIGAFIS                                                    ³
*/		
Function RegC470(	aRegC470	, cProduto	, nQUANT	, nValCont		,;
					cCFOP		, nALIQICM	, nVALPIS	, nVALCOF		,; 
					cCST		, nQtCanc	, aProdB1	, nLinhaPai 	,;
					cFilSB1 	, cProdUN 	, aWizard 	, nQuantD		, cHierarq )

Local lRet 		:= .T.   
Local nPosAux	:= 0
Local nPos470	:= 0    

Default aWizard := {}
Default nQuantD   := Min(TAMSX3("FT_QUANT")[2],3)

	nPosAux := Ascan(aRegC470, {|x| x[3] == cProduto .AND. x[8] == cCST .AND. x[1] == nLinhaPai})

	If nPosAux == 0 		
		//³Preenchimento do registro 470  ³
		      
		aAdd(aRegC470, {})        
		nPos470 :=	Len (aRegC470)                  
		
		aAdd (aRegC470[nPos470], nLinhaPai		       )				//00 - RELACIONAMENTO COM REGISTRO PAI
		aAdd (aRegC470[nPos470], "C470"			       )	 			//01 - REG
		aAdd (aRegC470[nPos470], cProduto        	   )	 			//02 - COD_ITEM
		aAdd (aRegC470[nPos470], {nQUANT+nQtCanc , nQuantD }   )	 	//03 - QTD
		aAdd (aRegC470[nPos470], nQtCanc	           )	 			//04 - QTD_CANC
		aAdd (aRegC470[nPos470], cProdUN		       )				//05 - UNID         
		aAdd (aRegC470[nPos470], nValCont  		       )	 			//06 - VL_ITEM     
		aAdd (aRegC470[nPos470], cCST			       )	 			//07 - CST_ITEM
		aAdd (aRegC470[nPos470], cCFOP			       )	 			//08 - CFOP
		aAdd (aRegC470[nPos470], nALIQICM		       )	   			//09 - ALIQ_ICMS
		aAdd (aRegC470[nPos470], Iif("1"$aWizard[1][15],nVALPIS,0))		//10 - VL_PIS
		aAdd (aRegC470[nPos470], Iif("1"$aWizard[1][15],nVALCOF,0))		//11 - VL_COFINS

		aAdd (aRegC470[nPos470], cHierarq + "C460" + StrZero(nLinhaPai, nTTRBITEM, 0) + "C470" + StrZero(nPos470, nTTRBITEM, 0) )		//12 - Posicao de Hierarquia, utilizada para organizacao dos registros	
	Else
		aRegC470[nPosAux][4][1]  += nQUANT	+ nQtCanc   				//03 - QTD		   
		aRegC470[nPosAux][7]  += nValCont		 	   					//06 - VL_ITEM     
		aRegC470[nPosAux][5]  += nQtCanc			 					//04 - QTD_CANC
		aRegC470[nPosAux][11] += Iif("1"$aWizard[1][15],nVALPIS,0)		//10 - VL_PIS
		aRegC470[nPosAux][12] += Iif("1"$aWizard[1][15],nVALCOF,0)		//11 - VL_COFINS
	EndIf
	

Return(lRet)


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³RegC490   ³ Autor ³ Vendas e CRM          ³ Data ³ 29/01/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Efetua a carga dos dados dos registros C490                ³±±
±±³          ³ REGISTRO C490 - REGISTRO ANALITICO DO MOVIMENTO DIARIO     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGAFIS                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/		
Static Function RegC490(aRegC490	, dDtMovim	, nLinhaPai	,;
						cPdv		, aProdB1	, nPos405	,;
						aReg0200	, cAlias    , aReg0190	,;
						AREG0220	, nValCof	, nValPis	, cHierarq	)

Local lRet 		:= .T.
Local nPosAux   := 0
Local aAreaLoc	:= GetArea()
Local aClasFis	:=	{"","","",""}   
Local aAreaSFT	:=	SFT->(GetArea ())
Local nALIQRed	:= 0
Local nALIQICM	:= 0
Local nBCIcms	:= 0
Local lUsaQuery := .F.  
Local cTemp1     := GetNextAlias()		// Pega o proximo Alias Disponivel
Local nAliqSFT  := 0
Local aAuxReg   := {}
Local nValIcm	:= 0					// Valor do ICM
Local lMVUFICSEP:= aSPDSX6[MV_ESTADO]$aSPDSX6[MV_UFICSEP]

Default aReg0200 := {}
Default cAlias   := ""
Default AREG0190 := {}
Default AREG0220 := {}
Default nValCof	 := 0
Default nValPis	 := 0

//³Verifica se utiliza Query³
#IFDEF TOP
	If TcSrvType() <> "AS/400"
		lUsaQuery 	:= .T.		
	Endif
#ENDIF

If lUsaQuery
	
	BeginSql alias cTemp1
		SELECT 	SUM(FT_VALICM) FT_VALICM,SUM(FT_VALCONT) FT_VALCONT,SUM(FT_VALPIS) FT_VALPIS,SUM(FT_VALCOF) FT_VALCOF,SUM(FT_QUANT) FT_QUANT,
				SUM(FT_BASEICM) FT_BASEICM,FT_FILIAL,FT_CLASFIS,FT_CFOP,FT_ALIQICM,D2_SITTRIB, FT_CTIPI,FT_CSTPIS,FT_CSTCOF, FT_TIPO
		FROM %table:SFT% SFT  , %table:SD2% SD2 
		WHERE   SFT.FT_FILIAL   = %xfilial:SFT%  		AND
				SFT.FT_TIPOMOV  = 'S'   				AND
				SFT.FT_ENTRADA  = %exp:DTOS(dDtMovim)%  AND
				SFT.FT_PDV      = %exp:cPdv%			AND 
				(SFT.FT_ESPECIE	= 'CF'				OR SFT.FT_ESPECIE	= 'ECF') AND
				SFT.FT_DTCANC	= ' '					AND
                SFT.%notDel%       						AND
                SFT.FT_FILIAL   = SD2.D2_FILIAL   		AND 
			    SFT.FT_PDV      = SD2.D2_PDV     		AND 
			    SFT.FT_NFISCAL	= SD2.D2_DOC        	AND
                SFT.FT_SERIE	= SD2.D2_SERIE			AND	
                SFT.FT_ITEM 	= SD2.D2_ITEM			AND
   				SD2.%notDel%
		GROUP BY FT_FILIAL,FT_CLASFIS,FT_CFOP,FT_ALIQICM,D2_SITTRIB,FT_CTIPI,FT_CSTPIS,FT_CSTCOF,FT_TIPO
        ORDER BY FT_FILIAL,FT_CFOP,FT_CLASFIS,FT_ALIQICM
	EndSql
    
	While !(cTemp1)->(Eof ())
		cSitTrib := (cTemp1)->D2_SITTRIB	
		lRet := .T.		
		
		If ("T" $ cSitTrib)
			If Len(cSitTrib) > 4
				nAliqSFT := Val(SubStr(cSitTrib,2,2)+"."+SubStr(cSitTrib,4,Len(cSitTrib)))
			Else
				nAliqSFT := Val(SubStr(cSitTrib,2,Len(cSitTrib)))
			EndIf		
			nBCIcms	 := (cTemp1)->FT_VALCONT		   
			nValIcm  := (cTemp1)->FT_VALICM-(cTemp1)->(IIF(!lMVUFICSEP.Or.Left(FT_CFOP,1)<>'5'.Or.FT_TIPO$"BD",0,FT_VALFECP))
		ElseIf ("S" $ cSitTrib)
			nAliqSFT := 0
			nBCIcms	 :=	0
			nValIcm	 := 0
		Else
			nAliqSFT := (cTemp1)->FT_ALIQICM	
			nBCIcms	 :=	(cTemp1)->FT_BASEICM
			nValIcm  := (cTemp1)->FT_VALICM-(cTemp1)->(IIF(!lMVUFICSEP.Or.Left(FT_CFOP,1)<>'5'.Or.FT_TIPO$"BD",0,FT_VALFECP))
		EndIf	
		
		aClasFis := SPDRetCCST (cTemp1,.F.,)
		//³Guarda os valores de PIS e Confins para 490 ³
		nValCof += (cTemp1)->FT_VALCOF
		nValPis += (cTemp1)->FT_VALPIS
		//³Foi criado o array aAuxReg para que nao seja necessario dar o Ascan o array aReg490, ³
		//³ pois estava ocasionando uma lentidao no sistema pelo tamanho. 						³
		nPosAux := Ascan(aAuxReg, {|x| x[1] == nPos405 .AND. x[3] == aClasFis[1] .AND.  x[4] == (cTemp1)->FT_CFOP .AND. x[5] == nAliqSFT })   
		//³Preenchimento do registro C490 ³
		If nPosAux == 0
			aAdd(aRegC490, {})
			nPos :=	Len (aRegC490)
			
			aAdd (aRegC490[nPos], nPos405		 		)	  	//00 - RELACIONAMENTO COM O REGISTRO PAI
			aAdd (aRegC490[nPos], "C490"		 		) 	   	//01 - REG
			aAdd (aRegC490[nPos], aClasFis[1]			)	   	//02 - CST_ITEM
			aAdd (aRegC490[nPos], (cTemp1)->FT_CFOP	)	   		//03 - CFOP
			aAdd (aRegC490[nPos], nAliqSFT				)	   	//04 - ALIQ_ICMS
			aAdd (aRegC490[nPos], (cTemp1)->FT_VALCONT	)	   	//05 - VL_OPR
			aAdd (aRegC490[nPos], nBCIcms				)	   	//06 - VL_BC_ICMS
			aAdd (aRegC490[nPos], nValIcm				)	   	//07 - VL_ICMS
			aAdd (aRegC490[nPos], ""					)		//08 - COD_OBS
			nPos490 := nPos
			aAdd(aAuxReg, {})
			nPos :=	Len (aAuxReg)   
			aAdd (aAuxReg[nPos], nPos405		 		)	  	//01 - RELACIONAMENTO COM O REGISTRO PAI
			aAdd (aAuxReg[nPos], "C490"		 	   		) 	   	//02 - REG
			aAdd (aAuxReg[nPos], aClasFis[1]			)	   	//03 - CST_ITEM
			aAdd (aAuxReg[nPos], (cTemp1)->FT_CFOP		)	   	//04 - CFOP
			aAdd (aAuxReg[nPos], nAliqSFT				)	   	//05 - ALIQ_ICMS    
			aAdd (aAuxReg[nPos], nPos490				)	   	//06 - Posicao do ARegC490    
			

			aAdd (aRegC490[nPos], cHierarq + "C490" + StrZero(nPos, nTTRBITEM, 0)  )	//09 - Posicao de Hierarquia, utilizada para organizacao dos registros	
		Else 
			nPos490 := aAuxReg[nPosAux][6]			
			aRegC490[nPos490][6] += (cTemp1)->FT_VALCONT		//05 - VL_OPR
			aRegC490[nPos490][7] += nBCIcms					   	//06 - VL_BC_ICMS
			aRegC490[nPos490][8] += nValIcm						//07 - VL_ICMS
		EndIf	
							
		(cTemp1)->(dbSkip())
	End
	
	DbSelectArea(cTemp1)
	(cTemp1)->(DbCloseArea())   

Else

	DbSelectArea("SFT")
	DbSetOrder(2)   //FT_FILIAL+FT_TIPOMOV+DTOS(FT_ENTRADA)+FT_SERIE+FT_NFISCAL+FT_CLIEFOR+FT_LOJA+FT_ITEM+FT_PRODUTO
	MsSeek(aSPDFil[PFIL_SFT]+"S"+DtoS(dDtMovim), .T.)
	
		While !SFT->(Eof ()) .And. aSPDFil[PFIL_SFT] == SFT->FT_FILIAL .AND. SFT->FT_TIPOMOV == "S" .And.; 
			dDtMovim = SFT->FT_EMISSAO
			//³Somente para cupom e que nao tenha sido cancelado ³
			If !Empty(SFT->FT_PDV) .AND. Empty(SFT->FT_DTCANC) .AND. AllTrim(cPdv) == AllTrim(SFT->FT_PDV) .AND. SFT->FT_TIPO <> "S"
				//³Preenchimento do registro 490 ³
				aClasFis := SPDRetCCST ("SFT",.F.)
				//³Preenchimento do registro 470  ³
				nALIQRed:= RetUMProd(aProdB1, SFT->FT_PRODUTO)[2]
				If nALIQRed > 0
					nALIQICM := nALIQRed
					nBCIcms	 := SFT->FT_VALCONT
				Else 
					nALIQICM := SFT->FT_ALIQICM	
					nBCIcms	 :=	SFT->FT_BASEICM
				EndIf	
				      
				//Guarda os valores de PIS e Confins para 490      
				nValCof += SFT->FT_VALCOF
				nValPis += SFT->FT_VALPIS  
				
				nValIcm	:= SFT->FT_VALICM-SFT->(IIF(!lMVUFICSEP.Or.Left(FT_CFOP,1)<>'5'.Or.FT_TIPO$"BD",0,FT_VALFECP))
				nPosAux := Ascan(aRegC490, {|x| x[1] == nLinhaPai .AND. x[3] == aClasFis[1] .AND.  x[4] == SFT->FT_CFOP .AND. x[5] == nALIQICM })
				
				If nPosAux ==  0			
					aAdd(aRegC490, {})        
					nPos :=	Len (aRegC490)
					
					aAdd (aRegC490[nPos], nLinhaPai		 		)	 	   	//00 - RELACIONAMENTO COM O REGISTRO PAI
					aAdd (aRegC490[nPos], "C490"		 		)	 	   	//01 - REG
					aAdd (aRegC490[nPos], aClasFis[1]			)	 	   	//02 - CST_ITEM
					aAdd (aRegC490[nPos], SFT->FT_CFOP			)	 	   	//03 - CFOP
					aAdd (aRegC490[nPos], nALIQICM				)	 	   	//04 - ALIQ_ICMS
					aAdd (aRegC490[nPos], SFT->FT_VALCONT		)	 	   	//05 - VL_OPR
					aAdd (aRegC490[nPos], nBCIcms				)	 	   	//06 - VL_BC_ICMS
					aAdd (aRegC490[nPos], nValIcm				)	 	   	//07 - VL_ICMS
					aAdd (aRegC490[nPos], ""					)			//08 - COD_OBS
					
					aAdd (aRegC490[nPos], cHierarq + "C490" + StrZero(nPos, nTTRBITEM, 0)  )	//09 - Posicao de Hierarquia, utilizada para organizacao dos registros	
				Else 
					aRegC490[nPosAux][6] += SFT->FT_VALCONT				 	//05 - VL_OPR
					aRegC490[nPosAux][7] += nBCIcms			 				//06 - VL_BC_ICMS
					aRegC490[nPosAux][8] += nValIcm							//07 - VL_ICMS
				EndIf
			EndIf
			
			SFT->(dbSkip())
		End  

EndIf
RestArea(aAreaLoc)	 
RestArea(aAreaSFT)		

Return(lRet)


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³RegC495   ³ Autor ³ Vendas e CRM                 ³ Data ³ 29/01/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Efetua a carga dos dados dos registros C495                       ³±±
±±³          ³ REGISTRO C495 - RESUMO MENSAL DE ITENS DO ECF POR ESTABELECIMENTO ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGAFIS                                                           ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/		
Function RegC495( 	aRegC495, aProdB1	, nRegPai	, dDataIni	,;
					dDataFim, cPdv		, aReg0200	, cAlias	,;
					aReg0190, aReg0220	, aSLX		, cFilB1	, aWizard, cHierarq )

Local lRet 		:= .T.
Local nPosAux   := 0
Local aAreaLoc	:= GetArea()   
Local nPosSlx	:= 0 
Local aAreaSFT	:=	SFT->(GetArea ())
Local nALIQRed	:= 0
Local nALIQICM	:= 0
Local nBCIcms	:= 0
Local cProd		:= ""
Local aProd		:= {}
Local lMVC495TRI	:=	aSPDSX6[MV_C495TRI]

DbSelectArea("SLX")
SLX->(DbSetOrder(2)) //DTMOVTO + PDV

If Len(aSLX) == 0
	If MsSeek(aSPDFil[PFIL_SLX]+ DtoS(dDataIni), .T.)
		While !SLX->(Eof ()) .AND. SLX->LX_DTMOVTO <= dDataFim
			//³Preenchimento do registro 470  ³
			nALIQRed:= RetUMProd(aProdB1, SLX->LX_PRODUTO)[2]
			If nALIQRed > 0 .AND. lMVC495TRI
				nALIQICM := nALIQRed
			Else 
				nALIQICM := SLX->LX_ALIQICM	
			EndIf	
			
			nPosAux	:= Ascan(aSLX, {|x| x[1] == SLX->LX_PRODUTO .AND. x[2] == nALIQICM})
			
			If nPosAux == 0		
				aAdd(aSLX, {})        
				nPosSlx :=	Len (aSLX)           
				
				aAdd (aSLX[nPosSlx], SLX->LX_PRODUTO+cFilB1	)	 	
				aAdd (aSLX[nPosSlx], nALIQICM		)
				aAdd (aSLX[nPosSlx], SLX->LX_QTDE	)	   	
				aAdd (aSLX[nPosSlx], SLX->LX_VALOR	)	   	
			Else 
				aSLX[nPosAux][3] += SLX->LX_QTDE
				aSLX[nPosAux][4] += SLX->LX_VALOR
			EndIf
						
			SLX->(dbSkip())
		End
	EndIf
EndIf

DbSelectArea("SFT")
DbSetOrder(2)   //FT_FILIAL+FT_TIPOMOV+DTOS(FT_ENTRADA)+FT_SERIE+FT_NFISCAL+FT_CLIEFOR+FT_LOJA+FT_ITEM+FT_PRODUTO
MsSeek(aSPDFil[PFIL_SFT]+"S"+DtoS(dDataIni), .T.)
	
	While !SFT->(Eof ()) .AND. aSPDFil[PFIL_SFT] == SFT->FT_FILIAL .AND. SFT->FT_TIPOMOV == "S" .AND. SFT->FT_EMISSAO >= dDataIni;
			.AND. SFT->FT_EMISSAO <= dDataFim
			
		If AllTrim(SFT->FT_PDV) == AllTrim(cPdv) .AND. Empty(SFT->FT_DTCANC) .AND. SFT->FT_TIPO <> "S"
			//³Preenchimento do registro 470  ³
			nALIQRed:= RetUMProd(aProdB1, SFT->FT_PRODUTO)[2]
			If nALIQRed > 0 .AND. lMVC495TRI
				nALIQICM := nALIQRed
				nBCIcms	 := SFT->FT_VALCONT
			Else 
				nALIQICM := SFT->FT_ALIQICM	
				nBCIcms	 :=	SFT->FT_BASEICM	
			EndIf	
			//³Preenchimento do registro 495 ³
			cProd	:= SFT->FT_PRODUTO+Iif(lConcFil,cFilB1,"")
			If aExistBloc[05]
				aProd := Execblock("SPEDPROD", .F., .F., {"SFT","C495"})
				If Len(aProd)>=11
					cProd 	:= 	aProd[1]
				Else
					aProd := {"","","","","","","","","","","",""}
				EndIf
			EndIf			
			
			nPosAux := Ascan(aRegC495, {|x| x[4] == cProd})
			
			nPosSlx	:= Ascan(aSLX, {|x| x[1] == cProd .AND. x[2] == nALIQICM })
					
			If nPosAux ==  0			
				aAdd(aRegC495, {})        
				nPos :=	Len (aRegC495)
	
				aAdd (aRegC495[nPos], nRegPai		 						)	 	//00 - RELACIONAMENTO COM O REGISTRO PAI
				aAdd (aRegC495[nPos], "C495"		 						)	   	//01 - REG
				aAdd (aRegC495[nPos], nALIQICM								)	   	//02 - ALIQ_ICMS
				aAdd (aRegC495[nPos], cProd									)	   	//03 - COD_ITEM
				aAdd (aRegC495[nPos], SFT->FT_QUANT							) 	   	//04 - QTD
	            
				If nPosSlx > 0 
					aAdd (aRegC495[nPos], aSLX[nPosSlx][3]					)	   	//05 - QTD_CANC			
				Else
					aAdd (aRegC495[nPos], 0									)	   	//05 - QTD_CANC
				EndIf
				
				aAdd (aRegC495[nPos], RetUMProd(@aProdB1, SFT->FT_PRODUTO)[1])		//06 - UNID      
				aAdd (aRegC495[nPos], (SFT->FT_QUANT*SFT->FT_PRCUNIT)		) 	   	//07 - VL_ITEM
				aAdd (aRegC495[nPos], SFT->FT_DESCONT						)	   	//08 - VL_DESC 
				
				If nPosSlx > 0 
					aAdd (aRegC495[nPos], aSLX[nPosSlx][4]					)	   	//09 - VL_CANC 			
				Else
					aAdd (aRegC495[nPos], 0									)	   	//09 - VL_CANC 
				EndIf
				
				aAdd (aRegC495[nPos], SFT->FT_DESPESA						) 	   	//10 - VL_ACMO
				aAdd (aRegC495[nPos], nBCIcms								) 	   	//11 - VL_BC_ICMS
				aAdd (aRegC495[nPos], SFT->FT_VALICM						)	   	//12 - VL_ICMS
				aAdd (aRegC495[nPos], SFT->FT_ISENICM						) 	   	//13 - VL_ISEN
				aAdd (aRegC495[nPos], 0										)	   	//14 - VL_NT
				aAdd (aRegC495[nPos], SFT->FT_ICMSRET						) 	   	//15 - VL_ICMS_ST

				aAdd (aRegC495[nPos], cHierarq + "C495" + StrZero(nPos, nTTRBITEM, 0) )		//16 - Posicao de Hierarquia, utilizada para organizacao dos registros	

				SB1->(DbSetOrder(1))
				SB1->(MsSeek(cFilB1+SFT->FT_PRODUTO))

				//Gera Registro 0200
				If AScan(aReg0200, {|aX| aX[2]==cProd}) == 0
					SFRG0200(cAlias, @aReg0200, @aReg0190, dDataIni, dDataFim, ,cProd , @aReg0220,,,,,,,,,,,,,,,,,,,aWizard)
				EndIf
			Else 
				aRegC495[nPosAux][5]  += SFT->FT_QUANT								//04 - QTD
				
				If nPosSlx > 0 
					aRegC495[nPosAux][6] += aSLX[nPosSlx][3]					   	//05 - QTD_CANC			
				EndIf
	
				aRegC495[nPosAux][8]  += (SFT->FT_QUANT*SFT->FT_PRCUNIT)			//07 - VL_ITEM
				aRegC495[nPosAux][9]  += SFT->FT_DESCONT		 	  			 	//08 - VL_DESC 
				
				If nPosSlx > 0 
					aRegC495[nPosAux][10] += aSLX[nPosSlx][3]					   	//09 - VL_CANC 
				EndIf
				
				aRegC495[nPosAux][11] += SFT->FT_DESPESA		 	  			 	//10 - VL_ACMO
				aRegC495[nPosAux][12] += nBCIcms				 	  			 	//11 - VL_BC_ICMS
				aRegC495[nPosAux][13] += SFT->FT_VALICM		 	  		  		 	//12 - VL_ICMS
				aRegC495[nPosAux][14] += SFT->FT_ISENICM		 	 			  	//13 - VL_ISEN
				aRegC495[nPosAux][15] += 0											//14 - VL_NT
				aRegC495[nPosAux][16] += SFT->FT_ICMSRET		 	 			  	//15 - VL_ICMS_ST
			EndIf
		EndIf
		SFT->(dbSkip())
	End
	
RestArea(aAreaLoc)    
RestArea(aAreaSFT)

Return(lRet)
/*
±±³Programa  ³RegC500   ³ Autor ³Gustavo G. Rueda       ³ Data ³09.03.2011³±±

±±³Descri‡…o ³                                                            ³±±
±±³          ³     NOTA FISCAL CONTA DE ENERGIA ELETRICA (MODELO 06)      ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao e gravacao do Registro C500                       ³±±

±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com as informacoe contidas no array    ³±±
±±³          ³ aRegC100 para o Modelo 06.                                 ³±±

±±³Nivel Hier³2(varios por arquivo)                                       ³±±

±±³Retorno   ³.T.                                                         ³±±

±±³Parametros³cAlias -> Alias do TRB que recebera as informacoes          ³±±
±±³          ³nRelac -> Flag de relacionamento com os sub-registros       ³±±
±±³          |aRegC100 -> Informacoes sobre todos documentos fiscais pro- ³±±
±±³          ³ cessados no while da funcao principal.                     ³±±
±±³          ³aTotaliza -> Totalizadores de valores para a tabela SFT.    ³±±
±±³          ³aRegC500 -> Conteudo gravado do registro C500 para utiliza- ³±±
±±³          ³ cao em outros registros da funcao principal.               ³±±
±±³          ³nItem -> Contador do item para cada documento fiscal.       ³±±
±±³          ³lAchouSFU -> Flag de localizacao do SFU para o NF em proces-³±±
±±³          ³ samento.                                                   ³±±
±±³          ³lAchouCD3 -> Flag de localizacao do CD3 para o NF em proces-³±±
±±³          ³ samento.                                                   ³±±
±±³          ³lGravaC500-> Flag de gravacao do registro conforme regras   ³±±
±±³          ³ anteriores de processamento                                ³±±
±±³          ³lGrava0150-> Flag de gravacao do registro conforme regras   ³±±
±±³          ³ anteriores de processamento                                ³±±
±±³          ³aCmpAntSFT-> Campos da tabela SFT por documento fiscal      ³±±
±±³          ³lAchouCD4 -> Flag de localizacao do CD4 para o NF em proces-³±±
±±³          ³ samento.                                                   ³±±
±±³          ³aInfCompl -> Array com as informacoes complementares do     ³±±
±±³          ³cAliasCD4 -> Alias da tabela CD4 baseado em SELECT ou Ind-  |±±
±±³          ³             regua                                          |±±
*/
Static Function RegC500(cAlias,nRelac,aRegC100,aTotaliza,aRegC500,nItem,lAchouSFU,lAchouCD3,lGravaC500,lGrava0150,aCmpAntSFT,lAchouCD4,aInfCompl,cAliasCD4,aWizard,aDadSFU,aPartDoc,lAchouCDD,cAliasCDD)
Local	lRet   		:=	.T.
Local	nPos		:=	0
Local	cCodCons	:= ""
Local	nVlTerc  	:=	0
Local   cTpLiga     := ""
Local   cGrpTens    := ""
Local 	nVlFornec	:= 0
Local 	cFinDoc		:= ""
Local 	cIND_DEST	:= ""
Local 	cChvRef		:= ""
Local 	lNfAtiva	:= !aRegC100[1][6]$"02#04#05" //Cancelada /denegada e inutilizada
Local 	cCliente	:= aRegC100[1][4]
Local	lMod66		:= aRegC100[1][5]=="66"
Local	cContCtb	:= ""
Local 	cCodMun		:= ""
Local 	cSerRef		:= ""
Local 	cNumRef		:= ""
Local 	cMAnoRef	:= ""
Local   cModRef		:= ""

Default aWizard := {}
Default aDadSFU := {}

//³Tratamento para energia eletrica³
If aRegC100[1][5] == "06" .Or. aRegC100[1][5] == "66"	
	// O Len de aDadSFU sera > 0 nas NF's de entrada. Este array contem
	// os valores do(s) complemento(s) agrupados por classe de consumo.
	// Considero sempre a primeira posicao pois soh existe um campo de
	// classe de consumo no registro C500, logo, nao deveria ser possivel
	// haver mais de uma classe na mesma NF. 
	If Len(aDadSFU) > 0
		cCodCons 	:= aDadSFU[1,1]
		nVlTerc  	:= aDadSFU[1,4]
		nVlFornec	:= aDadSFU[1,5]
		cGrpTens 	:= aDadSFU[1,3]
		cTpLiga 	:= aDadSFU[1,2]				
	ElseIf lAchouSFU 
		cCodCons 	:= SFU->FU_CLASCON
		nVlTerc  	:= SFU->FU_VALTERC
		nVlFornec	:= Iif(aSPDSX3[FP_FU_VLFORN], SFU->FU_VLFORN, 0)
		cGrpTens 	:= Iif(aSPDSX3[FP_FU_GRUPT], SFU->FU_GRUPT, "")
		cTpLiga   := Iif(aSPDSX3[FP_FU_TIPLIGA], SFU->FU_TIPLIGA, "")			
	EndIf

	
 		cSerRef		:= (cAliasCDD)->CDD_SERREF
 		cNumRef		:= (cAliasCDD)->CDD_DOCREF 
		cMAnoRef	:= Iif(aSPDSX3[FP_CDD_MEANRF],(cAliasCDD)->CDD_MEANRF,"")
		cModRef     := Iif(aSPDSX3[FP_CDD_MODREF],aModnot((cAliasCDD)->CDD_MODREF),"")
		
//³Tratamento para Gas³
ElseIf aRegC100[1][5] == "28" .And. lAchouCD3
	cCodCons := CD3->CD3_CLASCO
	nVlTerc  := CD3->CD3_VLTERC

//³Tratamento para Agua canalizada³
ElseIf aRegC100[1][5] == "29" .And. lAchouCD4
	cCodCons := (cAliasCD4)->CD4_CLASCO
	nVlTerc  := (cAliasCD4)->CD4_VLTERC

EndIf

IF lNfAtiva 
	cContCtb := RetCOD_CTA(,"C500", aCmpAntSFT )
	If Empty(cContCtb)
		cContCtb := aCmpAntSFT[19]
	Endif	

	If aRegC100[1][2] <> "0"
		IF "ISENT" $ Upper(Alltrim(aPartDoc[6])) // IE
			cIND_DEST := "2" // Contribuinte Isento de Inscrição no Cadastro de Contribuintes do ICMS
		Elseif !Empty(aPartDoc[6])
			cIND_DEST := "1" // Contribuinte
		Else
			cIND_DEST := "9" // Não Contribuinte
		Endif
		
		cCodMun := Iif(!Empty(aCmpAntSFT[58]),aCmpAntSFT[58],aPartDoc[7])
	EndIf
Endif

IF lMod66
	
	If aRegC100[1][2] == "1" .and. cIND_DEST <> "1"
		//Quando o COD_MOD for “66” e IND_OPER for “1”, este campo só deve ser informado se o campo IND_DEST for “1”.
		cCliente := ""
	Endif

	IF lNfAtiva
		If aCmpAntSFT[20] $ "IP" 
			// A nota será gerada como 2 (NF-e complementar) apenas para a nota complementar de imposto. Sendo neste caso, obrigatório referenciar nota de origem.
			cFinDoc := "2"
		Elseif aCmpAntSFT[20] $ "C" 
			//A nota será gerada como 3 (NF-e de ajuste) para nota complementar de entrada e nota de diferença de preço.
			cFinDoc := "3"
		Else 
			//Notmal
			cFinDoc := "1" 
		Endif

		If !empty(cSerRef) .and. !empty(cNumRef) .and. !empty(cMAnoRef)
			cFinDoc := "2"
		Endif

		//Chave doc referenciado
		If cFinDoc == "2" .AND. lAchouCDD .And. cModRef == '66'
			cChvRef := (cAliasCDD)-> CDD_CHVNFE
		Endif
	Endif	
Endif

aAdd(aRegC500, {})
nPos	:=	Len (aRegC500)
aAdd (aRegC500[nPos], "C500")	 	   										//01 - REG
aAdd (aRegC500[nPos], aRegC100[1][2])	   			  						//02 - IND_OPER
aAdd (aRegC500[nPos], aRegC100[1][3])	   			  						//03 - IND_EMIT
aAdd (aRegC500[nPos], cCliente)	   					  						//04 - COD_PART
aAdd (aRegC500[nPos], aRegC100[1][5])	   			  						//05 - COD_MOD
aAdd (aRegC500[nPos], aRegC100[1][6])	   			   						//06 - COD_SIT
aAdd (aRegC500[nPos], aRegC100[1][7])	   									//07 - SER
aAdd (aRegC500[nPos], "")	   						   						//08 - SUB
aAdd (aRegC500[nPos], Iif(lMod66,"",cCodCons) )		   						//09 - COD_CONS
aAdd (aRegC500[nPos], aRegC100[1][8])	   			   						//10 - NUM_DOC
aAdd (aRegC500[nPos], aCmpAntSFT[6])	   			   						//11 - DT_DOC
aAdd (aRegC500[nPos], aRegC100[1][11])	   									//12 - DT_E_S
aAdd (aRegC500[nPos], aRegC100[1][12])										//13 - VL_DOC  
aAdd (aRegC500[nPos], aRegC100[1][14])	   				   					//14 - VL_DESC
// O campo 15 não pode conter o valor "0" pois ocorre erro de validação no PVA. 
// Quando o documento for emitido por regime especial ou norma específica (sit. "08"),
// o tratamento do sistema é zerar o valor da mercadoria/prestação nos registros cabeçalho 
// (C100, C500, D100, D400, etc.) porém este é o único campo que possui a validação ">0" 
// (Vide Guia Prático). Desta forma, o valor deve ser demonstrado mesmo nesta situação. 
aAdd (aRegC500[nPos], IIF(lNfAtiva,IIF(nVlFornec>0,nVlFornec,aTotaliza[10]),"")) //15 - VL_FORN
aAdd (aRegC500[nPos], IIF(lNfAtiva,aTotaliza[7],""))						//16 - VL_SERV_NT
aAdd (aRegC500[nPos], IIF(lNfAtiva,nVlTerc,""))								//17 - VL_TERC
aAdd (aRegC500[nPos], aRegC100[1][20])	   				  					//18 - VL_DA
aAdd (aRegC500[nPos], aRegC100[1][21])	   									//19 - VL_BC_ICMS
aAdd (aRegC500[nPos], aRegC100[1][22])	   									//20 - VL_ICMS
aAdd (aRegC500[nPos], aRegC100[1][23])				   						//21 - VL_BC_ICMS_ST
aAdd (aRegC500[nPos], aRegC100[1][24])	   									//22 - VL_ICMS_ST
aAdd (aRegC500[nPos], aInfCompl[1])											//23 - COD_INF
aAdd (aRegC500[nPos], Iif("1"$aWizard[1][15],aRegC100[1][26],0))			//24 - VL_PIS
aAdd (aRegC500[nPos], Iif("1"$aWizard[1][15],aRegC100[1][27],0))			//25 - VL_COFINS
If cVersao >= "003"
	aAdd (aRegC500[nPos], Iif(lMod66,"",cTpLiga))							//26 - TP_LIGACAO - LAYOUT 2010
	aAdd (aRegC500[nPos], Iif(lMod66,"",cGrpTens))							//27 - COD_GRUPO_TENSAO - LAYOUT 2010
EndIf
If cVersao >= "014"
	aAdd (aRegC500[nPos], Iif(cVersao >= "016",Iif(aRegC100[1][5] == "66",aCmpAntSFT[25],""),aCmpAntSFT[25]))	//28 - CHV_DOCe
	aAdd (aRegC500[nPos], Iif(cVersao >= "016",Iif(aRegC100[1][5] == "66",cFinDoc,""),cFinDoc))			//29 - FIN_DOCe
	aAdd (aRegC500[nPos], cChvRef)  	 	  								//30 - CHV_DOCe_REF
	aAdd (aRegC500[nPos], cIND_DEST)  		   								//31 - IND_DEST
	aAdd (aRegC500[nPos], cCodMun)  										//32 - COD_MUN_DEST
	aAdd (aRegC500[nPos], cContCtb) 										//33 - COD_CTA
Endif

If cVersao >= "016"
	//Segundo Manual Guia Prático EFD - Versão 3.0.9.pdf as posições 15, 16 e 17 do registro C500
	//só devem ser apresentadas para Modelo 66 NF3E em alguns códigos de Grupo vide pagina 136
	aRegC500[nPos][15] := IIF(lMod66,aRegC500[nPos][15],0)					//15 - VL_FORN
	aRegC500[nPos][16] := IIF(lMod66,aRegC500[nPos][16],0)			   		//16 - VL_SERV_NT
	aRegC500[nPos][17] := IIF(lMod66,aRegC500[nPos][17],0)					//17 - VL_TERC
	aAdd (aRegC500[nPos], Iif(cFinDoc == "2" .And. (aRegC100[1][5] == "06" .Or. aRegC100[1][5] == "66"),cModRef,""))//34 - COD_MOD_DOC_REF
	aAdd (aRegC500[nPos], "") 												//35 - HASH_DOC_REF
	aAdd (aRegC500[nPos], Iif(cModRef =='06',cSerRef,""))  	 	  			//36 - SER_DOC_REF 
	aAdd (aRegC500[nPos], Iif(cModRef =='06',cNumRef,""))  		   			//37 - NUM_DOC_REF 
	aAdd (aRegC500[nPos], Iif(cModRef =='06',cMAnoRef,""))					//38 - MES_DOC_REF	
	aAdd (aRegC500[nPos], "")											    //39 - ENER_INJET
	aAdd (aRegC500[nPos], "") 												//40 - OUTRAS_DED 
Endif

If lGravaC500
	GrvRegTrS(cAlias,RetRD(nRelac),aRegC500,nItem)
	//³No registro C100, quando este campo estiver em branco, eh pq nao deve       ³
	//³ ser enviado o codigo do participante, assim nao precisa gerar tambem o 0150³
	If !Empty(cCliente) //Valida proprio registro para gerar 0150 devido modelo 66
		lGrava0150 := .T.
	EndIf
EndIf

Return (lRet)
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³RegC510   ³ Autor ³Gustavo G. Rueda       ³ Data ³09.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±³          ³               ITENS DO DOCUMENTO (MODELO 06)               ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao e gravacao do Registro C510                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com as informacoe contidas no array    ³±±
±±³          ³ aRegC170 para o Modelo 06.                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³3(1:N) Para cada C500                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nil                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cAlias     -> Alias do TRB que recebera as informacoes      ³±±
±±³          ³nRelac     -> Flag de relacionamento com os sub-registros   ³±±
±±³          |aRegC170   -> Informacoes sobre os itens dos documentos     ³±±
±±³          ³              fiscais processados no while da funcao prin-  ³±±
±±³          ³              cipal.                                        ³±±
±±³          ³aPartDoc   -> Array com informacoes sobre o participante do ³±±
±±³          ³ 				documento fiscal, este array eh montado pela  ³±±
±±³          ³ 				funcao principal                              ³±±
±±³          ³aRegC510   -> Conteudo gravado do registro C510 para utili- ³±±
±±³          ³              zacao em outros registros da funcao principal.³±±
±±³          ³nItem      -> Contador do item para cada documento fiscal.  ³±±
±±³          ³lAchouSFU  -> Flag de seek da tabela SFU                    ³±±
±±³          ³lGravaC500 -> Flag para determinar se deverah gravar o C500 ³±±
±±³          ³lGrava0150 -> Flag para determinar se deverah gravar o 0150 ³±±
±±³          ³cSituaDoc  -> Status do documento fiscal.                   ³±±
±±³          ³lGrava0200 -> Flag para determinar se deverah gravar o 0200 ³±±
±±³          ³cEntSai    -> Identifica ENTRADA=1/SAIDA=2.                 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function RegC510(cAlias,nRelac,aRegC170,aPartDoc,aRegC510,nItem,lAchouSFU,lGravaC500,;
	lGrava0150,cSituaDoc,lGrava0200,cEntSai,aWizard)
	
Local	nPos		:=	0
Local	cCodClas	:= ""
Default aWizard		:= {}

If lAchouSFU
	If TamSx3("FU_GRPCLAS")[1] == 2
		cCodClas	:= SFU->FU_GRPCLAS+IIf(aSPDSX3[FP_FU_CLASSIF],SFU->FU_CLASSIF,"")
	Else
		cCodClas	:= "0"+SFU->FU_GRPCLAS+IIf(aSPDSX3[FP_FU_CLASSIF],SFU->FU_CLASSIF,"")
	EndIf	
EndIf

aAdd(aRegC510, {})
nPos	:=	Len (aRegC510)
aAdd (aRegC510[nPos], "C510")	 	   					//01 - REG
aAdd (aRegC510[nPos], aRegC170[1][2])	   				//02 - NUM_ITEM
aAdd (aRegC510[nPos], aRegC170[1][3])	   				//03 - COD_ITEM
aAdd (aRegC510[nPos], cCodClas)							//04 - COD_CLASS
aAdd (aRegC510[nPos], aRegC170[1][5][1])				//05 - QTD
aAdd (aRegC510[nPos], aRegC170[1][6])	   				//06 - UNID
aAdd (aRegC510[nPos], aRegC170[1][7])	   				//07 - VL_ITEM
aAdd (aRegC510[nPos], aRegC170[1][8])	   				//08 - VL_DESC
aAdd (aRegC510[nPos], aRegC170[1][10])	   				//09 - CST_ICM
aAdd (aRegC510[nPos], aRegC170[1][11])	   				//10 - CFOP
aAdd (aRegC510[nPos], aRegC170[1][13])	   				//11 - VL_BC_ICMS
aAdd (aRegC510[nPos], aRegC170[1][14])	   				//12 - ALIQ_ICMS
aAdd (aRegC510[nPos], aRegC170[1][15])	   				//13 - VL_ICMS
aAdd (aRegC510[nPos], aRegC170[1][16])	   				//14 - VL_BC_ICMS_ST
aAdd (aRegC510[nPos], aRegC170[1][17])	   				//15 - ALIQ_ICMS_ST
aAdd (aRegC510[nPos], aRegC170[1][18])	   				//16 - VL_ICMS_ST
aAdd (aRegC510[nPos], "0")			   					//17 - IND_REC
aAdd (aRegC510[nPos], aPartDoc[1])	   					//18 - COD_PART
aAdd (aRegC510[nPos], Iif("1"$aWizard[1][15],aRegC170[1][30],0))	//19 - VL_PIS
aAdd (aRegC510[nPos], Iif("1"$aWizard[1][15],aRegC170[1][36],0))	//20 - VL_COFINS
aAdd (aRegC510[nPos], aRegC170[1][37])					//21 - COD_CTA

//³Segundo manual, para documentos cancelados, somente o registro³
//³ pai deve ser gravado (alguns campos), nao deve gerar nenhum  ³
//| do filhos                                                    |
If lGravaC500 .And. !cSituaDoc$"02#04#05#03" .And. cEntSai=="2"
	//GrvRegTrS(cAlias,nRelac,{aRegC510[nPos]},nItem)           
	GrvRegTrS(cAlias,GetRelaGrv(nRelac, 3),{aRegC510[nPos]},nItem)      

	lGrava0200 := .T.

	lGrava0150 := .T.
EndIf
Return
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  |RegC590   ³ Autor ³Gustavo G. Rueda       ³ Data ³09.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±³          ³C590 - REGISTRO ANALITICO DO DOCUMENTO (MODELOS 06, 28 E 29)³±±
±±³          ³                                                            ³±±
±±³          ³- Acumula valores para a gravacao do registro E105 junto com³±±
±±³          ³ a gravacao do registro E100.                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com as informacoe contidas na tabela   ³±±
±±³          ³ SFT.                                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³E760 - 3(1:N) Para cada E700                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nil                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros|cAliasSFT-> Alias da tabela SFT aberta no momento.          ³±±
±±³          ³aRegC590 -> Array com as informacoes acumuladas             ³±±
±±³          ³cSituaDoc-> Situação do documento                           ³±±
±±³          ³aClasFis -> Codigo da Situação Tributaria                   ³±±
±±³          ³aRegC170 -> Array com as informacoes jah processadas        ³±±
±±³          ³aLanCDA - array com os lancamentos do documento fiscal      ³±±
±±³          ³nRedBSICM -> Valor de reducao da base de calculo do ICMS    |±±
±±³          ³cAliasSF4-> Informa qual o alias da tabela SF4, podendo ser ³±±
±±³          ³            query                                           ³±±
±±³          ³aLancFis-> Array com lancamentos de documento nao amarrados³±±
±±³          ³            ao C197                                         ³±±
±±³          ³aReg0460  -> Array com a estrutura do 0460 gerado ateh o    ³±±
±±³          ³            momento.                                        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function RegC590(cAliasSFT,aRegC590,cSituaDoc,aClasFis,aRegC170,aLanCDA,nRedBSICM,cAliasSF4,aLancFis,aReg0460,cEspecie,aRegC591,aWizard,lAchouSF4,nRecnoCCE)
Local	nPos 	 := 0
Local	nVlFcpOP := 0
Local	nVlFcpST := 0
Local	nPos591	 := 0


//³REGISTRO C590 - REGISTRO ANALITICO DOS DOCUMENTOS (MODELOS 06, 28 E 29)³
If (nPos := aScan(aRegC590,{|aX| aX[2]==aClasFis[1] .And. aX[3]==aRegC170[1][11] .And. aX[4]==aRegC170[1][14]}))==0
	aAdd (aRegC590, {})
	nPos	:=	Len (aRegC590)
	aAdd (aRegC590[nPos], "C590")							//01 - REG
	aAdd (aRegC590[nPos], aClasFis[1])						//02 - CST_ICMS
	aAdd (aRegC590[nPos], aRegC170[1][11])	   	  		   	//03 - CFOP
	aAdd (aRegC590[nPos], aRegC170[1][14])			   		//04 - ALIQ_ICMS
	aAdd (aRegC590[nPos], 0)						   		//05 - VL_OPR
	aAdd (aRegC590[nPos], 0)						   		//06 - VL_BC_ICMS
	aAdd (aRegC590[nPos], 0)						   		//07 - VL_ICMS
	aAdd (aRegC590[nPos], 0)						   		//08 - VL_BC_ICMS_ST
	aAdd (aRegC590[nPos], 0)						   		//09 - VL_ICMS_ST
	aAdd (aRegC590[nPos], 0)						   		//10 - VL_RED_BC
	aAdd (aRegC590[nPos], "")						  		//11 - COD_OBS
	
	//³Se houver lancamento fiscal nao amarrado ao C197, devo prioriza-lo³
	If Len(aLancFis)>=1
		aRegC590[nPos,11] := aLancFis[1,1]
		
		//³REGISTRO 0460 - TABELA DE OBSERVACOES DO LANCAMENTO FISCAL      ³
   		Reg0460(@aReg0460,{aLancFis[1,1],aLancFis[1,2]})

	//³Quando este array estiver com conteudo, jah terah de todos os itens,³
	//³ neste caso, preciso obter somente o lancamento do referido item    ³
	ElseIf Len(aLanCDA)>0 .And. (nPosIt := aScan(aLanCDA,{|aX|aX[14]==(cAliasSFT)->FT_ITEM}))>0
		aRegC590[nPos,11] := aLanCDA[nPosIt,7] 	
	ElseIf lAchouSF4
		lAchouCCE := SPEDSeek("CCE",,aSPDFil[PFIL_CCE]+SF4->F4_CODOBSE,nRecnoCCE)

		If lAchouCCE
			nPos0460 := aScan(aReg0460,{|aX| aX[2]==AllTrim(CCE->CCE_COD) })		
			
			If nPos0460 == 0 
				//³REGISTRO 0460 - TABELA DE OBSERVACOES DO LANCAMENTO FISCAL      ³
				Reg0460(@aReg0460,{CCE->CCE_COD,CCE->CCE_DESCR})
			EndIf
			aRegC590[nPos,11] := CCE->CCE_COD
		EndIf
	EndIf

	aAdd (aRegC590[nPos], RetRD(GetRelacPr())+strzero(nPos,nTamFT_IT * 2))		//12 - Posição de Hierarquia  		
EndIf

If !cSituaDoc$"02#03#04#05"
	aRegC590[nPos][5]	+=	(cAliasSFT)->FT_VALCONT	 		//05 - VL_OPR
	aRegC590[nPos][6]	+=	aRegC170[1][13]					//06 - VL_BC_ICMS
	aRegC590[nPos][7]	+=	aRegC170[1][15]					//07 - VL_ICMS
	aRegC590[nPos][8]	+=	aRegC170[1][16]					//08 - VL_BC_ICMS_ST
	aRegC590[nPos][9]	+=	aRegC170[1][18]					//09 - VL_ICMS_ST
	aRegC590[nPos][10]	+=	nRedBSICM						//10 - VL_RED_BC

	nVlFcpOP  := Iif(aRegC590[nPos][7] > 0,(cAliasSFT)->FT_VALFECP,0)
	nVlFcpST  := Iif(aRegC590[nPos][9] > 0,(cAliasSFT)->FT_VFECPST,0)

	//REGISTRO C591: INFORMAÇÕES DO FUNDO DE COMBATE À POBREZA – FCP NA NF3e (CÓDIGO 66)
	If aWizard[1][23]=="1-Sim" .and. cVersao >= "014" .and. cEspecie $ "66"
		If (nVlFcpOP+nVlFcpST) > 0
			IF (nPos591 := aScan (aRegC591, {|aX| aX[1]==nPos}) ) == 0
				aAdd(aRegC591, {})
				nPos591	:=	Len(aRegC591)
				aAdd (aRegC591[nPos591], nPos)	 		//Relação com Registro C590 Pai
				aAdd (aRegC591[nPos591], "C591")		//01 - REG
				aAdd (aRegC591[nPos591], nVlFcpOP)		//02 - VL_FCP_OP
				aAdd (aRegC591[nPos591], nVlFcpST)		//03 - VL_FCP_ST		

				aAdd (aRegC591[nPos591], RetRD(GetRelacPr())+strzero(nPos,nTamFT_IT * 2))		//04 - Posição de Hierarquia  				
			Else
				aRegC591[nPos591][3]	+=	nVlFcpOP	//02 - VL_FCP_OP
				aRegC591[nPos591][4]	+=	nVlFcpST	//03 - VL_FCP_ST				
			Endif
		Endif
	Endif

Endif
Return
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³RegC600   ³ Autor ³Gustavo G. Rueda       ³ Data ³10.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±³          ³            REGISTRO C600 - CONSOLIDACAO DIARIA:            ³±±
±±³          ³    NOTAS FISCAIS/CONTA DE ENERGIA ELETRICA (MODELO 06),    ³±±
±±³          ³    NOTA FISCAL/CONTA DE FORNECIMENTO D'AGUA CANALIZADA     ³±±
±±³          ³      (CODIGO 29) E NOTA FISCAL/CONTA DE FORNECIMENTO       ³±±
±±³          ³                      DE GAS (CODIGO 28)                    ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao da estrutura do Registro C600                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS no final do processamento da rotina    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³C600 - 2(varios por arquivo)                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpN1    -> Posicao de gravacao do registro C600 para       ³±±
±±³          ³            relacionamento com os registros filhos          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros|aRegC500 -> Conteudo gravado do registro C500 para utiliza- ³±±
±±³          ³ cao em outros registros da funcao principal.               ³±±
±±³          ³aPartDoc -> Informacoes sobre o participante do  documentos ³±±
±±³          ³aRegC600 -> Array contendo as informacoes processadas pela  ³±±
±±³          ³ funcao a ser retornado para gravacao pela funcao principal.³±±
±±³          ³lAchouSFU-> Flag do resultado do seek na tabela SFU         ³±±
±±³          ³lAchouCD3-> Flag do resultado do seek na tabela CD3         ³±±
±±³          ³lAchouCD4-> Flag do resultado do seek na tabela CD4         ³±±
±±³          ³cAliasCD4 -> Alias da tabela CD4 baseado em SELECT ou Ind-  |±±
±±³          ³             regua                                          |±±
±±³          ³cSituaDoc-> Situacao do documento                           ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function RegC600(aRegC500,aPartDoc,aRegC600,lAchouSFU,lAchouCD3,lAchouCD4,cAliasCD4,cSituaDoc,aWizard)
Local	nPos		:=	0
Local	cCodCons	:=	""
Local	nVlTerc  	:=	0
Local	nConskwh  	:=	0
Local	lClasCo		:=	aSPDSX3[FP_F3_CLASCO]
Default aWizard		:= {}
//³Obtendo valores das tabelas complementares³
If (aRegC500[1][5] == "06" .Or. aRegC500[1][5] == "66") .And. lAchouSFU
	cCodCons := SFU->FU_CLASCON
	nVlTerc  := SFU->FU_VALTERC
	nConskwh := SFU->FU_CONSTOT

ElseIf aRegC500[1][5] == "28" .And. lAchouCD3
	cCodCons := CD3->CD3_CLASCO
	nVlTerc  := CD3->CD3_VLTERC

ElseIf aRegC500[1][5] == "29" .And. lAchouCD4
	cCodCons := (cAliasCD4)->CD4_CLASCO
	nVlTerc  := (cAliasCD4)->CD4_VLTERC
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Para as notas canceladas do modelo 29 (NFFA), existe o tratamento na tabela SF3 para gravar a classe de consumo.			 |
//³Como o complemento foi excluido ao deletar a nota, deve-se pegar o codigo na tabela SF3, pois na CD4 nao ira existir mais.|
//|Tratamento feito para evitar que o C600 seja gerado sem a classe de consumo, o que ocasiona erro no validador.			 |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cSituaDoc$"02#04#05#03" .And. Empty(cCodCons) .And. aRegC500[1][5] == "29" .And. lClasCo
	cCodCons	:=	SF3->F3_CLASCO
Endif	

//³REGISTRO C600 - CONSOLIDACAO DE NOTAS FISCAIS/CONTA DE ENERGIA ELETRICA (MODELO 06)|
If (nPos := aScan(aRegC600,{|aX| aX[2]==aRegC500[1][5] .And. aX[3]==aPartDoc[7] .And. aX[6]==cCodCons .And. aX[9]==aRegC500[1][11]}))==0
	aAdd(aRegC600, {})
	nPos	:=	Len (aRegC600)
	aAdd (aRegC600[nPos], "C600")	 	 	  					//01 - REG
	aAdd (aRegC600[nPos], aRegC500[1][5]) 	   					//02 - COD_MOD
	aAdd (aRegC600[nPos], aPartDoc[7])	 	   					//03 - COD_MUN
	aAdd (aRegC600[nPos], aRegC500[1][7]) 	   					//04 - SER
	aAdd (aRegC600[nPos], aRegC500[1][8]) 	   					//05 - SUB
	aAdd (aRegC600[nPos], cCodCons) 		   					//06 - COD_CONS
	aAdd (aRegC600[nPos], "0") 	   								//07 - QTD_CONS
	aAdd (aRegC600[nPos], "0") 	   								//08 - QTD_CANC
	aAdd (aRegC600[nPos], aRegC500[1][11])						//09 - DT_DOC
	aAdd (aRegC600[nPos], 0) 	   								//10 - VL_DOC
	aAdd (aRegC600[nPos], 0) 	   								//11 - VL_DESC
	aAdd (aRegC600[nPos], {0,0}) 		   						//12 - CONS
	aAdd (aRegC600[nPos], 0) 	   								//13 - VL_FORN
	aAdd (aRegC600[nPos], 0) 	   								//14 - VL_SERV_NT
	aAdd (aRegC600[nPos], 0) 	   								//15 - VL_TERC
	aAdd (aRegC600[nPos], 0) 	   								//16 - VL_DA
	aAdd (aRegC600[nPos], 0) 	   								//17 - VL_BC_ICMS
	aAdd (aRegC600[nPos], 0) 	   								//18 - VL_ICMS
	aAdd (aRegC600[nPos], 0) 	   								//19 - VL_BC_ICMS_ST
	aAdd (aRegC600[nPos], 0) 	   								//20 - VL_ICMS_ST
	aAdd (aRegC600[nPos], 0) 	   								//21 - VL_PIS
	aAdd (aRegC600[nPos], 0) 	   								//22 - VL_COFINS
EndIf
//
aRegC600[nPos][7]		:=	Alltrim(STR(Val(aRegC600[nPos][7])+1))//07 - QTD_CONS
If !cSituaDoc$"02#03#04#05"
	aRegC600[nPos][10]		+=	aRegC500[1][13]						//10 - VL_DOC
	aRegC600[nPos][11]		+=	aRegC500[1][14]						//11 - VL_DESC
	aRegC600[nPos][12][1]	+=	nConskwh  							//12 - CONS
	aRegC600[nPos][13]		+=	aRegC500[1][15]						//13 - VL_FORN
	aRegC600[nPos][14]		+=	aRegC500[1][16]						//14 - VL_SERV_NT
	aRegC600[nPos][15]		+=	nVlTerc								//15 - VL_TERC
	aRegC600[nPos][16]		+=	aRegC500[1][18]						//16 - VL_DA
	aRegC600[nPos][17]		+=	aRegC500[1][19]						//17 - VL_BC_ICMS
	aRegC600[nPos][18]		+=	aRegC500[1][20]						//18 - VL_ICMS
	aRegC600[nPos][19]		+=	aRegC500[1][21]						//19 - VL_BC_ICMS_ST
	aRegC600[nPos][20]		+=	aRegC500[1][22]						//20 - VL_ICMS_ST
	aRegC600[nPos][21]		+=	IIf("1"$aWizard[1][15],aRegC500[1][24],0)	//21 - VL_PIS
	aRegC600[nPos][22]		+=	IIf("1"$aWizard[1][15],aRegC500[1][25],0)	//22 - VL_COFINS
Endif
Return nPos
/*

Programa  ³RegC601   ³ Autor ³Gustavo G. Rueda       ³ Data ³10.03.2011
Descri‡…o ³                                                            
          ³REGISTRO C601 - DOCUMENTOS CANCELADOS - CONSOLIDACAO DIARIA:
          ³    NOTAS FISCAIS/CONTA DE ENERGIA ELETRICA (MODELO 06),    
          ³    NOTA FISCAL/CONTA DE FORNECIMENTO D'AGUA CANALIZADA     
          ³      (CODIGO 29) E NOTA FISCAL/CONTA DE FORNECIMENTO       
          ³                      DE GAS (CODIGO 28)                    
          ³                                                            
          ³- Geracao da estrutura do Registro C601                     

Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves 
          ³ da funcao GrvRegTrS no final do processamento da rotina    

Nivel Hier³C600 - 2(varios por arquivo)                                
          ³C601 - 3(1:N) Para cada C600                                

Retorno   ³Nil                                                         

Parametros|aCmpAntSFT -> Informacoes sobre o cabecalho dos documentos. 
          ³aRegC600 -> Array contendo as informacoes processadas pela  
          ³ funcao a ser retornado para gravacao pela funcao principal.
          ³aRegC601 -> Array contendo as informacoes processadas pela  
          ³ funcao a ser retornado para gravacao pela funcao principal.
          ³nPosC600 -> Posicao de gravacao do registro C600 para       
          ³            relacionamento com os registros filhos          
          ³aRegC500 -> Conteudo gravado do registro C500 para utiliza- 
          ³ cao em outros registros da funcao principal.               
*/
Static Function RegC601(aCmpAntSFT,aRegC600,aRegC601,nPosC600,aRegC500)
Local	nPos	:=	0
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³REGISTRO C601 - DOCUMENTOS CANCELADOS - CONSOLIDACAO DIARIA DE NOTAS FISCAIS/CONTA |
//|                DE ENERGIA ELETRICA (MODELO 06), NOTA FISCAL/CONTA DE FORNECIMENTO |
//|                D'AGUA CANALIZADA (CODIGO 29) E NOTA FISCAL/CONTA DE FORNECIMENTO  |
//|                DE GAS (CODIGO 28)                                                 |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !Empty (aCmpAntSFT[7]) //Documento cancelado		
	If (nPos := aScan(aRegC601,{|aX| aX[1]==nPosC600 .And. aX[3]==aRegC500[1][10]}))==0
	
		//³Tratamento para contagem dos documentos cancelados do registro C600³
		aRegC600[nPosC600][8]	:=	Alltrim(STR(Val(aRegC600[nPosC600][8])+1))//08 - QTD_CANC

		aAdd(aRegC601, {})
		nPos	:=	Len (aRegC601)
		aAdd (aRegC601[nPos], nPosC600)	 	 	  					//01 - CHAVE RELACIONAMENTO
		aAdd (aRegC601[nPos], "C601")	 	 	  					//01 - REG
		aAdd (aRegC601[nPos], aRegC500[1][10])	 	 	  			//02 - NUM_DOC_CANC
	EndIf
EndIf
Return
/*
±±³Programa  ³RegC610   ³ Autor ³Gustavo G. Rueda       ³ Data ³10.03.2011³±±

±±³Descri‡…o ³                                                            ³±±
±±³          ³    REGISTRO C610 - ITENS DOS DOCUMENTOS CONSOLIDADOS:      ³±±
±±³          ³    NOTAS FISCAIS/CONTA DE ENERGIA ELETRICA (MODELO 06),    ³±±
±±³          ³    NOTA FISCAL/CONTA DE FORNECIMENTO D'AGUA CANALIZADA     ³±±
±±³          ³      (CODIGO 29) E NOTA FISCAL/CONTA DE FORNECIMENTO       ³±±
±±³          ³                      DE GAS (CODIGO 28)                    ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao da estrutura do Registro C610                     ³±±

±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS no final do processamento da rotina    ³±±

±±³Nivel Hier³C600 - 2(varios por arquivo)                                ³±±
±±³          ³C610 - 3(1:N) Para cada C600                                ³±±

±±³Retorno   ³Nil                                                         ³±±

±±³Parametros|aRegC500 -> Conteudo gravado do registro C500 para utiliza- ³±±
±±³          ³ cao em outros registros da funcao principal.               ³±±
±±³          ³aRegC510 -> Conteudo gravado do registro C510 para utiliza- ³±±
±±³          ³ cao em outros registros da funcao principal.               ³±±
±±³          ³lAchouSFU-> Flag do resultado do seek na tabela SFU         ³±±
±±³          ³aRegC610 -> Array contendo as informacoes processadas pela  ³±±
±±³          ³ funcao a ser retornado para gravacao pela funcao principal.³±±
±±³          ³nPosC600 -> Posicao de gravacao do registro C600 para       ³±±
±±³          ³            relacionamento com os registros filhos          ³±±
±±³          ³cSituaDoc-> Situacao do documento                           ³±±
*/
Static Function RegC610(aRegC500,aRegC510,lAchouSFU,aRegC610,nPosC600,cSituaDoc,aWizard)
Local	nI		:=	0
Local	nPos	:=	0
Local	cCodClas	:=	""
Default aWizard	:= {}

If aRegC500[1][5] == "06" .And. lAchouSFU
	If TamSx3("FU_GRPCLAS")[1] == 2
		cCodClas	:= SFU->FU_GRPCLAS+IIf(aSPDSX3[FP_FU_CLASSIF],SFU->FU_CLASSIF,"")
	Else
		cCodClas	:= "0"+SFU->FU_GRPCLAS+IIf(aSPDSX3[FP_FU_CLASSIF],SFU->FU_CLASSIF,"")
	EndIf
EndIf
//³REGISTRO C610 - ITENS DO DOCUMENTO CONSOLIDADO (MODELO 06)                         ³
For nI := 1 To Len (aRegC510)
	If (nPos := aScan(aRegC610,{|aX| aX[1]==nPosC600 .And. aX[3]==cCodClas .And. aX[4]==aRegC510[nI][3] .And. aX[11]==aRegC510[nI][12]}))==0
		aAdd(aRegC610, {})
		nPos	:=	Len (aRegC610)
		aAdd(aRegC610[nPos], nPosC600)	 	 	  				//01 - CHAVE RELACIONAMENTO
		aAdd(aRegC610[nPos], "C610")	 	 	  				//02 - REG
		aAdd(aRegC610[nPos], cCodClas) 			  				//03 - COD_CLASS
		aAdd(aRegC610[nPos], aRegC510[nI][3]) 	  				//04 - COD_ITEM
		aAdd(aRegC610[nPos], aRegC510[nI][5])					//05 - QTD
		aAdd(aRegC610[nPos], aRegC510[nI][6]) 	  				//06 - UNID
		aAdd(aRegC610[nPos], aRegC510[nI][7]) 	  				//07 - VL_ITEM
		aAdd(aRegC610[nPos], aRegC510[nI][8]) 	  				//08 - VL_DESC
		aAdd(aRegC610[nPos], aRegC510[nI][9]) 	  				//09 - CST
		aAdd(aRegC610[nPos], aRegC510[nI][10]) 	  				//10 - CFOP
		aAdd(aRegC610[nPos], aRegC510[nI][12])	 				//11 - ALIQ_ICMS
		aAdd(aRegC610[nPos], 0)	 	   						  	//12 - VL_BC_ICMS
		aAdd(aRegC610[nPos], 0)		  						  	//13 - VL_ICMS
		aAdd(aRegC610[nPos], 0)	 	 						  	//14 - VL_BC_ICMS_ST
		aAdd(aRegC610[nPos], 0)	   							  	//15 - VL_ICMS_ST
		aAdd(aRegC610[nPos], 0)		 						  	//16 - VL_PIS
		aAdd(aRegC610[nPos], 0)								  	//17 - VL_COFINS
		aAdd(aRegC610[nPos], aRegC510[nI][21])			 	 	//18 - COD_CTA
	
	EndIf
	If !cSituaDoc$"02#03#04#05"
		aRegC610[nPos][12] += aRegC510[nI][11] 		   		  	//12 - VL_BC_ICMS
		aRegC610[nPos][13] += aRegC510[nI][13]		   		  	//13 - VL_ICMS
		aRegC610[nPos][14] += aRegC510[nI][14] 		   		  	//14 - VL_BC_ICMS_ST
		aRegC610[nPos][15] += aRegC510[nI][16]		   		  	//15 - VL_ICMS_ST
		aRegC610[nPos][16] += Iif("1"$aWizard[1][15],aRegC510[nI][19],0)	//16 - VL_PIS
		aRegC610[nPos][17] += Iif("1"$aWizard[1][15],aRegC510[nI][20],0)	//17 - VL_COFINS
	Endif
Next nI
Return
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³RegC690   ³ Autor ³Gustavo G. Rueda       ³ Data ³10.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±³          ³    REGISTRO C690 - REGISTRO ANALITICO  DOS DOCUMENTOS:     ³±±
±±³          ³    NOTAS FISCAIS/CONTA DE ENERGIA ELETRICA (MODELO 06),    ³±±
±±³          ³    NOTA FISCAL/CONTA DE FORNECIMENTO D'AGUA CANALIZADA     ³±±
±±³          ³      (CODIGO 29) E NOTA FISCAL/CONTA DE FORNECIMENTO       ³±±
±±³          ³                      DE GAS (CODIGO 28)                    ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao da estrutura do Registro C690                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS no final do processamento da rotina    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³C600 - 2(varios por arquivo)                                ³±±
±±³          ³C690 - 3(1:N) Para cada C600                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nil                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros|aRegC590 -> Conteudo gravado do registro C590 para utiliza- ³±±
±±³          ³ cao em outros registros da funcao principal.               ³±±
±±³          ³nPosC600 -> Posicao de gravacao do registro C600 para       ³±±
±±³          ³            relacionamento com os registros filhos          ³±±
±±³          ³aRegC690 -> Array contendo as informacoes processadas pela  ³±±
±±³          ³ funcao a ser retornado para gravacao pela funcao principal.³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function RegC690(aRegC590,nPosC600,aRegC690)
Local	nPos	:=	0
Local	nI		:=	0
	
//³REGISTRO C690 - ITENS DO DOCUMENTO CONSOLIDADO (MODELO 06)                         ³
For nI := 1 To Len (aRegC590)
	If (nPos := aScan(aRegC690,{|aX| aX[1]==nPosC600 .And. aX[3]==aRegC590[nI][2] .And. aX[4]==aRegC590[nI][3] .And. aX[5]==aRegC590[nI][4]}))==0
		aAdd (aRegC690, {})
		nPos	:=	Len (aRegC690)
		aAdd (aRegC690[nPos], nPosC600)	 	 	  	 			//01 - CHAVE RELACIONAMENTO
		aAdd (aRegC690[nPos], "C690")				 			//02 - REG
		aAdd (aRegC690[nPos], aRegC590[nI][02])		 			//03 - CST_ICMS
		aAdd (aRegC690[nPos], aRegC590[nI][03])	   	 			//04 - CFOP
		aAdd (aRegC690[nPos], aRegC590[nI][04])	   	 			//05 - ALIQ_ICMS
		aAdd (aRegC690[nPos], aRegC590[nI][05])		 	  		//06 - VL_OPR
		aAdd (aRegC690[nPos], aRegC590[nI][06])		 	  		//07 - VL_BC_ICMS
		aAdd (aRegC690[nPos], aRegC590[nI][07])		   			//08 - VL_ICMS
		aAdd (aRegC690[nPos], aRegC590[nI][10])		   			//09 - VL_RED_BC
		aAdd (aRegC690[nPos], aRegC590[nI][08])			   		//10 - VL_BC_ICMS_ST
		aAdd (aRegC690[nPos], aRegC590[nI][09])			   		//11 - VL_ICMS_ST
		aAdd (aRegC690[nPos], aRegC590[nI][11])			   		//12 - COD_OBS
	Else
		aRegC690[nPos][6]	+=	aRegC590[nI][05]				//06 - VL_OPR
		aRegC690[nPos][7]	+=	aRegC590[nI][06]				//07 - VL_BC_ICMS
		aRegC690[nPos][8]	+=	aRegC590[nI][07]				//08 - VL_ICMS
		aRegC690[nPos][9]	+=	aRegC590[nI][10]				//09 - VL_RED_BC
		aRegC690[nPos][10]	+=	aRegC590[nI][08]				//10 - VL_BC_ICMS_ST
		aRegC690[nPos][11]	+=	aRegC590[nI][09]				//11 - VL_ICMS_ST
	EndIf
Next nI
Return
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  |RegC700   ³ Autor ³Gustavo G. Rueda       ³ Data ³09.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³C700 - CONSOLIDACAO DOS DOCUMENTOS NF/CONTA DE ENERGIA ELET.³±±
±±³          ³ EMITIDAS EM VIA UNICA (CPN. ICMS 115/03)                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com as informacoe contidas na tabela   ³±±
±±³          ³ SFT.                                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³C700 - 2(1:N)                                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpN1 -> Posicao de relacionamento entre o C700 e C790      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros|aRegC100 -> Array com as informacoes jah processadas.       ³±±
±±³          ³aRegC700 -> Array com as informacoes acumuladas para serem  ³±±
±±³          ³            gravadas ao final do processamento da rotina    ³±±
±±³          ³lAchouSFU-> Variavel de posicionamento da tabela SFU        ³±±
±±³          ³aCmpAntSFT-> Campos da tabela SFT posicionado por docuemto  ³±±
±±³          ³lAchouCD3-> Flag de posicionamento da tabela CD3            ³±±  
±±³          ³cEspecie  -> Modelo do documento fiscal                     ³±±  
±±³          ³cSituaDoc -> Situacao do documento fiscal                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function RegC700(aRegC100,aRegC700,lAchouSFU,aCmpAntSFT,lAchouCD3,cEspecie,cSituaDoc)
Local	nPos1	:=	0
Local	cChv115	:=	""
Local	cVol115	:=	""
Local 	lMod66	:= cEspecie=="66"
Local 	cChave	:= ""
Local 	nIndice	:= 9

If !cSituaDoc$"02#03"     
	If cEspecie$"28"
		If lAchouCD3
		    If aSPDSX3[FP_CD3_VOL115] .And. aSPDSX3[FP_CD3_CHV115]	
		     	cChave:= cChv115 :=	CD3->CD3_CHV115
			    cVol115	:=	CD3->CD3_VOL115	
		    EndIf
		EndIf
	ElseIf lMod66
		cVol115:="" // Campo 08 (NOM_MEST) Esse campo não deve ser preenchido somente para documentos fiscais modelo 66
		cChv115:="" //Campo 09 (CHV_COD_DIG) Esse campo não deve ser preenchido somente para documentos fiscais modelo 66

		cChave:=aCmpAntSFT[6] //Para a escrituração de documentos fiscais do modelo 66, 
								//este registro consolida o total das notas, por data de emissão e série
		nIndice:= 6
	Else		
		If lAchouSFU
			cChave:= cChv115 :=	SFU->FU_CHV115
			cVol115	:=	SFU->FU_VOL115	
		EndIf
	EndIf

	//³REGISTRO C700 - CONSOLIDACAO                                           ³
	If (nPos1 := aScan(aRegC700,{|aX| aX[3]==aRegC100[1][7] .And. aX[nIndice]==cChave}))==0
		aAdd (aRegC700, {})
		nPos1	:=	Len (aRegC700)
		aAdd (aRegC700[nPos1], "C700")						//01 - REG
		aAdd (aRegC700[nPos1], aRegC100[1][5])				//02 - COD_MOD
		aAdd (aRegC700[nPos1], aRegC100[1][7])	   			//03 - SER
		aAdd (aRegC700[nPos1], aRegC100[1][8])	   	 		//04 - NRO_INI
		aAdd (aRegC700[nPos1], aRegC100[1][8])				//05 - NRO_FIN
		aAdd (aRegC700[nPos1], aCmpAntSFT[6])	   	 		//06 - DT_DOC_INI
		aAdd (aRegC700[nPos1], aCmpAntSFT[6])	   	 		//07 - DT_DOC_FIM
		aAdd (aRegC700[nPos1], cVol115) 					//08 - NOM_MEST
		aAdd (aRegC700[nPos1], cChv115)						//09 - CHV_COD_DIG
	EndIf
	aRegC700[nPos1][5]	:=	aRegC100[1][8]					//05 - NRO_FIN
	aRegC700[nPos1][7]	:=	aCmpAntSFT[6]		   			//07 - DT_DOC_FIM
EndIf
Return nPos1
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³RegC790   ³ Autor ³Gustavo G. Rueda       ³ Data ³09.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±³          ³     C790 - REGISTRO ANALITICO DO DOCUMENTO (MODELO 06)     ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao da estrutura do Registro C790                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS no final do processamento da rotina    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³C700 - 2(varios por arquivo)                                ³±±
±±³          ³C790 - 3(1:N) Para cada C700                                ³±±
±±³          ³C791 - 4(1:N) Para cada C790                                ³±±   
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nil                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros|aRegC590 -> Conteudo gravado do registro C590 para utiliza- ³±±
±±³          ³ cao em outros registros da funcao principal.               ³±±
±±³          ³nPosC700 -> Posicao de gravacao do registro C700 para       ³±±
±±³          ³            relacionamento com os registros filhos          ³±±
±±³          ³aRegC790 -> Array contendo as informacoes processadas pela  ³±±
±±³          ³ funcao a ser retornado para gravacao pela funcao principal.³±±
±±³          ³aRegC700 -> Array contendo as informacoes do registro C700  ³±±
±±³          ³aRegC791 -> Array contendo as informacoes do regsitro C791  ³±±
±±³          ³aCmpAntSFT->Array contendo as informacoes da SFT			  ³±±
±±³          ³cMVSUBTRIB-> Conteudo do parametro MV_SUBTRIB               ³±±
±±³          ³cSituaDoc -> Situacao do documento fiscal                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function RegC790(aRegC590,nPosC700,aRegC790,aRegC700,aRegC791,aCmpAntSFT,cMVSUBTRIB,cSituaDoc,aReg0460)
Local	nPos	:=	0
Local   nPos2   :=  0
Local	nI		:=	0
Local	aVlrObs :=	{}
Local	nIcmIsen := 0
Local	nOutrICM := 0
Local	nICMSST	 := 0

If !cSituaDoc$"02#03"  
 
	//REGISTRO C790 - REGISTRO ANALITICO DOS DOCUMENTOS (MODELO 06) 
	For nI := 1 To Len (aRegC590)
		If (nPos := aScan(aRegC790,{|aX| aX[1]==nPosC700 .And. aX[3]==aRegC590[nI][02] .And. aX[4]==aRegC590[nI][03] .And. aX[5]==aRegC590[nI][04]}))==0
			aAdd (aRegC790, {})
			nPos	:=	Len (aRegC790)
			aAdd (aRegC790[nPos], nPosC700)							   	//Relacionamento, serah manipulado na funcao REGC700
			aAdd (aRegC790[nPos], "C790")						   		//01 - REG
			aAdd (aRegC790[nPos], aRegC590[nI][02])					   	//02 - CST_ICMS
			aAdd (aRegC790[nPos], aRegC590[nI][03])	   	  		   		//03 - CFOP
			aAdd (aRegC790[nPos], aRegC590[nI][04])   			   		//04 - ALIQ_ICMS
			aAdd (aRegC790[nPos], 0)						   	   		//05 - VL_OPR
			aAdd (aRegC790[nPos], 0)						   	   		//06 - VL_BC_ICMS
			aAdd (aRegC790[nPos], 0)						   	   		//07 - VL_ICMS
			aAdd (aRegC790[nPos], 0)						   	   		//08 - VL_BC_ICMS_ST
			aAdd (aRegC790[nPos], 0)						   	   		//09 - VL_ICMS_ST
			aAdd (aRegC790[nPos], 0)						   	   		//10 - VL_RED_BC
			aAdd (aRegC790[nPos], aRegC590[nI][11])	   					//11 - COD_OBS
		EndIf 
		aRegC790[nPos][6]	+=	aRegC590[nI][05]					//05 - VL_OPR
		aRegC790[nPos][7]	+=	aRegC590[nI][06]			   		//06 - VL_BC_ICMS
		aRegC790[nPos][8]	+=	aRegC590[nI][07]			  		//07 - VL_ICMS
		aRegC790[nPos][9]	+=	aRegC590[nI][08]					//08 - VL_BC_ICMS_ST
		aRegC790[nPos][10]	+=	aRegC590[nI][09]					//09 - VL_ICMS_ST
	 	aRegC790[nPos][11]	+=	aRegC590[nI][10]		 			//10 - VL_RED_BC
	
		If !Empty(aRegC590[nI][11])
			If SubStr(aRegC790[nPos][3],2,2) $ "30/40/41" //Valor da coluna Isentas/Não tributadas - PORTARIA CAT 66, DE 23-10-2019
				nIcmIsen := (aRegC790[nPos][6] - aRegC790[nPos][7] - aRegC790[nPos][10] - aRegC790[nPos][11])+aRegC790[nPos][11] //VL_OPR - VL_BC_ICMS - VL_ICMS_ST - VL_RED_BC //Valor da coluna Outras - PORTARIA CAT 66, DE 23-10-2019
			ElseIf !(SubStr(aRegC790[nPos][3],2,2) $ "00/10") 
				nOutrICM := (aRegC790[nPos][6] - aRegC790[nPos][7] - aRegC790[nPos][10] - aRegC790[nPos][11])
			EndIf

			nICMSST	:= aRegC790[nPos][10]

			nPos0460 := aScan(aReg0460,{|aX| aX[2]==AllTrim(aRegC590[nI][11]) })

			If nPos0460 > 0 .And. "C790" $ aReg0460[nPos0460][03]

				aVlrObs := StrToKarr(aReg0460[nPos0460][03],";")

				aVlrObs[2] := VAL(STRTRAN(aVlrObs[2],",","."))+nIcmIsen
				aVlrObs[3] := VAL(STRTRAN(aVlrObs[3],",","."))+nOutrICM
				aVlrObs[4] := VAL(STRTRAN(aVlrObs[4],",","."))+nICMSST

				cObsC790 := "C790;"+ALLTRIM(TRANSFORM(aVlrObs[2],"@E 9999999999999.99"))+";"+ALLTRIM(TRANSFORM(aVlrObs[3],"@E 9999999999999.99"))+";";
				+ALLTRIM(TRANSFORM(aVlrObs[4],"@E 9999999999999.99"))+";"+AllTrim(aVlrObs[5])

				aReg0460[nPos0460][03] := cObsC790

			Else

				cObsC790 := "C790;"+ALLTRIM(TRANSFORM(nIcmIsen,"@E 9999999999999.99"))+";"+ ALLTRIM(TRANSFORM(nOutrICM,"@E 9999999999999.99"))+";";
				+ ALLTRIM(TRANSFORM(nICMSST,"@E 9999999999999.99"))+";"

				If nPos0460 > 0 
					aReg0460[nPos0460][03] := cObsC790+aReg0460[nPos0460][03]
				ElseIf !Empty(aRegC590[nI][11])
					Reg0460(@aReg0460,{AllTrim(aRegC590[nI][11]),cObsC790})
				EndIf
			EndIf
		EndIf

		If aRegC790[nPos][9]+aRegC790[nPos][10] > 0 .And. aCmpAntSFT[23]$cMVSUBTRIB
			
			//REGISTRO C791 - REGISTRO DE INFORMACOES DE ST POR UF DOCUMENTOS (MODELO 06) 		
	   	    If (nPos2 := aScan(aRegC791,{|aX|  aX[1] == nPos .And. aX[3]==aCmpAntSFT[23]}))==0
	             aAdd (aRegC791, {})
	             nPos2	:=	Len (aRegC791)
	   	         aAdd (aRegC791[nPos2], nPos)			    //Relacionamento, serah manipulado na funcao REGC791
	   	    	 aAdd (aRegC791[nPos2], "C791")				//02 - REG
		   		 aAdd (aRegC791[nPos2], aCmpAntSFT[23])		//03 - UF
		         aAdd (aRegC791[nPos2], 0)     	            //04 - VL_BC_ICMS_ST
		         aAdd (aRegC791[nPos2], 0)  	            //05 - VL_CIMS_ST		
		    EndIf
	        aRegC791[nPos2][04]	+=	aRegC790[nPos][09]		//04 - VL_BC_ICMS_ST
	        aRegC791[nPos2][05]	+=	aRegC790[nPos][10]		//05 - VL_ICMS_ST
	    EndIf
	Next nI
EndIf
Return
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³RegD100   ³ Autor ³Gustavo G. Rueda       ³ Data ³11.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                       D100                                 ³±±
±±³          ³     NOTA FISCAL DE SERVICO DE TRANSPORTE (MODELO 07)       ³±±
±±³          ³ CONHECIMENTO DE TRANSPORTE RODOVIARIO DE CARGAS (MODELO 08)³±±
±±³          ³- Geracao e gravacao do Registro D100                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com as informacoes contidas no array   ³±±
±±³          ³ aTotaliza/aPartDoc/aCmpAntSFT para os Modelos 07/08.       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³D100 - 2(varios por arquivo)                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nil                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cAlias -> Alias do TRB que recebera as informacoes.         ³±±
±±³          |cEntSai -> Flag Entrada(1)/Saida(2).                        ³±±
±±³          ³aPartDoc -> Array com informacoes sobre o participante do   ³±±
±±³          ³ documento fiscal, este array eh montado pela funcao princi-³±±
±±³          ³ pal.                                                       ³±±
±±³          |aTotaliza -> Totalizadores de valores para a tabela SFT.    ³±±
±±³          ³nRelac    -> Flag de relacionamento com os sub-registros    ³±±
±±³          ³cEspecie  -> Modelo do documento fiscal                     ³±±
±±³          |aCmpAntSFT-> Informacoes sobre o cabecalho dos documentos.  ³±±
±±³          ³cSituaDoc -> Situacao do documento fiscal                   ³±±
±±³          ³lGrava0150-> Flag de geracao do registro 0150               ³±±
±±³          ³cOpSemF   -> Conteudo do parametro MV_OPSEMF                ³±±
±±³          ³lSpedRTms -> Flag de existencia do PESPEDRTMS               ³±±
±±³          ³lIntTMS   -> Retorno da chamada da funcao INTTMS()          ³±±
±±³          ³aInfCompl -> Informacao complementar da tabela CDT          ³±±
±±³          ³cAliasSFT -> Alias da tabela SFT posicionada no momento     ³±±
±±³          ³aReg0450  -> Array com a estrutura do 0450 gerado ateh o    ³±±
±±³          ³            momento.                                        ³±±
±±³          ³cVersao -> numero da versao do leiaute                      ³±±   
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function RegD100(cAlias,cEntSai,aPartDoc,aTotaliza,nRelac,cEspecie,aCmpAntSFT,cSituaDoc,;
						lGrava0150,cOpSemF,lSpedRTms,lIntTMS,aInfCompl,cAliasSFT,aReg0450,cVersao,cCdMunOri,cCdMunDes,cMunSM0, lAchouDT6, lInfCTEO)
Local aReg      := {}
Local aRetPE    := {}
Local cDoctms   := ""
Local cDocbpe   := "0"
Local cDocCtEos := "0"
Local cChvCte   := aCmpAntSFT[25]
Local nPos      := 0
Local nPosIt    := 0
Local cCodInf   := ""
Local cRetPE    := ""              
Local dDT_A_P	:= aCmpAntSFT[5]
Local cConta	:= ""
Local cSerie	:= ""  
Local cContCtb	:= RetCOD_CTA(cAliasSFT, "D100",aCmpAntSFT)
Local aDadosGZH := {}

aAdd (aReg, {})
nPos := Len(aReg)
             
//-- Permite alterar o calculo padrao atraves do PE SPEDRTMS
If lSpedRTMS
	aRetPE := ExecBlock("SPEDRTMS",.F.,.F.,{nPos,"D100",cAliasSFT,aCmpAntSFT})
	If ValType(aRetPE) == "A" .And. Len(aRetPE) > 0
		aReg := {}
		aEval(aRetPE,{|x| AAdd(aReg, x)})
		lGrava0150 := .T.
		If aExistBloc[13] 
			For nPosIt := 1 To Len(aReg)
				//-- Ponto de entrada para gravar informacoes complementares
				cCodInf := aReg[nPosIt,22] //22 - COD_INF
				cRetPE  := ExecBlock("SPEDR450", .F., .F., {cCodInf})
				If  ValType(cRetPE) == "C"
					Reg0450({cCodInf, cRetPE},@aReg0450)
				EndIf
			Next PosIt
		EndIf
	EndIf
EndIf

If Empty(aCmpAntSFT[19]) .Or. Empty(cContCtb)
	dbSelectArea("SB1")
	SB1->(dbSetOrder(1))  
	If SB1->(MsSeek( aSPDFil[PFIL_SB1] + aCmpAntSFT[45]))
		cConta := SB1->B1_CONTA
	EndIf
EndIf

//-- Verifica se o PE nao alterou a criacao do registro
If Len(aReg[nPos])==0
	
	//-- Tratamento para o conhecimento Transporte Eletronico
	If cEspecie=='57'
		//-- Se for SAIDA e com Integracao com o TMS, o DT6 jah estah posicionado
		If	cEntSai=="2" .And. lIntTMS .And. lAchouDT6
			cDoctms := "0"
			// Situacao do CT-e:
			// 00 - Normal
			// 02 - Cancelado
			// 04 - Uso Denegado
			// 05 - Inutilizacao
			// 06 - Complemento
			// 08 - Regime especial ou norma especifica
			If !cSituaDoc$"02#03#05"
				// Tipo do CT-e:                      
				// 0 - CT-e Normal,                   
				// 1 - CT-e de Complemento de Valores,
				// 2 - CT-e de Anulação de Valores,   
				// 3 - CT-e Substituto                
				Do Case
					Case aCmpAntSFT[59] $ "1/2/5/6/9/A/B/C/D/F/G/H/I/J/K/N/O"
						cDoctms := "0" //- CT-e Normal
					Case aCmpAntSFT[59] $ "7/8/E/L"
						cDoctms := "1" //- CT-e de Complemento de Valores
					Case aCmpAntSFT[59] $ "M"
						cDoctms := "2" //- CT-e de Anulação de Valores
					Case aCmpAntSFT[59] $ "P"
						cDoctms := "3" //- CT-e Substituto
				EndCase
				If Empty(cChvCte)
					cChvCte := aCmpAntSFT[60]
				EndIf
			EndIf
		Else
			Do Case
			Case aCmpAntSFT[40]=="N"
					cDoctms := "0" //- CT-e Normal
			Case aCmpAntSFT[40]=="C"
					cDoctms := "1" //- CT-e de Complemento de Valores
			Case aCmpAntSFT[40]=="A"
					cDoctms := "2" //- CT-e de Anulação de Valores
			Case aCmpAntSFT[40]=="S"
					cDoctms := "3" //- CT-e Substituto
			EndCase
		EndIf
	Elseif cEspecie == '63' // BP-e 
		/*
		Temos os seguintes tipos de BP-e:
		0 - Normal;
		3 – Substituição.
		*/
		If cEntSai=="2"
			cDocbpe := "0" //- Normal
		Elseif cEntSai=="1"
			Do Case 
				Case aCmpAntSFT[40] == "N"
					cDocbpe := "0" //- Normal
				Case aCmpAntSFT[40] == "S"
					cDocbpe := "3" //- Substituto				
			EndCase
		Endif
	Elseif cEspecie == '67' // CTEOS
		/*
		Temos os seguintes tipos de BP-e:
		0 - Normal;
		3 – Substituição.
		*/
		If cEntSai=="2"
			cDocCtEos := "0" //- Normal
		Elseif cEntSai=="1"
			Do Case 
				Case aCmpAntSFT[40] == "N"
					cDocCtEos := "0" //- Normal
				Case aCmpAntSFT[40] == "C"
					cDocCtEos := "1" //- Complemento de Valores
				Case aCmpAntSFT[40] == "A"
					cDocCtEos := "2" //- Anulação de Valores
				Case aCmpAntSFT[40] == "S"
					cDocCtEos := "3" //- Substituto				
			EndCase
		Endif
	EndIf

	//³Somente deve gerar a chave da NFE/CTE no registro D100 se a nota fiscal for modelo 57, 63 ou 67  ³
	//³e o formulario proprio seja sim (a partir de 2012, para qualquer caso)                 ³
	If !(cEspecie$"57#63#67")
		cChvCte := ""
	ElseIf (cEspecie$"57#63#67") .And. cSituaDoc == "05" 
		cChvCte := ""
	Else
		If cVersao<="004" .And. aCmpAntSFT[26] == "1"
			cChvCte := ""
		EndIf
	EndIf
	//³Tratamento para nota de Conhecimento de Frete - Gerada via MATA116                     ³
	//³ Verifica se existe amarracao na SF8 (significa q foi gerado pela rotina MATA116)      ³
	//³ e se for sit. 06 (complemento), altera o cod. sit. para '00' conforme boletim tecnico ³
	dbSelectArea("SF8")
	SF8->(dbSetOrder(1))  // FILIAL + DOC + SERIE + CLIENTE + LOJA 
	If cSituaDoc=="06" .And. SF8->(MsSeek( aSPDFil[PFIL_SF8] + aCmpAntSFT[1] + aCmpAntSFT[2] + aCmpAntSFT[3] + aCmpAntSFT[4] ))
		cSituaDoc := '00'
	EndIf
							
	//Se for doc extemporaneo pega data da CDT, caso não seja digitada pega a data do doc
	If cSituaDoc$"01,07"
		dDT_A_P := If(Empty(aCmpAntSFT[41]),dDT_A_P,aCmpAntSFT[41])		
	Endif  

	/*vOLTAR este trecho quando nao for mais necessario fazer o seek na tabeala SB1 para pegar codigo da conta...impactando blocog nao fazer o seek na SB1  neste momento
	If (Empty(aCmpAntSFT[19]) .Or. Empty(cContCtb)) .And. !(Empty(aCmpAntSFT[63]))
		cConta := aCmpAntSFT[64]
	EndIf	
	*/

	cSerie	:=	SpedSerie(aCmpAntSFT[2],cEspecie)

	If aCmpAntSFT[62] > 0  .And. ((Empty(aCmpAntSFT[55]) .And. Empty(aCmpAntSFT[57]) .And. !cSituaDoc$"02#03#05") .Or. Empty(cSituaDoc)) .And.;
		lInfCTEO // Integração com modulo GTP
		aDadosGZH := GetInfCTEO(aCmpAntSFT[22],aCmpAntSFT[1],aCmpAntSFT[2],aCmpAntSFT[3],aCmpAntSFT[4])
	EndIf

	aAdd (aReg[nPos], "D100")														//01 - REG
	aAdd (aReg[nPos], STR(Val (cEntSai)-1,1))										//02 - IND_OPER
	aAdd (aReg[nPos], aCmpAntSFT[26])												//03 - IND_EMIT
	aAdd (aReg[nPos], "")															//04 - COD_PART
	aAdd (aReg[nPos], cEspecie)													   	//05 - COD_MOD
	If Empty(cSituaDoc) .And. Len(aDadosGZH) > 0
		aAdd (aReg[nPos], aDadosGZH[5])												//06 - COD_SIT
	Else
		aAdd (aReg[nPos], cSituaDoc)											    //06 - COD_SIT
	Endif
	aAdd (aReg[nPos], cSerie)														//07 - SER
	aAdd (aReg[nPos], "")															//08 - SUB
	aAdd (aReg[nPos], aCmpAntSFT[1])												//09 - NUM_DOC
	aAdd (aReg[nPos], cChvCte)														//10 - CHV_CTE
	aAdd (aReg[nPos], "")															//11 - DT_DOC
	aAdd (aReg[nPos], "")															//12 - DT_A_P
	aAdd (aReg[nPos], "")															//13 - TP_CTE
	aAdd (aReg[nPos], "")															//14 - CHV_CTE_REF
	aAdd (aReg[nPos], "")															//15 - VL_DOC
	aAdd (aReg[nPos], "")															//16 - VL_DESC
	aAdd (aReg[nPos], "")															//17 - IND_FRT
	aAdd (aReg[nPos], "")															//18 - VL_SERV
	aAdd (aReg[nPos], "")															//19 - VL_BC_ICMS
	aAdd (aReg[nPos], "")															//20 - VL_ICMS
	aAdd (aReg[nPos], "")															//21 - VL_NT
	aAdd (aReg[nPos], "")															//22 - COD_INF
	aAdd (aReg[nPos], "")															//23 - COD_CTA

	If cVersao >= "012" 
		aAdd (aReg[nPos], "")  														//24 - COD_MUN_ORIG
		aAdd (aReg[nPos], "")														//25 - COD_MUN_DEST
	Endif

	If !cSituaDoc$"02#03#05"
		If cEspecie <> "63" // BP-e (modelo 63) não possui registro 0150
			aReg[nPos, 4] := aPartDoc[1]											//04 - COD_PART
		Endif
		aReg[nPos,11] := aCmpAntSFT[6]												//11 - DT_DOC
		aReg[nPos,12] := dDT_A_P													//12 - DT_A_P (se for extemporaneo pega data da CDT)
		
		If cEspecie == "63"
			aReg[nPos,13] := cDocbpe												//13 - TP_CTE
		Elseif cEspecie == "57"
			aReg[nPos,13] := cDoctms												//13 - TP_CTE
		Elseif cEspecie == "67"
			aReg[nPos,13] := cDocCtEos												//13 - TP_CTE
		Endif
		aReg[nPos,15] := aTotaliza[1]												//15 - VL_DOC
		aReg[nPos,16] := aTotaliza[9]												//16 - VL_DESC
		//³Campo 17 - Valores validos: [0, 1, 2, 9]                                                             |
		//³Preenchimento: usar o valor 0 (por conta de terceiros)                                               |
		//³     para os casos em que o tomador e' diferente do emitente ou destinatario.                        |
		//³Tem-se por tomador quem efetuou o contrato junto a transportadora, arcando com o valor do servico.   |
		//³Somente a este deve ser enviada a primeira via do conhecimento e so ele tera direito ao credito.     ³
		If cEntSai=="2" .And. lIntTMS
			aReg[nPos,17] := aCmpAntSFT[21]											//17 - IND_FRT
		Else	
			If Len(aCmpAntSFT[21])>0 .And.  AllTrim(aCmpAntSFT[21])<>"9"
				aReg[nPos,17] := If(AllTrim(aCmpAntSFT[21]) $ "3/4", "1",aCmpAntSFT[21])	//17 - IND_FRT

			ElseIf AllTrim(aCmpAntSFT[9])$cOpSemF
				aReg[nPos,17] := "9"												//17 - IND_FRT

			ElseIf Len(aCmpAntSFT[24])>0 .And.  AllTrim(aCmpAntSFT[24])== "CONHEC. FRETE" 	//17 - IND_FRT
				aReg[nPos,17] := "2"

			Else
				aReg[nPos,17] := "1"												//17 - IND_FRT
			EndIf
		EndIf
		
		IF cEntSai=="2" .And. cEspecie == "63" // Quando modelo BP-e sempre deixar em branco, leiaute preve A partir de 01/01/2018: Valores válidos: [0, 1, 2, 3, 4, 9], mas só valida para mod 63 quando esta em branco. (Teste validador)
			aReg[nPos,17] := ""													 //17 - IND_FRT
		Endif

		aReg[nPos,18] := aTotaliza[1]												//18 - VL_SERV
		aReg[nPos,19] := aTotaliza[2]												//19 - VL_BC_ICMS
		aReg[nPos,20] := aTotaliza[3]												//20 - VL_ICMS
		aReg[nPos,21] := aTotaliza[14]												//21 - VL_NT
		aReg[nPos,22] := Iif(Len(aInfCompl)>0,aInfCompl[1],"")		   				//22 - COD_INF
		cConta		  := Iif(!Empty(aCmpAntSFT[19]),aCmpAntSFT[19],cConta)				//37 - COD_CTA
		aReg[nPos,23] := Iif(!Empty(cContCtb),cContCtb,cConta)						//23 - COD_CTA

		If cVersao >= "012"  
			// Esse If, é para atender aos clientes que estão com  os codigos de origem e destino na SF2 e SF1 em branco, pois esse tratamento foi corrigi pelo GTP, quando o cliente vai atualizar o CTEOS , replica os codigos para SF2 e SF1
			// mas por padrão iremos sempre utilziar nossa rotina na linhas 2923 e 2929 UfCodIBGE, como exceção quando os campos F2_CMUNOR,F2_CMUNDE, F1_MUDESTR,F1_MUORITR estiver em branco , buscamos da tabela do GZH
			If (Empty(aCmpAntSFT[55]) .And. Empty(aCmpAntSFT[57])) .And. Len(aDadosGZH) > 0
				//Function GetInfCTEO(cFilialAux,cDocumento,cSerie,cCliente,cLoja) - GTP
				//AAdd( aDados, { (cAliasTmp)->GZH_UMUINI, ALLTRIM((cAliasTmp)->GZH_CMUINI),(cAliasTmp)->GZH_UMUFIM,ALLTRIM((cAliasTmp)->GZH_CMUFIM),GetTPSta( (cAliasTmp)->GZH_STATUS ), GetTPEve( (cAliasTmp)->GZH_EVENTO )} )
				//Passo em branco por que se o cliente não preencheu os codigos na rotina GZH não gero errorlog.
				aReg[nPos,24] := IIf(Empty(UfCodIBGE(aDadosGZH[1][1])+ aDadosGZH[1][2]),cMunSM0,UfCodIBGE(aDadosGZH[1][1])+ aDadosGZH[1][2])           	//24 - COD_MUN_ORIG 
				aReg[nPos,25] := IIf(Empty(UfCodIBGE(aDadosGZH[1][3])+ aDadosGZH[1][4]),cMunSM0,UfCodIBGE(aDadosGZH[1][3])+ aDadosGZH[1][4])           	//25 - COD_MUN_DEST
			Else
				aReg[nPos,24] := Iif(Empty(cCdMunOri),cMunSM0,cCdMunOri)  				//24 - COD_MUN_ORIG 
				aReg[nPos,25] := Iif(Empty(cCdMunDes),cMunSM0,cCdMunDes)  				//25 - COD_MUN_DEST
			EndIf
		Endif
		
		If cEspecie == "63" // BP-e (modelo 63) não possui registro 0150
			lGrava0150 := .F.
		Else
			lGrava0150 := .T.
		Endif
	EndIf
EndIf

GrvRegTrS(cAlias,RetRD(nRelac),aReg)

Return
/*
±±³Programa  ³RegD110   ³ Autor ³Gustavo G. Rueda       ³ Data ³11.03.2011³±±

±±³Descri‡…o ³                                                            ³±±
±±³          ³                         D110                               ³±±
±±³          ³  ITENS DA NOTA FISCAL DE SERVICO DE TRANSPORTE (MODELO 07) ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao e gravacao do Registro D110                       ³±±

±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com as informacoes contidas na tabela  ³±±
±±³          ³ SFT.                                                       ³±±

±±³Nivel Hier³D120 - 3(1:N) Para cada D100                                ³±±

±±³Retorno   ³Nil                                                         ³±±

±±³Parametros³cAlias -> Alias do TRB que recebera as informacoes.         ³±±
±±³          ³cAliasSFT -> Alias da tabela SFT posicionada no momento do  ³±±
±±³          | processamento.                                             ³±±
±±³          |nRelac -> Flag de relacionamento de registro para gravar no ³±±
±±³          | TRB.                                                       ³±±
±±³          |nItem  -> Numero do item em processamento para gravar no TRB³±±
±±³          |cProd  -> Codigo do produto montado pela rotina             ³±±
±±³          |lSpedRTms -> Flag de existencia do PE SPEDRTMS              ³±±
±±³          |aCmpAntSFT-> Informacoes sobre o cabecalho dos documentos.  ³±±
*/
Static Function RegD110(cAlias,cAliasSFT,nRelac,nItem,cProd,lSpedRTms,aCmpAntSFT)
local nPos     := 0
Local aRegD110 := {}
Local aRetPE   := {}

aAdd (aRegD110, {})
nPos := Len(aRegD110)

//-- Ponto de entrada para substituir o calculo do sistema
If lSpedRTMS
	aRetPE := ExecBlock("SPEDRTMS",.F.,.F.,{nPos,"D110",cAliasSFT,aCmpAntSFT})
	If ValType(aRetPE) == "A" .And. Len(aRetPE) > 0
		aRegD110 := {}
		aEval(aRetPE,{|x| AAdd(aRegD110, x)})
	EndIf
EndIf

//-- Se nao foi alterado nada via PE, faco o padrao
If Len(aRegD110[nPos]) == 0
	aAdd (aRegD110[nPos], "D110")								//01 - REG
	aAdd (aRegD110[nPos], {Val((cAliasSFT)->FT_ITEM), 0})		//02 - NUM_ITEM
	aAdd (aRegD110[nPos], cProd)								//03 - COD_ITEM
	aAdd (aRegD110[nPos], (cAliasSFT)->FT_TOTAL)				//04 - VL_SERV
	aAdd (aRegD110[nPos], (cAliasSFT)->FT_DESPESA)				//05 - VL_OUT
EndIf

//GrvRegTrS(cAlias,nRelac,aRegD110,nItem)
GrvRegTrS(cAlias,GetRelaGrv(nRelac, 9),aRegD110,nItem) 

Return
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³RegD120   ³ Autor ³Gustavo G. Rueda       ³ Data ³11.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±³          ³                         D120                               ³±±
±±³          ³    COMPLEMENTO DA NOTA FISCAL DE SERVICO DE TRANSPORTE     ³±±
±±³          ³                     (MODELO 07)                            ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao e gravacao do Registro D120                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com as informacoes contidas nas tabelas³±±
±±³          ³ DT6/DA3/DUY/SA1 caso tenham integracao com o TMS.          ³±±
±±³          ³O DA3 utilizado nesta funcao pode estar posicionado de acor-³±±
±±³          ³ do com a tabela  DTR quando envolver TMS ou DB1 quando     ³±±
±±³          ³ envolver o recebimento no compras (MATR145).               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³D120 - 3(1:1) Para cada D100                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T.                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cAlias -> Alias do TRB que recebera as informacoes.         ³±±
±±³          ³nRelac -> Flag de relacionamento com os sub-registros       ³±±
±±³          ³lAchouDA3 -> Flag que identifica se a tabela DA3 foi posi-  ³±±
±±³          ³ cionada.                                                   ³±±
±±³          ³nItem  -> Numero do item para controle do TRB               ³±±
±±³          |lSpedRTms -> Flag de existencia do PE SPEDRTMS              ³±±
±±³          |aCmpAntSFT-> Informacoes sobre o cabecalho dos documentos.  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function RegD120(cAlias,nRelac,lAchouDA3,nItem,lSpedRTms,cAliasSFT,aCmpAntSFT, lAchouDT6)
Local aReg     := {}
Local aAreaSA1 := SA1->(GetArea())
Local cCodMun  := ''
Local aRetPE   := {}
Local aRetHash := {}	
Local cChvSeek := ""

aAdd (aReg, {})
nPos := Len(aReg)

//-- Ponto de entrada para substituir o calculo do sistema
If lSpedRTMS
	aRetPE := ExecBlock("SPEDRTMS",.F.,.F.,{nPos,"D120",cAliasSFT,aCmpAntSFT})
	If ValType(aRetPE) == "A" .And. Len(aRetPE) > 0
		aReg := {}
		aEval(aRetPE,{|x| AAdd(aReg, x)})
	EndIf
EndIf

//-- Se nao foi alterado nada via PE, faco o padrao
If Len(aReg[nPos])==0
	aAdd (aReg[nPos], "D120")												//01 - REG

	//³Remetente³
	If lAchouDT6
		If !Empty((cAliasSFT)->(DT6_CLIREM+DT6_LOJREM))
			cChvSeek 	:= aSPDFil[PFIL_SA1]+(cAliasSFT)->(DT6_CLIREM+DT6_LOJREM)
			aRetHash 	:= fHashInfP("SA1", cChvSeek)
		Else
			aRetHash	:= {}	
		EndIf	
	EndIf

	If Len(aRetHash) > 0
		cCodMun	:= TMSCodMun((cAliasSFT)->DT6_CDRORI, , , aRetHash[7], aRetHash[13])
		AAdd (aReg[nPos],cCodMun)											//02 - COD_MUN_ORIG	
	Else
		aAdd (aReg[nPos], "")												//02 - COD_MUN_ORIG	                                            
	EndIf	
	////////////////////////////////////////////////////

	aRetHash := {}

	//³Destinatario³
	If lAchouDT6
		If !Empty((cAliasSFT)->(DT6_CLIDES+DT6_LOJDES))
			cChvSeek 	:= aSPDFil[PFIL_SA1]+(cAliasSFT)->(DT6_CLIDES+DT6_LOJDES)
			aRetHash 	:= fHashInfP("SA1", cChvSeek)
		Else
			aRetHash	:= {}	
		EndIf	
	EndIf	

	If Len(aRetHash) > 0
		If Upper(SA1->A1_EST) == "EX"
			cCodMun	:= TMSCodMun((cAliasSFT)->DT6_CDRCAL, , , aRetHash[7], aRetHash[13])
		Else
			cCodMun	:= TMSCodMun((cAliasSFT)->DT6_CDRDES, , , aRetHash[7], aRetHash[13])
		EndIf
		aAdd (aReg[nPos], cCodMun)											//03 - COD_MUN_DEST
	Else
		aAdd (aReg[nPos], "")												//03 - COD_MUN_DEST
	EndIf	                                            
	////////////////////////////////////////////////////

	//-- Obtendo dados do veiculo de transporte
	If lAchouDA3
		aAdd (aReg[nPos], SubStr(StrTran(DA3->DA3_PLACA,"-",""),1,7))		//04 - VEIC_ID
		aAdd (aReg[nPos], DA3->DA3_ESTPLA)									//05 - VEIC_ID
	Else
		aAdd (aReg[nPos], "")												//04 - VEIC_ID
		aAdd (aReg[nPos], "")												//05 - VEIC_ID
	EndIf
EndIf

//GrvRegTrS(cAlias,nRelac,aReg,nItem)
GrvRegTrS(cAlias,GetRelaGrv(nRelac, 9),aReg,nItem)

RestArea(aAreaSA1)

Return
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³RegD130   ³ Autor ³Gustavo G. Rueda       ³ Data ³11.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±³          ³                         D130                               ³±±
±±³          ³           COMPLEMENTO DO DOCUMENTO (MODELO 08)             ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao e gravacao do Registro D130                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com as informacoes contidas nas tabelas³±±
±±³          ³ DT6/DA3/DT8 caso tenham integracao com o TMS.              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³3(1:1) Para cada D100                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nil                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cAlias -> Alias do TRB que recebera as informacoes.         ³±±
±±³          ³nRelac -> Flag de relacionamento com os sub-registros       ³±±
±±³          ³lAchouDA3 -> Flag que identifica se a tabela DA3 estah      ³±±
±±³          ³   posicionada e pronta para ser lida                       ³±±
±±³          ³cSituaDoc -> Situacao do documento fiscal conforme funcao   ³±±
±±³          ³aMVCOMPFRT -> Array com os códigos de componentes que serão ³±±
±±³          ³ relacionados com registros do DT8, no seguinte formato:    ³±±
±±³          ³ {"FretePV","SEC/CAT","Despacho","Pedágio"}                 ³±±
±±³          ³lSpedRTms-> Flag de existencia do PE SPEDRTMS               ³±±
±±³          ³lAchouDT8 -> Flag de posicionamento da tabela DT8           ³±±
±±³          ³cAliasDT8 -> Alias da tabela DT8 a ser utilizada            ³±±
±±³          ³cCdMunOri -> Municipio de origem calculado pelo DT6         ³±±
±±³          ³aPartREM  -> Array com as informacoes do participante       ³±±
±±³          ³             Remetente                                      ³±±
±±³          ³cCdMunDes -> Municipio de destino calculado pelo DT6        ³±±
±±³          ³aPartDES  -> Array com as informacoes do participante       ³±±
±±³          ³             destinatario                                   ³±±
±±³          ³aPartCON  -> Array com as informacoes do participante       ³±±
±±³          ³             consignatario                                  ³±±
±±³          ³aPartDPC  -> Array com as informacoes do participante       ³±±
±±³          ³             despachante                                    ³±±
±±³          ³aReg0150  -> Array com a estrutura do registro 0150         ³±±
±±³          |aWizard   -> Array com as informacoes do wizard             ³±±
±±³          ³cAliasSFT -> Alias da tabela SFT posicionada no momento     ³±±
±±³          |aCmpAntSFT-> Informacoes sobre o cabecalho dos documentos.  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function RegD130(cAlias,nRelac,lAchouDA3,cSituaDoc,aMVCOMPFRT,lSpedRTms,lAchouDT8,cAliasDT8,;
					cCdMunOri,aPartREM,cCdMunDes,aPartDES,aPartCON,aPartDPC,aReg0150,aWizard,cAliasSFT,aCmpAntSFT, lAchouDT6)
Local aReg     := {}
Local aRetPE   := {}
Local nPos     := 0
Local nVlFrete := 0
Local lTipCmpDT3 	:= aSPDSX3[FP_DT3_TIPCMP]
Local cDT8Chv		:= ""

//-- Inicio da montagem do registro
aAdd (aReg, {})
nPos := Len(aReg)

//-- Gera registro dos participantes
If !cSituaDoc$"02#04#05#03"
	If Len(aPartCON) > 0
		SDPF150175(@aReg0150,aPartCON,cAlias,aWizard,aExistBloc)
	EndIf
	If Len(aPartDPC) > 0
		SDPF150175(@aReg0150,aPartDPC,cAlias,aWizard,aExistBloc)
	EndIf
EndIf

//-- Ponto de entrada para substituir o calculo do sistema
If lSpedRTMS
	aRetPE := ExecBlock("SPEDRTMS",.F.,.F.,{nPos,"D130",cAliasSFT,aCmpAntSFT})
	If ValType(aRetPE) == "A" .And. Len(aRetPE) > 0
		aReg := {}
		aEval(aRetPE,{|x| AAdd(aReg, x)})
	EndIf
EndIf

//-- Se nao foi alterado nada via PE, faco o padrao
If Len(aReg[nPos])==0
	aAdd (aReg[nPos], "D130")																//01 - REG
	aAdd (aReg[nPos], IIf (cSituaDoc$"02#03#04#05" .Or. Empty(aPartCON), "", aPartCON[1]))	//02 - COD_PART_CONSG
	aAdd (aReg[nPos], IIf (cSituaDoc$"02#03#04#05" .Or. Empty(aPartDPC), "", aPartDPC[1]))	//03 - COD_PART_RED

	//³Tipo de frete³
	//³1=CIF, 2=FOB ³
	If lAchouDT6 .And. (aCmpAntSFT[61] $ "1")
		aAdd (aReg[nPos],"0")															//04 - IND_FRT_RED
	Else
		aAdd (aReg[nPos],"1")															//04 - IND_FRT_RED
	EndIf

	//³Municipio de origem³
	If Empty(cCdMunOri)   //Não encontrou registro no SA1
		aAdd (aReg[nPos], aPartREM[7])													//05 - COD_MUN_ORIG
	Else
		aAdd (aReg[nPos], cCdMunOri)													//05 - COD_MUN_ORIG
	EndIf

	//³Municipio de destino³
	If Empty(cCdMunDes)   //Não encontrou registro no SA1
		aAdd (aReg[nPos], aPartDES[7])													//06 - COD_MUN_DEST	
	Else
		aAdd (aReg[nPos], cCdMunDes)													//06 - COD_MUN_DEST	
	EndIf

	aAdd (aReg[nPos], Iif(lAchouDA3,SubStr(StrTran(DA3->DA3_PLACA,"-",""),1,7),""))	//07 - VEIC_ID
	aAdd (aReg[nPos], 0)																//08 - VL_LIQ_FRT
	aAdd (aReg[nPos], 0)																//09 - VL_SEC_CAT
	aAdd (aReg[nPos], 0)																//10 - VL_DESP
	aAdd (aReg[nPos], 0)																//11 - VL_PEDG
	aAdd (aReg[nPos], 0)																//12 - VL_OUT
	aAdd (aReg[nPos], 0)																//13 - VL_FRT
	aAdd (aReg[nPos], Iif(lAchouDA3,DA3->DA3_ESTPLA,""))								//14 - UF_ID

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Quando lAchouDT8 estiver verdadeiro, significa que encontrou  o registro³
	//³ para o conhecimento em questao e que a tabela esta posicionada no      ³
	//³ primeiro registro.                                                     ³
	//³                                                                        ³
	//³NAO PRECISO DE TRATAMENTO DE TOP OU DBF PORQUE O TMS EH SOH AMBIENTE TOP³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lAchouDT8 
		cDT8Chv := (cAliasDT8)->(DT8_FILIAL+DT8_FILDOC+DT8_DOC+DT8_SERIE)
		Do While !(cAliasDT8)->(Eof ()) .AND. ((cAliasDT8)->(DT8_FILIAL+DT8_FILDOC+DT8_DOC+DT8_SERIE)==cDT8Chv)

			//--Campo DT3_TIPCMP (Tipo do componente de frete) criado para complementar o conhecimento rodoviario de cargas do SPEDFISCAL.
			If lTipCmpDT3 .AND.   ;
				Empty(aMVCOMPFRT[1]) .And. Empty(aMVCOMPFRT[2]) .And. Empty(aMVCOMPFRT[3]) .And. Empty(aMVCOMPFRT[4])

				//Valor Total do frete
				If (cAliasDT8)->DT8_CODPAS$"TF"
					aReg[nPos][13]	+=	(cAliasDT8)->DT8_VALTOT								//13 - VL_FRT

				ElseIf SpedSeek("DT3",1,aSPDFil[PFIL_DT3]+(cAliasDT8)->DT8_CODPAS) // Posiciona na DT3
					
					//Valor do frete por peso/volume
					If DT3->DT3_TIPCMP=="1"
						aReg[nPos][08]	+=	(cAliasDT8)->DT8_VALTOT								//08 - VL_FRT_PV
	
					//Valores do SEC/CAT
					ElseIf DT3->DT3_TIPCMP=="2"
						aReg[nPos][09]	+=	(cAliasDT8)->DT8_VALTOT								//09 - VL_SEC_CAT
	
					//Valores de despacho
					ElseIf DT3->DT3_TIPCMP=="3"
						aReg[nPos][10]	+=	(cAliasDT8)->DT8_VALTOT								//10 - VL_DESP
	
					//Valores de pedagio
					ElseIf DT3->DT3_TIPCMP=="4"
						aReg[nPos][11]	+=	(cAliasDT8)->DT8_VALTOT								//11 - VL_PEDG
                    
                    //Outros valores
                    Else
                    	aReg[nPos][12]	+=	(cAliasDT8)->DT8_VALTOT								//12 - VL_OUT
                    EndIf 
                    
				//Outros valores
				Else
					aReg[nPos][12]	+=	(cAliasDT8)->DT8_VALTOT								//12 - VL_OUT
				EndIf

			ElseIf Len(aMVCOMPFRT)==4
				//Valor Total do frete
				If (cAliasDT8)->DT8_CODPAS$"TF"
					aReg[nPos][13]	+=	(cAliasDT8)->DT8_VALTOT								//13 - VL_FRT

				//Valor do frete por peso/volume
				ElseIf (cAliasDT8)->DT8_CODPAS$aMVCOMPFRT[1]
					aReg[nPos][08]	+=	(cAliasDT8)->DT8_VALTOT								//08 - VL_FRT_PV

				//Valores do SEC/CAT
				ElseIf (cAliasDT8)->DT8_CODPAS$aMVCOMPFRT[2]
					aReg[nPos][09]	+=	(cAliasDT8)->DT8_VALTOT								//09 - VL_SEC_CAT

				//Valores de despacho
				ElseIf (cAliasDT8)->DT8_CODPAS$aMVCOMPFRT[3]
					aReg[nPos][10]	+=	(cAliasDT8)->DT8_VALTOT								//10 - VL_DESP

				//Valores de pedagio
				ElseIf (cAliasDT8)->DT8_CODPAS$aMVCOMPFRT[4]
					aReg[nPos][11]	+=	(cAliasDT8)->DT8_VALTOT								//11 - VL_PEDG

				//Outros valores
				Else
					aReg[nPos][12]	+=	(cAliasDT8)->DT8_VALTOT								//12 - VL_OUT
				EndIf

			//Valor Total do Frete
			ElseIf (cAliasDT8)->DT8_CODPAS$"TF"
				aReg[nPos][13]	+=	(cAliasDT8)->DT8_VALTOT									//13 - VL_FRT

			//Outros valores
			Else
				aReg[nPos][12]	+=	(cAliasDT8)->DT8_VALTOT									//12 - VL_OUT
			EndIf

			(cAliasDT8)->(DbSkip ())
		EndDo
		//-- Suprimir decimais: converte campo Volume (DTC_QTDVOL) para caracter
		AEval(aReg,{|x|nVlFrete+=x[8]})
		If	nVlFrete == 0
			aReg[nPos,4] := "9"																//04 - IND_FRT_RED
		EndIf
	EndIf
EndIf
//-- Gravacao do registro no TRB
If Len(aReg[nPos]) > 0
	//GrvRegTrS(cAlias,nRelac,aReg)
	GrvRegTrS(cAlias,GetRelaGrv(nRelac, 8),aReg)
EndIf
Return
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³RegD140   ³ Autor ³Gustavo G. Rueda       ³ Data ³11.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±³          ³                         D140                               ³±±
±±³          ³           COMPLEMENTO DO DOCUMENTO (MODELO 09)             ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao e gravacao do Registro D140                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com as informacoes contidas nas tabelas³±±
±±³          ³ DT6/DA3/DT8 caso tenham integracao com o TMS.              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³3(1:1) Para cada D100                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nil                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cAlias -> Alias do TRB que recebera as informacoes.         ³±±
±±³          ³nRelac -> Flag de relacionamento com os sub-registros       ³±±
±±³          ³lSpedRTms-> Flag de existencia do PE SPEDRTMS               ³±±
±±³          ³aWizard -> Informacoes digitadas no wizard da rotina        ³±±
±±³          ³lAchouDA3 -> Flag que identifica se a tabela DA3 estah      ³±±
±±³          ³   posicionada e pronta para ser lida                       ³±±
±±³          ³lAchouDUD -> Flag que identifica se a tabela DUD estah      ³±±
±±³          ³   posicionada e pronta para ser lida                       ³±±
±±³          ³lAchouDT8 -> Flag de posicionamento da tabela DT8           ³±±
±±³          ³cAliasDT8 -> Alias da tabela DT8 a ser utilizada            ³±±
±±³          ³aPartREM  -> Array com as informacoes do participante       ³±±
±±³          ³             Remetente                                      ³±±
±±³          ³aPartDES  -> Array com as informacoes do participante       ³±±
±±³          ³             destinatario                                   ³±±
±±³          ³aPartCON  -> Array com as informacoes do participante       ³±±
±±³          ³             consignatario                                  ³±±
±±³          ³cAliasSFT -> Alias da tabela SFT posicionada no momento     ³±±
±±³          |aCmpAntSFT-> Informacoes sobre o cabecalho dos documentos.  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function RegD140(cAlias,nRelac,lSpedRTms,lAchouDA3,lAchouDUD,lAchouDT8,cAliasDT8,aPartREM,aPartDES,aPartCON,cAliasSFT,aCmpAntSFT)

Local aReg   := {}
Local aRetPE := {}
Local cDT8Chv := ""

//³Inicio da montagem do registro ³
aAdd (aReg, {})
nPos := Len(aReg)

//-- Ponto de entrada para substituir o calculo do sistema
If lSpedRTMS
	aRetPE := ExecBlock("SPEDRTMS",.F.,.F.,{nPos,"D140",cAliasSFT,aCmpAntSFT})
	If ValType(aRetPE) == "A" .And. Len(aRetPE) > 0
		aReg := {}
		aEval(aRetPE,{|x| AAdd(aReg, x)})
	EndIf
EndIf

//-- Se nao foi alterado nada via PE, faco o padrao
If Len(aReg[nPos])==0
	aAdd (aReg[nPos], "D140")															//01 - REG
	aAdd (aReg[nPos], If(Empty(aPartCON),"",aPartCON[1]))								//02 - COD_PART_CONSG
	aAdd (aReg[nPos], aPartREM[7])														//03 -
	aAdd (aReg[nPos], aPartDES[7])														//04 - COD_MUN_DEST
	aAdd (aReg[nPos], "0")																//05 - IND_VEIC
	aAdd (aReg[nPos], Iif (lAchouDA3, SubStr(StrTran(DA3->DA3_PLACA,"-",""),1,7), ""))	//06 - VEIC_ID
	aAdd (aReg[nPos], "0")																//07 - IND_NAV
	aAdd (aReg[nPos], Iif (lAchouDUD, (cAliasSFT)->DUD_VIAGEM, ""))								//08 - VIAGEM
	aAdd (aReg[nPos], 0)																//09 - VL_LIQ_FRT
	aAdd (aReg[nPos], 0)																//10 - VL_DESP_PORT
	aAdd (aReg[nPos], 0)																//11 - VL_DESP_CAR_DESC
	aAdd (aReg[nPos], 0)																//12 - VL_OUT
	aAdd (aReg[nPos], 0)																//13 - VL_FRT_BRT
	aAdd (aReg[nPos], 0)																//14 - VL_FRT_MM

	//³Quando lAchouDT8 estiver verdadeiro, significa que encontrou  o registro³
	//³ para o conhecimento em questao e que a tabela esta posicionada no      ³
	//³ primeiro registro.                                                     ³
	//³                                                                        ³
	//³NAO PRECISO DE TRATAMENTO DE TOP OU DBF PORQUE O TMS EH SOH AMBIENTE TOP³
	If lAchouDT8  
		cDT8Chv := (cAliasDT8)->(DT8_FILIAL+DT8_FILDOC+DT8_DOC+DT8_SERIE) 
		Do While !(cAliasDT8)->(Eof ()) .AND. ((cAliasDT8)->(DT8_FILIAL+DT8_FILDOC+DT8_DOC+DT8_SERIE)==cDT8Chv)

			//Valor Total do frete
			If (cAliasDT8)->DT8_CODPAS$"TF"
				aReg[nPos][13]	+=	(cAliasDT8)->DT8_VALTOT								//13 - VL_FRT_BRT
			Else //Outros valores
				aReg[nPos][12]	+=	(cAliasDT8)->DT8_VALTOT								//12 - VL_OUT
			EndIf
			
			(cAliasDT8)->(DbSkip ())
		EndDo
	EndIf
EndIf
//-- Gravacao do registro no TRB
If Len(aReg[nPos]) > 0
	//GrvRegTrS(cAlias,nRelac,aReg)
	GrvRegTrS(cAlias,GetRelaGrv(nRelac, 7),aReg)
EndIf
Return
/*
³Programa  ³RegD150   ³ Autor ³Gustavo G. Rueda       ³ Data ³11.03.2011³

³Descri‡…o ³                                                            ³
³          ³                         D150                               ³
³          ³           COMPLEMENTO DO DOCUMENTO (MODELO 09)             ³
³          ³                                                            ³
³          ³- Geracao e gravacao do Registro D150                       ³

³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³
³          ³ da funcao GrvRegTrS com as informacoes contidas nas tabelas³
³          ³ DT6/DA3/DT8 caso tenham integracao com o TMS.              ³
³Nivel Hier³3(1:1) Para cada D100                                       ³

³Retorno   ³Nil                                                         ³

³Parametros³cAlias -> Alias do TRB que recebera as informacoes.         ³
³          ³nRelac -> Flag de relacionamento com os sub-registros       ³
³          ³lSpedRTms-> Flag de existencia do PE SPEDRTMS               ³
³          ³lAchouDA3 -> Flag que identifica se a tabela DA3 estah      ³
³          ³   posicionada e pronta para ser lida                       ³
³          ³lAchouDUD -> Flag que identifica se a tabela DUD estah      ³
³          ³   posicionada e pronta para ser lida                       ³
³          ³lAchouDT8 -> Flag de posicionamento da tabela DT8           ³
³          ³cAliasDT8 -> Alias da tabela DT8 a ser utilizada            ³
³          ³aPartREM  -> Array com as informacoes do participante       ³
³          ³             Remetente                                      ³
³          ³aPartDES  -> Array com as informacoes do participante       ³
³          ³             destinatario                                   ³
³          ³cAliasSFT -> Alias da tabela SFT posicionada no momento     ³
³          |aCmpAntSFT-> Informacoes sobre o cabecalho dos documentos.  ³
*/
Static Function RegD150(cAlias,nRelac,lSpedRTms,lAchouDA3,lAchouDUD,lAchouDT8,cAliasDT8,aPartREM,aPartDES,cAliasSFT,aCmpAntSFT)

Local aReg   := {}
Local aRetPE := {}
Local cDT8Chv := ""

//-- Inicio da montagem do registro
aAdd (aReg, {})
nPos := Len(aReg)

//-- Ponto de entrada para substituir o calculo do sistema
If lSpedRTMS
	aRetPE := ExecBlock("SPEDRTMS",.F.,.F.,{nPos,"D150",cAliasSFT,aCmpAntSFT})
	If ValType(aRetPE) == "A" .And. Len(aRetPE) > 0
		aReg := {}
		aEval(aRetPE,{|x| AAdd(aReg, x)})
	EndIf
EndIf

//-- Se nao foi alterado nada via PE, faco o padrao
If Len(aReg[nPos]) == 0
	aAdd (aReg[nPos], "D150")															//01 - REG
	aAdd (aReg[nPos], aPartREM[7])														//02 - COD_MUN_ORIG
	aAdd (aReg[nPos], aPartDES[7])														//03 - COD_MUN_DEST
	aAdd (aReg[nPos], Iif (lAchouDA3, SubStr(StrTran(DA3->DA3_PLACA,"-",""),1,7), ""))	//04 - VEIC_ID
	aAdd (aReg[nPos], Iif (lAchouDUD, (cAliasSFT)->DUD_VIAGEM, ""))								//05 - VIAGEM
	aAdd (aReg[nPos], "0")																//06 - IND_TFA
	aAdd (aReg[nPos], 0)																//07 - VL_PESO_TX
	aAdd (aReg[nPos], 0)																//08 - VL_TX_TERR
	aAdd (aReg[nPos], 0)																//09 - VL_TX_RED
	aAdd (aReg[nPos], 0)																//10 - VL_OUT
	aAdd (aReg[nPos], 0)																//11 - VL_TX_ADV


	//³Quando lAchouDT8 estiver verdadeiro, significa que encontrou  o registro³
	//³ para o conhecimento em questao e que a tabela esta posicionada no      ³
	//³ primeiro registro.                                                     ³
	//³                                                                        ³
	//³NAO PRECISO DE TRATAMENTO DE TOP OU DBF PORQUE O TMS EH SOH AMBIENTE TOP³
	If lAchouDT8                
		cDT8Chv := (cAliasDT8)->(DT8_FILIAL+DT8_FILDOC+DT8_DOC+DT8_SERIE)
		Do While !(cAliasDT8)->(Eof ()) .AND. ((cAliasDT8)->(DT8_FILIAL+DT8_FILDOC+DT8_DOC+DT8_SERIE)==cDT8Chv)

			//Valor Total do frete
			If (cAliasDT8)->DT8_CODPAS$"TF"
				aReg[nPos][07]	+=	(cAliasDT8)->DT8_VALTOT								//13 - VL_FRT_BRT
			Else //Outros valores
				aReg[nPos][10]	+=	(cAliasDT8)->DT8_VALTOT								//12 - VL_OUT
			EndIf

			(cAliasDT8)->(DbSkip ())
		EndDo
	EndIf
EndIf
//-- Gravacao do registro no TRB
If Len(aReg[nPos]) > 0
	//GrvRegTrS(cAlias,nRelac,aReg)
	GrvRegTrS(cAlias,GetRelaGrv(nRelac, 6),aReg)
EndIf
Return
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³RegD160   ³ Autor ³Gustavo G. Rueda       ³ Data ³14.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±³          ³          D160 - CARGA TRANSPORTADA (MODELO 08)             ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao e gravacao do Registro D160                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com as informacoes contidas nas tabelas³±±
±±³          ³ DT6/SA1/SFT caso tenham integracao com o TMS.              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³D160 - 3(1:1) Para cada D100                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nil                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cAlias -> Alias do TRB que recebera as informacoes.         ³±±
±±³          ³nRelac -> Flag de relacionamento com os sub-registros       ³±±
±±³          ³cEspecie -> Modelo do documento fiscal                      ³±±
±±³          |lSpedRTms -> Flag de existencia do PE SPEDRTMS              ³±±
±±³          ³aPartREM  -> Array com as informacoes do participante       ³±±
±±³          ³             Remetente                                      ³±±
±±³          ³cCdMunOri -> Municipio de origem calculado pelo DT6         ³±±
±±³          ³aPartDES  -> Array com as informacoes do participante       ³±±
±±³          ³cCdMunDes -> Municipio de destino calculado pelo DT6        ³±±
±±³          ³cAliasSFT -> Alias da tabela SFT posicionada no momento     ³±±
±±³          |aCmpAntSFT-> Informacoes sobre o cabecalho dos documentos.  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function RegD160(cAlias,nRelac,cEspecie,lSpedRTms,aPartREM,cCdMunOri,aPartDES,cCdMunDes,cAliasSFT,aCmpAntSFT)

Local aRegD160 := {}
Local nPos     := 0
Local cIndCg   := "0"
Local aRetPE   := {}

//³Montagem do indicador do tipo de carga.³
//³0=Rodoviario;                          ³
//³1=Ferroviario                          ³
//³2=Rodo-ferroviario                     ³
//³3=Aquaviario                           ³
//³4=Dutoviario                           ³
//³5=Aereo                                ³
//³9=Outros                               ³
If cEspecie=="09"
	cIndCg 	:= 	"2"
ElseIf cEspecie=="10"
	cIndCg 	:= 	"4"
ElseIf cEspecie=="11"
	cIndCg	:= 	"1"
ElseIf cEspecie=="26"
	cIndCg 	:= 	"9"
EndIf

//³REGISTRO D160 - CARGA TRANSPORTADA - Inicio da montagem do registro    ³
aAdd (aRegD160, {})
nPos := Len(aRegD160)

//-- Ponto de entrada para substituir o calculo do sistema
If lSpedRTMS
	aRetPE := ExecBlock("SPEDRTMS",.F.,.F.,{nPos,"D160",cAliasSFT,aCmpAntSFT})
	If ValType(aRetPE) == "A" .And. Len(aRetPE) > 0
		aRegD160 := {}
		aEval(aRetPE,{|x| AAdd(aRegD160, x)})
	EndIf
EndIf

//-- Se nao foi alterado nada via PE, faco o padrao
If Len(aRegD160[nPos]) == 0
	aAdd (aRegD160[nPos], "D160")	 										//01 - REG
	aAdd (aRegD160[nPos], "")				 								//02 - DESPACHO
	aAdd (aRegD160[nPos], If(Empty(aPartREM[4]),aPartREM[5],aPartREM[4]))	//03 - CNPJ_CPF_REM
	aAdd (aRegD160[nPos], aPartREM[6])										//04 - IE_REM

	//³Municipio de origem³
	If Empty(cCdMunOri)   //Nao encontrou registro no SA1
		aAdd (aRegD160[nPos], aPartREM[7])									//05 - COD_MUN_ORI
	Else
		aAdd (aRegD160[nPos], cCdMunOri)									//05 - COD_MUN_ORI
	EndIf

	aAdd (aRegD160[nPos], aPartDES[4])										//06 - CNPJ_CPF_DEST
	aAdd (aRegD160[nPos], aPartDES[6])										//07 - IE_DEST

	//³Municipio de destino³
	If Empty(cCdMunDes)   //Nao encontrou registro no SA1
		aAdd (aRegD160[nPos], aPartDES[7])									//08 - CPD_MUN_DEST
	Else
		aAdd (aRegD160[nPos], cCdMunDes)									//08 - CPD_MUN_DEST
	EndIf
EndIf
//-- Gravacao do registro no TRB
If Len(aRegD160[nPos]) > 0
	//GrvRegTrS(cAlias,nRelac,aRegD160)
	GrvRegTrS(cAlias,GetRelaGrv(nRelac, 5),aRegD160)
EndIf
Return
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³D161D162  ³ Autor ³Gustavo G. Rueda       ³ Data ³14.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±³          ³       D161 - LOCAL DE COLETA/ENTREGA (MODELO 08)           ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao e gravacao dos Registros D160, D161 e D162        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com as informacoes contidas nas tabelas³±±
±±³          ³ DT6/SA1/SFT caso tenham integracao com o TMS.              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³D120 - 3(1:1) Para cada D100                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T.                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cAlias -> Alias do TRB que recebera as informacoes.         ³±±
±±³          ³nRelac -> Flag de relacionamento com os sub-registros       ³±±
±±³          ³cEspecie -> Modelo do documento fiscal                      ³±±
±±³          |aCmpAntSFT -> Informacoes sobre o cabecalho dos documentos. ³±±
±±³          |cMvD162 -> Conteudo do parametro MV_NGD162                  ³±±
±±³          |lSpedRTms -> Flag de existencia do PE SPEDRTMS              ³±±
±±³          ³aPartREM  -> Array com as informacoes do participante       ³±±
±±³          ³             Remetente                                      ³±±
±±³          ³cCdMunOri -> Municipio de origem calculado pelo DT6         ³±±
±±³          ³aPartDES  -> Array com as informacoes do participante       ³±±
±±³          ³cCdMunDes -> Municipio de destino calculado pelo DT6        ³±±
±±³          ³cAliasSFT -> Alias da tabela SFT posicionada no momento     ³±±
±±³          ³cPerfil   -> Variavel com o perfil de processamento         ³±±
±±³          ³lAchouDT5 -> Flag de posicionamento da tabela DT5           ³±±
±±³          ³cAliasDT5 -> Alias da tabela DT5 posicionada no momento     ³±±
±±³          ³lAchouDUL -> Flag de posicionamento da tabela DUL           ³±±
±±³          ³cAliasDUL -> Alias da tabela DUL posicionada no momento     ³±±
±±³          ³lAchouDTC -> Flag de posicionamento da tabela DTC           ³±±
±±³          ³cAliasDTC -> Alias da tabela DTC posicionada no momento     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function D161D162(cAlias,nRelac,cEspecie,aCmpAntSFT,cMvD162,lSpedRTms,aPartREM,cCdMunOri,aPartDES,cCdMunDes,;
							cAliasSFT,cPerfil,lAchouDT5,cAliasDT5,lAchouDUL,cAliasDUL,lAchouDTC,cAliasDTC,lAchou2DUL,cDTCChv)
Local aRegD161  := {}
Local aRegD162  := {}
Local nPos      := 0
Local cIndCg    := "0"
Local aRetPE    := {}
Local cColCNPJ  := ""
Local cColIE    := ""
Local cCdMunCol := ""
Local cEntCNPJ  := ""
Local cEntIE    := ""
Local cCdMunEnt := ""
Local lRegD161  := .F.
//³Montagem do indicador do tipo de carga.³
//³0=Rodoviario;                          ³
//³1=Ferroviario                          ³
//³2=Rodo-ferroviario                     ³
//³3=Aquaviario                           ³
//³4=Dutoviario                           ³
//³5=Aereo                                ³
//³9=Outros                               ³
If cEspecie=="09"
	cIndCg := "2"
ElseIf cEspecie=="10"
	cIndCg := "4"
ElseIf cEspecie=="11"
	cIndCg := "1"
ElseIf cEspecie=="26"
	cIndCg := "9"
EndIf

//³REGISTRO D161 - LOCAL DA COLETA E ENTREGA                              ³
If cPerfil == "A"

	//-- Inicio da montagem do registro
	aAdd (aRegD161, {})
	nPos := Len(aRegD161)

	//-- Ponto de entrada para substituir o calculo do sistema
	If lSpedRTMS
		aRetPE := ExecBlock("SPEDRTMS",.F.,.F.,{nPos,"D161",cAliasSFT,aCmpAntSFT})
		If ValType(aRetPE) == "A" .And. Len(aRetPE) > 0
			aRegD161 := {}
			aEval(aRetPE,{|x| AAdd(aRegD161, x)})
		EndIf
	EndIf

	//-- Se nao foi alterado nada via PE, faco o padrao
	If Len(aRegD161[nPos])==0
		cColCNPJ  := ""
		cColIE    := ""
		cCdMunCol := ""
		cEntCNPJ  := ""
		cEntIE    := ""
		cCdMunEnt := ""
		lRegD161  := .F.

		//-- Busca endereco de coleta diferente do remetente
		If	lAchouDT5  
			If lAchou2DUL 
				cColCNPJ  := IIf(aSPDSX3[FP_DUL_CGC], DUL->DUL_CGC,"")
		   		cColIE    := IIf(aSPDSX3[FP_DUL_INSCR], DUL->DUL_INSCR,"") 
		   		cCdMunCol := UfCodIBGE(DUL->DUL_EST)+DUL->DUL_CODMUN   
		  	EndIf 
			If	!Empty(cColCNPJ) .And. cColCNPJ <> If(Empty(aPartREM[4]),aPartREM[5],aPartREM[4])
				lRegD161  := .T.
			EndIf
		EndIf

		//-- Busca endereco de entrega diferente do destinatario
		If	lAchouDUL
			cEntCNPJ  := (cAliasDUL)->(Iif(FieldPos("DUL_CGC")>0,DUL_CGC,""))
			cEntIE    := (cAliasDUL)->(Iif(FieldPos("DUL_INSCR")>0, DUL_INSCR,""))
			cCdMunEnt := UfCodIBGE((cAliasDUL)->DUL_EST)+(cAliasDUL)->DUL_CODMUN
			If	!Empty(cEntCNPJ) .And. cEntCNPJ <> If(Empty(aPartDES[4]),aPartDES[5],aPartDES[4])
				lRegD161  := .T.
			EndIf
		EndIf
	EndIf
	
	If	lRegD161
		aAdd (aRegD161[nPos], "D161")			//01 - REG
		aAdd (aRegD161[nPos], cIndCg)			//02 - IND_CARGA
		aAdd (aRegD161[nPos], cColCNPJ)			//03 - CNPJ_COL
		aAdd (aRegD161[nPos], cColIE)			//04 - IE_COL
		aAdd (aRegD161[nPos], cCdMunCol)		//05 - COD_MUN_COL
		aAdd (aRegD161[nPos], cEntCNPJ)			//06 - CNPJ_ENTG
		aAdd (aRegD161[nPos], cEntIE)			//07 - IE_ENTG
		aAdd (aRegD161[nPos], cCdMunEnt)		//08 - COD_MUN_ENTG
	EndIf
	//-- Gravacao do registro no TRB
	If Len(aRegD161[nPos]) > 0
		//GrvRegTrS(cAlias,nRelac,aRegD161)
		GrvRegTrS(cAlias,GetRelaGrv(nRelac, 5),aRegD161)		
	EndIf
EndIf

//³REGISTRO D162 - IDENTIFICACAO DOS DOCUMENTOS FISCAIS                   ³

//-- Ponto de entrada para substituir o calculo do sistema
If lSpedRTMS
	aRetPE := ExecBlock("SPEDRTMS",.F.,.F.,{nPos,"D162",cAliasSFT,aCmpAntSFT})
	If ValType(aRetPE) == "A" .And. Len(aRetPE) > 0
		aEval(aRetPE,{|x| AAdd(aRegD162, x)})
		nPos := Len(aRegD162)
	EndIf
EndIf

//-- Se nao foi alterado nada via PE, faco o padrao
If Empty(aRegD162)

	If lAchouDTC
		//-- Parametro MV_NGD162 - Identifica os CFOP s, que nao gera registro D162.
		If !Alltrim(aCmpAntSFT[9])$cMvD162
			//³Tabela jah estah filtrada³
			While !(cAliasDTC)->(Eof()) .And. ((cAliasDTC)->(DTC_FILIAL+DTC_FILDOC+DTC_DOC+DTC_SERIE)==cDTCChv)
				//-- Tratamento para evitar duplicidade no registro.
				If (nPos := aScan(aRegD162,{|aX| aX[3]==(cAliasDTC)->DTC_SERNFC .And. aX[4]==(cAliasDTC)->DTC_NUMNFC}))==0
					aAdd (aRegD162, {})
					nPos := Len(aRegD162)
					aAdd (aRegD162[nPos], "D162")							//01 - REG
					aAdd (aRegD162[nPos], "01")								//02 - COD_MOD
					aAdd (aRegD162[nPos], (cAliasDTC)->DTC_SERNFC)			//03 - SER
					aAdd (aRegD162[nPos], (cAliasDTC)->DTC_NUMNFC)			//04 - NUM_DOC
					aAdd (aRegD162[nPos], (cAliasDTC)->DTC_EMINFC)			//05 - DT_DOC
					aAdd (aRegD162[nPos], (cAliasDTC)->DTC_VALOR)			//06 - VL_DOC
					aAdd (aRegD162[nPos], (cAliasDTC)->DTC_VALOR)			//07 - VL_MERC
					aAdd (aRegD162[nPos], (cAliasDTC)->DTC_QTDVOL)			//08 - QTD_VOL
					aAdd (aRegD162[nPos], (cAliasDTC)->DTC_PESO)			//09 - PESO_BRT
					aAdd (aRegD162[nPos], (cAliasDTC)->DTC_PESO)			//10 - PESO_LIQ
				Else
					aRegD162[nPos,06] += (cAliasDTC)->DTC_VALOR				//06 - VL_DOC
					aRegD162[nPos,07] += (cAliasDTC)->DTC_VALOR				//07 - VL_MERC
					aRegD162[nPos,08] += (cAliasDTC)->DTC_QTDVOL			//08 - QTD_VOL
					aRegD162[nPos,09] += (cAliasDTC)->DTC_PESO				//09 - PESO_BRT
					aRegD162[nPos,10] += (cAliasDTC)->DTC_PESO				//10 - PESO_LIQ
				EndIf
				(cAliasDTC)->(DbSkip())
			EndDo
			//-- Suprimir decimais: converte campo Volume (DTC_QTDVOL) para caracter
			AEval(aRegD162,{|x|x[8]:=Alltrim(Str(x[8]))})
		EndIf
	EndIf
EndIf
//-- Gravacao do registro no TRB
If !Empty(aRegD162) .And. Len(aRegD162[nPos]) > 0
	//GrvRegTrS(cAlias,nRelac,aRegD162)
	GrvRegTrS(cAlias,GetRelaGrv(nRelac, 5),aRegD162)		
EndIf

Return
/*
±±³Programa  ³RegD190   ³ Autor ³Gustavo G. Rueda       ³ Data ³11.03.2011³±±
±±³Descri‡…o ³                                                            ³±±
±±³          ³      REGISTRO ANALITICO DO DOCUMENTO (MODELO 07,08,26,27)  ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao do Registro D190                                  ³±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com as informacoes contidas no array   ³±±
±±³          ³ aRegC170(Itens) aglutinados CFOP, CST e ALIQ.              ³±±

±±³Nivel Hier³3(1:N) Para cada Registro D100                              ³±±

±±³Retorno   ³.T.                                                         ³±±

±±³Parametros³aRegC170  -> Informacoes dos Itens do documento fiscal      ³±±
±±³          ³cAliasSFT -> Alias da tabela SFT posicionada no momento     ³±±
±±³          ³aRegD190  -> Array contendo as informacoes aglutinadas do   ³±±
±±³          ³ do documento fiscal para posterior geracao na funcao prin- ³±±
±±³          ³ cipal.                                                     |±±
±±³          |lSpedRTms -> Flag de existencia do PE SPEDRTMS              ³±±
±±³          |aLanCDA   -> Lancamento do documento fiscal                 ³±±
±±³          ³nRedBSICM -> Valor de reducao da base de calculo do ICMS    |±±
±±³          ³aCmpAntSFT-> Informacoes de cabecalho do documento fiscal   ³±±
±±³          ³aReg0460  -> Array com a estrutura do 0460 gerado ateh o    ³±±
±±³          ³            momento.                                        ³±±
±±³          ³cAliasSF4-> Informa qual o alias da tabela SF4, podendo ser ³±±
±±³          ³            query                                           ³±±
±±³          ³aLancFis-> Array com lancamentos de documento nao amarrados³±±
±±³          ³            ao C197                                         ³±±
±±³          ³aReg0460  -> Array com a estrutura do 0460 gerado ateh o    ³±±
±±³          ³            momento.                                        ³±±
*/
Static Function RegD190(aRegC170,cAliasSFT,aRegD190,lSpedRTMS,aLanCDA,nRedBSICM,aCmpAntSFT,aReg0460,cAliasSF4,aLancFis,aReg0460)

Local nPos     := 0
Local aRetPE   := {}
Local cRetPE   := ""
Local cCodObs  := ""
Local lDefault := .T.
Local nPosIt   := 0  

Default aLancFis := {}

If (nPos := aScan(aRegD190,{|aX| aX[2]==aRegC170[1][10] .And. aX[3]==aRegC170[1][11] .And. aX[4]==aRegC170[1][14]}))==0

	aAdd(aRegD190, {})
	nPos := Len(aRegD190)

	//-- Ponto de entrada para substituir o calculo do sistema
	If lSpedRTMS
		aRetPE := ExecBlock("SPEDRTMS",.F.,.F.,{nPos,"D190",cAliasSFT,aCmpAntSFT})
		If ValType(aRetPE) == "A" .And. Len(aRetPE) > 0
			aRegD190 := {}
			aEval( aRetPE, {|x| AAdd(aRegD190, x) } )
			If Len(aRegD190[nPos]) > 0
				lDefault:= .F.
				If aExistBloc[14]
					For nPosIt := 1 To Len(aRegD190)
						//-- Ponto de entrada para gravar lancamentos de observacoes dos documentos
						cCodObs := aRegD190[nPosIt,9] //09 - COD_OBS
						cRetPE  := ExecBlock("SPEDR460",.F.,.F.,{cCodObs})
						If ValType(cRetPE) == "C"
							Reg0460(@aReg0460,{cCodObs,cRetPE})
						EndIf
					Next nPosIt
				EndIf
			EndIf
		EndIf
	EndIf

	//-- Se o PE nao montar o registro, executo o padrao
	If lDefault
		aAdd (aRegD190[nPos], "D190")						//01 - REG
		aAdd (aRegD190[nPos], aRegC170[1][10])				//02 - CST
		aAdd (aRegD190[nPos], aRegC170[1][11])				//03 - CFOP
		aAdd (aRegD190[nPos], aRegC170[1][14])				//04 - ALIQ_ICMS
		aAdd (aRegD190[nPos], 0)							//05 - VL_OPR
		aAdd (aRegD190[nPos], 0)							//06 - VL_BC_ICMS
		aAdd (aRegD190[nPos], 0)							//07 - VL_ICMS
		aAdd (aRegD190[nPos], 0)							//08 - VL_RED_BC
		aAdd (aRegD190[nPos], "")							//09 - COD_OBS
		
		//³Se houver lancamento fiscal nao amarrado ao D197, devo prioriza-lo³
		If Len(aLancFis)>=1
			aRegD190[nPos,9] := aLancFis[1,1]
			
			//³REGISTRO 0460 - TABELA DE OBSERVACOES DO LANCAMENTO FISCAL      ³
	   		IF !( EMPTY(aLancFis[1,2]) .AND. EMPTY(aLancFis[1,3]))
	   			Reg0460(@aReg0460,{aLancFis[1,1],aLancFis[1,2]})
			ENDIF
		//³Quando este array estiver com conteudo, jah terah de todos os itens,³
		//³ neste caso, preciso obter somente o lancamento do referido item    ³
		ElseIf Len(aLanCDA)>0 .And. (nPosIt := aScan(aLanCDA,{|aX|aX[14]==(cAliasSFT)->FT_ITEM}))>0
			aRegD190[nPos,9] := aLanCDA[nPosIt,7]
		EndIf
	EndIf
EndIf

//-- Execucao padrao
If lDefault
	aRegD190[nPos][5]		+=	(cAliasSFT)->FT_VALCONT	 		//05 - VL_OPR
	aRegD190[nPos][6]		+=	aRegC170[1][13]					//06 - VL_BC_ICMS
	aRegD190[nPos][7]		+=	aRegC170[1][15]					//07 - VL_ICMS
	aRegD190[nPos][8]		+=	nRedBSICM						//08 - VL_RED_BC
EndIf

Return
/*
±±³Programa  ³RegD500   ³ Autor ³Gustavo G. Rueda       ³ Data ³10.03.2011³±±

±±³Descri‡…o ³                                                            ³±±
±±³          ³  NOTA FISCAL DE SERVICO DE COMUNICACAO (MODELO 21) E NOTA  ³±±
±±³          ³      FISCAL DE SERVICO DE TELECOMUNICACAO (MODELO 22)      ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao e gravacao do Registro D500                       ³±±

±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com as informacoe contidas no array    ³±±
±±³          ³ aRegC100/aTotaliza/aCmpAntSFT para os Modelos(21 e 22)     ³±±

±±³Nivel Hier³2(varios por arquivo)                                       ³±±

±±³Retorno   ³.T.                                                         ³±±

±±³Parametros³cAlias -> Alias do TRB que recebera as informacoes          ³±±
±±³          ³nRelac -> Flag de relacionamento.                           ³±±
±±³          |aRegC100 -> Informacoes sobre todos documentos fiscais pro- ³±±
±±³          ³ cessados no while da funcao principal.                     ³±±
±±³          |aTotaliza -> Totalizadores de valores para a tabela SFT.    ³±±
±±³          |aCmpAntSFT -> Informacoes sobre o cabecalho dos documentos. ³±±
±±³          ³aRegD500 -> Array contendo as informacoes processadas pela  ³±±
±±³          ³ funcao a ser retornado para utilizacao pela funcao         ³±±
±±³          ³ principal                                                  ³±±
±±³          ³nItem -> Contador do item para cada documento fiscal.       ³±±
±±³          ³lAchouSFX -> Flag de localizacao do registro da NF na tabela³±±
±±³          ³ SFX.                                                       ³±±
±±³          ³aInfCompl -> Informacao complementar da tabela CDT          ³±±
*/
Static Function RegD500(cAlias,nRelac,aRegC100,aTotaliza,aCmpAntSFT,aRegD500,nItem,lAchouSFX,lGravaD500,cSituaDoc,aInfCompl,aWizard)

Local nPos    := 0
Local nVlTerc := 0
Local cTpAss  := ""
Local	cContCtb	:= RetCOD_CTA(,"D500", aCmpAntSFT )
Default cSituaDoc := ""
Default aWizard	:= {}

If lAchouSFX
	nVlTerc  := SFX->FX_VALTERC
	cTpAss   := If(aSPDSX3[FP_FX_TPASSIN], SFX->FX_TPASSIN, "")
EndIf
 		
aAdd(aRegD500, {})
nPos	:=	Len (aRegD500)
aAdd (aRegD500[nPos], "D500")			 	   																		//01 - REG
aAdd (aRegD500[nPos], aRegC100[1][2])			   																	//02 - IND_OPER
aAdd (aRegD500[nPos], aRegC100[1][3])	   																			//03 - IND_EMIT
aAdd (aRegD500[nPos], IIF(cSituaDoc$"02#03#05","",aRegC100[1][4]))													//04 - COD_PART
aAdd (aRegD500[nPos], aRegC100[1][5])			   																	//05 - COD_MOD
aAdd (aRegD500[nPos], aRegC100[1][6])	   																			//06 - COD_SIT
aAdd (aRegD500[nPos], aRegC100[1][7])   		                                                                   	//07 - SER
aAdd (aRegD500[nPos], Iif(Empty(AllTrim(aCmpAntSFT[53])), "", aCmpAntSFT[53]))		                                //08 - SUB
aAdd (aRegD500[nPos], aRegC100[1][8])	   			 																//09 - NUM_DOC
aAdd (aRegD500[nPos], aCmpAntSFT[6])			   																	//10 - DT_DOC
aAdd (aRegD500[nPos], IIF(cSituaDoc$"02#03#05","",aRegC100[1][11]))													//11 - DT_A_P
aAdd (aRegD500[nPos], IIF(cSituaDoc$"02#03#05","",aRegC100[1][12]))													//12 - VL_DOC
aAdd (aRegD500[nPos], IIF(cSituaDoc$"02#03#05","",aRegC100[1][14]))													//13 - VL_DESC
aAdd (aRegD500[nPos], IIF(cSituaDoc$"02#03#05","",aRegC100[1][16]))													//14 - VL_SERV
aAdd (aRegD500[nPos], IIF(cSituaDoc$"02#03#05","",aRegC100[1][15]))													//15 - VL_SERV_NT
aAdd (aRegD500[nPos], IIF(!(aRegC100[1][6]$"02#04#05"),nVlTerc,""))													//16 - VL_TERC
aAdd (aRegD500[nPos], IIF(cSituaDoc$"02#03#05","",aRegC100[1][20]))													//17 - VL_DA
aAdd (aRegD500[nPos], IIF(cSituaDoc$"02#03#05","",aRegC100[1][21]))													//18 - VL_BC_ICMS
aAdd (aRegD500[nPos], IIF(cSituaDoc$"02#03#05","",aRegC100[1][22]))													//19 - VL_ICMS
aAdd (aRegD500[nPos], Iif(Len(aInfCompl)>0,aInfCompl[1],""))														//20 - COD_INF
aAdd (aRegD500[nPos], Iif("1"$aWizard[1][15],IIF(cSituaDoc$"02#03#05",0,aRegC100[1][26]),0))						//21 - VL_PIS
aAdd (aRegD500[nPos], Iif("1"$aWizard[1][15],IIF(cSituaDoc$"02#03#05",0,aRegC100[1][27]),0))						//22 - VL_COFINS
aAdd (aRegD500[nPos], IIF(cSituaDoc$"02#03#05","",Iif(!Empty(cContCtb),cContCtb,aCmpAntSFT[19])))					//23 - COD_CTA
aAdd (aRegD500[nPos], IIF(cSituaDoc$"02#03#05","",If(cVersao >= "003",cTpAss,"")))									//24 - TP_ASSINANTE - LAYOUT 2010
//
If lGravaD500
	GrvRegTrS(cAlias,RetRD(nRelac),aRegD500,nItem)
EndIF

Return
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³RegD510   ³ Autor ³Gustavo G. Rueda       ³ Data ³10.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±³          ³           ITENS DO DOCUMENTO (MODELOS 21 E 22)             ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao e gravacao do Registro D510                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com as informacoes contidas no array   ³±±
±±³          ³ aRegC170/aPartDoc para os Modelos(21 e 22) .               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³3(1:N) Para cada D500                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nil                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cAlias -> Alias do TRB que recebera as informacoes          ³±±
±±³          ³nRelac -> Flag de relacionamento.                           ³±±
±±³          |aRegC170 -> Informacoes sobre os itens dos documentos       ³±±
±±³          ³  fiscais processados no while da funcao principal.         ³±±
±±³          |aRegD510 -> Array contendo a estrutura do registro gravado  ³±±
±±³          | para utilizacao pelo funcao principal.                     ³±±
±±³          ³aPartDoc -> Array com informacoes sobre o participante do   ³±±
±±³          ³ documento fiscal, este array eh montado pela funcao        ³±±
±±³          ³ principal                                                  ³±±
±±³          ³nItem -> Contador do item para cada documento fiscal.       ³±±
±±³          ³lAchouSFX -> Flag de retorno do seek para a tabela SFX      ³±±
±±³          ³cEntSai -> Flag de entrada=1/Saida=2                        ³±±
±±³          ³lGravaD500 -> Flag que determina a gravacao do registro D500³±±
±±³          ³cPerfil    -> Variavel com o perfil de processamento        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function RegD510(cAlias,nRelac,aRegC170,aRegD510,aPartDoc,nItem,lAchouSFX,cEntSai,lGravaD500,cPerfil,lGrava0200,aWizard)
	
	Local	nPos		:=	0
	Local	cCodClass	:=	""
	Local	cIndRec		:=	""
	Default aWizard		:= {}

	If lAchouSFX
		If TamSx3("FX_GRPCLAS")[1] == 2
			cCodClass	:= SFX->FX_GRPCLAS+SFX->FX_CLASSIF
		Else
			cCodClass	:= Iif("A"$SFX->FX_GRPCLAS,"10","0"+SFX->FX_GRPCLAS)+SFX->FX_CLASSIF
		EndIf
		cIndRec		:= SFX->FX_TIPOREC
	EndIf

	aAdd(aRegD510, {})
	nPos	:=	Len (aRegD510)
	aAdd (aRegD510[nPos], "D510")	 	   					//01 - REG
	aAdd (aRegD510[nPos], aRegC170[1][2])	   				//02 - NUM_ITEM
	aAdd (aRegD510[nPos], aRegC170[1][3])	   				//03 - COD_ITEM
	aAdd (aRegD510[nPos], cCodClass)						//04 - COD_CLASS
	aAdd (aRegD510[nPos], aRegC170[1][5][1])  				//05 - QTD
	aAdd (aRegD510[nPos], aRegC170[1][6])	   				//06 - UNID
	aAdd (aRegD510[nPos], aRegC170[1][7])	   				//07 - VL_ITEM
	aAdd (aRegD510[nPos], aRegC170[1][8])	   				//08 - VL_DESC
	aAdd (aRegD510[nPos], aRegC170[1][10])	   				//09 - CST_ICMS
	aAdd (aRegD510[nPos], aRegC170[1][11])	   				//10 - CFOP
	aAdd (aRegD510[nPos], aRegC170[1][13])	   				//11 - VL_BC_ICMS
	aAdd (aRegD510[nPos], aRegC170[1][14])	   				//12 - ALIQ_ICMS
	aAdd (aRegD510[nPos], aRegC170[1][15])	   				//13 - VL_ICMS
	aAdd (aRegD510[nPos], aRegC170[1][16])	   				//14 - VL_BC_ICMS_ST
	aAdd (aRegD510[nPos], aRegC170[1][18])	   				//15 - VL_ICMS_ST
	aAdd (aRegD510[nPos], cIndRec )							//16 - IND_REC
	aAdd (aRegD510[nPos], aPartDoc[1])	   					//17 - COD_PART
	aAdd (aRegD510[nPos], Iif("1"$aWizard[1][15],aRegC170[1][30],0))	//18 - VL_PIS
	aAdd (aRegD510[nPos], Iif("1"$aWizard[1][15],aRegC170[1][36],0))	//19 - VL_COFINS
	aAdd (aRegD510[nPos], aRegC170[1][37])					//20 - COD_CTA

	If lGravaD500 .And. cEntSai=="2"
		GrvRegTrS(cAlias,GetRelaGrv(nRelac, 3),{aRegD510[nPos]},nItem)
		lGrava0200 := .T.
	EndIf
Return
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³RegD530   ³ Autor ³Gustavo G. Rueda       ³ Data ³10.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±³          ³           TERMINAL FATURADO (MODELOS 21 E 22)              ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao e gravacao do Registro D530                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com as informacoes contidas na tabela  ³±±
±±³          ³ SFX posicionada.                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³3(1:1) Para cada D500                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nil                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cAlias -> Alias do TRB que recebera as informacoes          ³±±
±±³          ³nRelac -> Flag de relacionamento.                           ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function RegD530 (cAlias, nRelac)
	
	Local	nPos		:=	0
	Local	aReg		:=	{}

	aAdd(aReg, {})
	nPos	:=	Len (aReg)
	aAdd (aReg[nPos], "D530")	 	   					//01 - REG
	aAdd (aReg[nPos], SFX->FX_TIPSERV)	   				//02 - IND_SERV
	aAdd (aReg[nPos], SFX->FX_DTINI)	   				//03 - DT_INI_SERV
	aAdd (aReg[nPos], SFX->FX_DTFIM)	   	 			//04 - DT_FIN_SERV
	aAdd (aReg[nPos], SFX->FX_PERFIS)	   				//05 - PER_FISCAL
	aAdd (aReg[nPos], SFX->FX_AREATER)	   				//06 - COD_AREA
	aAdd (aReg[nPos], SFX->FX_TERMINA)	   				//07 - TERMINAL

	GrvRegTrS(cAlias,GetRelaGrv(nRelac, 2),aReg)
Return
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³RegD590   ³ Autor ³Gustavo G. Rueda       ³ Data ³10.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±³          ³      REGISTRO ANALITICO DO DOCUMENTO (MODELO 07,08,26,27)  ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao do Registro D590                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com as informacoes contidas no array   ³±±
±±³          ³ aRegC170(Itens) aglutinados CFOP, CST e ALIQ.              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³3(1:N) Para cada Registro D100                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T.                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³aRegC170 -> Informacoes dos Itens do documento fiscal       ³±±
±±³          ³cAliasSFT -> Alias da tabela SFT posicionada no momento     ³±±
±±³          ³aRegD590 -> Array contendo as informacoes aglutinadas do    ³±±
±±³          ³ do documento fiscal para posterior geracao na funcao prin- ³±±
±±³          ³ cipal.                                                     |±±
±±³          ³aLanCDA - array com os lancamentos do documento fiscal      ³±±
±±³          ³nRedBSICM -> Valor de reducao da base de calculo do ICMS    |±±
±±³          ³cAliasSF4-> Informa qual o alias da tabela SF4, podendo ser ³±±
±±³          ³            query                                           ³±±
±±³          ³aLancFis-> Array com lancamentos de documento nao amarrados³±±
±±³          ³            ao C197                                         ³±±
±±³          ³aReg0460  -> Array com a estrutura do 0460 gerado ateh o    ³±±
±±³          ³            momento.                                        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function RegD590(aRegC170,cAliasSFT,aRegD590,aLanCDA,nRedBSICM,cSituaDoc,cAliasSF4,aLancFis,aReg0460)

Local	nPos		:=	0

If (nPos := aScan(aRegD590,{|aX| aX[2]==aRegC170[1][10] .And. aX[3]==aRegC170[1][11] .And. aX[4]==aRegC170[1][14]}) )==0
	aAdd(aRegD590, {})
	nPos	:=	Len (aRegD590)
	aAdd (aRegD590[nPos], "D590")	 	   				//01 - REG
	aAdd (aRegD590[nPos], aRegC170[1][10])				//02 - CST
	aAdd (aRegD590[nPos], aRegC170[1][11])				//03 - CFOP
	aAdd (aRegD590[nPos], aRegC170[1][14])				//04 - ALIQ_ICMS
	aAdd (aRegD590[nPos], 0)		 		 			//05 - VL_OPR
	aAdd (aRegD590[nPos], 0)							//06 - VL_BC_ICMS
	aAdd (aRegD590[nPos], 0)	 		  				//07 - VL_ICMS
	aAdd (aRegD590[nPos], 0)	 						//08 - VL_BC_ICMS_ST
	aAdd (aRegD590[nPos], 0)	 		  				//09 - VL_ICMS_ST
	aAdd (aRegD590[nPos], 0)	 		  				//10 - VL_RED_BC
	aAdd (aRegD590[nPos], "")	 						//11 - COD_OBS
	
	
	//³Se houver lancamento fiscal nao amarrado ao C197, devo prioriza-lo³
	If Len(aLancFis)>=1
		aRegD590[nPos,11] := aLancFis[1,1]
		
		//³REGISTRO 0460 - TABELA DE OBSERVACOES DO LANCAMENTO FISCAL      ³
   		IF(!EMPTY(aLancFis[1,2]) .AND. !EMPTY(aLancFis[1,3]))
	   			Reg0460(@aReg0460,{aLancFis[1,1],aLancFis[1,2]})
		ENDIF

	//³Quando este array estiver com conteudo, jah terah de todos os itens,³
	//³ neste caso, preciso obter somente o lancamento do referido item    ³
	ElseIf Len(aLanCDA)>0 .And. (nPosIt := aScan(aLanCDA,{|aX|aX[14]==(cAliasSFT)->FT_ITEM}))>0
		aRegD590[nPos,11]  :=  aLanCDA[nPosIt,7]
	EndIf
EndIf
aRegD590[nPos][5]	+=	(cAliasSFT)->FT_VALCONT	 					//05 - VL_OPR
aRegD590[nPos][6]	+=	Iif(cSituaDoc$"02#03#04#05",0,aRegC170[1][13])//06 - VL_BC_ICMS
aRegD590[nPos][7]	+=	Iif(cSituaDoc$"02#03#04#05",0,aRegC170[1][15])//07 - VL_ICMS
aRegD590[nPos][8]	+=	Iif(cSituaDoc$"02#03#04#05",0,aRegC170[1][16])//08 - VL_BC_ICMS_ST
aRegD590[nPos][9]	+=	Iif(cSituaDoc$"02#03#04#05",0,aRegC170[1][18])//09 - VL_ICMS_ST
aRegD590[nPos][10]	+=	nRedBSICM									//10 - VL_RED_BC

Return
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  |D600D610  ³ Autor ³Gustavo G. Rueda       ³ Data ³10.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±³          ³D600 - CONSOLIDACAO DE NOTA FISCAL DE SERVICO DE COMUNICACAO³±±
±±³          ³  (MODELO 21) E NOTA FISCAL DE SERVICO DE TELECOMUNICACAO   ³±±
±±³          ³                           (MODELO 22)                      ³±±
±±³          ³                                                            ³±±
±±³          ³   D610 - ITENS CONSOLIDADO DE NOTA FISCAL DE SERVICO DE    ³±±
±±³          ³    COMUNICACAO (MODELO 21) E NOTA FISCAL DE SERVICO DE     ³±±
±±³          ³                TELECOMUNICACAO (MODELO 22)                 ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao do Registro D600 e D610                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com as informacoe contidas no array    ³±±
±±³          ³ aRegD500/aRegD510/aTotaliza/aPartDoc/aCmpAntSFT para os mo-³±±
±±³          ³ delos 21 e 22 que serao gravados no final da funcao        ³±±
±±³          ³ principal                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³D600 - 2(varios por arquivo)                                ³±±
±±³          ³D610 - 3(1:N) Para cada D600                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³nPos                                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros|aRegD500 -> Informacoes ja gravadas no registro D500 para   ³±±
±±³          ³ utilizacao.                                                ³±±
±±³          |aTotaliza -> Totalizadores de valores para a tabela SFT.    ³±±
±±³          ³aPartDoc -> Array com informacoes sobre o participante do   ³±±
±±³          ³ documento fiscal, este array eh montado pela funcao princi-³±±
±±³          ³ pal.                                                       ³±±
±±³          |aCmpAntSFT -> Informacoes sobre o cabecalho dos documentos. ³±±
±±³          ³aRegD600 -> Array contendo as informacoes processadas pela  ³±±
±±³          ³ funcao a ser retornado para gravacao pela funcao principal.³±±
±±³          ³aRegD510 -> Informacoes ja gravadas no registro D510 para   ³±±
±±³          ³ utilizacao.                                                ³±±
±±³          ³aRegD610 -> Array contendo as informacoes processadas pela  ³±±
±±³          ³ funcao a ser retornado para gravacao pela funcao principal.³±±
±±³          ³lAchouSFX -> Flag de posicionamento da tabela SFX           ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function D600D610(aRegD500,aPartDoc,aCmpAntSFT,aRegD600,aRegD510,aRegD610,lAchouSFX,aWizard)
	Local	nPos		:=	0
	Local	nPos2		:=	0
	Local	nI			:=	0
	Local	cCodCons	:=	""
	Default aWizard		:= {}

	If lAchouSFX
		cCodCons := SFX->FX_CLASCON
	EndIf
	//³REGISTRO D600 - CONSOLIDACAO DE NOTA FISCAL DE SERVICO DE COMUNICACAO (MODELO 21) E NOTA FISCAL DE SERVICO DE TELECOMUNICACAO (MODELO 22)³
	If Empty(aCmpAntSFT[7])	//NOTA FISCAL CANCELADA.
		If (nPos := aScan(aRegD600,{|aX| aX[2]==aRegD500[1][5] .And. aX[3]==aPartDoc[7] .And. aX[4]==aRegD500[1][7] .And. aX[6]==cCodCons .And. aX[8]==aRegD500[1][10]}))==0
			aAdd(aRegD600, {})
			nPos	:=	Len (aRegD600)
			aAdd (aRegD600[nPos], "D600")	 	 	  					//01 - REG
			aAdd (aRegD600[nPos], aRegD500[1][5]) 	   					//02 - COD_MOD
			aAdd (aRegD600[nPos], aPartDoc[7]) 		   					//03 - COD_MUN
			aAdd (aRegD600[nPos], aRegD500[1][7]) 	   					//04 - SER
			aAdd (aRegD600[nPos], aRegD500[1][8])     		//05 - SUB
			aAdd (aRegD600[nPos], cCodCons)				 	   			//06 - COD_CONS
			aAdd (aRegD600[nPos], "1")	 	   							//07 - QTD_CONS
			aAdd (aRegD600[nPos], aRegD500[1][10])						//08 - DT_DOC
			aAdd (aRegD600[nPos], aRegD500[1][12])						//09 - VL_DOC
			aAdd (aRegD600[nPos], aRegD500[1][13])	  					//10 - VL_DESC
			aAdd (aRegD600[nPos], aRegD500[1][14])						//11 - VL_SERV
			aAdd (aRegD600[nPos], aRegD500[1][15])						//12 - VL_SERV_N
			aAdd (aRegD600[nPos], aRegD500[1][16])						//13 - VL_TERC
			aAdd (aRegD600[nPos], aRegD500[1][17])						//14 - VL_DA
			aAdd (aRegD600[nPos], aRegD500[1][18])						//15 - VL_BC_ICMS
			aAdd (aRegD600[nPos], aRegD500[1][19])						//16 - VL_ICMS
			aAdd (aRegD600[nPos], Iif("1"$aWizard[1][15],aRegD500[1][21],0))	//17 - VL_PIS
			aAdd (aRegD600[nPos], Iif("1"$aWizard[1][15],aRegD500[1][22],0))	//18 - VL_COFINS
		Else
			aRegD600[nPos][7]	:=	Alltrim(STR(Val(aRegD600[nPos][7])+1))	//07 - QTD_CONS
			aRegD600[nPos][9]	+=	aRegD500[1][12]						//09 - VL_DOC
			aRegD600[nPos][10]	+=	aRegD500[1][13]						//10 - VL_DESC
			aRegD600[nPos][11]	+=	aRegD500[1][14]						//11 - VL_SERV
			aRegD600[nPos][12]	+=	aRegD500[1][15]						//12 - VL_SERV_N
			aRegD600[nPos][13]	+=	aRegD500[1][16]						//13 - VL_TERC
			aRegD600[nPos][14]	+=	aRegD500[1][17]						//14 - VL_DA
			aRegD600[nPos][15]	+=	aRegD500[1][18]						//15 - VL_BC_ICMS
			aRegD600[nPos][16]	+=	aRegD500[1][19]						//16 - VL_ICMS
			aRegD600[nPos][17]	+=	IIf("1"$aWizard[1][15],aRegD500[1][21],0)	//17 - VL_PIS
			aRegD600[nPos][18]	+=	IIf("1"$aWizard[1][15],aRegD500[1][22],0)	//18 - VL_COFINS
		EndIf

		//³REGISTRO D610 - ITENS CONSOLIDADO DE NOTA FISCAL DE SERVICO DE COMUNICACAO (MODELO 21) E NOTA FISCAL DE SERVICO DE TELECOMUNICACAO (MODELO 22)³
		For nI := 1 To Len (aRegD510)
			If (nPos2 := aScan(aRegD610,{|aX| aX[1]==nPos .And. aX[3]==aRegD510[nI][4] .And. aX[4]==aRegD510[nI][3] .And. aX[11]==aRegD510[nI][12] .And. aX[10]==aRegD510[nI][10]}))==0
				aAdd(aRegD610, {})
				nPos2	:=	Len (aRegD610)
				aAdd (aRegD610[nPos2], nPos)	 	 	  				//00 - RELACIONAMENTO COM O REGISTRO D600
				aAdd (aRegD610[nPos2], "D610")	 	 	  				//01 - REG
				aAdd (aRegD610[nPos2], aRegD510[nI][4])	  			//02 - COD_CLASS
				aAdd (aRegD610[nPos2], aRegD510[nI][3])	  			//03 - COD_ITEM
				aAdd (aRegD610[nPos2], aRegD510[nI][5])				//04 - QTD
				aAdd (aRegD610[nPos2], aRegD510[nI][6])	  			//05 - UNID
				aAdd (aRegD610[nPos2], aRegD510[nI][7])	 	  		//06 - VL_ITEM
				aAdd (aRegD610[nPos2], aRegD510[nI][8])	 	  		//07 - VL_DESC
				aAdd (aRegD610[nPos2], aRegD510[nI][9]) 	  			//08 - CST_ICMS
				aAdd (aRegD610[nPos2], aRegD510[nI][10]) 	  			//09 - CFOP
				aAdd (aRegD610[nPos2], aRegD510[nI][12]) 	  			//10 - ALIQ_ICMS
				aAdd (aRegD610[nPos2], aRegD510[nI][11])	 			//11 - VL_BC_ICMS
				aAdd (aRegD610[nPos2], aRegD510[nI][13])			 	//12 - VL_ICMS
				aAdd (aRegD610[nPos2], aRegD510[nI][14])	 			//13 - VL_BC_ICMS_ST
				aAdd (aRegD610[nPos2], aRegD510[nI][15])			 	//14 - VL_ICMS_ST
				aAdd (aRegD610[nPos2], 0)	 			  				//15 - VL_RED_BC_ICMS
				aAdd (aRegD610[nPos2], Iif("1"$aWizard[1][15],aRegD510[nI][18],0))	 			//16 - VL_PIS
				aAdd (aRegD610[nPos2], Iif("1"$aWizard[1][15],aRegD510[nI][19],0))			 	//17 - VL_COFINS
				aAdd (aRegD610[nPos2], aRegD510[nI][20])	  			//18 - COD_CTA
			Else				 			
				aRegD610[nPos2][05] += aRegD510[nI][05]	 			//04 - QTD
				aRegD610[nPos2][07] += aRegD510[nI][07]	 			//06 - VL_ITEM
				aRegD610[nPos2][08] += aRegD510[nI][08]	 			//07 - VL_DESC
				aRegD610[nPos2][12] += aRegD510[nI][11]	 			//11 - VL_BC_ICMS
				aRegD610[nPos2][13] += aRegD510[nI][13]			 	//12 - VL_ICMS
				aRegD610[nPos2][14] += aRegD510[nI][14]	 			//13 - VL_BC_ICMS_ST
				aRegD610[nPos2][15] += aRegD510[nI][15]			 	//14 - VL_ICMS_ST
				aRegD610[nPos2][17] += Iif("1"$aWizard[1][15],aRegD510[nI][18],0)	//16 - VL_PIS
				aRegD610[nPos2][18] += Iif("1"$aWizard[1][15],aRegD510[nI][19],0)	//17 - VL_COFINS
			EndIf		
		Next nI
	EndIf
Return nPos
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³RegD690   ³ Autor ³Gustavo G. Rueda       ³ Data ³10.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±³          ³      REGISTRO ANALITICO DO DOCUMENTO (MODELO 07,08,26,27)  ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao do Registro D690                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com as informacoes contidas no array   ³±±
±±³          ³ aRegD590(Itens) aglutinados CFOP, CST e ALIQ.              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³3(1:N) Para cada Registro D100                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nil                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³aRegD590 -> Array base para geracao deste registro          ³±±
±±³          ³cAlias -> Alias do arquivo de trabalho para gravacao das    |±±
±±³          ³ informacoes do registro                                    |±±
±±³          ³aRegD690  -> Array para gravacao dos valores do registro    |±±
±±³			 ³ "D690".													  |±±
±±³          ³nPosD600  -> Posicao do registro pai "D600"                 |±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function RegD690(aRegD590,cAlias,aRegD690,nPosD600)
Local	nPos		:=	0
Local	nI			:=	0

For nI := 1 To Len(aRegD590)
	If (nPos := aScan(aRegD690,{|aX| aX[1]==nPosD600 .And. aX[3]==aRegD590[nI][02] .And. aX[4]==aRegD590[nI][03] .And. aX[5]==aRegD590[nI][04]}))==0
		aAdd(aRegD690, {})
		nPos	:=	Len (aRegD690)  
		aAdd (aRegD690[nPos], nPosD600)	 	   				//01 - RELACIONAMENTO
		aAdd (aRegD690[nPos], "D690")	 	   				//02 - REG
		aAdd (aRegD690[nPos], aRegD590[nI][02])				//03 - CST
		aAdd (aRegD690[nPos], aRegD590[nI][03])				//04 - CFOP
		aAdd (aRegD690[nPos], aRegD590[nI][04])				//05 - ALIQ_ICMS
		aAdd (aRegD690[nPos], 0)		 		 			//06 - VL_OPR
		aAdd (aRegD690[nPos], 0)							//07 - VL_BC_ICMS
		aAdd (aRegD690[nPos], 0)	 		  				//08 - VL_ICMS
		aAdd (aRegD690[nPos], 0)	 						//09 - VL_BC_ICMS_ST
		aAdd (aRegD690[nPos], 0)	 		  				//10 - VL_ICMS_ST
		aAdd (aRegD690[nPos], 0)	 		  				//11 - VL_RED_BC
		aAdd (aRegD690[nPos], aRegD590[nI][11])				//12 - COD_OBS
	EndIf
	
	        
	aRegD690[nPos][6]	+=	aRegD590[nI][05]	 	  		//06 - VL_OPR
	aRegD690[nPos][7]	+=	aRegD590[nI][06]				//07 - VL_BC_ICMS
	aRegD690[nPos][8]	+=	aRegD590[nI][07]				//08 - VL_ICMS
	aRegD690[nPos][9]	+=	aRegD590[nI][08]				//09 - VL_BC_ICMS_ST
	aRegD690[nPos][10]	+=	aRegD590[nI][09]				//10 - VL_ICMS_ST
	aRegD690[nPos][11]	+=	aRegD590[nI][10]				//11 - VL_RED_BC
Next nI


Return
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  |D695D696  ³ Autor ³Gustavo G. Rueda       ³ Data ³10.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³D696 - REGISTRO ANALITICO DO DOCUMENTO (MODELOS 21 e 22 )   ³±±
±±³          ³D695 - CONSOLIDACAO DOS DOCUMENTOS NFSC ou NFST EMITIDA     ³±±
±±³          ³       EM VIA UNICA (CPN. ICMS 115/03)                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com as informacoe contidas na tabela   ³±±
±±³          ³ SFT.                                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³D696 - 3(1:N) Para cada D695                                ³±±
±±³           D697 - 4(1:N) Para cada D696                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nil                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros|aRegD696 -> Array com as informacoes acumuladas             ³±±
±±³          ³aRegD695 -> Array com as informacoes acumuladas             ³±±
±±³          ³lAchouSFX-> Flag de posicionamento da tabela SFX            ³±±
±±³          ³aRegD590 -> Array base para geracao do registro D696        ³±±
±±³          ³aRegC100 -> Array base para geracao do registro D695        ³±±
±±³          ³aCmpAntSFT-> Campos salvos da tabela SFT antes do skip      ³±±
±±³          ³aRegD697 -> Array com as informacoes do registro D697       ³±±
±±³          ³cSituaDoc -> Situacao do documento fiscal                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function D695D696(aRegD696,aRegD695,lAchouSFX,aRegD590,aRegC100,aCmpAntSFT,aRegD697,cSituaDoc)
Local	nPos	:=	0
Local	nPos1	:=	0
Local   nPos2   :=  0
Local	cChv115	:=	""
Local	cVol115	:=	""
Local	nI		:=	0
	
If !cSituaDoc$"02#03"		
	If lAchouSFX
		cChv115	:=	SFX->FX_CHV115
		cVol115	:=	SFX->FX_VOL115	
	EndIf
	//³REGISTRO C700 - CONSOLIDACAO                                           ³
	If (nPos1 := aScan(aRegD695,{|aX| aX[3]==aRegC100[1][7] .And. aX[9]==cChv115}))==0
		aAdd (aRegD695, {})
		nPos1	:=	Len (aRegD695)
		aAdd (aRegD695[nPos1], "D695")						//01 - REG
		aAdd (aRegD695[nPos1], aRegC100[1][5])				//02 - COD_MOD
		aAdd (aRegD695[nPos1], aRegC100[1][7])	   			//03 - SER
		aAdd (aRegD695[nPos1], aRegC100[1][8])	   	 		//04 - NRO_INI
		aAdd (aRegD695[nPos1], aRegC100[1][8])				//05 - NRO_FIN
		aAdd (aRegD695[nPos1], aCmpAntSFT[6])	   	 		//06 - DT_DOC_INI
		aAdd (aRegD695[nPos1], aCmpAntSFT[6])	   	 		//07 - DT_DOC_FIM
		aAdd (aRegD695[nPos1], cVol115) 					//08 - NOM_MEST
		aAdd (aRegD695[nPos1], cChv115)						//09 - CHV_COD_DIG
	EndIf
	aRegD695[nPos1][5]	:=	aRegC100[1][8]					//05 - NRO_FIN
	aRegD695[nPos1][7]	:=	aCmpAntSFT[6]		   			//07 - DT_DOC_FIM
	
	//³REGISTRO D696 - REGISTRO ANALITICO DOS DOCUMENTOS                      ³
	For nI := 1 To Len(aRegD590)
		If (nPos := aScan(aRegD696,{|aX| aX[1]==nPos1 .And. aX[3]==aRegD590[nI][02] .And. aX[4]==aRegD590[nI][03] .And. aX[5]==aRegD590[nI][04]}))==0
			aAdd(aRegD696, {})
			nPos	:=	Len (aRegD696)
			aAdd (aRegD696[nPos], nPos1)	 	   				//01 - Relacionamento
			aAdd (aRegD696[nPos], "D696")	 	   				//02 - REG
			aAdd (aRegD696[nPos], aRegD590[nI][02])			//03 - CST
			aAdd (aRegD696[nPos], aRegD590[nI][03])			//04 - CFOP
			aAdd (aRegD696[nPos], aRegD590[nI][04])			//05 - ALIQ_ICMS
			aAdd (aRegD696[nPos], 0)		 		 			//06 - VL_OPR
			aAdd (aRegD696[nPos], 0)							//07 - VL_BC_ICMS
			aAdd (aRegD696[nPos], 0)	 		  				//08 - VL_ICMS
			aAdd (aRegD696[nPos], 0)	 						//09 - VL_BC_ICMS_ST
			aAdd (aRegD696[nPos], 0)	 		  				//10 - VL_ICMS_ST
			aAdd (aRegD696[nPos], 0)	 		  				//11 - VL_RED_BC
			aAdd (aRegD696[nPos], aRegD590[nI][11])			//12 - COD_OBS
		EndIf
		//
		aRegD696[nPos][6]	+=	aRegD590[nI][05]	 	  		//06 - VL_OPR
		aRegD696[nPos][7]	+=	aRegD590[nI][06]				//07 - VL_BC_ICMS
		aRegD696[nPos][8]	+=	aRegD590[nI][07]				//08 - VL_ICMS
		aRegD696[nPos][9]	+=	aRegD590[nI][08]				//09 - VL_BC_ICMS_ST
		aRegD696[nPos][10]	+=	aRegD590[nI][09]				//10 - VL_ICMS_ST
		aRegD696[nPos][11]	+=	aRegD590[nI][10]				//11 - VL_RED_BC
		
	    //³REGISTRO D697 - REGISTRO SERVICOS NAO MEDIDOS DE TELEVISAO POR ASSINATURA POR UF ³
	    If lAchouSFX
		    If (SFX->FX_GRPCLAS=="A" .And. SFX->FX_CLASSIF=="03") .Or. SFX->FX_GRPCLAS=="10" .And. SFX->FX_CLASSIF=="03"	
	           	If (nPos2 := aScan(aRegD697,{|aX| aX[3]==aCmpAntSFT[23]}))==0			
	  		        aAdd (aRegD697, {})
				    nPos2	:=	Len (aRegD697)
				    aAdd (aRegD697[nPos2], nPos)	 	   				//01 - Relacionamento
				    aAdd (aRegD697[nPos2], "D697")						//02 - REG
				    aAdd (aRegD697[nPos2], aCmpAntSFT[23])				//03 - UF
	  				aAdd (aRegD697[nPos2], 0)   	   			        //04 - VL_BC_ICMS
				    aAdd (aRegD697[nPos2], 0)	   	 		            //05 - VL_ICMS		    
			    EndIf
				aRegD697[nPos2][04]	+=	aRegD696[nPos][7]			    //04 - VL_BC_ICMS
				aRegD697[nPos2][05]	+=	aRegD696[nPos][8]			    //05 - VL_ICMS
		    EndIf
		EndIf
	Next nI         
EndIf
Return
/*±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³BlocoE    | Autor ³Gustavo G. Rueda 			   ³ Data ³22.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡ao ³                        GERACAO DO BLOCO E                         ³±± 
±±³          ³REGISTRO E100 - PERIODO DA APURACAO DO ICMS                        ³±± 
±±³          ³REGISTRO E110 - APURACAO DE ICMS - OPERACOES PROPRIAS              ³±± 
±±³          ³REGISTRO E111 - AJUSTES/BENEFICIOS/INCENTIVO DA APURACAO DE ICMS   ³±± 
±±³          ³REGISTRO E112 - INFORMACOES ADICIONAIS DOS AJUSTES DE APURACAO DO  ³±± 
±±³          ³                ICMS                                               ³±± 
±±³          ³REGISTRO E115- INF. ADICIONAIS DA APURACAO DO ICMS                 ³±± 
±±³          ³REGISTRO E116 - OBRIGACOES DO ICMS A RECOLHER - OPERACOES PROPRIAS ³±± 
±±³          ³REGISTRO E200 - PERIODO DA APURACAO DO ICMS ST                     ³±± 
±±³          ³REGISTRO E210 - APURACAO DO ICMS - SUBSTITUICAO TRIBUTARIA         ³±±  
±±³          ³REGISTRO E220 - AJUSTES/BENEFICIOS/INCENTIVOS DA APURACAO DO ICMS  ³±± 
±±³          ³                SUBSTITUICAO TRIBUTARIA                            ³±±  
±±³          ³REGISTRO E230 - INFORMACOES ADICIONAIS DOS AJUSTES DE APURACAO DO  ³±± 
±±³          ³                ICMS SUBSTITUICAO TRIBUTARIA                       ³±±  
±±³          ³REGISTRO E250 - OBRIGACOES DO ICMS A RECOLHER - SUBSTITUICAO       ³±± 
±±³          ³                TRIBUTARIA                                         ³±± 
±±³          ³REGISTRO E500 - PERIODO DA APURACAO DO IPI                         ³±± 
±±³          ³REGISTRO E510 - CONSOLIDACAO DOS VALROES DE IPI POR CFOP E CODIGO  ³±±
±±³          ³                DE TRIBUTACAO DO IPI                               ³±±
±±³          ³REGISTRO E520 - APURACAO DO IPI                                    ³±±
±±³          ³REGISTRO E530 - AJUSTES DA APURACAO DO IPI                         ³±±
±±³          ³                                                                   ³±±
±±³          ³Funcao utilizada para montar a estrutura dos registros acima e     ³±±
±±³          ³  gravar no TRB para geracao do TXT                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³lTabComp - Flag de existencia das tabelas complementares           ³±±
±±³          ³aWizard  - Informacoes do assistente da rotina                     ³±±
±±³          ³cFilDe   - Filial inicial para processament multifilial            ³±±
±±³          ³cFilAte  - Filial final para processament multifilial              ³±±
±±³          ³cAlias   - Alias do TRB                                            ³±±
±±³          ³cMVEstado- Conteudo do parametro MV_ESTADO                         ³±±
±±³          ³lTop     - Flag para identificar ambiente TOP                      ³±±
±±³          ³cMVSUBTRIB-Conteudo do parametro MV_SUBTRIB                        ³±±
±±³          |oProcess -> Objeto da nova barra de progressao                     ³±±
±±³          |aVlrMovST- Valores de apuracao obtidos durante o processamento     ³±±
±±³          |aIcmPago - Informacoes das GNREs de documentos fiscais para o E250 ³±±
±±³			 |aLanCDA - Array com informacoes da tabela CDA.					 ³±±
±±³			 |aLanCDA2 - Array com informacoes da tabela CDA (Totalizador).		 ³±±
±±³			 |cMVSTNIEUF - Conteudo do parametro MV_STNIEUF, auxilia do MV_SUBTRIB³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGAFIS - SPEDFISCAL                                              ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±*/
Function BlocoE(lTabComp  , aWizard   , cFilDe    , cFilAte   , cAlias    , cMVEstado  , lTop    ,cMVSUBTRIB, aRegE510,;
				oProcess  , aVlrMovST , aIcmPago  , aLanCDA   , aLanCDA2  , cMVSTNIEUF , lOldLan , aReg0200,;
				aReg0190  , aReg0220  , aInfRgE313, lDifal    , aMovSemIe , lExtratTAF , aRegT020, aRegT020AA,;
				aRegT020AB, aRegT020AC, aRegT020AD, aRegT020AE, aRegT020AG, aRegT021Val, aRegT021Est,;
				aRegT021AA, aRegT021AB, aRegT021AC, aRegT021AD, aRegT022  , aRegT022AA , aRegT051, aRegT051ax,;
				aRegT051AA, aRegT051AB, aRegT051AC, aRegT051AD, lJob, aInfE531,lE300Ori,aStruCDA)

Local	dDataDe		:=	''
Local	dDataAte	:=	''
Local	aRegE110	:=	{"E110",0,0,0,0,0,0,0,0,0,0,0,0,0,0}
Local	lImpCrdST	:= 	.F.
Local	nApurIpi	:=	0
Local	nApuracao	:=	3
Local	nPeriodo	:=	1
Local	cNrLivro	:=	''
Local	cArqAnt	:=	''
Local	lSeekCDH	:=	.F.
Local	aRegE200	:=	{}
Local	aRegE210	:=	{}
Local	aRegE250	:=	{}
Local	aApICM		:=	{}
Local	cICMGNR	:=	""
Local	aRegE116 	:= 	{}
Local	aApICMST	:=	{}
Local	cICMSTGNR	:=	""
Local	nUf			:=	0
Local	cMvSFUfGnr	:=	aSPDSX6[MV_SFUFGNR]
Local	cCodRec		:=	""

Default aInfRgE313	:= {}
Default aMovSemIe	:= {}
Default aInfE531	:= {}
Default lExtratTAF   := .F.
Default lE300Ori	:= .F.

Default aRegT020    :=  {}	 
Default aRegT020AA  :=  {}  
Default aRegT020AB  :=  {}  
Default aRegT020AC  :=  {}  
Default aRegT020AE  :=  {}  
Default aRegT020AG  :=  {}  
Default aRegT020AD  :=  {}

Default aRegT021Val := {}
Default aRegT021Est := {}
Default aRegT021AA  := {}
Default aRegT021AB  := {}
Default aRegT021AC  := {}
Default aRegT021AD  := {}
Default aRegT022    := {}
Default aRegT022AA  := {}   

Default aRegT051 		:= {}
Default aRegT051ax	:= {}
Default aRegT051AA	:= {}
Default aRegT051AB	:= {}
Default aRegT051AC	:= {}
Default aRegT051AD	:= {}

if !lExtratTAF
	dDataDe	  := SToD(aWizard[1][1])
	dDataAte  := STod(aWizard[1][2])
	nApurIpi  := Iif(!Empty(aWizard[1][13]),Val(aWizard[1][13]),0)
	lImpCrdST := Iif("1"$aWizard[1][11],.T.,.F.)
	cNrLivro  := aWizard[1][3]
	cArqAnt   := aWizard[1][10]
else
	dDataDe  :=	aWizard[1][3]
	dDataAte :=	aWizard[1][4]	
	nApurIpi := Iif(!Empty(aWizard[1][6]),Val(aWizard[1][6]),0)
	cNrLivro :=	'*'
endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³REGISTRO E100 - PERIODO DA APURACAO DO ICMS                                  ³
//³REGISTRO E110 - APURACAO DE ICMS - OPERACOES PROPRIAS                        ³
//³REGISTRO E111 - AJUSTES/BENEFICIOS/INCENTIVO DA APURACAO DE ICMS             ³
//³REGISTRO E112 - INFORMACOES ADICIONAIS DOS AJUSTES DE APURACAO DO            ³
//³                ICMS 														³
//³REGISTRO E113 - INFORMACOES ADICIONAIS DOS AJUSTES DA APURACAO DO			³
//³ 			   ICMS E IDENTIFICACAOO DOS DOCUMENTOS FISCAIS.				³
//³REGISTRO E115- INF. ADICIONAIS DA APURACAO DO ICMS                           ³
//³REGISTRO E116 - OBRIGACOES DO ICMS A RECOLHER - OPERACOES PROPRIAS           ³
//³                                                                             ³
//³- Funcao independente, geracao e gravacao das informacoes dos registros acima³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lTabComp	//Flag de existencia das tabelas complementares do SPED

	lSeekCDH	:=	SPDAPICMS(cFilDe,cFilAte,nApuracao,nPeriodo,cNrLivro,"IC",cAlias,dDataDe,dDataAte,;
								cMVEstado,lTop,lImpCrdST,cArqAnt,,,,cMVSUBTRIB,aLanCDA,;
								@aLanCDA2,cMVSTNIEUF, , lExtratTAF,@aRegT020,@aRegT020AA,@aRegT020AB,@aRegT020AC,;
								@aRegT020AE,@aRegT021Val,@aRegT021Est,@aRegT021AA,@aRegT021AB,@aRegT021AC,@aRegT021AD,, @aReg0200,;
								@aReg0190, @aReg0220,cMvSFUfGnr, @aRegT020AG,aWizard, @aRegT020AD,@aStruCDA )
																											      									
EndIf

If !lSeekCDH
	//³GRAVACAO DO REGISTRO E100 - PERIODO DA APURACAO DO ICMS                                 ³
	If !lExtratTAF //Para ir ao TAF tem que possuir tabela CDH 
		RegE100(cAlias,dDataDe,dDataAte)	
    
		//³Leio o arquivo de apuracao ICMS ³
		aApICM			:=	FisApur("IC",Year(dDataAte),Month(dDataAte),nApuracao,nPeriodo,cNrLivro,.F.,{},1,.F.,"")
		
		aRegE110[2]		:=	Iif (aScan(aApICM, {|a| a[1]=="001"}   )<>0, aApICM[aScan(aApICM, {|a| a[1]=="001"   })][3],0)
		aRegE110[3]		:=	0
		aRegE110[4]		:=	Iif (aScan(aApICM, {|a| a[4]=="002.00"})<>0, aApICM[aScan(aApICM, {|a| a[4]=="002.00"})][3],0)
		aRegE110[5]		:=	Iif (aScan(aApICM, {|a| a[4]=="003.00"})<>0, aApICM[aScan(aApICM, {|a| a[4]=="003.00"})][3],0)
		aRegE110[6]		:=	Iif (aScan(aApICM, {|a| a[1]=="005"   })<>0, aApICM[aScan(aApICM, {|a| a[1]=="005"   })][3],0)
		aRegE110[7]		:=	0
		aRegE110[8]		:=	Iif (aScan(aApICM, {|a| a[4]=="006.00"})<>0, aApICM[aScan(aApICM, {|a| a[4]=="006.00"})][3],0)
		aRegE110[9]		:=	Iif (aScan(aApICM, {|a| a[4]=="007.00"})<>0, aApICM[aScan(aApICM, {|a| a[4]=="007.00"})][3],0)
		aRegE110[10]	:=	Iif (aScan(aApICM, {|a| a[1]=="009"   })<>0, aApICM[aScan(aApICM, {|a| a[1]=="009"   })][3],0)
		aRegE110[11]	:=	Iif (aScan(aApICM, {|a| a[1]=="011"   })<>0, aApICM[aScan(aApICM, {|a| a[1]=="011"   })][3],0)
		aRegE110[12]	:=	Iif (aScan(aApICM, {|a| a[4]=="012.00"})<>0, aApICM[aScan(aApICM, {|a| a[4]=="012.00"})][3],0)
		aRegE110[13]	:=	Iif (aScan(aApICM, {|a| a[1]=="013"   })<>0, aApICM[aScan(aApICM, {|a| a[1]=="013"   })][3],0)
		aRegE110[14]	:=	Iif (aScan(aApICM, {|a| a[1]=="014"   })<>0, aApICM[aScan(aApICM, {|a| a[1]=="014"   })][3],0)
		aRegE110[15]	:=	Iif (aScan(aApICM, {|a| a[4]=="900.00"})<>0, aApICM[aScan(aApICM, {|a| a[4]=="900.00"})][3],0)
	
		//³USASPED = .F.                                                                                                        ³
		//³Obtencao da GNRE do .IC0 para gerar o registro E116. A GNRE somente sera considerada se o valor da mesma             ³
		//³  for igual ao "Imposto a recolher", pois eh a unica amarracao que se consegue fazer, caso contrario, o contribuinte ³
		//³  deverá informar manualmente no SPED Fiscal as informacoes do registro E116 e/ou E250.                              ³
		//³                                                                                                                     ³
		//³USASPED = .T.                                                                                                        ³
		//³Funciona normalmente.                                                                                                ³
		//³                                                                                                                     ³
		If aRegE110[13]>0
			cICMGNR  := Iif(aScan(aApICM,{|a| a[1]=="GNR" .And. Val(a[4])==aRegE110[13]})<>0, aApICM[aScan(aApICM, {|a| a[1]=="GNR" .And. Val(a[4])==aRegE110[13]})][2],"")
			cICMGNR	 :=	SubStr(cICMGNR,1,At("/",cICMGNR)-3)
			
			//  Verifico se a UF de Recolhimento do ICMS Proprio deve apresentar o campo 05 - COD_REC
			//  considerando o Codigo da Receita + Classe de Vencimento ( F6_CODREC + F6_CLAVENC )
			cCodRec	:=	Iif( cMvEstado $ cMvSFUfGnr , "SF6->( Alltrim( F6_CODREC ) + Alltrim( F6_CLAVENC ) )" , "SF6->F6_CODREC" )
			
			//³Posicionamento da tabela SF6, conforme dados do .IC0    ³
			If !Empty(cICMGNR) .And. SPEDSeek("SF6",1,aSPDFil[PFIL_SF6]+cMVESTADO+cICMGNR)
				aAdd(aRegE116, {})
				nPos	:=	Len (aRegE116)
				aAdd(aRegE116[nPos], 1)	
				aAdd(aRegE116[nPos], "E116")									//01 - REG
				aAdd(aRegE116[nPos], Iif(aSPDSX3[FP_F6_COBREC] .And. !Empty(SF6->F6_COBREC),SF6->F6_COBREC,"000"))	//02 - COD_OR
				aAdd(aRegE116[nPos], SF6->F6_VALOR)  							//03 - VL_OR
				aAdd(aRegE116[nPos], SF6->F6_DTVENC)  							//04 - DT_VCTO
				aAdd(aRegE116[nPos], &( cCodRec ))								//05 - COD_REC		
				aAdd(aRegE116[nPos], "")											//06 - NUM_PROC
				aAdd(aRegE116[nPos], "")											//07 - IND_PROC
				aAdd(aRegE116[nPos], "")											//08 - PROC
				aAdd(aRegE116[nPos], SF6->F6_OBSERV)							//09 - TXT_COMPL 
				
				If cVersao >= "004" 
					aAdd(aRegE116[nPos],SF6->(StrZero(F6_MESREF,2)+cValToChar(F6_ANOREF)))//10 - MES_REF
				EndIf
			EndIf
		EndIf
	
		//³GRAVACAO DO REGISTRO E110 - APURACAO DE ICMS - OPERACOES PROPRIAS                       ³			

		//GrvRegTrS(cAlias,,{aRegE110})
	
		//³GRAVACAO DO REGISTRO E116 - OBRIGACOES DO ICMS A RECOLHER - OPERACOES PROPRIAS          ³	
		//GrvRegTrS(cAlias,,aRegE116)

		SPEDRegs(cAlias,{{aRegE110}, aRegE116})
	 
		//³GRAVACAO DO REGISTRO E200 - PERIODO DA APURACAO DO ICMS/ST                              ³
		
		//³Funcao responsabel pela geracao das informacoes do registro E200 e E210³
		PrcE200E210(@aRegE200,@aRegE210,cMVSUBTRIB,cAlias,aVlrMovST,dDataDe,dDataAte,cMVSTNIEUF,cMVEstado,lExtratTAF)
	    
		//³Apos o fim do processamento das informacoes da apuracao, eh necessario³
		//³ complementa-los com algumas que faltaram                             ³
		SpedApE200(aRegE200,@aRegE210,@aRegE250,aVlrMovST,nApuracao,nPeriodo,cNrLivro,cArqAnt,cMVEstado,aIcmPago,cMVSUBTRIB,lExtratTAF)
	
		//³Leio o arquivo de apuracao ICMS/ST³
		aApICMST		:=	FisApur("ST",Year(dDataAte),Month(dDataAte),nApuracao,nPeriodo,cNrLivro,.F.,{},1,.F.,"")
		
		//³USASPED = .F.                                                                                                        ³
		//³Obtencao da GNRE do .IC0 para gerar o registro E116. A GNRE somente sera considerada se o valor da mesma             ³
		//³  for igual ao "Imposto a recolher", pois eh a unica amarracao que se consegue fazer, caso contrario, o contribuinte ³
		//³  deverá informar manualmente no SPED Fiscal as informacoes do registro E116 e/ou E250.                              ³
		//³                                                                                                                     ³
		//³USASPED = .T.                                                                                                        ³
		//³Funciona normalmente.                                                                                                ³
		//³                                                                                                                     ³
		If Len(aApICMST)>0 .And. aApICMST[14,3]>0
			cICMSTGNR		:=	Iif(aScan(aApICM,{|a| a[1]=="GNR" .And. AllTrim(a[4])==AllTrim(Str(aApICMST[14,3],15,2))})<>0, aApICM[aScan(aApICM, {|a| a[1]=="GNR" .And. AllTrim(a[4])==AllTrim(Str(aApICMST[14,3],15,2))})][2],"")
			cICMSTGNR		:=	SubStr(cICMSTGNR,1,At("/",cICMSTGNR)-3)
			
			//³REGISTRO E250 - OBRIGACOES DO ICMS A RECOLHER - SUBSTITUICAO TRIBUTARIA                       ³
	            //|                                                                                              |
			//³Gero registro E250 para todas as GNREs geradas pela Apuracao de ICMS/ST atraves do .ST0       ³
			If !Empty(cICMSTGNR) .And. (SPEDSeek("SF6",1,aSPDFil[PFIL_SF6]+cMVESTADO+cICMSTGNR) .And. (nUf := aScan(aRegE200,{|x|x[2]==SF6->F6_EST}))>0)
				
				//  Verifico se a UF de Recolhimento do ICMS Proprio deve apresentar o campo 05 - COD_REC
				//  considerando o Codigo da Receita + Classe de Vencimento ( F6_CODREC + F6_CLAVENC )
				cCodRec	:=	Iif( cMvEstado $ cMvSFUfGnr , "SF6->( Alltrim( F6_CODREC ) + Alltrim( F6_CLAVENC ) )" , "SF6->F6_CODREC" )
				
				aAdd(aRegE250, {})
				nPos	:=	Len (aRegE250)
				aAdd(aRegE250[nPos], nUF)									//Relacionamento com o PAI - E210
				aAdd(aRegE250[nPos], "E250")								//01 - REG
	
				//³Definindo o codigo da obrigacao a recolher³
				If SF6->F6_OPERNF == "1"
					aAdd (aRegE250[nPos], "001")							//02 - COD_OR - Entradas
					
				ElseIf SF6->F6_EST==cMvEstado
					aAdd (aRegE250[nPos], "002")							//02 - COD_OR - Saidas p/ Estado
					
				Else	
					aAdd (aRegE250[nPos], "999")							//02 - COD_OR - Saidas fora Estado
					
				EndIf
			
				aAdd(aRegE250[nPos], SF6->F6_VALOR)							//03 - VL_OR
				aAdd(aRegE250[nPos], SF6->F6_DTVENC)						//04 - DT_VCTO
				aAdd(aRegE250[nPos], &( cCodRec ))							//05 - COD_REC			
				aAdd(aRegE250[nPos], SF6->F6_NUMPROC)						//06 - NUM_PROC
				aAdd(aRegE250[nPos], SF6->F6_INDPROC)						//07 - IND_PROC
				aAdd(aRegE250[nPos], SF6->F6_DESCOMP)						//08 - PROC
			    aAdd(aRegE250[nPos], SF6->F6_OBSERV)						//09 - TXT_COMPL    
			
				If cVersao >= "004" //A partir de janeiro de 2011 incluir o campo 10 mmaaaa
					aAdd(aRegE250[nPos], SF6->(StrZero(F6_MESREF,2)+cValToChar(F6_ANOREF)))//10 - MES_REF
				EndIf
	
			EndIf
		EndIf
	
		//³GRAVACAO DO REGISTRO E200 - PERIODO DA APURACAO DO ICMS ST                                                ³
		//|GRAVACAO DO REGISTRO E210 - APURACAO DO ICMS - SUBSTITUICAO TRIBUTARIA                                    |
		//³GRAVACAO DO REGISTRO E250 - OBRIGACOES DO ICMS A RECOLHER - SUBSTITUICAO TRIBUTARIA                       ³
		SPEDRegs(cAlias,{aRegE200,aRegE210,aRegE250})
	EndIf
Else
    
	//³REGISTRO E200 - PERIODO DA APURACAO DO ICMS ST                               ³
	//³REGISTRO E210 - APURACAO DO ICMS - SUBSTITUICAO TRIBUTARIA                   ³
	//³REGISTRO E220 - AJUSTES/BENEFICIOS/INCENTIVOS DA APURACAO DO ICMS            ³
	//³                SUBSTITUICAO TRIBUTARIA                                      ³
	//³REGISTRO E230 - INFORMACOES ADICIONAIS DOS AJUSTES DE APURACAO DO            ³
	//³                ICMS SUBSTITUICAO TRIBUTARIA                                 ³
	//³REGISTRO E240 - INFORMACOES ADICIONAIS DOS AJUSTES DA APURACAO DO			³
	//³				   ICMS ST E IDENTIFICACAO DOS DOCUMENTOS FISCAIS.              ³
	//³REGISTRO E250 - OBRIGACOES DO ICMS A RECOLHER - SUBSTITUICAO                 ³
	//³                TRIBUTARIA                                                   ³
	//³- Funcao independente, geracao e gravacao das informacoes dos registros acima³
   	SPDAPICMS(cFilDe,cFilAte,nApuracao,nPeriodo,cNrLivro,"ST",cAlias,dDataDe,dDataAte,cMVEstado,lTop,;
   				lImpCrdST,cArqAnt,,aVlrMovST,aIcmPago,cMVSUBTRIB,aLanCDA,aLanCDA2,cMVSTNIEUF,;
   				lOldLan, lExtratTAF,@aRegT020,@aRegT020AA,@aRegT020AB,@aRegT020AC,@aRegT020AE,;
   				@aRegT021Val,@aRegT021Est,@aRegT021AA,@aRegT021AB,@aRegT021AC,@aRegT021AD,, @aReg0200, @aReg0190,;
   				@aReg0220, cMvSFUfGnr, @aRegT020AG,aWizard, @aRegT020AD,aStruCDA )
   				   				
EndIf

If "0"$aWizard[2][5] .Or. lExtratTAF
	//³GRAVACAO - REGISTRO E500 - PERIODO DA APURACAO DO IPI ³
	//|                                                      |
	//| - Funcao independente, geracao e gravacao do registro|
	if !lExtratTAF
		RegE500(cAlias,dDataDe,dDataAte,nApurIpi)
	endif
	
	//³GRAVACAO - REGISTRO E510 - CONSOLIDACAO DOS VALROES DE IPI POR CFOP E CODIGO DE TRIBUTACAO DO IPI³
	if !lExtratTAF
		GrvRegTrS(cAlias,,aRegE510)
	endif

	//³REGISTRO E520 - APURACAO DO IPI                       ³
	//³REGISTRO E530 - AJUSTES DA APURACAO DO IPI            ³
	//                                                       |
	//| - Funcao independente, geracao e gravacao do registro|
	SPDE520530(cAlias,dDataDe,cNrLivro,nApuracao,lTop,lExtratTAF, @aRegT022, @aRegT022AA, aRegE510, aInfE531,aWizard,aReg0190,aReg0200,aReg0220,dDataAte)	
EndIf

//----------------------------------------------------
//PROCESSA FAMÍLIA DO REGISTRO E300 - APURAÇÃO DIFAL
//----------------------------------------------------
IF lDifal 
	//Se geração for posterior a janeiro de 2016 e tabelas da apuração do difal existirem será processado
	//registros da família do E300
	ApurDifal (dDataDe, dDataAte, cNrLivro, aInfRgE313,cAlias,aMovSemIe,aIcmPago,@aRegT051, @aRegT051ax, @aRegT051AA, @aRegT051AB, @aRegT051AC, @aRegT051AD, lExtratTAF,lE300Ori)
EndIF

Return

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  |RegE100   ³ Autor ³Gustavo G. Rueda       ³ Data ³21.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±³          ³               PERIODO DE APURACAO DO ICMS                  ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao e gravacao do Registro E100                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS.                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³2(um por periodo)                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nil                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros|cAlias -> Alias do TRB que devera conter as informacoes do  ³±±
±±³          ³ meio-magnetico.                                            ³±±
±±³          ³dDataDe -> Data incial do periodo de apuracao.              ³±±
±±³          ³dDataAte -> Data final do periodo de apuracao.              ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function RegE100(cAlias,dDataDe,dDataAte)

Local	aReg		:=	{}
Local	nPos		:=	0

aAdd (aReg, {})
nPos	:=	Len (aReg)
aAdd (aReg[nPos], "E100")								//01 - REG
aAdd (aReg[nPos], dDataDe)								//02 - DT_INI
aAdd (aReg[nPos], dDataAte)								//03 - DT_FIN

GrvRegTrS(cAlias,,aReg)
Return
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  |RegE115   ³ Autor ³Gustavo G. Rueda       ³ Data ³22.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±³          ³        INFORMAÇÕES ADICIONAIS DA APURAÇÃO                  ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao e gravacao do Registro E115                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS.                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³2(um por periodo)                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³aRegE115 - Array populado com o registro                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros|cAlias -> Alias do TRB que devera conter as informacoes do  ³±±
±±³          ³ meio-magnetico.                                            ³±±
±±³          ³dDataDe -> Data incial do periodo de apuracao.              ³±±
±±³          ³dDataAte -> Data final do periodo de apuracao.              ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function RegE115(cAlias,dDataDe,dDataAte,lExtratTAF)

Local aRegE115	:=	{}
Local nPos		:=	0
Local cPeriodo  :=	StrZero(Year(dDataDe),4)+StrZero(Month(dDataDe),2)
Local cDados	:= ""
Local lCDVCFOP	:=	aSPDSX3[FP_CDV_CFOP]
Local lApGIEFD	:=	aSPDSX6[MV_GIAEFD]
Local cDescr	:= ""
Local cCompl	:= ""
Local lNewCDV	:=  aSPDSX3[FP_CDV_TXTDSC] .And. aSPDSX3[FP_CDV_CODCPL] .And. aSPDSX3[FP_CDV_CODMSG] .And. aSPDSX3[FP_CDV_VLOUTR] .And. aSPDSX3[FP_CDV_REGCAL];
					 .And. aSPDSX3[FP_CDV_OPBASE] .And. aSPDSX3[FP_CDV_OPALIQ] .And. aSPDSX3[FP_CDV_IDMSG]

Local lCDVZeraVl := .F.

Default lExtratTAF := .F.

//Tabela de complemento criado para amarrar as informacoes pertinentes ao registr E115     
If aSPDSX2[AI_CDV] 	 
	dbSelectArea("CDV")
    CDV->(DbSetOrder(1)) 
	CDV->(MsSeek(aSPDFil[PFIL_CDV]+cPeriodo))	 
	While !CDV->(Eof()) .And. CDV->CDV_FILIAL==aSPDFil[PFIL_CDV] .And. CDV->CDV_PERIOD==cPeriodo
		cDescr := SubStr(Alltrim(CDV->CDV_DESCR),0,200)
		cCompl := IIF(!"RS" $ CDV->CDV_CODAJU,cDescr +" "+ cDados, Iif(!Empty(CDV->CDV_CFOP), CDV->CDV_CFOP +" - "+ cDescr, cDescr))
		lCDVZeraVl := aSPDSX3[FP_CDV_ZERAVL] .And. CDV->CDV_ZERAVL == "1"	

		If !lNewCDV .Or. Empty(CDV->CDV_REGCAL)
			If (lApGIEFD .And. CDV->CDV_VALOR > 0) .OR. ("RS" $ CDV->CDV_CODAJU .And. lCDVCFOP)
				nPos := aScan(aRegE115, {|aX| CDV->CDV_CODAJU + CDV->CDV_CFOP $ aX[3]+aX[5]})
				If nPos == 0
					aAdd (aRegE115, {})
					nPos :=Len(aRegE115)				
					cDados:= RetQCDV(CDV->CDV_DOC,CDV->CDV_SERIE,CDV->CDV_CLIFOR,CDV->CDV_LOJA) 
					aAdd(aRegE115[nPos], 1)																					//01 - Chave com PAI E110
					aAdd(aRegE115[nPos], "E115")																			//02 - REG
					aAdd(aRegE115[nPos], CDV->CDV_CODAJU)																	//03 - COD_INF_ADIC
					aAdd(aRegE115[nPos], IIF(lCDVZeraVl, 0 , CDV->CDV_VALOR))	//04 - VL_INF_ADIC		
					aAdd(aRegE115[nPos], IIF(lCDVZeraVl, "", cCompl))			//05 - DESCR_COMPL_AJ - Preencher com CFOP conforme layout 8.5 GIA-RS
				else
					aRegE115[nPos][4] += IIF(lCDVZeraVl, 0 , CDV->CDV_VALOR)
				EndIf
			Else 
				nPos := aScan(aRegE115, {|aX| aX[3]==CDV->CDV_CODAJU})	
				If nPos == 0
					aAdd(aRegE115, {})
					nPos :=Len(aRegE115)
					aAdd(aRegE115[nPos], 1)			//01 - REG
					aAdd(aRegE115[nPos], "E115")			//01 - REG
					aAdd(aRegE115[nPos], CDV->CDV_CODAJU)	//02 - COD_INF_ADIC
					aAdd(aRegE115[nPos], IIF(lCDVZeraVl, 0 , CDV->CDV_VALOR))	//03 - VL_INF_ADIC
					aAdd(aRegE115[nPos], IIF(lCDVZeraVl, "", cCompl))			//04 - DESCR_COMPL_AJ
				Else
					aRegE115[nPos][4] += IIF(lCDVZeraVl, 0 , CDV->CDV_VALOR)
				Endif
			Endif
		Else // quando vier do configurador

			If !Empty(CDV->CDV_IDMSG) .And. CJL->(MsSeek(aSPDFil[PFIL_CDV]+CDV->CDV_IDMSG))
				cCompl := SubStr(Alltrim(CJL->CJL_MENSG),0,200) 
			Endif
			If Empty(cCompl)
				cDados:= RetQCDV(CDV->CDV_DOC,CDV->CDV_SERIE,CDV->CDV_CLIFOR,CDV->CDV_LOJA) 
				cCompl := Iif(!"RS"$CDV->CDV_CODAJU,cDescr + " "+ cDados,CDV->CDV_CFOP+"- "+ cDescr)
			Endif	
			If CDV->CDV_AGRLAN == "01"
				nPos := aScan(aRegE115, {|aX| aX[3]==CDV->CDV_CODAJU})	
			ElseIf CDV->CDV_AGRLAN == "02"
				nPos := aScan(aRegE115, {|aX| aX[3]==CDV->CDV_CODAJU .And. aX[5] == cCompl})	
			Else
				nPos := 0
			Endif	
			If nPos == 0				
				aAdd(aRegE115, {})
				nPos :=Len(aRegE115)
				aAdd(aRegE115[nPos], 1)			        //01 - REG
				aAdd(aRegE115[nPos], "E115")			//01 - REG
				aAdd(aRegE115[nPos], CDV->CDV_CODAJU)	//02 - COD_INF_ADIC
				aAdd(aRegE115[nPos], CDV->CDV_VALOR + CDV->CDV_VLOUTR )	//03 - VL_INF_ADIC
				aAdd(aRegE115[nPos], cCompl)	        //04 - DESCR_COMPL_AJ
			Else
				aRegE115[nPos][4] += CDV->CDV_VALOR + CDV->CDV_VLOUTR 
			Endif
		Endif	

		cCompl := ""
	CDV->(DbSkip())
		
	EndDo
		
	//if !lExtratTAF	
	//	GrvRegTrS(cAlias,,aRegE115)	//Passo a gravar o registro fora da função, ja amarrando ao seu pai E110
	//endif
Endif

Return aRegE115

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  |RegE500   ³ Autor ³Gustavo G. Rueda       ³ Data ³23.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±³          ³               PERIODO DE APURACAO DO IPI                   ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao e gravacao do Registro E500                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS.                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³2(um por periodo)                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nil                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros|cAlias -> Alias do TRB que devera conter as informacoes do  ³±±
±±³          ³ meio-magnetico.                                            ³±±
±±³          ³dDataDe -> Data incial do periodo de apuracao.              ³±±
±±³          ³dDataAte -> Data final do periodo de apuracao.              ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function RegE500 (cAlias, dDataDe, dDataAte, nApuracao)
	
	Local	aReg		:=	{}
	Local	nPos		:=	0

	aAdd (aReg, {})
	nPos	:=	Len (aReg)
	aAdd (aReg[nPos], "E500")							//01 - REG
	aAdd (aReg[nPos], STR(nApuracao,1))					//02 - IND_APUR
	aAdd (aReg[nPos], dDataDe)							//03 - DT_INI
	aAdd (aReg[nPos], dDataAte)							//04 - DT_FIN

	GrvRegTrS(cAlias,,aReg)
Return
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  |RegE510   ³ Autor ³Gustavo G. Rueda       ³ Data ³15.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±³          ³    CONSOLIDACAO DOS VALORES DE IPI POR CFOP E CODIGO DE    ³±±
±±³          ³                   TRIBUTACAO DO IPI                        ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao do Registros E510                                 |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com as informacoe contidas na tabela   ³±±
±±³          ³ SFT somente para operacoes TRIBUTADAS                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³3(varios por periodo)                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nil                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros|cAliasSFT -> Alias da tabela SFT aberta no momento.         ³±±
±±³          ³ funcao a ser retornado para gravacao pela funcao principal.³±±
±±³          |aRegE510 -> Array contendo as informacoes processadas pela  ³±±
±±³          ³ funcao a ser retornado para gravacao pela funcao principal.³±±
±±³          ³cSituaDoc -> Situação do documento.						  ³±±
±±³          ³aClasFis -> Array contendo os CSTs de PIS/COFINS/ICMS       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function RegE510(cAliasSFT,aRegE510,cSituaDoc,aClasFis,cEntSai,cAliasSF4)
	
	Local nPos := 0
	
	// MV_VLCTBZL -> Indique os CFOP's que terao os seus Valores contabeis Zerados no Livros de Entrada e Saida. - 16/10/2017 - Vitor Ribeiro (vitor.e@totvs.com.br)
	Local lVLCTBZL	:= AllTrim((cAliasSFT)->FT_CFOP) $ aSPDSX6[MV_VLCTBZL]
	Local lValIpi := .F.
	
	Default	cEntSai := ""
	Default	cAliasSF4 := ""
	
	If !lVLCTBZL
		If !Empty(cEntSai) .And. !Empty(cAliasSF4)
			If (cEntSai == "1" .And. (cAliasSF4)->F4_LFIPI $ "T") .Or. cEntSai == "2"
				lValIpi := .T.
			EndIf
			If ((cEntSai == "2" .And. (cAliasSFT)->FT_TIPO == "D" .And. (cAliasSF4)->F4_LFIPI <> "T") .And. (cAliasSF4)->F4_IPI == "R")
				lValIpi := .F.
			EndIf
		Else
			lValIpi := .T.
		EndIf
		
		nPos := aScan(aRegE510,{|aX| aX[2] == (cAliasSFT)->FT_CFOP .And. aX[3] == aClasFis[2] })
		
		If nPos < 1
			aAdd(aRegE510,{})
			nPos := Len(aRegE510)
			
			aAdd(aRegE510[nPos],"E510")	  	 			// 01 - REG
			aAdd(aRegE510[nPos],(cAliasSFT)->FT_CFOP)	// 02 - CFOP
			aAdd(aRegE510[nPos],aClasFis[2])			// 03 - CST_IPI
			aAdd(aRegE510[nPos],0)						// 04 - VL_CONT_IPI
			aAdd(aRegE510[nPos],0)						// 05 - VL_BC_IPI
			aAdd(aRegE510[nPos],0)						// 06 - VL_IPI
		EndIf
		
		aRegE510[nPos][4] += (cAliasSFT)->FT_VALCONT	// 04 - VL_CONT_IPI
		aRegE510[nPos][5] += IIf((cAliasSF4)->F4_IPI=="R",0,(cAliasSFT)->FT_BASEIPI)	// 05 - VL_BC_IPI
		
		If lValIpi
			aRegE510[nPos][6] += (cAliasSFT)->FT_VALIPI	// 06 - VL_IPI
		EndIf
	EndIf
		
Return
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  |SPDE520530³ Autor ³Gustavo G. Rueda       ³ Data ³23.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±³          ³REGISTRO E520 - APURACAO DO IPI                             ³±±
±±³          ³REGISTRO E530 - AJUSTES DA APURACAO DO IPI                  ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao e gravacao dos Registros E520 e E530              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com as informacoe contidas na apuracao ³±±
±±³          ³ de IPI.                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³E520 - 3(varios por periodo)                                ³±±
±±³          ³E530 - 4(para cada E520)                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nil                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros|cAlias    -> Alias do TRB para gravacao.                    ³±±
±±³          ³dDataDe   -> Data do inicio do periodo de apuracao.         ³±±
±±³          ³cNrLivro  -> Numero do livro selecionado no wizard.         ³±±
±±³          ³nApuracao -> Periodo de Apuracao (1=Mensal e 3=Decendial)   ³±±
±±³          ³lTop      -> Flag de processamento via TOP                  ³±±
±±³          ³lExtratTAF-> Indica se a origem da chamada eh o Extrator TAF³±±
±±³          ³aRegT022  -> Array de Retorno para o Extrator gerar T022    ³±±
±±³          ³aRegT022AA  -> Array de Retorno para o Extrator gerar T022AA³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function SPDE520530(cAlias,dDataDe,cNrLivro,nApuracao,lTop,lExtratTAF, aRegT022, aRegT022AA,aRegE510,aInfE531,aWizard,aReg0190,aReg0200,aReg0220,dDataAte)

Local	nPos		:=	0
Local	nPeriodo	:=	1
Local	cIndAj		:=	""
Local	aReg		:=	{}
Local	aRegE530	:=	{}
Local	aApIPI		:=	{}
Local	nVLSdAnt	:=	0
Local	nVLDbIpi	:=	0
Local	nVLCdIpi	:=	0
Local	nVLOdIpi	:=	0
Local	nVLOcIpi	:=	0
Local	nVLScIpi	:=	0
Local	nVLSdIpi	:=	0
Local	nVLTcIpi	:=	0
Local  nE020OIPI  	:= 	0
Local  cChave     	:=	 ""
Local	cAliasCDP	:=	"CDP"
Local	aParFil		:=	{}
Local	nRecnoCCK	:=	Nil
Local	lAchouCCK	:=	.F.
Local	cSequen		:=	""
Local	cSomaSeq	:=	""    
Local	nX 		:= 	0
Local 	aRegE531   := {}
Local 	lCmpPcLanc := CDP->(FieldPos("CDP_TPLANC")) > 0

Default lExtratTAF  := .F. 
Default aRegT022    := {}    
Default aRegT022AA  := {}
Default aRegE510	:= {}
Default aInfE531	:= {}
Default aReg0190	:= {}
Default aReg0200	:= {}
Default aReg0220	:= {}


//³O periodo de geracao podera ser somente 0 - Mensal ou 1 - Descendial ³
If (nApuracao<>1)
	nApuracao	:=	3
EndIf

//³Para ambiente ADS/DBF, devo pegar a ultima sequencia para montar o indregua³
If !lTop
	cChave	:=	STR(nApuracao,1)+STR(nPeriodo,1)+DTOS(dDataDe)+cNrLivro
	
	If CDP->(MsSeek(aSPDFil[PFIL_CDP]+"IP"+cChave))
		cSomaSeq  		:= 	CDP->CDP_SEQUEN

		While CDP->(MsSeek(aSPDFil[PFIL_CDP]+"IP"+cChave+cSomaSeq)) // Posiciona na ultima sequencia
			cSequen  	:= 	CDP->CDP_SEQUEN
			cSomaSeq 	:= 	Soma1(cSequen)
		EndDo
	EndIf
EndIf

//³Montando array de parametros para SPEDFFiltro³
aAdd(aParFil,"IP")
aAdd(aParFil,STR(nApuracao,1))
aAdd(aParFil,STR(nPeriodo,1))
aAdd(aParFil,DTOS(dDataDe))
aAdd(aParFil,cNrLivro)
aAdd(aParFil,cSequen)
             
//³Tratamento para quando existir a tabela de APuração de IP³
If AliasIndic("CDP") .And. AliasIndic("CCK") .And. SPEDFFiltro(1,"CDP",@cAliasCDP,aParFil)                                                     

	//³A tabela de Apuracao jah estah filtrada neste momento ³
	//³  atraves da funcao SPEDFFiltro acima                  ³
	While !(cAliasCDP)->(Eof())
		//³Para ambiente TOP devo pegar o recno retornado na query, se nao for TOP,³
		//³ devo deixar como declarado, igual a Nil                                ³
		If lTop
			nRecnoCCK	:=	(cAliasCDP)->CCKRECNO
		EndIf
		
		lAchouCCK	:=	SPEDSeek("CCK",,aSPDFil[PFIL_CCK]+(cAliasCDP)->CDP_CODLAN,nRecnoCCK)

		//³REGISTRO E530 - AJUSTES DA APURACAO DO IPI³
		If lAchouCCK .And. !(cAliasCDP)->CDP_LINHA=="007"
			//³Define o tipo de utilizacao do lancamento.³
			//³C=Credito;                                ³
			//³D=Debito                                  ³
			If "C"$CCK->CCK_TPUTI
				cIndAj:="1"
			Else
				cIndAj:="0"
			EndIf
			  
			aAdd(aRegE530, {})
			nPos	:=	Len (aRegE530)
			aAdd(aRegE530[nPos], "E530")	   	   						//01 - REG
			aAdd(aRegE530[nPos], cIndAj)				 				//02 - IND_AJ
			aAdd(aRegE530[nPos], (cAliasCDP)->CDP_VALOR)				//03 - VL_AJ
			aAdd(aRegE530[nPos], (cAliasCDP)->CDP_CODLAN)				//04 - COD_AJ
			aAdd(aRegE530[nPos], (cAliasCDP)->CDP_INDDOC)				//05 - IND_DOC
			aAdd(aRegE530[nPos], (cAliasCDP)->CDP_NUMDOC)				//06 - NUM_DOC
			aAdd(aRegE530[nPos], (cAliasCDP)->CDP_DESC)					//07 - DESCR_AJ
			
			nE020OIPI += iif(cIndAj=='1',(cAliasCDP)->CDP_VALOR,0) // aglutino o valor para gerar o campo 6 do E020
			
			//Processa E531 -Este registro somente deverá ser informado quando o Campo IND_DOC do Registro E530 for igual a 3. 
			IF cVersao >= "012" .And. lCmpPcLanc .And. Len(aRegE530) > 0 .AND. (cAliasCDP)->CDP_INDDOC =='3' .and. ((cAliasCDP)->CDP_TPLANC =='1' .Or. (cAliasCDP)->CDP_TPLANC =='3' ) //3 – Documento Fiscal
		
				nPosE531 	:=  aScan ( aInfE531, { |aX| allTrim(ax[1]) == allTrim((cAliasCDP)->CDP_CODLAN)}) 
				If nPosE531 > 0				
					RegE531(aRegE531, aInfE531, nPos, alltrim((cAliasCDP)->CDP_CODLAN ),cAlias,aWizard,aReg0190,aReg0200,aReg0220,dDataDe,dDataAte,(cAliasCDP)->CDP_TPLANC)
				EndIF
			EndIF

		EndIf


		//³Obtendo valores da apuracao do IPI para montar o registro E520 na sequencia³
		Do Case

			//³Valor total dos "Creditos por entrada"  ³
		 	Case (cAliasCDP)->CDP_LINHA$"001/002/003"
		      nVLCdIpi	+=	(cAliasCDP)->CDP_VALOR

			//³Valor total de "Outros Creditos"        ³
		    Case (cAliasCDP)->(CDP_LINHA=="005" .And. Upper(AllTrim(CDP_DESC))=="OUTROS CREDITOS") 
		      nVLOcIpi	+=	(cAliasCDP)->CDP_VALOR

			//³Saldo credor do IPI transferido do periodo anterior³
		    Case (cAliasCDP)->CDP_LINHA=="007"
		      nVLSdAnt	+= 	(cAliasCDP)->CDP_VALOR
		      
			//³Valor Total de cretido do imposto                   ³
		    Case (cAliasCDP)->CDP_LINHA=="006"
		      nVLTcIpi	+= 	(cAliasCDP)->CDP_VALOR

			//³Valor total dos "Saidas com debito do imposto"³
		    Case (cAliasCDP)->CDP_LINHA=="009"
		      nVLDbIpi	+= 	(cAliasCDP)->CDP_VALOR
		         
			//³Valor de "Outros debitos do IPI"³
			Case(cAliasCDP)->(CDP_LINHA=="011" .And. Upper(AllTrim(CDP_DESC))=="RESSARCIMENTO DE CRÉDITOS") .Or.;
				(cAliasCDP)->(CDP_LINHA == "012" .And. Upper(AllTrim(CDP_DESC))=="OUTROS DEBITOS") .Or.;
				(cAliasCDP)->(CDP_LINHA == "010" .And. Upper(AllTrim(CDP_DESC))=="ESTORNO DE CREDITOS")
		      nVLOdIpi	+= 	(cAliasCDP)->CDP_VALOR

			//³Valor do saldo devedor do IPI³
		    Case (cAliasCDP)->CDP_LINHA=="016"
		      nVLSdIpi	+= 	(cAliasCDP)->CDP_VALOR

			//³Valor do saldo credor do IPI³
		    Case (cAliasCDP)->CDP_LINHA=="017"
		      nVLScIpi	+= 	(cAliasCDP)->CDP_VALOR
		      
		EndCase
		
		(cAliasCDP)->(dbSkip())		
	End
	
	//³GRAVACAO DO REGISTRO E530 - AJUSTES DA APURACAO DO IPI³
	//|                                                      |
	//|A gravacao eh feita somente quando existe lancamentos |
	//|  de apuracao com codigos relacionados, e para isso,  |
	//|  eh necessario que as tabelas CDP e CCK estejam em   |
	//|  uso.                                                |

	if !lExtratTAF
		SPEDRegs(cAlias,{aRegE530,{aRegE531,1}})
	endif
	
	//³Fecho query ou indregua criada³
	SPEDFFiltro(2,,cAliasCDP)

Else

	//³Obtendo valores da Apuracao de IPI gerado no modo antigo, atraves do arquivo *.IP³
	aApIPI	:=	FisApur("IP",Year(dDataDe),Month(dDataDe),nApuracao,nPeriodo,cNrLivro,.F.,{},1,.F.,"")

	//³Valor total dos "Creditos por entrada"  ³
	nVLCdIpi	:=	Iif (aScan (aApIPI, {|a| a[1]=="001"})<>0, aApIPI[aScan (aApIPI, {|a| a[1]=="001"})][3], 0)
	nVLCdIpi	+=	Iif (aScan (aApIPI, {|a| a[1]=="002"})<>0, aApIPI[aScan (aApIPI, {|a| a[1]=="002"})][3], 0)
	nVLCdIpi	+=	Iif (aScan (aApIPI, {|a| a[1]=="003"})<>0, aApIPI[aScan (aApIPI, {|a| a[1]=="003"})][3], 0)

	//³Valor total de "Outros Creditos"        ³
	nVLOcIpi	:=	Iif (aScan (aApIPI, {|a| a[1]=="005"})<>0, aApIPI[aScan (aApIPI, {|a| a[1]=="005"})][3], 0)
	//nVLOcIpi 	+= 	Iif (aScan (aApIPI, {|a| a[1]=="004"})<>0, aApIPI[aScan (aApIPI, {|a| a[1]=="004"})][3], 0)

	//³Saldo credor do IPI transferido do periodo anterior³
	nVLSdAnt	:=	Iif (aScan (aApIPI, {|a| a[1]=="007"})<>0, aApIPI[aScan (aApIPI, {|a| a[1]=="007"})][3], 0)
	
	//³Valor Total de cretido do imposto                   ³
    nVLTcIpi	:=	Iif (aScan (aApIPI, {|a| a[1]=="006"})<>0, aApIPI[aScan (aApIPI, {|a| a[1]=="006"})][3], 0)
    
	//³Valor total dos "Saidas com debito do imposto"³
	nVLDbIpi	:=	Iif (aScan (aApIPI, {|a| a[1]=="009"})<>0, aApIPI[aScan (aApIPI, {|a| a[1]=="009"})][3], 0)
	
	//³Valor de "Outros debitos do IPI"³
	nVLOdIpi	:=	Iif (aScan (aApIPI, {|a| a[1]=="012"})<>0, aApIPI[aScan (aApIPI, {|a| a[1]=="012"})][3], 0)
	nVLOdIpi 	+= 	Iif (aScan (aApIPI, {|a| a[1]=="011"})<>0, aApIPI[aScan (aApIPI, {|a| a[1]=="011"})][3], 0)
	nVLOdIpi 	+= 	Iif (aScan (aApIPI, {|a| a[1]=="010"})<>0, aApIPI[aScan (aApIPI, {|a| a[1]=="010"})][3], 0)
	
	//³Valor do saldo devedor do IPI³
	nVLSdIpi	:=	Iif (aScan (aApIPI, {|a| a[1]=="016"})<>0, aApIPI[aScan (aApIPI, {|a| a[1]=="016"})][3], 0)

	//³Valor do saldo credor do IPI³
	nVLScIpi	:=	Iif (aScan (aApIPI, {|a| a[1]=="017"})<>0, aApIPI[aScan (aApIPI, {|a| a[1]=="017"})][3], 0)
EndIf

If Len(aRegE510) > 0
	nVLCdIpi := 0
	For nX := 1 to Len(aRegE510)
		If SUBSTR(aRegE510[nX][2],1,1)$"1/2/3" 
			nVLCdIpi += aRegE510[nX][6]
		EndIf
	Next nX
Else
	nVLCdIpi := nVLCdIpi + nVLOcIpi
EndIf
//³REGISTRO E520 - APURACAO DO IPI                                             ³
//³                                                                            ³
//³Neste momento tambem eh efetuado a gravacao do mesmo no TRB de processamento³
//³  da rotina.                                                                ³
aAdd(aReg, {})
nPos	:=	Len (aReg)
aAdd (aReg[nPos], "E520")	   					//01 - REG
aAdd (aReg[nPos], nVLSdAnt)						//02 - VL_SD_ANT_IPI
aAdd (aReg[nPos], nVLDbIpi)						//03 - VL_DEB_IPI
aAdd (aReg[nPos], nVLCdIpi)               		//04 - VL_CRED_IPI
aAdd (aReg[nPos], nVLOdIpi)						//05 - VL_OD_IPI
aAdd (aReg[nPos], Iif (Len(aRegE530)>0,nE020OIPI,0))//06 - VL_OC_IPI
aAdd (aReg[nPos], nVLScIpi)						//07 - VL_SC_IPI
aAdd (aReg[nPos], nVLSdIpi)						//08 - VL_SD_IPI

If !lExtratTAF
	GrvRegTrS(cAlias,,aReg)	
Else
	aRegT022 := aReg        
	aRegT022AA := aRegE530
EndIf

Return
  	
/*/
±±³Programa  |SPDBlocoH ³ Autor ³Gustavo G. Rueda       ³ Data ³29.03.2011³±±
±±³Descri‡…o ³REGISTRO H005 - TOTAIS DE INVENTARIO                        ³±±
±±³          ³REGISTRO H010 - INVENTARIO                                  ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao e gravacao dos Registros H005 e H010              |±±

±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com as informacoes obtidas pela funcao ³±±
±±³          ³ FsEstInv.                                                  ³±±

±±³Nivel Hier³2 H005 (um por data)                                        ³±±
±±³          ³3 H010 (para cada H005)                                     ³±±

±±³Retorno   ³Nil                                                         ³±±

±±³Parametros|cAlias    -> Alias do TRB que recebe a gravacao dos registro³±±
±±³          ³bWhileSM0 -> Condicao do while do SIGAMAT                   ³±±
±±³          ³aWizard   -> Informacoes do assistente da rotina            ³±±
±±³          ³cFilDe    -> Filial de inicio de processamento da rotina    ³±±
±±³          ³aLisFil   -> Filiais selecionadas no assistente da rotina   ³±±
±±³          ³aReg0190  -> Informacoes a serem atualizadas da sobre a UM  ³±±
±±³          ³aReg0200  -> Informacoes a serem atualizadas da sobre o     ³±±
±±³          ³             Produto                                        ³±±
±±³          ³aReg0220  -> Informacoes a serem atualizadas da sobre a     ³±±
±±³          ³             alteracao de produto                           ³±±
±±³          ³aReg0150  -> Informacoes a serem atualizadas da sobre o     ³±±
±±³          ³             participante                                   ³±±
±±³          ³nCtdFil   -> Quantidade de registros da tabela SM0 que serao³±±
±±³          ³             processados                                    ³±±
±±³          ³lEnd      -> Flag de cancelamento do processamento          ³±±
±±³          ³cFilAte   -> Filial final para processamento                ³±±
±±³          ³lExtTaf   -> Indica que a chamada da funcao eh o Extrator   ³±±
±±³          ³			   TAF											  ³±±
±±³          ³aRegT079  -> Array para geracao do Registro T079 do Extrator³±±
±±³          ³aRegT079AA-> Array para geracao do Registro T079AA do       ³±±
±±³          ³			   Extrator  								      ³±±
±±³          ³aRegT079AB-> Array para geracao do Registro T079AB do       ³±±
±±³          ³			   Extrator  								      ³±±
±±³			 |cExtVer   -> Versao do Sped Que o Extrator TAF considera    ³±±   /*/
Function SPDBlocoH(cAlias,bWhileSM0,aWizard,cFilDe,aLisFil,aReg0190,aReg0200,aReg0220,aReg0150,oProcess,nCtdFil,lEnd,cFilAte,lExtTAF,aRegT079,aRegT079AA,aRegT079AB,cExtVer)
Local aPartDoc		:=	{}
Local aRegH005		:=	{}
Local aAuxH005		:=	{}
Local aRegH010		:=	{}
Local aRegH020		:=	{}
Local aRegH030		:=	{}
Local nAcVlrEst		:=	0
Local lExistF0M		:=	aSPDSX2[AI_F0M]
Local aAreaSM0		:=	SM0->(GetArea())
Local nTamProd		:=	TamSX3("B1_COD")[1]
local ntamCli		:= 	TamSX3("F0M_CLIFOR")[1]
Local nTamLoj		:= 	TamSX3("F0M_LOJA")[1]
Local nTamCOD		:= 	TamSX3("F0M_CODIGO")[1]
Local nFilial		:= 	0
Local nI			:=	0
Local nY			:=	0
Local nX			:=	0
Local nZ			:=	0
Local nPos			:=	0
Local nPosH020		:= 	0
Local nPosH030		:=	0
Local cMotInv		:=	""
Local dDataDe		:=	cToD( "  / /  ") 
Local dDataAte		:=	cToD( "  / /  ") 
Local dDataFec		:=	cToD( "  / /  ") 
Local nEmpProc		:=	0
Local nCtdInv		:=	0
Local nInv			:=	0
Local cUnid			:=	Nil
Local aProd			:=	Nil
Local cProd			:=	""
Local nQuant    	:=	0
Local nVlrIte   	:=	0
Local nVlIteIR  	:=	0
Local nValUnit 		:=  0
Local nAliqProd		:=	0
Local cClasFis		:=	""
Local lTipoinv		:= aSPDSX2[AI_F0Q]    .And. aSPDSX3[FP_F0Q_PERIOD] .And. aSPDSX3[FP_F0Q_ID]
Local lNvcampos 	:= aSPDSX3[FP_F0M_UM] .And. aSPDSX3[FP_F0M_VUNIT]  .And. aSPDSX3[FP_F0M_TPCF] .And. aSPDSX3[FP_F0M_CONTA]
Local aQtdArq		:= {}
Local cSegUnid		:= ""
Local cTpUnid		:= ""
Local nConvUnid		:= 0
Local aPeH020		:= {}
Local cMsgh020		:= ""
Local cMVH020		:= ""
Local lAchouF0M		:= .F.
Local nRegPai		:= 0
Local nArquivos		:= 0
Local nBasIcm 		:= 0
Local nTotICM 		:= 0
Local nValICM		:= 0
Local cAliBLH		:= ''
Local cAliasF0Q		:= ''
Local cPerF0Q 		:= ''
Local lATribF0Q		:= .F.
Local nAliqint		:= 0
Local cSituacao		:= ''
Local lSPDBlocH		:= FindFunction("SPDBlocH")
Local lSPDFIS02		:= aExistBloc[01]
Local nFatorPE		:= 0
Local cTpCv			:= ''
Local lCmpAltTri 	:= aSPDSX3[FP_B5_ALTTRIB] 
Local lH020	  		:= .F.
Local lAchouCIL 	:= .F.
Local cAnoMes		:= ""
Local nICMSOP		:= 0
Local nBCICMSST 	:= 0
Local nICMSST   	:= 0 
Local nFCP			:= 0
Local lRegCompST 	:= .F.
Local lPrintH005 	:= .F.
Local cWhere     	:= ""
Local nTipoMot06 	:= 0
Local cCIISped 		:= Iif(aSPDSX3[FP_CII_SPED], "% CII_SPED <> '2' AND %", "%%")
Local nH020BaseIcm 	:= 0
Local nH020ValorIcm := 0
Local lProcH020		:= .F.
Local lPESPEDH020	:= aExistBloc[26]
Local cUnidBkp		:=	""

Default lExtTAF 	:= .F.   
Default cExtVer 	:= ""
Default aRegT079	:= {}
Default aRegT079AA	:= {}
Default aRegT079AB	:= {}

// Se não for top, não executa - 05/10/2017 - Vitor Ribeiro (vitor.e@totvs.com.br)
#IFNDEF TOP
	Return
#ENDIF

cMotInv	 	:= Iif( !lExtTAF, Substr(aWizard[1][19],1,2), Substr(aWizard[2][7],1,2) )

dDataDe	 	:= Iif( !lExtTAF, SToD(aWizard[1][1]), aWizard[1][3] )
dDataAte 	:= Iif( !lExtTAF, SToD(aWizard[1][2]), aWizard[1][4] )
dDataFec	:= Iif( !lExtTAF, SToD(aWizard[1][8]), aWizard[2][9] )
lH020		:= Iif( !lExtTAF, Iif("1"$aWizard[1][21],.T.,.F.),.F.)
cPerF0Q		:= cvaltochar(strzero(month(dDataDe),2)) + cvaltochar(year(dDataAte ))

If lExtTAF
	cVersao := cExtVer
Else
	lRegCompST := GerCompST(aWizard,DTOS(dDataDe),DTOS(dDataAte))
EndIf
//³Montando o processamento de multi empresas conforme selecionado nos³
//³  parametros da rotina³
If !(("1" $ aWizard[1][12]) .And. Len(aLisFil) > 0) .And. !lExtTAF
	SM0->(MsSeek(cEmpAnt+cFilDe,.T.))
EndIf	
While Eval(bWhileSM0)

	If !lExtTAF //.Or. (lExtTAF .And. "1" $ aWizard[1][5])
		cFilAnt := FWGETCODFILIAL
	EndIf

	//³Quando a rotina for chamada pelo Extrator TAF ja estou posicionado na filial³
	//³correta, sendo assim nao eh necessario realizar validacoes                  ³
	If !lExtTAF	
		If Len(aLisFil)>0 .And. cFilAnt <= cFilAte
			nFilial := Ascan(aLisFil,{|x|x[2]==cFilAnt})
			If nFilial==0 .Or. !(aLisFil[nFilial,1])  //Filial não marcada, vai para proxima
				SM0->( dbSkip() )
				Loop
			EndIf
		Else
			If "1"$aWizard[1][12]  //Somente faz skip se a opção de selecionar filiais estiver como Sim.
				SM0->(dbSkip())
				Loop
			EndIf		
		EndIf
	EndIf
	
	// Refazendo o cache do SX6 para cada filial.
	aSPDSX6 := SpedLoadX6()

	// Refazendo o cache dos xFilial para cada filial.
	aSPDFil	:= fGetSpdFil()

	aQtdArq	  := {}

	If "1"$aWizard[1][6]		
		nArquivos := 1		
		aAdd(aQtdArq,{})
		aAdd(aQtdArq[nArquivos],dDataFec)
		aAdd(aQtdArq[nArquivos],cMotInv)	
	Endif
	
	//F0Q_FILIAL+DTOS(F0Q_DTFECH)+F0Q_MOTINV
	If lTipoinv			
		cAliasF0Q := GetNextAlias()
			
		BeginSql Alias cAliasF0Q
		COLUMN F0Q_DTFECH AS DATE 
		
		SELECT DISTINCT F0Q_MOTINV,F0Q_DTFECH
		FROM 	%TABLE:F0Q% F0Q
			WHERE  F0Q.F0Q_FILIAL=%XFILIAL:F0Q%
			AND F0Q.F0Q_PERIOD = %Exp:cPerF0Q%
			AND F0Q.%NOTDEL%
			ORDER BY F0Q_DTFECH
		EndSql
	
		DbSelectArea (cAliasF0Q)
		
		While (cAliasF0Q)->(!Eof())
			If (aScan(aQtdArq,{|aX| aX[1]==(cAliasF0Q)->F0Q_DTFECH .and. aX[2] == (cAliasF0Q)->F0Q_MOTINV})) == 0
				nArquivos ++ 
				aAdd(aQtdArq,{})
				aAdd(aQtdArq[nArquivos],(cAliasF0Q)->F0Q_DTFECH)
				aAdd(aQtdArq[nArquivos],(cAliasF0Q)->F0Q_MOTINV)			
			Endif
			(cAliasF0Q)->(dbSkip())
		ENDDO
		
		(cAliasF0Q)->(DbCloseArea())
		
	Endif

	//H030 - Apruação de ressarcimento e complemento de ICMS ST
	If lRegCompST
		nArquivos ++
		aAdd(aQtdArq,{})
		aAdd(aQtdArq[nArquivos],dDataDe-1)	//H005 com “MOT_INV” = 06 e com o campo “DT_INV” igual ao dia imediatamente anterior ao campo “DT_INI” informado no registro 0000				
		aAdd(aQtdArq[nArquivos],"06")  		//06 – Para controle das mercadorias sujeitas ao regime de substituição tributária – restituição /ressarcimento/ complementação		

		//---Para o Motivo de Inventário 06, por mais que não exista quantidade de determinado produto na data do inventário, é necessário gerar um registro H010 para tal produto, caso contrário ocorre erro de validação. Tal comportamento não é observado para outros motivos de inventário---//
		//---Sabemos que o alias retornado da função SPDBlocH() não possui produtos com quantidade = 0---//
		//---Dessa forma, o motivo 06 é inserido novamente no vetor. Em sua primeira passagem pelo laço, processará o alias retornado por SPDBlocH(). Na segunda passagem, processará uma query na tabela CIL---//
		nArquivos ++
		aAdd(aQtdArq,{})
		aAdd(aQtdArq[nArquivos],dDataDe-1)	//H005 com “MOT_INV” = 06 e com o campo “DT_INV” igual ao dia imediatamente anterior ao campo “DT_INI” informado no registro 0000				
		aAdd(aQtdArq[nArquivos],"06")  		//06 – Para controle das mercadorias sujeitas ao regime de substituição tributária – restituição /ressarcimento/ complementação		

		nTipoMot06 := 1                     //---[1]-Alias SPDBlocH() [2]-Alias CIL---//
	Endif

	nEmpProc := 0 

	
	For nY := 1 to nArquivos
		
		dDataFec  := Iif( !lExtTAF, aQtdArq[nY][1], aWizard[2][9] )
		cMotInv	  := Iif( !lExtTAF, aQtdArq[nY][2], Substr(aWizard[2][7],1,2) )		
		cAnoMes   := AnoMes(dDataDe)

		cMVH020		:= aSPDSX6[MV_TXTH020]		
		nEmpProc	+=	1
		
		//³Tratamento para identificar a quantidade de processamento que serah ³
		//³  efetuado conforme selecao das opcoes no assistente da rotina      ³
		nCtdInv		:=	nArquivos		
		nInv		:=	nEmpProc

		//|Processando os Saldos em Estoque(1)	|
		lAchouF0M	:= .F.		

		nAliqint := aSPDSX6[MV_ICMPAD]
		
		If cMotInv == '06' .And. nTipoMot06 = 2

			cAliBLH := GetNextAlias()

    		BeginSql Alias cAliBLH
    		    SELECT CIL_FILIAL FILIAL, CIL_PRODUT COD_ITEM, SB1.B1_UM UNID, SB1.B1_CONTA COD_CTA, SB1.B1_PICM ALQ_PICM, SB1.B1_ORIGEM COD_ORIG, SB1.B1_CLASFIS CL_CLASS, 'H010' REG, CIL_QTDSLD QTD, 0 VL_UNIT, 0 VL_ITEM, '0' IND_PROP, '' COD_PART, 0 VL_ITEM_IR, 0 TOTALDC
    		    FROM %TABLE:CIL% CIL      INNER JOIN %TABLE:SB1% SB1 ON (SB1.B1_FILIAL = %XFILIAL:SB1% AND SB1.B1_COD = CIL.CIL_PRODUT AND SB1.%NOTDEL%)
                                     LEFT OUTER JOIN (SELECT CII.CII_FILIAL, CII.CII_PERIOD, CII.CII_PRODUT , MAX(CII.CII_ORDEM) CII_ORDEM
                                                      FROM %Table:CII% CII
                                                      WHERE CII.CII_FILIAL = %xFilial:CII%  AND 
                                                            CII.CII_PERIOD = %Exp:cAnoMes%  AND
                                                            CII_TPREG      = ' '            AND
															%Exp:cCIISped%
                                                            CII.%NotDel%
                                                      GROUP BY CII.CII_FILIAL, CII.CII_PERIOD, CII.CII_PRODUT) CII_ ON (CII_.CII_FILIAL = %xFilial:CII% AND CII_.CII_PERIOD = %Exp:cAnoMes% AND CII_.CII_PRODUT = CIL.CIL_PRODUT)
    		    WHERE CIL_FILIAL = %XFILIAL:CIL% AND CIL_PERIOD = %EXP:cAnoMes% AND CIL_QTDSLD = 0 AND CIL.%NOTDEL% AND ISNULL(CII_.CII_ORDEM,'') <> ''
    		EndSql

			DbSelectArea(cAliBLH) 
    		(cAliBLH)->(DbGoTop())

		ElseIf aExistBloc[31]//ExistBlock("SPEDALTH") 			

			cAliBLH := ExecBlock("SPEDALTH",.F.,.F.,{dDataFec,cMotInv})

			//Verifica se arquivo existe
			IF MSFile(cAliBLH+GetDBExtension(),,__LocalDriver)
				lAchouF0M := .F.
				
				dbSelectArea(cAliBLH) 
				(cAliBLH)->(dbGoTop())				
			Else
				Conout("Não foi encontrado dados no ponto de entrada SPEDALTH para compor Bloco H")
				Loop
			Endif
			
		ElseIF cMotInv $ "02|03|04|05" .and. lNvcampos .and. !lPESPEDH020 .And. lExistF0M .And. F0M->(MsSeek( aSPDFil[PFIL_F0M] + DTOS(dDataFec)))	

			If aSPDSX3[FP_F0M_MOTINV]
				cWhere := "% AND (F0M.F0M_MOTINV = '" + cMotInv + "'"
				
				If cMotInv == "02"
					cWhere += " OR F0M.F0M_MOTINV = ' '"
				Endif
				
				cWhere += ")%"		

			Else
				cWhere := "%%"
			EndIf

			lAchouF0M := .T.
			
			cAliBLH := GetNextAlias()
			
			BeginSql Alias cAliBLH
			
			COLUMN F0M_DTFECH AS DATE 

			SELECT F0M_CODIGO,F0M_UM,F0M_QUANT,F0M_VUNIT,F0M_VALCMD,F0M_CLIFOR,F0M_LOJA,F0M_SITUA,F0M_TPCF,F0M_CONTA,F0M_CST,F0M_ALIQ,F0M_BASICM,F0M_TOTICM,F0M_VALICM
			FROM 	%TABLE:F0M% F0M
				WHERE  F0M.F0M_FILIAL=%XFILIAL:F0M%
				AND F0M.F0M_DTFECH = %Exp:DToS(dDataFec)%	
				AND F0M.%NOTDEL%	
				%Exp:cWhere%
			EndSql
			
			DbSelectArea (cAliBLH)
			
			
		ElseIF lSPDBlocH			
			cAliBLH	:= ''
			SPDBlocH(@cAliBLH,'',dDataFec)
			lAchouF0M := .F.
			
			If Empty(cAliBLH)
				Conout("Nao foi encontrado dados no retorno da funçao SPDBlocH")
				Loop				
			Else
				dbSelectArea(cAliBLH) 
				(cAliBLH)->(dbGoTop())
			Endif
		Else
			Conout("Não foi encontrada função SPDBlocH ou Dados na tabela F0M")
			Loop
		Endif
		
		nI	:= 0

		Do While (cAliBLH)->(!Eof()) 
			nI++			
			nBasIcm		:= 0
			nTotICM		:= 0
			nValICM		:= 0
			nICMSOP		:= 0
			nBCICMSST 	:= 0
			nICMSST   	:= 0
			nFCP		:= 0
			cClifor	:=	Space(ntamCli)
			cLoja	:=	Space(nTamLoj)
			cTPCF 		:= ""
			
			lATribF0Q 	:= .F.
			cSegUnid 	:= ''			
			cTpUnid 	:= ''
			nConvUnid 	:= 0
			nVlIteIR	:= 0
			lAchouCIL	:= .F.
			lPrintH005  := .F.
			lProcH020	:= .F.
		
			//Processa registros ja gravados na tabela F0M
			IF lAchouF0M

				cProd		:= PadR(Alltrim((cAliBLH)->F0M_CODIGO),nTamProd)   	// 01 - Produto.
				cUnid		:= (cAliBLH)->F0M_UM       	// 02 - Unidade.
				nQuant		:= (cAliBLH)->F0M_QUANT 		// 03 - Quantidade.
				nValUnit	:= (cAliBLH)->F0M_VUNIT	 	// 04 - Valor Unidade.
				nVlrIte 	:= (cAliBLH)->F0M_VALCMD     	// 05 - Valor Total.
				cClifor		:= (cAliBLH)->F0M_CLIFOR     	// 06 - Codigo do Cliente/Fornecedor.
				cLoja		:= (cAliBLH)->F0M_LOJA       	// 07 - Codigo da loja Cliente/Fornecedor.
				cSituacao 	:= (cAliBLH)->F0M_SITUA   	// 08 - Situacao do estoque.
				cTPCF		:= (cAliBLH)->F0M_TPCF       	// 09 - Cliente/Fornecedor.
				//F0M->F0M_FILIAL		// 10 - Filial.
				cCodCtaH010 := (cAliBLH)->F0M_CONTA		// 11 - Conta contabil
				cClasFis	:= (cAliBLH)->F0M_CST			// 12 - Classificacao fiscal
				nAliqProd	:= (cAliBLH)->F0M_ALIQ		// 13 - Aliquota Produto
				nBasIcm 	:= (cAliBLH)->F0M_BASICM		// 14 - Base ICMS H020
				nTotICM		:= (cAliBLH)->F0M_TOTICM		// 15 - Total ICMS H020
				nValICM		:= (cAliBLH)->F0M_VALICM        //Valor unitario do ICMS H020 Campo 4 //informar o ICMS aplicável ao item (valor unitário),
				
				//Tratamento para cadastros F0M antes da criação do campo F0M_VUNIT
				//Calculo realizado conforme MATXSPED
				IF nValUnit = 0
					nValUnit := Round(nVlrIte / nQuant,6)
				Endif
			Else
			//Processa Retorno da rotina SPDBlocH
				//Tratamento cliente e loja para produtos Em/De terceiro				
				IF (cAliBLH)->IND_PROP <> '0'
					cClifor		:= SubsTring((cAliBLH)->COD_PART,4,ntamCli)
					cLoja		:= SubsTring((cAliBLH)->COD_PART,4+ntamCli,nTamLoj)
					//Define cadastro  F = Fornecedor SA2 ou C =  Cliente SA1
					If SubsTring((cAliBLH)->COD_PART,1,3) == 'SA1'
						cTPCF		:= 'C'
					Else
						cTPCF		:= 'F'
					Endif
				Endif
				
				//(cAliBLH)->FILIAL,;		// 10 - Filial.
				cProd		:= PadR(Alltrim((cAliBLH)->COD_ITEM),nTamProd)   	// 01 - Produto.
				cUnid		:= (cAliBLH)->UNID      	// 02 - Unidade.
				nQuant		:= (cAliBLH)->QTD 			// 03 - Quantidade.
				nValUnit	:= (cAliBLH)->VL_UNIT		// 04 - Valor Unidade.
				nVlrIte		:= (cAliBLH)->VL_ITEM   	// 05 - Valor Total.
				cSituacao	:= (cAliBLH)->IND_PROP		// 08 - Situacao do estoque.

				nVlIteIR	:= IF((cAliBLH)->VL_ITEM_IR > 0,(cAliBLH)->VL_ITEM_IR,nVlrIte)	//11 - Valor do item para efeitos do Imposto de Renda.
				cCodCtaH010	:= (cAliBLH)->COD_CTA	// 11 - Conta contabil
				cClasFis	:= (cAliBLH)->COD_ORIG + (cAliBLH)->CL_CLASS	// 12 - Classificacao fiscal
				nAliqProd	:= (cAliBLH)->ALQ_PICM	// 13 - Aliquota Produto
			Endif

			//verifica se produto esta cadastrado na F0Q, caso sim não precisa verificar B5_ALTTRIB
			If lTipoinv .And. cMotInv $ "02|03|04|05" .And. F0Q->(MsSeek(aSPDFil[PFIL_F0Q]+DTOS(dDataFec)+PadR(Alltrim(cProd),nTamCOD)+cMotInv))
				lATribF0Q := .T.
			Endif
			
			IF nAliqProd <= 0 //Caso produto sem aliquota usa do parametro MV_ICMPAD
				nAliqProd	:= nAliqint
			Endif

			//Verifica se produto esta na tabela CIL - Apuração dos registros de ressarcimento C180, C185....
			If cMotInv == '06'											//CIL_FILIAL+CIL_PERIOD+CIL_PRODUT                                                                                                                                
				If CIL->(MsSeek( aSPDFil[PFIL_CIL] + cAnoMes + PadR(Alltrim(cProd),nTamCOD)))
					IF CIL->CIL_SPED == '1'
						lAchouCIL 	:=  .T.
						nICMSOP		:= CIL->CIL_MICM   //---Valor Médio Unitário Inicial ICMS OP
						nBCICMSST	:= CIL->CIL_MUBCST //---Valor Médio Unitário Inicial BC ICMS ST
						nICMSST		:= CIL->CIL_MUST   //---Valor Médio Unitário Inicial ICMS ST
						nFCP		:= CIL->CIL_MIFC   //---Valor Médio Unitário Inicial FECP ST
					Endif
				Endif
			Endif

			Do Case
				Case cMotInv == "01"
					lPrintH005 := lAchouF0M .or. lATribF0Q .Or. SpedMotInv(cMotInv,cProd,lCmpAltTri,@nAliqProd) .Or. lH020
				Case cMotInv == "02"
					lPrintH005 := lATribF0Q .Or. SpedMotInv(cMotInv,cProd,lCmpAltTri,@nAliqProd)
				Case cMotInv == "06"
					lPrintH005 := lAchouCIL
				OtherWise
					lPrintH005 := lATribF0Q //Os motivos 03, 04 e 05 são gerados à partir da tabela F0Q
			EndCase
			
			//Verifica se existe F0M, caso sim não precisa validar B5_ALTTRIB ou F0Q, validação foi feita na rotina FISA116
			If lPrintH005								
				
				//Quando operação De/Em Terceiro grava 0150 e flhos
				//³GRAVACAO REGISTRO 0150 - TABELA DE CADASTRO DE PARTICIPANTES
				//³GRAVACAO REGISTRO 0175 - ALTERACAO DA TABELA DE CADASTRO DE PARTICIPANTE
				If cSituacao $ '1|2' .And. !Empty(cClifor)
					If cTPCF=="F"
						If SA2->(MsSeek(aSPDFil[PFIL_SA2]+cClifor+cLoja))
							aPartDoc :=	InfPartDoc("SA2")
						EndIf
					ElseIf cTPCF=="C"
						If SA1->(MsSeek(aSPDFil[PFIL_SA1]+cClifor+cLoja))
							aPartDoc :=	InfPartDoc("SA1")
						EndIf
					Endif
					
					If !lExtTAF .And. Len(aPartDoc) > 0
						SDPF150175(@aReg0150,aPartDoc,cAlias,aWizard,aExistBloc)
					EndIf
					
					//Atualiza para Cliente/fornecedor conforme aPartDoc do registro 0150
					cClifor := Iif(Len(aPartDoc)>0,aPartDoc[1],"")
				Endif				
				
				If lExtTAF			    
					cProd 			:= 	cProd
				Else
					cProd 			:= 	cProd+Iif(lConcFil,aSPDFil[PFIL_SB1],"") 
				EndIF
				
				//Posicionando o cadastro de produtos para verificacao da funcao SFRG0200 // Gerar registro 0220 - Fatores de Conversão de Unidades
				If SB1->(MsSeek(aSPDFil[PFIL_SB1]+PadR(Alltrim(cProd),nTamProd)))
					cSegUnid		:= SB1->B1_SEGUM
					nConvUnid		:= SB1->B1_CONV
					cTpUnid			:= SB1->B1_TIPCONV
					//Caso não tenha sido informada conta pego do produto.
					IF Empty(cCodCtaH010)
						cCodCtaH010		:= SB1->B1_CONTA
					Endif
					//Caso não tenha sido informada Unidade pego do produto.
					IF Empty(cUnid)
						cUnid		:= SB1->B1_UM
					Endif
				Endif
				
				cUnidBkp := cUnid

				//Verificando se existe o PE SPDFIS07 para alterar a conta contabil obtida pelo sistema padrao
				If aExistBloc[16]
					cCodCtaH010 := 	ExecBlock("SPDFIS07", .F., .F., {cProd,cSituacao,''}) //Removido armazem
				EndIf
	
				//Ponto de entrada para taratmento da informação de produtos quando o mesmo estah fora do padrao do sistema
				If aExistBloc[05] 
					aProd := Execblock("SPEDPROD", .F., .F., {"SB1","H010",cUnid})
					If Len(aProd)>=11
						cProd 	:= 	aProd[1]
						cUnid	:=	aProd[5]
					Else
						aProd := {"","","","","","","","","","","",""}
					EndIf					
				EndIf
				
				If aExistBloc[01]
			  		aSpdFis02 := ExecBlock("SPDFIS02", .F., .F., {cAliBLH,,"H010"})

					If ValType(aSpdFis02)=="A"
						cUnid     := aSpdFis02[1]
						nQtde     := aSpdFis02[2]
						If Len(aSpdFis02) > 2
							nFatorPE  := aSpdFis02[3]
						EndIf
				    	If Len(aSpdFis02) > 3  
				    		cTpCv:= aSpdFis02[4]
				    	Endif				
					Else   
						cUnid     := ExecBlock("SPDFIS02", .F., .F., {cAliBLH,,"H010"})
					EndIf
				EndIf				
								
				If !lExtTAF
					//³GRAVACAO - REGISTRO 0200 PARA PRODUTOS DO INVENTARIO        ³
					SFRG0200(cAlias,@aReg0200,@aReg0190,dDataDe,dDataAte,aProd,cProd,@aReg0220,,cUnid,,lSPDFIS02,nFatorPe,,,,,,{cSegUnid,nConvUnid,cTpUnid},,,,,,,,aWizard,,cTpCv)										
				EndIf
				
				If lSPDFIS02 //Restaura a unidade padrão para gravação no H010 conforme o 0200
					cUnid		:= cUnidBkp      	// 02 - Unidade.
				Endif

				nX := aScan(aAuxH005, {|aX| aX[1]+Dtos(aX[3])==cMotInv+DTOS(dDataFec)})		
				If nX == 0
					aAdd (aAuxH005, {})
					nX	:=	Len(aAuxH005)			
					aAdd (aAuxH005[nX], cMotInv)			
					aAdd (aAuxH005[nX], 0)
					aAdd (aAuxH005[nX], dDataFec)
				Endif
				nRegPai := nX
				
				nPos		:= Ascan(aRegH010, {|x| x[1]==nRegPai .And. x[3]+x[8]+x[9] == cProd+cSituacao+cClifor})
				nPosH020	:= Ascan(aRegH020, {|x| x[1] == nPos .And. x[3] == cClasFis})
				cMsgh020	:= ""
				lProcF0M	:= .F.
				
				IF (!cMotInv $ "01|06".And. nVlrIte > 0) 
					cMsgh020  := cMVH020
					IF  !lPESPEDH020 .And. (lAchouF0M .Or. F0M->(MsSeek( aSPDFil[PFIL_F0M] + DTOS(dDataFec) + PadR(Alltrim(cProd),nTamCOD)+cClasFis+cSituacao+SubsTring(cClifor,4+len(Iif(lConcFil,cFilAnt,"")),ntamCli+nTamLoj))))
						lProcF0M := .T.
					Endif
				Endif
				
				If nPos==0
					aAdd (aRegH010, {})
					nPos := Len(aRegH010)
					aAdd (aRegH010[nPos], nRegPai) 				//00 - RELACIONAMENTO COM O CABECALHO
					aAdd (aRegH010[nPos], Iif( !lExtTAF, "H010", "T079AA" ))		//01-REG
					aAdd (aRegH010[nPos], cProd)				//02-COD_ITEM
					aAdd (aRegH010[nPos], cUnid)				//03-UNID
					aAdd (aRegH010[nPos], Iif( !lExtTAF, {nQuant,3}, nQuant))								//04-QTD
					aAdd (aRegH010[nPos], Iif( !lExtTAF, {nValUnit,6}, Val2Str( nValUnit, 16, 6 ) ) )		//05-VL_UNIT
					aAdd (aRegH010[nPos], nVlrIte)				//06-VL_ITEM							
					aAdd (aRegH010[nPos], cSituacao)			//07-IND_PROP
					aAdd (aRegH010[nPos], cClifor)				//08-COD_PART
					aAdd (aRegH010[nPos], cMsgh020)				//09-TXT_COMPL
					aAdd (aRegH010[nPos], cCodCtaH010)			//10-COD_CTA
					IF ddatade >= ctod('01/01/2015') 
						aAdd (aRegH010[nPos], nVlIteIR)			//11-VL_ITEM_IR
					EndIF
				Else

					If !lExtTAF
						aRegH010[nPos,5, 1]		+=	nQuant
					Else
						aRegH010[nPos,5]		+=	nQuant
					EndIf
					aRegH010[nPos,7]			+=	nVlrIte

					If nPosH020 <> 0
						If !lExtTAF
							aRegH010[nPos,6, 1]		+=	nValUnit
						Else
							aRegH010[nPos,6]		:= Val2Str(Val(aRegH010[nPos,6]) +nValUnit, 16, 6 )
						EndIf
					EndIf

					If ddatade >= ctod('01/01/2015')
						aRegH010[nPos,12]		+=	nVlIteIR
					EndIF		
				Endif	
				
				aAuxH005[nX][2] +=  nVlrIte				

				If cMotInv <> '06' .and. ( cMotInv <> "01" .Or. lH020) //.And. nVlrIte > 0 //H020 é obrigatorio para motivo de inventário diferente de 01 			
					//Caso esteja incluindo H010 e possuir PE ou F0M processa somente uma vez H020
					//Com Exceção do RS, pois a Legislação do Estado exige que seja enviado mais de 1 H020 para cada H010 agrupado por Produto + CST - DSERFIS1-29804
					If (lPESPEDH020 .Or. lProcF0M)
						IF lPESPEDH020
							aPeH020 := Execblock("SPEDH020", .F., .F., {aRegH010[nPos][3], cMotInv})
						EndIF
						
						IF Valtype(aPeH020) == 'A' .AND. Len(aPeH020) >= 1 .AND. Len(aPeH020[1]) >=3
							//Preencher H020 com informações do PE
							For nZ := 1 To Len(aPeH020)
								RegH020Sped(aRegH010, aRegH020, nPos, nPosH020, lExtTAF, aPeH020[nZ][1], aPeH020[nZ][2], aPeH020[nZ][3], lPESPEDH020)
							Next
							lProcH020		:= .F.
						ElseIf lExistF0M .And. lProcF0M
							//Novo tratamento pela rotina FISA116 (tabela F0M)							
							nH020BaseIcm 	:= nBasIcm		// 03 BC_ICMS
							nH020ValorIcm 	:= nValICM		// 04 VL_ICMS
							lProcH020		:= .T.
						Endif
					Endif
					
					//Caso esteja não exista PE ou F0M processa Soma H010
					IF  !lPESPEDH020 .And. !lProcF0M
						//Preencher H020 com informações do Inventário						
						nH020BaseIcm 	:= (nVlrIte/nQuant)							// 03 BC_ICMS
						nH020ValorIcm 	:= (((nVlrIte/nQuant)*nAliqProd) / 100)		// 04 VL_ICMS
						lProcH020		:= .T.
					EndIF

					If lProcH020						
						RegH020Sped(aRegH010, aRegH020, nPos, nPosH020, lExtTAF, cClasFis, nH020BaseIcm, nH020ValorIcm)
					EndIf
				Endif
					
				If cMotInv == "06" //Processa H030
					nPosH030	:=	aScan(aRegH030,{ |x| x[1]==nPos })
					If nPosH030 = 0
						aAdd (aRegH030, {})
						nPosH030	:=	Len(aRegH030)									
						aAdd (aRegH030[nPosH030], nPos)									
						aAdd (aRegH030[nPosH030], Iif( !lExtTAF, "H030", "" ) )			//01 REG											
						aAdd (aRegH030[nPosH030], nICMSOP)		//02 VL_ICMS_OP
						aAdd (aRegH030[nPosH030], nBCICMSST)	//03 VL_BC_ICMS_ST
						aAdd (aRegH030[nPosH030], nICMSST)		//04 VL_ICMS_ST	
						aAdd (aRegH030[nPosH030], nFCP)			//05 VL_FCP
					EndIf
				Endif
				
			EndIf		
			
			(cAliBLH)->(dbSkip())
		Enddo

		(cAliBLH)->(dbCloseArea())
		//Exclui tabela temporia do estoque quando usada
		If !lAchouF0M
			if lDelH010
				DelTblH010()
			else 
				Ferase(cAliBLH+GetDBExtension())
			endif
		Endif

		If cMotInv == '06' .And. nTipoMot06 = 1
			nTipoMot06 := 2 //---[1]-Alias SPDBlocH() [2]-Alias CIL---//
		EndIf

	Next nY
	If !lExtTAF .Or. (lExtTAF .And. "1" $ aWizard[1][5])
		SM0->(DbSkip ())
	ElseIf (lExtTAF .And. "2" $ aWizard[1][5])
		SM0->(DbSkip ())
		cFilAnt   := FWGETCODFILIAL
	EndIf
	
End
	
//³Restauro a area de processamento do SIGAMAT³
RestArea(aAreaSM0)
cFilAnt := FWGETCODFILIAL
aSPDFil	:= fGetSpdFil() // Refazendo o cache xFilial

If len(aAuxH005) > 0
	For nX := 1 To  len(aAuxH005)
		//³REGISTRO H005 - TOTAIS DO INVENTARIOS³
		aAdd(aRegH005, {})
		nY := Len(aRegH005)	
		aAdd (aRegH005[nY], Iif( !lExtTAF, "H005", "T079" ) )	//01 - REG
		aAdd (aRegH005[nY], aAuxH005[nX][3])					//02 - DT_FIN
		aAdd (aRegH005[nY], aAuxH005[nX][2])  		 			//03 - VL_INV
		If cVersao >= "006"
			aAdd (aRegH005[nY],	aAuxH005[nX][1])				//04 - MOT_INV
		Endif	
	Next

	If !lExtTAF	
		SPEDRegs(cAlias,{aRegH005,aRegH010,aRegH020,{aRegH030,2}})				
	Else
		aRegT079AA := aRegH010
		aRegT079AB := aRegH020		
	EndIf

	If lExtTAF
		aRegT079 := aRegH005
	EndIf
Else
	dDataFec :=	Iif( !lExtTAF, SToD(aWizard[1][8]), aWizard[2][9] )
	cMotInv	 :=	Iif( !lExtTAF, Substr(aWizard[1][19],1,2), Substr(aWizard[2][7],1,2) )	
	aAdd(aRegH005, {})
	aAdd (aRegH005[Len(aRegH005)], Iif( !lExtTAF, "H005", "T079" ) )	//01 - REG
	aAdd (aRegH005[Len(aRegH005)], dDataFec)							//02 - DT_FIN
	aAdd (aRegH005[Len(aRegH005)], nAcVlrEst)  		 					//03 - VL_INV
	If cVersao >= "006"
		aAdd (aRegH005[Len(aRegH005)],	cMotInv)						//04 - MOT_INV
	Endif

	If !lExtTAF	
		GrvRegTrS (cAlias,,aRegH005)
	Else
		aRegT079 := aRegH005
	EndIf
Endif
	
Return

//--------------------------------------------------------------------------------------------------
/*/{Protheus.doc} RegH020Sped
Função que irá realizar a gravação do Bloco H020

@author Matheus Bispo
@since 08/09/2022
@version 1.00
/*/
//--------------------------------------------------------------------------------------------------
Static Function RegH020Sped(aRegH010, aRegH020, nPos, nPosH020, lExtTAF, cClasFis, nBasIcm, nValICM, lPESPEDH020)
	
	If lPESPEDH020
		nPosH020 := Ascan(aRegH020, {|x| x[1] == nPos .And. x[3] == cClasFis})
	EndIf

	If nPosH020 == 0
		aAdd (aRegH020, {})
		nPosH020 :=	Len(aRegH020)
		aAdd (aRegH020[nPosH020], nPos)
		aAdd (aRegH020[nPosH020], Iif( !lExtTAF, "H020", "T079AB" ) )	// 01 REG
		aAdd (aRegH020[nPosH020], cClasFis)								// 02 CST_ICMS
		aAdd (aRegH020[nPosH020], nBasIcm)								// 03 BC_ICMS
		aAdd (aRegH020[nPosH020], nValICM)								// 04 VL_ICMS
	Else			
		aRegH020[nPosH020][4] += nBasIcm								// 03 BC_ICMS
		aRegH020[nPosH020][5] += nValICM								// 04 VL_ICMS
	EndIf

Return

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³Reg1100Spd | Autor ³Gustavo G. Rueda             ³ Data ³03.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡ao ³OPERACEOS DE EXPORTACAO DIRETA E INDIRETA                          ³±±
±±³          ³                                                                   ³±±
±±³          ³- Geracao e gravacao dos Registros 1100, 1105, 1110                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ExpL1 := Reg1100spd(cAlias,dDataDe,dDataAte,aReg0200,aReg0190,;    ³±±
±±³          ³                 aReg0220,aReg0150)                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cAlias -> Alias do TRB que recebera as informacoes                 ³±±
±±³          ³dDataDe  -> Data inicial do processamento do SPED Fiscal           ³±±
±±³          ³dDataAte -> Data final do processamento do SPED Fiscal             ³±±
±±³          ³aReg0200 -> Array com as informacoes a sere retornadads por        ³±±
±±³          ³ referencia para gerar o registro 0200                             ³±±
±±³          ³aReg0190 -> Array com as informacoes a sere retornadads por        ³±±
±±³          ³ referencia para gerar o registro 0190                             ³±±
±±³          ³aReg0220 -> Array com as informacoes a sere retornadads por        ³±±
±±³          ³ referencia para gerar o registro 0220                             ³±±
±±³          ³aReg0150 -> Array com as informacoes a serem retornadas por refe-  ³±±
±±³          ³ rencia para gerar o registro 0150                                 ³±±
±±³          ³aWizard  -> Informacoes do wizard da rotina                        ³±±
±±³          ³cFilDe -> Filial inicial para processament multifilial             ³±±
±±³          ³cFilAte -> Filial final para processament multifilial              ³±±
±±³          ³aLisFil -> Listas das filiais validas para processament multifilial³±±
±±³          |oProcess -> Objeto da nova barra de progressao                     ³±±
±±³          ³lEnd -> Flag de cancelamento de execucao                           ³±±
±±³          ³nCtdFil   -> Quantidade de registros da tabela SM0 que serao       ³±±
±±³          ³lEnd     -> Flag de encerramento do processamento da regua         ³±±
±±³          ³bWhileSM0 -> Condicao padrao para o while do SM0                   ³±±
±±³          ³             processados                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1 - Sempre .T.                                                 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function Reg1100Spd(cAlias,aReg0200,aReg0190,aReg0220,aReg0150,aWizard,cFilDe,cFilAte,aLisFil,oProcess,nCtdFil,lEnd,bWhileSM0,nCountTot,nRegsProc,lExtratTaf,aRegT066,aRegT066AA,aRegT066AB)

Local	aReg1100	:=	{}
Local	aReg1105	:=	{}
Local	aReg1110	:=	{}
Local	lRet		:=	.T.
Local	cAliasCDL	:=	"CDL"
Local	cProd		:=	""
Local 	cCFOPInd 	:= 	aSPDSX6[MV_EXPIND]  
Local	lCmpCDL		:= 	aSPDSX3[FP_CDL_DOCORI] .AND. aSPDSX3[FP_CDL_SERORI] 
Local 	lDocExp		:= 	aSPDSX3[FP_CDL_NFEXP] .AND. aSPDSX3[FP_CDL_SEREXP] .AND. aSPDSX3[FP_CDL_ESPEXP] .AND. aSPDSX3[FP_CDL_EMIEXP] .AND. aSPDSX3[FP_CDL_CHVEXP] .AND. aSPDSX3[FP_CDL_QTDEXP]
Local	cAliasQry	:=	"SFT"
Local	lTop		:=	.F.
Local	cAliasSB1	:=	"SB1"
Local	nPos1100	:=	0	
Local	nPos1105    :=	0
Local	nIndex		:= 	0  
Local   nRecnoCDL   :=  0
Local	cIndex		:= 	""
Local	cFiltro		:= 	""
Local	aGrava		:=	{}
Local	aProd		:=	Nil
Local	cUnid		:=	Nil
Local	aSpdFis02	:=	{}  
Local	dDataDe		:=	''
Local	dDataAte	:=	''
Local	nFilial		:=	0
Local	nEmpProc	:=	0
Local	aAreaSM0	:=	SM0->(GetArea())
Local   lReprocCDL  := 	.F.            
Local   lCDLItemNf  := 	aSPDSX3[FP_CDL_ITEMNF]
Local	cChvCDL		:=	""     
Local   cOrdBy      :=  ""
Local   aItemCDL    :=  {}
Local	nDBFRecOri	:=	0  
Local   lUltReg     := .F.
Local 	cSFTChv 	:= ""    
Local 	cChvWhl		:= ""

Default lExtratTaf := .F.

if !lExtratTAF
	dDataDe  := SToD(aWizard[1][1])
	dDataAte := STod(aWizard[1][2])
else
	dDataDe  := aWizard[1][3]
	dDataAte := aWizard[1][4]	
endif

SFT->(DbSetOrder(1))

//³Processamento de multifiliais³
DbSelectArea("SM0")
SM0->(DbGoTop())
SM0->(MsSeek(cEmpAnt+cFilDe, .T.))	//Pego a filial mais proxima 
	
//³Quando a opcao de seleciona filiais estiver configurada como sim, serah    ³
//³    considerado as filiais selecionadas no browse. Caso contrario, valera o³
//³    que estiver configurado na pergunta 'Filial DE/ATE'                    ³
Do While Eval(bWhileSM0)
	
	cFilAnt := FWGETCODFILIAL

	If Len(aLisFil)>0 .And. cFilAnt <= cFilAte
		nFilial := Ascan(aLisFil,{|x|x[2]==cFilAnt})
		If nFilial==0 .Or. !(aLisFil[nFilial,1])  //Filial não marcada, vai para proxima
			SM0->(dbSkip())
			Loop
		EndIf
	Else
		If (!lExtratTAF .and. "1" $ aWizard[1][12]) .or. (lExtratTAF .and. "1" $ aWizard[1][5])  //Somente faz skip se a opção de selecionar filiais estiver como Sim.
			SM0->( dbSkip())
			Loop
		EndIf		
	EndIf
	
	// Refazendo o cache do SX6 para cada filial.
	aSPDSX6 := SpedLoadX6()	

	// Refazendo o cache dos xFilial para cada filial.
	aSPDFil	:= fGetSpdFil()
	
	nEmpProc += 1

	//³Query para pegar todas as declaracoes de exportacao cadastrados na³
	//³ CDL e com data de avebacao no periodo                            ³
	#IFDEF TOP
		If (TcSrvType ()<>"AS/400")
			lTop		:=	.T.
			cAliasCDL	:=	GetNextAlias()
			cOrdBy      := "%"+SqlOrder(CDL->(IndexKey()))+"%"

			BeginSql Alias cAliasCDL

			COLUMN CDL_DTDE AS DATE
			COLUMN CDL_DTREG AS DATE
			COLUMN CDL_DTCHC AS DATE
			COLUMN CDL_DTAVB AS DATE
			COLUMN CDL_EMIEXP AS DATE

			SELECT * FROM %Table:CDL% CDL
			WHERE 
				CDL.CDL_FILIAL=%xFilial:CDL% AND 
				CDL.CDL_DTAVB>=%Exp:DToS(dDataDe)% AND 
				CDL.CDL_DTAVB<=%Exp:DToS(dDataAte)% AND 
				CDL.%NotDel%
			ORDER BY
				%Exp:cOrdBy%
			EndSql
		Else
	#ENDIF
			cIndex	:= CriaTrab(NIL,.F.)
			cFiltro	:= 'CDL_FILIAL=="'+aSPDFil[PFIL_CDL]+'".And.'
			cFiltro += 'DToS (CDL_DTAVB)>="'+DToS(dDataDe)+'".And.DToS(CDL_DTAVB)<="'+DToS(dDataAte)+'" '
			cOrdBy  := CDL->(IndexKey())
			IndRegua (cAliasCDL,cIndex,cOrdBy,,cFiltro)
			nIndex := RetIndex(cAliasCDL)
			#IFNDEF TOP
				DbSetIndex(cIndex+OrdBagExt())
			#ENDIF
			DbSelectArea(cAliasCDL)
			DbSetOrder(nIndex+1)
			CDL->(DBGOTOP())
	#IFDEF TOP
		Endif
	#ENDIF

	ProcRegua ((cAliasCDL)->(RecCount ()))

	lReprocCDL 	:= .F.       
	lUltReg     := .F.	
	nRecnoCDL  	:= 	0
	nDBFRecOri	:=	0
	cAlsCDLOld	:=	cAliasCDL 
	
	Do While !(cAliasCDL)->(Eof())

		nRegsProc	+=	1

		//³Tratamento abaixo (IF) se refere a uma implementacao no MATA926 que permite o usuario      ³
		//³  amarrar por item de documento fiscal a tabela CDL. Tambem foi implementado um facilitador³
		//³  que caso o item esteja em branco, ele possa ser considerado para os itens que nao foram  ³
		//³  amarrados 1:1. Ex: Em uma NF com 3 itens, pode-se incluir um CDL para o Item 1 e outro   ³
		//³  com o item em branco que passa a valer para o item 2 e 3.                                ³
	    If lCDLItemNf .And. !lUltReg .And. ;	//Tratamento somente para quando existir o campo CDL_ITEMNF, caso contrario, nada muda, fica como sempre esteve antes
	    	( cChvCDL <> (cAliasCDL)->( CDL_SERIE+CDL_DOC+CDL_CLIENT+CDL_LOJA ) .Or. ;		//Se mudar a NF e tiver recno para processar
	    	( cChvCDL == (cAliasCDL)->( CDL_SERIE+CDL_DOC+CDL_CLIENT+CDL_LOJA ) .And. Empty( (cAliasCDL)->CDL_ITEMNF ) ) )	//Se for a mesma nota e o item em branco nao for o primeiro da CDL

			//³Tratamento para o Recno do registro do CDL_ITEMNF em branco, pois preciso processa-lo quando mudar a chave³
	    	If nRecnoCDL > 0
	    		If !lTop	//Para TOP tenho duas tabelas de trabalho, a QUERY e a tabela FISICA CDL, em DBF nao, soh a CDL
	    			nDBFRecOri	:=	(cAliasCDL)->( Recno() )
	    		EndIf
   				CDL->(DbGoTo(nRecnoCDL))	//Posiciono no RECNO do CDL_ITEMNF em branco para processa-lo com os mesmos tratamentos abaixo, no final do SKIP, retorno as variaveis e o registro de onde parei para continuar o processamento
				//³Troco o alias da tabela somente para processar o registro em com o item em ³
				//³   branco que teve o recno armazenado. Depois de processar este CDL, volto ³
				//³   o alias da query e continuo da posicao que havia parado                 ³
				cAliasCDL	:=	"CDL"
	   			nRecnoCDL 	:= 	0

	    	Else
				cChvCDL		:=	(cAliasCDL)->( CDL_SERIE+CDL_DOC+CDL_CLIENT+CDL_LOJA )
	
				//³Para o CDL_ITEMNF em branco, quando for encontrado, armazeno o registro    ³
				//³  para processa-lo ao final da quebra por documento ou no final do arquivo.³
	    		If Empty( (cAliasCDL)->CDL_ITEMNF )
			    	nRecnoCDL	:=	(cAliasCDL)->( Iif( lTop , R_E_C_N_O_ , Recno() ) )
	    	        	    			
					//³Avanco para proximo registro³
			    	(cAliasCDL)->( dbSkip() )
			    				    	
					//³Se estiver em final de arquivo eu devo processar o while mais uma vez caso³
					//³possua RECNO armazenado                                                   ³
			    	If (cAliasCDL)->( Eof() )
   			    		If !lTop	//Para TOP tenho duas tabelas de trabalho, a QUERY e a tabela FISICA CDL, em DBF nao, soh a CDL
			    			nDBFRecOri	:=	(cAliasCDL)->( Recno() )
			    		EndIf
		   				CDL->(DbGoTo(nRecnoCDL))	//Posiciono no RECNO do CDL_ITEMNF em branco para processa-lo com os mesmos tratamentos abaixo, no final do SKIP, retorno as variaveis e o registro de onde parei para continuar o processamento
						//³Troco o alias da tabela somente para processar o registro em com o item em ³
						//³   branco que teve o recno armazenado. Depois de processar este CDL, volto ³
						//³   o alias da query e continuo da posicao que havia parado                 ³
		   				cAliasCDL	:=	"CDL"
		   				nRecnoCDL 	:= 	0
			    	Else
				    	Loop
				    EndIf
				EndIf
		    EndIf
		EndIf

		//³Gerando a estutura do registro 1100³
		If (nPos1100 := aScan(aReg1100,{|aX| aX[3]==(cAliasCDL)->CDL_NUMDE .And. aX[4]==(cAliasCDL)->CDL_DTDE .And. aX[6]==(cAliasCDL)->CDL_NRREG}))==0
			aAdd(aReg1100, {})
			nPos1100 := Len (aReg1100)                           
			aAdd (aReg1100[nPos1100], "1100")							//01 - REG
			aAdd (aReg1100[nPos1100], (cAliasCDL)->CDL_INDDOC)			//02 - IND_DOC
			aAdd (aReg1100[nPos1100], (cAliasCDL)->CDL_NUMDE)			//03 - NRO_DE
			aAdd (aReg1100[nPos1100], (cAliasCDL)->CDL_DTDE)			//04 - DT_DE
			aAdd (aReg1100[nPos1100], (cAliasCDL)->CDL_NATEXP)			//05 - NAT_EXP
			aAdd (aReg1100[nPos1100], (cAliasCDL)->CDL_NRREG)			//06 - NRO_DE
			aAdd (aReg1100[nPos1100], If((cAliasCDL)->CDL_INDDOC == "0",(cAliasCDL)->CDL_DTREG,""))			//07 - DT_RE
			aAdd (aReg1100[nPos1100], (cAliasCDL)->CDL_CHCEMB)			//08 - CHC_EMB
			aAdd (aReg1100[nPos1100], Iif(Empty((cAliasCDL)->CDL_DTCHC),"",(cAliasCDL)->CDL_DTCHC))			//09 - DT_CHC
			aAdd (aReg1100[nPos1100], (cAliasCDL)->CDL_DTAVB)			//10 - DT_AVB
			aAdd (aReg1100[nPos1100], (cAliasCDL)->CDL_TPCHC)			//11 - TP_CHC
			aAdd (aReg1100[nPos1100], (cAliasCDL)->CDL_PAIS)			//12 - PAIS
		EndIf

		//³Montando filtro para a tabela SFT que serah utilizada no processamento³
		cSFTChv := xFilial(cAliasQry)+"S"+(cAliasCDL)->CDL_SERIE+(cAliasCDL)->CDL_DOC+(cAliasCDL)->CDL_CLIENT+(cAliasCDL)->CDL_LOJA
		
		//³Tratamento para o campo CDL_ITEMNF, que deve fazer parte da query na SFT se existir na base de dados³
		If lCDLItemNf
			cSFTChv += (cAliasCDL)->CDL_ITEMNF 
		EndIf
		//³Para TOP faco um SELECT com JOIN nas tabelas SFT,SB1,SA1,SA1,³
		//³Para DBF faco um indregua na tabela SFT                      ³
		If SPedSeek(cAliasQry,1,cSFTChv)            
		
			cChvWhl := (cAliasQry)->(FT_FILIAL+FT_TIPOMOV+FT_SERIE+FT_NFISCAL+FT_CLIEFOR+FT_LOJA)  
			cChvWhl += Iif(lCDLItemNf,(cAliasQry)->FT_ITEM,"")      
			                                                                  
			Do While !(cAliasQry)->(Eof()) .AND. (cChvWhl==cSFTChv)   
				
				//³Tratamento para quando existir o campo CDL_ITEMNF³
				If lCDLItemNf
					If Empty( (cAliasCDL)->CDL_ITEMNF ) .And. ;
						(cAliasQry)->( aScan( aItemCDL, { |x| x == FT_NFISCAL + FT_SERIE + FT_CLIEFOR + FT_LOJA + FT_ITEM } ) ) > 0
					//³Tratamento para armazenar os itens jah processados, para quando for processar a CDL³
					//³  em branco nao repetir os itens jah processados.                                  ³
						(cAliasQry)->(DbSkip())
						Loop
				 	Else				
						Aadd( aItemCDL , (cAliasQry)->( FT_NFISCAL + FT_SERIE + FT_CLIEFOR + FT_LOJA + FT_ITEM ) )
					EndIf
				EndIf

				//³Identifica se, sendo uma exportacao indireta, se trata da remessa     ³
				//³com fim exclusivo de exportacao a uma comercial exportadora (Trading).³
				lExpInd := 	(cAliasCDL)->CDL_NATEXP == "1" .And. Alltrim((cAliasQry)->FT_CFOP)$cCFOPInd .And. lCmpCDL .And. lDocExp

				If !Empty((cAliasCDL)->CDL_PRODNF)
					cProd	:=	(cAliasCDL)->CDL_PRODNF+Iif(lConcFil,cFilAnt,"")				
				Else
					cProd	:=	(cAliasQry)->FT_PRODUTO+Iif(lConcFil,cFilAnt,"")
				EndIf

	            SB1->(MsSeek(aSPDFil[PFIL_SB1]+(cAliasQry)->FT_PRODUTO))
	
				//³Ponto de entrada para tratamento da informação de produtos quando o mesmo estah fora do padrao do sistema³
				If aExistBloc[05] 
					aProd := Execblock("SPEDPROD", .F., .F., {cAliasQry,"1105"})
					If Len(aProd)>=11
						cProd 	:= 	aProd[1]
						cUnid	:=	aProd[5]
					Else
						aProd := {"","","","","","","","","","","",""}
					EndIf					
				EndIf
	
				//³Processamento do ponto de entrada para alteracao da unidade de medida caso exista³
				If aExistBloc[01]
   					aSpdFis02 := ExecBlock("SPDFIS02", .F., .F., {cAliasQry,(cAliasQry)->FT_TIPOMOV,"1105"})
	
				   If ValType(aSpdFis02)=="A"
				      cUnid     := aSpdFis02[1]
				   Else   
				      cUnid     := ExecBlock("SPDFIS02", .F., .F., {cAliasQry,(cAliasQry)->FT_TIPOMOV,"1105"})
				   EndIf
				EndIf
	
				//³REGISTRO 0200 - TABELA DE IDENTIFICACAO DO ITEM³
				If aScan(aReg0200, {|aX| aX[2]==cProd})==0 .and. !lExtratTaf
					SFRG0200(cAlias,@aReg0200,@aReg0190,dDataDe,dDataAte,aProd,cProd,@aReg0220,cAliasSB1,cUnid,,,,,,,,,,,,,,,,,aWizard,lExtratTaf)
				EndIf
	
				//³REGISTRO 1105 - DOCUMENTOS FISCAIS DE EXPORTACAO³
	            nPos1105	:=	SPDReg1105(cAliasCDL,cProd,lExpInd,@aReg1105,nPos1100,cAliasQry)
	
				//³REGISTRO 1110 - OPERACOES DE EXPORTACOES INDIRETAS - MERCADORIAS DE TERCEIROS³
				//|                        So para exportacao indireta                          |
				If nPos1105>0 .And. lExpInd .And. aSPDSX3[FP_CDL_FORNEC] .And.;
				   aSPDSX3[FP_CDL_LOJFOR] .And. !Empty((cAliasCDL)->CDL_FORNEC)
	
					SPDReg1110(cAliasCDL,@aReg1110,nPos1105,cProd,@aReg0150,cAlias,aWizard,lExtratTaf)
				EndIf
	            
	  	   		(cAliasQry)->(DbSkip()) 
	  	   		
	  	   		cChvWhl := (cAliasQry)->(FT_FILIAL+FT_TIPOMOV+FT_SERIE+FT_NFISCAL+FT_CLIEFOR+FT_LOJA)  
				cChvWhl += Iif(lCDLItemNf,(cAliasQry)->FT_ITEM,"")    
			Enddo

		EndIf		
						
		If !lCDLItemNf	//Controle atraves do novo campo CDL_ITEMNF. Se o mesmo nao existir, continuo tratamento antigo
			(cAliasCDL)->(DbSkip())

		//³Se o campo CDL_ITEMNF existir, tenho que fazer alguns controles³
		Else
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Se o alias nao mudou significa que estah no processamento padrao da rotina.                  ³
			//³  Para ambiente TOP indica que nao foi encontrado o CDL_ITEMNF e posso seguir em frente      ³
			//³  Para ambiente DBF, o alias sempre serah CDL, entao tenho a consistencia abaixo que verifica³
			//³     se tive de mudar de registro em algum momento.                                          ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If cAliasCDL == cAlsCDLOld
	    		If nDBFRecOri > 0	//Se houver numeracao de RECNO quer dizer que foi encontrado o CDL_ITEMNF e que jah foi processado, portanto devo continuar de onde parou.
	    			(cAliasCDL)->( DbGoTo( nDBFRecOri ) )
	    			nDBFRecOri	:=	0	//Restauro ZERO quando voltar no registro original, para nao deixar sujeira na variavel
	    		EndIf
	    			
				(cAliasCDL)->(DbSkip())				
	
		    	If (cAliasCDL)->( Eof() ) .And. nRecnoCDL > 0
		    		If !lTop	//Para TOP tenho duas tabelas de trabalho, a QUERY e a tabela FISICA CDL, em DBF nao, soh a CDL
		    			nDBFRecOri	:=	(cAliasCDL)->( Recno() )
		    		EndIf
	   				CDL->(DbGoTo(nRecnoCDL))
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Troco o alias da tabela somente para processar o registro em com o item em ³
					//³   branco que teve o recno armazenado. Depois de processar este CDL, volto ³
					//³   o alias da query e continuo da posicao que havia parado                 ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	   				cAliasCDL	:=	"CDL" 	   				
	   				nRecnoCDL 	:= 	0   
	   				lUltReg     := .T.
	   			EndIf
	   		Else
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Utilizo o ALIAS inicial do processamento para continuar a executar o³
				//³while do ponto em que parou para gerar o registro com item em branco³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	    		cAliasCDL	:=	cAlsCDLOld
			Endif
		EndIf
	EndDo

	// Fecha o alias
	(cAliasCDL)->(DbCloseArea())

	SM0->(dbSkip())
EndDo

//³Restauro a area do SM0³
RestArea(aAreaSM0)
cFilAnt := FWGETCODFILIAL
aSPDFil	:= fGetSpdFil() // Refazendo o cache xFilial

if lExtratTaf
	aRegT066   := aReg1100
	aRegT066AA := aReg1105
	aRegT066AB := aReg1110
else
	aAdd(aGrava,aReg1100)
	aAdd(aGrava,aReg1105)
	aAdd(aGrava,aReg1110)
	SPEDRegs(cAlias,aGrava,"1100/1105/1110")
endif
		
Return(lRet)
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³SPDReg1105| Autor ³Gustavo G. Rueda              ³ Data ³03.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡ao ³DOCUMENTOS FISCAIS DE EXPORTACAO                                   ³±±
±±³          ³- Geracao do Registro 1105                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ExpN1 := SPDReg1105(cAliasCDL,cProd,lExpInd,aReg1105,nPos1100,;       ³±±
±±³          ³                 cAliasQry)                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cAliasCDL -> Alias para utilizacao da tabela CDL                   ³±±
±±³          ³cProd     -> Codigo do produto formatado pelo SPED Fiscal          ³±±
±±³          ³lExpInd   -> Flag de indicacao de uma exportacao indireta          ³±±
±±³          ³aReg1105  -> Array com a estrutura do registro 1105 a ser          ³±±
±±³          ³             gravado no futuro.                                    |±±
±±³          ³nPos1100  -> Posicao para relacionamento com o registro 1100       ³±±
±±³          ³cAliasQry -> Alias para a query/indregua na tabela SFT             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpN1 - Posicao da informacao dentro do array aReg1105             ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function SPDReg1105(cAliasCDL,cProd,lExpInd,aReg1105,nPos1100,cAliasQry)
	Local nProc   := 0
	Local nPos    := 0
	Local cModelo := aModNot((cAliasQry)->FT_ESPECIE)
	Local cSerie  := SpedSerie((cAliasQry)->FT_SERIE, cModelo)//Função que trada a SERIE

	// conforme chamado TTBGRC, foi verificado que este bloco não deve olhar a CDL
	// Pois o mesmo estará informando apenas a nota de exportação
	// as notas informadas no complemento dever ser registradas no registro 1110
	nProc := aScan(aReg1105, {|aX| aX[1]==nPos1100 .And.;
							aX[3]==cModelo .And. ;
							aX[4]==cSerie .And. ;
							aX[5]==(cAliasQry)->FT_NFISCAL .And. ;
							aX[6]==(cAliasQry)->FT_CHVNFE .And. ;
							aX[7]==(cAliasQry)->FT_EMISSAO .And. ;
							aX[8]==cProd})
	If nProc==0
		aAdd(aReg1105, {})
		nPos	:=	Len (aReg1105)
		aAdd (aReg1105[nPos], nPos1100)								//Posicao de relacionamento com o registro 1100
		aAdd (aReg1105[nPos], "1105" )								//01 - REG
		aAdd (aReg1105[nPos], cModelo)								//02 - COD_MOD
		aAdd (aReg1105[nPos], cSerie)								//03 - SERIE
		aAdd (aReg1105[nPos], (cAliasQry)->FT_NFISCAL)				//04 - NUM_DOC
		aAdd (aReg1105[nPos], (cAliasQry)->FT_CHVNFE)				//05 - CHV_NFE
		aAdd (aReg1105[nPos], (cAliasQry)->FT_EMISSAO)				//06 - DT_DOC
		aAdd (aReg1105[nPos], cProd)								//07 - COD_ITEM
	Else
		nPos	:= nProc
	EndIf

Return (nPos)
/*ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³SPDReg1110| Autor ³Gustavo G. Rueda              ³ Data ³03.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡ao ³DOCUMENTOS FISCAIS DE EXPORTACAO INDIRETA                          ³±±
±±³          ³- Geracao do Registro 1110                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ExpN1 := SPDReg1110(cAliasCDL,aReg1110,nPos1105,cProd,aReg0150,cAlias)³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cAliasCDL -> Alias para utilizacao da tabela CDL                   ³±±
±±³          ³aReg1110  -> Array com a estrutura do registro 1110 a ser          ³±±
±±³          ³             gravado no futuro.                                    |±±
±±³          ³nPos1105  -> Posicao para relacionamento com o registro 1105       ³±±
±±³          ³cProd     -> Codigo do produto formatado pelo SPED Fiscal          ³±±
±±³          ³aReg0150  -> Array com a estrutura do registro 0150 a ser          ³±±
±±³          ³             gravado no futuro.                                    |±±
±±³          ³cAlias    -> Alias do arquivo temporario para geracao do TXT       |±±
±±³          ³aWizard   -> Informacoes do wizard da rotina                       ³±±
±±³          ³lExtTaf   -> Indica se a chamada da rotina foi o Extrator          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1 - Sempre .T.                                                 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function SPDReg1110(cAliasCDL,aReg1110,nPos1105,cProd,aReg0150,cAlias,aWizard,lExtTaf)
Local	lRet		:=	.T.
Local	nPos		:=	0
Local	aPartDoc	:=	{}
Local	cUnid		:=	SD2->D2_UM
Local	nQtde		:=	SD2->D2_QUANT	  
Local	cModelo		:= ""
Local	cSerie		:= ""
Local	nDecimal	:= TamSX3("D2_QUANT")[2]	  

Default lExtTaf     := .F.

//Posiciono o fornecedor do documento fiscal para utilizar mais abaixo
//na gravacao dos registro 0150 e 0175
If SPEDSeek("SA2",,aSPDFil[PFIL_SA2]+(cAliasCDL)->(CDL_FORNEC+CDL_LOJFOR))
	aPartDoc	:=	InfPartDoc("SA2",,,,,,,lExtTaf)
	
	//³GRAVACAO REGISTRO 0150 - TABELA DE CADASTRO DE PARTICIPANTES            ³
	//³GRAVACAO REGISTRO 0175 - ALTERACAO DA TABELA DE CADASTRO DE PARTICIPANTE³
	If !lExtTaf
		SDPF150175(@aReg0150,aPartDoc,cAlias,aWizard,aExistBloc)
	EndIf
		
	//³Este seek na tabela SF3 eh para pegar a nota de entreda da mercadoria de exportacao.³
	//³ Serah utilizada algumas informacoes dela para montar o registro                    ³
	If SPEDSeek("SF3",5,aSPDFil[PFIL_SF3]+(cAliasCDL)->(CDL_SERORI+CDL_DOCORI+CDL_FORNEC+CDL_LOJFOR))
		aAdd(aReg1110, {})
		nPos	:=	Len (aReg1110)
		
		aAdd (aReg1110[nPos], nPos1105)							//Posicao de relacionamento com o registro pai, 1105
		aAdd (aReg1110[nPos], "1110" )							//01 - REG			

		cModelo	:=	AModNot(SF3->F3_ESPECIE)
		cSerie	:=	SpedSerie(SF3->F3_SERIE,cModelo)
				
		aAdd (aReg1110[nPos], aPartDoc[1])							//02 - COD_PART FORNECEDOR DA MERCADORIA DESTINADA A EXPORTACAO
		aAdd (aReg1110[nPos], cModelo)								//02 - COD_MOD DO DOCUMENTO FISCAL DE ENTRADA
		aAdd (aReg1110[nPos], cSerie)								//03 - SERIE DO DOC DE ENTRADA
		aAdd (aReg1110[nPos], SF3->F3_NFISCAL)						//04 - NUM_DOC DO DOC DE ENTRADA
		aAdd (aReg1110[nPos], SF3->F3_EMISSAO)						//05 - DT_DOC DE EMISSAO DO DOC DE ENTRADA
		aAdd (aReg1110[nPos], IIf(aSPDSX3[FP_F3_CHVNFE],SF3->F3_CHVNFE,""))					//06 - CHV_NFE DO DOC DE ENTRADA
		aAdd (aReg1110[nPos], (cAliasCDL)->CDL_NRMEMO)				//07 - NR_MEMO DE EXPORTACAO
		aAdd (aReg1110[nPos], 0)									//08 - QTD EFETIVAMENTE EXPORTADA
		aAdd (aReg1110[nPos], "")									//09 - UNID DO PRODUTO
		//³Este seek se faz necessario porque as duas ultimas informacoes do registro  ³
		//³ sao referentes a nota de exportacao e para exportacao indireta, temos outro³
		//³ documento para este fim, portanto temos que posiciona-lo e utilizar o      ³
		//| produto correspondente                                                     |
		If SPEDSeek("SD2",3,aSPDFil[PFIL_SD2]+(cAliasCDL)->(CDL_NFEXP+CDL_SEREXP))		
			While !SD2->(Eof()) .And. SD2->(D2_DOC+D2_SERIE)==(cAliasCDL)->(CDL_NFEXP+CDL_SEREXP)
				If SD2->D2_COD==SubStr(cProd,1,TamSx3("D2_COD")[1])				
					cUnid	:=	SD2->D2_UM
					nQtde	:=	(cAliasCDL)->CDL_QTDEXP							
					//³IF lAchouSF4, significa que achou o SD1/SD2 e tambem o SF4,      ³
					//³  por isso faco este tratamento, senao nao executo o PE, mantendo³
					//³  a regra definida anteriormente.                                ³
					//|                                                                 |
					//|Este PE eh utilizado para quando se deseja alterar a UM e a      |
					//| quantidade padrao calculada pelo sistema. Eh mais utilizado     |
					//| quando se utiliza a quantidade na segunda unidade de medida     |
					If aExistBloc[01]
 						aSpdFis02 := ExecBlock("SPDFIS02", .F., .F., {"SD2","S"})
					   If ValType(aSpdFis02)=="A"
					      cUnid     := aSpdFis02[1]
					      nQtde     := aSpdFis02[2]
					   Else   
	  				      cUnid     := ExecBlock("SPDFIS02", .F., .F., {"SD2","S"})
					   EndIf
					EndIf	
					
					aReg1110[nPos][10] :=	{nQtde,Iif(nDecimal > 3,3,nDecimal)}	 		//08 - QTD EFETIVAMENTE EXPORTADA
					aReg1110[nPos][11] :=	cUnid			   			//09 - UNID DO PRODUTO												
					Exit
				EndIf				
				SD2->(dbSkip())
			End
		Else  // D1_FILIAL, D1_DOC, D1_SERIE, D1_FORNECE, D1_LOJA, D1_COD, D1_ITEM, R_E_C_N_O_, D_E_L_E_T_
			IF SPEDSeek("SD1",1,aSPDFil[PFIL_SD1]+(cAliasCDL)->(CDL_DOCORI+CDL_SERORI+CDL_FORNEC+CDL_LOJFOR+CDL_PRODNF+CDL_ITEORI))	

					cUnid	:=	SD1->D1_UM
					nQtde	:=	(cAliasCDL)->CDL_QTDEXP		
					If aExistBloc[01]
 						aSpdFis02 := ExecBlock("SPDFIS02", .F., .F., {"SD2","S"})
					   If ValType(aSpdFis02)=="A"
					      cUnid     := aSpdFis02[1]
					      nQtde     := aSpdFis02[2]
					   Else   
	  				      cUnid     := ExecBlock("SPDFIS02", .F., .F., {"SD2","S"})
					   EndIf
					EndIf

					aReg1110[nPos][10] :=	{nQtde,Iif(nDecimal > 3,3,nDecimal)}	 		//08 - QTD EFETIVAMENTE EXPORTADA
					aReg1110[nPos][11] :=	cUnid	
			Endif				
		EndIf
	EndIf	        	
EndIf

Return (lRet)
/*ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³Reg1100Av | Autor ³Gustavo G. Rueda              ³ Data ³07.04.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡ao ³OPERACEOS DE EXPORTACAO DIRETA E INDIRETA                          ³±±
±±³          ³                                                                   ³±±
±±³          ³- Geracao e gravacao dos Registros 1100, 1105, 1110                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ExpL1 := eg1100Av(cAlias,dDataDe,dDataAte,aReg0200,aReg0190,;      ³±±
±±³          ³                 aReg0220,aReg0150)                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cAlias -> Alias do TRB que recebera as informacoes                 ³±±
±±³          ³aReg0200 -> Array com as informacoes a sere retornadads por        ³±±
±±³          ³ referencia para gerar o registro 0200                             ³±±
±±³          ³aReg0190 -> Array com as informacoes a sere retornadads por        ³±±
±±³          ³ referencia para gerar o registro 0190                             ³±±
±±³          ³aReg0220 -> Array com as informacoes a sere retornadads por        ³±±
±±³          ³ referencia para gerar o registro 0220                             ³±±
±±³          ³aReg0150 -> Array com as informacoes a serem retornadas por refe-  ³±±
±±³          ³ rencia para gerar o registro 0150                                 ³±±
±±³          ³aWizard  -> Informacoes do wizard da rotina                        ³±±
±±³          ³cFilDe -> Filial inicial para processament multifilial             ³±±
±±³          ³cFilAte -> Filial final para processament multifilial              ³±±
±±³          ³aLisFil -> Listas das filiais validas para processament multifilial³±±
±±³          |oProcess -> Objeto da nova barra de progressao                     ³±±
±±³          ³lEnd -> Flag de cancelamento de execucao                           ³±±
±±³          ³nCtdFil   -> Quantidade de registros da tabela SM0 que serao       ³±±
±±³          ³lEnd     -> Flag de encerramento do processamento da regua         ³±±
±±³          ³bWhileSM0 -> Condicao padrao para o while do SM0                   ³±±
±±³          ³             processados                                           ³±±
±±³          ³nCountTot -> Total de registros a serem processados no periodo     ³±±
±±³          ³nRegsProc -> Registros jah processados antes da chamada desta funca³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nil                                                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGAFIS - SPEDFISCAL                                              ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function Reg1100Av(cAlias,aReg0200,aReg0190,aReg0220,aReg0150,aWizard,cFilDe,cFilAte,aLisFil,oProcess,nCtdFil,lEnd,bWhileSM0,nCountTot,nRegsProc,lExtratTaf,aRegT066,aRegT066AA,aRegT066AB)
Local	aReg1100	:=	{}
Local	aReg1105	:=	{}
Local	aReg1110	:=	{}
Local	nPos1100	:=	0	
Local	nPos1105	:=	0
Local	dDataDe		:=	''
Local	dDataAte	:=	''
Local	aGrava		:=	{}
Local	nFilial		:=	0
Local	nEmpProc	:=	0
Local	aAreaSM0	:=	SM0->(GetArea())

Default lExtratTaf := .F.

if !lExtratTAF
	dDataDe  := SToD(aWizard[1][1])
	dDataAte := STod(aWizard[1][2])
else
	dDataDe  := aWizard[1][3]
	dDataAte := aWizard[1][4]	
endif

//³Processamento de multifiliais³
DbSelectArea ("SM0")
SM0->(DbGoTop ())
SM0->(MsSeek (cEmpAnt+cFilDe, .T.))	//Pego a filial mais proxima 
	
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Quando a opcao de seleciona filiais estiver configurada como sim, serah    ³
//³    considerado as filiais selecionadas no browse. Caso contrario, valera o³
//³    que estiver configurado na pergunta 'Filial DE/ATE'                    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Do While Eval(bWhileSM0)

	cFilAnt := FWGETCODFILIAL

	If Len(aLisFil)>0 .And. cFilAnt <= cFilAte
		nFilial := Ascan(aLisFil,{|x|x[2]==cFilAnt})
		If nFilial==0 .Or. !(aLisFil[nFilial,1])  //Filial não marcada, vai para proxima
			SM0->(dbSkip())
			Loop
		EndIf
	Else
		If (!lExtratTAF .and. "1" $ aWizard[1][12]) .or. (lExtratTAF .and. "1" $ aWizard[1][5])  //Somente faz skip se a opção de selecionar filiais estiver como Sim.
			SM0->(dbSkip())
			Loop
		EndIf
	EndIf

	// Refazendo o cache do SX6 para cada filial.
	aSPDSX6 := SpedLoadX6()

	// Refazendo o cache dos xFilial para cada filial.
	aSPDFil	:= fGetSpdFil()

	nEmpProc += 1

	//³Processamento da funcao da Average que retorna os avisos de embarque conforme regras do SIGAEEC³
	//|                                                                                               |
	//|                     FUNCAO DISPONIBILIZADA PELA AVEGARE - FONTE AVGERAL.PRW                   |
	AvGetExpSped(dDataDe,dDataAte,lConcFil)
	
	If Select("SPED1100")>0
		DbSelectArea("SPED1100")
		SPED1100->(DbGoTop())
	
		While !SPED1100->(Eof())

			nRegsProc += 1

			//³Gerando a estutura do registro 1100³
	        If (nPos1100 := aScan(aReg1100,{|aX| aX[3]== SPED1100->NRO_DE .And. aX[4]== SPED1100->DT_DE .And. aX[6]== SPED1100->NRO_RE}))==0
				aAdd(aReg1100,{})
				nPos1100 := Len(aReg1100)
				aAdd (aReg1100[nPos1100], "1100")							//01 - REG
				aAdd (aReg1100[nPos1100], SPED1100->IND_DOC)		 		//02 - IND_DOC
				aAdd (aReg1100[nPos1100], SPED1100->NRO_DE)		 			//03 - NRO_DE
				aAdd (aReg1100[nPos1100], SPED1100->DT_DE)			 		//04 - DT_DE
				aAdd (aReg1100[nPos1100], SPED1100->NAT_EXP)		 		//05 - NAT_EXP
				aAdd (aReg1100[nPos1100], SPED1100->NRO_RE)		   			//06 - NRO_RE
				aAdd (aReg1100[nPos1100], If(SPED1100->IND_DOC == "0",SPED1100->DT_RE,""))		   	   		//07 - DT_RE
				aAdd (aReg1100[nPos1100], SPED1100->CHC_EMB)				//08 - CHC_EMB
				aAdd (aReg1100[nPos1100], SPED1100->DT_CHC)		   			//09 - DT_CHC
				aAdd (aReg1100[nPos1100], SPED1100->DT_AVB)		   			//10 - DT_AVB
				aAdd (aReg1100[nPos1100], SPED1100->TP_CHC)		   			//11 - TP_CHC
				aAdd (aReg1100[nPos1100], SPED1100->PAIS)		   			//12 - PAIS
	        EndIf
	        
			If Select("SPED1105")>0	
				//³REGISTRO 1105 - DOCUMENTOS FISCAIS DE EXPORTACAO³
				nPos1105	:=	Reg1105Av(SPED1100->PREEMB,SPED1100->ID,nPos1100,@aReg1105,@aReg0200,@aReg0190,dDataDe,dDataAte,@aReg0220,cAlias,aWizard,lExtratTaf)
	
				If Select("SPED1110")>0	
					//³REGISTRO 1110 - OPERACOES DE EXPORTACOES INDIRETAS - MERCADORIAS DE TERCEIROS³
					//|                        So para exportacao indireta                          |
					Reg1110Av(SPED1100->PREEMB,SPED1100->ID,@aReg1110,nPos1105,@aReg0150,cAlias,aWizard,lExtratTaf)
				EndIf
			EndIf
			
			SPED1100->(dbSkip ())	
		End

	EndIf

	SM0->(dbSkip())
End

//³Restauro a area do SM0³
RestArea(aAreaSM0)
cFilAnt := FWGETCODFILIAL
aSPDFil	:= fGetSpdFil() // Refazendo o cache xFilial

if lExtratTaf
	aRegT066   := aReg1100
	aRegT066AA := aReg1105
	aRegT066AB := aReg1110
else
	aAdd(aGrava,aReg1100)
	aAdd(aGrava,aReg1105)
	aAdd(aGrava,aReg1110)
	SPEDRegs(cAlias,aGrava,"1100/1105/1110")
endif

Return
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³Reg1105Av | Autor ³Gustavo G. Rueda              ³ Data ³07.04.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡ao ³DOCUMENTOS FISCAIS DE EXPORTACAO                                   ³±±
±±³          ³                                                                   ³±±
±±³          ³- Geracao do Registro 1105                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ExpN1 := Reg1105Av(cEmbarque,nPos1100,aReg1105,aReg0200,aReg0190,; ³±±
±±³          ³                 dDataDe,dDataAte,aReg0220,cAlias)                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cEmbarque -> Numero de embarque                                    ³±±
±±³          ³nPos1100  -> Posicao para relacionamento com o registro 1100       ³±±
±±³          ³aReg1105  -> Array com a estrutura do registro 1105 a ser          ³±±
±±³          ³             gravado no futuro.                                    |±±
±±³          ³aReg0200 -> Array com as informacoes a sere retornadads por        ³±±
±±³          ³ referencia para gerar o registro 0200                             ³±±
±±³          ³aReg0190 -> Array com as informacoes a sere retornadads por        ³±±
±±³          ³ referencia para gerar o registro 0190                             ³±±
±±³          ³dDataDe  -> Data inicial do processamento do SPED Fiscal           ³±±
±±³          ³dDataAte -> Data final do processamento do SPED Fiscal             ³±±
±±³          ³aReg0220 -> Array com as informacoes a sere retornadads por        ³±±
±±³          ³ referencia para gerar o registro 0220                             ³±±
±±³          ³cAlias -> Alias do TRB que recebera as informacoes                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpN1 - Posicao da informacao dentro do array aReg1105             ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function Reg1105Av(cEmbarque,cID,nPos1100,aReg1105,aReg0200,aReg0190,dDataDe,dDataAte,aReg0220,cAlias,aWizard,lExtratTaf)
Local   nPos1105	:=	0
Local 	cProd		:= 	""
Local	aProd		:=	Nil
Local	aSpdFis02	:=	{}  
Local	cUnid		:=	""
Local 	nProc		:= 0

Default cEmbarque	:= 	""

SPED1105->(MsSeek(cEmbarque+cID))
While !SPED1105->(Eof()) .And. cEmbarque+cID==SPED1105->(PREEMB+ID)
	
	nProc := aScan(aReg1105, {|aX| aX[1]==nPos1100		.And.;
							aX[3]==SPED1105->COD_MOD	.And.;
							aX[4]==SPED1105->SERIE		.And.;
							aX[5]==SPED1105->NUM_DOC	.And.;
							aX[6]==SPED1105->CHV_NFE	.And.;
							aX[7]==SPED1105->DT_DOC		.And.;
							aX[8]==SPED1105->COD_ITEM		})
	If nProc==0
		aAdd(aReg1105, {})
		nPos1105 := Len (aReg1105)
		aAdd (aReg1105[nPos1105], nPos1100)								//Posicao de relacionamento com o registro 1100
		aAdd (aReg1105[nPos1105], "1105")				   				//01 - REG	
		aAdd (aReg1105[nPos1105], SPED1105->COD_MOD)	   				//02 - COD_MOD
		aAdd (aReg1105[nPos1105], SPED1105->SERIE)						//03 - SERIE
		aAdd (aReg1105[nPos1105], SPED1105->NUM_DOC)					//04 - NUM_DOC
		aAdd (aReg1105[nPos1105], SPED1105->CHV_NFE)					//05 - CHV_NFE
		aAdd (aReg1105[nPos1105], SPED1105->DT_DOC)						//06 - DT_DOC
		aAdd (aReg1105[nPos1105], SPED1105->COD_ITEM)		  			//07 - COD_ITEM			
	Else
		nPos1105	:= nProc
	EndIf

		
	If SB1->(MsSeek(aSPDFil[PFIL_SB1]+SPED1105->COD_ITEM))
		
		cProd 	:= 	SB1->B1_COD+Iif(lConcFil,cFilAnt,"")
		cUnid	:=	SB1->B1_UM
		//³Ponto de entrada para tratamento da informação de produtos quando o mesmo estah fora do padrao do sistema³
		If aExistBloc[05] 
			aProd := Execblock("SPEDPROD", .F., .F., {"SPED1105","1105"})
			If Len(aProd)>=11
				cProd 	:= 	aProd[1]
				cUnid	:=	aProd[5]
			Else
				aProd := {"","","","","","","","","","","",""}
			EndIf					
		EndIf

		//³Processamento do ponto de entrada para alteracao da unidade de medida caso exista³
		If aExistBloc[01]
			aSpdFis02 := ExecBlock("SPDFIS02", .F., .F., {"SPED1105","S","1105"})

		   If ValType(aSpdFis02)=="A"
		      cUnid     := aSpdFis02[1]
		   Else   
			  cUnid     := ExecBlock("SPDFIS02", .F., .F., {"SPED1105","S","1105"})
		   EndIf
		EndIf

		//³REGISTRO 0200 - TABELA DE IDENTIFICACAO DO ITEM³
		If aScan(aReg0200,{|aX| aX[2]==cProd})==0 .and. !lExtratTaf
			SFRG0200(cAlias,@aReg0200,@aReg0190,dDataDe,dDataAte,aProd,cProd,@aReg0220,,cUnid,,,,,,,,,,,,,,,,,aWizard,lExtratTaf)
		EndIf
	EndIf 	

	SPED1105->(dbSkip())
End
Return nPos1105
/*ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³Reg1110Av | Autor ³Gustavo G. Rueda              ³ Data ³07.04.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡ao ³DOCUMENTOS FISCAIS DE EXPORTACAO INDIRETA                          ³±±
±±³          ³                                                                   ³±±
±±³          ³- Geracao do Registro 1110                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³Reg1110Av(cEmbarque,aReg1110,nPos1105,aReg0150,cAlias,aWizard)     ³±±
±±³          ³                                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cEmbarque -> Numero do aviso de embarque                           ³±±
±±³          ³aReg1110  -> Array com a estrutura do registro 1110 a ser          ³±±
±±³          ³             gravado no futuro.                                    |±±
±±³          ³nPos1105  -> Posicao para relacionamento com o registro 1105       ³±±
±±³          ³aReg0150  -> Array com a estrutura do registro 0150 a ser          ³±±
±±³          ³             gravado no futuro.                                    |±±
±±³          ³cAlias    -> Alias do arquivo temporario para geracao do TXT       |±±
±±³          ³aWizard   -> Informacoes do wizard da rotina                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nil                                                                ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function Reg1110Av(cEmbarque,cID,aReg1110,nPos1105,aReg0150,cAlias,aWizard,lExtratTaf)
Local	nPos		:=	0
Local	cCodLoj		:=	""
Local	aPartDoc	:=	{}
Local	nDecimal	:= TamSX3("EYY_QUANT")[2]

Default cEmbarque	:= ""

SPED1110->(MsSeek(cEmbarque+cID))
While !SPED1110->(Eof ()) .And. cEmbarque+cID==SPED1110->(PREEMB+ID)

	cCodLoj	:=	Right(Alltrim(SPED1110->COD_PART),TamSx3("A2_COD")[1]+TamSx3("A2_LOJA")[1])

	//³GRAVACAO - REGISTRO 0150        ³    
	If SA2->(MsSeek(aSPDFil[PFIL_SA2]+cCodLoj))
		aPartDoc	:=	InfPartDoc("SA2",,,,,,,lExtratTaf)
	EndIf
	
	aAdd(aReg1110, {})
	nPos	:=	Len(aReg1110)
	aAdd (aReg1110[nPos], nPos1105)	  						//Posicao de relacionamento com o registro pai, 1105
	aAdd (aReg1110[nPos], "1110")				   			//01 - REG
	aAdd (aReg1110[nPos], aPartDoc[1] )					//02 - COD_PART FORNECEDOR DA MERCADORIA DESTINADA A EXPORTACAO
	aAdd (aReg1110[nPos], SPED1110->COD_MOD)				//02 - COD_MOD DO DOCUMENTO FISCAL DE ENTRADA
	aAdd (aReg1110[nPos], SPED1110->SER)					//03 - SERIE DO DOC DE ENTRADA
	aAdd (aReg1110[nPos], SPED1110->NUM_DOC)				//04 - NUM_DOC DO DOC DE ENTRADA
	aAdd (aReg1110[nPos], SPED1110->DT_DOC)					//05 - DT_DOC DE EMISSAO DO DOC DE ENTRADA
	aAdd (aReg1110[nPos], SPED1110->CHV_NFE)				//06 - CHV_NFE DO DOC DE ENTRADA
	aAdd (aReg1110[nPos], SPED1110->NR_MEMO)				//07 - NR_MEMO DE EXPORTACAO
	aAdd (aReg1110[nPos], {Val(StrTran(SPED1110->QTD,',','.')),Iif(nDecimal > 3,3,nDecimal)})		   	   		//08 - QTD EFETIVAMENTE EXPORTADA
	aAdd (aReg1110[nPos], SPED1110->UNID)			   		//09 - UNID DO PRODUTO
	
	//³GRAVACAO REGISTRO 0150 - TABELA DE CADASTRO DE PARTICIPANTES            ³
	//³GRAVACAO REGISTRO 0175 - ALTERACAO DA TABELA DE CADASTRO DE PARTICIPANTE³
	if !lExtratTaf
		SDPF150175(@aReg0150,aPartDoc,cAlias,aWizard,,lExtratTaf)
	endif
	
	SPED1110->(dbSkip())
End
Return

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³Fun‡ao    ³R12001210 | Autor ³Luccas Curcio                 ³ Data ³18/08/2011³±±
±±³Descri‡ao ³CONTROLE DE CRÉDITOS FISCAIS                               		 ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function R12001210(bWhileSM0,cFilDe,dDataDe,dDataAte,cAlias,aWizard,oProcess,nRegsProc,nCtdFil,aLisFil,nCountTot,lEnd,cFilAte,lExtratTaf,aRegT067,aRegT067AA)
Local nPos1200	:= 0
Local nPos1210	:= 0
Local nSaldAnt	:= 0
Local nFilial	:= 0
Local nEmpProc	:= 0
Local aParamCE6	:= {}
Local aReg1200	:= {}
Local aReg1210	:= {}
Local lTop		:= .F.
Local cPeriodo	:= ""
Local cCodLan	:= ""
Local cAliasQry	:= "CE6"
Local cChaveCE6	:= ""
Local cAliasCE5	:= "CE5"
Local aAreaSM0	:= SM0->(GetArea())
Local lNf		:= .T.
Local lSkip1200	:= .T.

Default lExtratTaf := .F.

//³Processamento de multifiliais³
DbSelectArea("SM0")
SM0->(DbGoTop())
SM0->(MsSeek(cEmpAnt+cFilDe, .T.))	//Pego a filial mais proxima

//³Quando a opcao de seleciona filiais estiver configurada como sim, serah    ³
//³    considerado as filiais selecionadas no browse. Caso contrario, valera o³
//³    que estiver configurado na pergunta 'Filial DE/ATE'                    ³
Do While Eval(bWhileSM0)

	cFilAnt := FWGETCODFILIAL

	If Len(aLisFil)>0 .And. cFilAnt <= cFilAte
	nFilial := Ascan(aLisFil,{|x|x[2]==cFilAnt})
		If nFilial==0 .Or. !(aLisFil[nFilial,1])  //Filial não marcada, vai para proxima
			SM0->(dbSkip())
			Loop
		EndIf
	Else
		If (!lExtratTAF .and. "1" $ aWizard[1][12]) .or. (lExtratTAF .and. "1" $ aWizard[1][5])  //Somente faz skip se a opção de selecionar filiais estiver como Sim.
			SM0->(dbSkip())
			Loop
		EndIf
	EndIf

	// Refazendo o cache do SX6 para cada filial.
	aSPDSX6 := SpedLoadX6()

	// Refazendo o cache dos xFilial para cada filial.
	aSPDFil	:= fGetSpdFil()	

	nEmpProc += 1

	#IFDEF TOP
		If (TcSrvType ()<>"AS/400")
			lTop	:=	.T.
		Endif
	#ENDIF
    
	aParamCE6	:=	{}
	aAdd(aParamCE6,Substr(DTOS(dDataDe),1,6))
	If SPEDFFiltro(1,"CE6",@cAliasQry,aParamCE6)

		While !(cAliasQry)->(Eof())

			If lTop
				cAliasCE5	:=	cAliasQry
			Else
				SPEDSeek("CE5",2,aSPDFil[PFIL_CE5]+cCodLan+cPeriodo)
			Endif

			lSkip1200	:= .T.
			nRegsProc	+=	1
			cPeriodo	:=	(cAliasQry)->CE6_PERIOD
			cCodLan		:=	(cAliasQry)->CE6_CODLAN
			nSaldAnt	:=	(cAliasQry)->CE6_SALDO + ((cAliasQry)->CE6_TOTUTI - ((cAliasQry)->CE6_TOTCRE + (cAliasQry)->CE6_TOTTRA))
			
			If (nPos1200 := aScan(aReg1200, {|aZ| aZ[2] == cCodLan})) == 0 .And.;
			((cAliasQry)->CE6_TOTCRE > 0 .Or. (cAliasQry)->CE6_TOTTRA > 0 .Or.; 
			(cAliasQry)->CE6_TOTUTI > 0 .Or. (cAliasQry)->CE6_SALDO > 0)					
				aAdd (aReg1200, {})
				nPos1200	:=	Len(aReg1200)
				aAdd (aReg1200[nPos1200], "1200")								//01 - REG
				aAdd (aReg1200[nPos1200], cCodLan)								//02 - COD_AJ_APUR
				aAdd (aReg1200[nPos1200], nSaldAnt)								//03 - SLD_CRED
				aAdd (aReg1200[nPos1200], (cAliasQry)->CE6_TOTCRE)				//04 - CRED_APR
				aAdd (aReg1200[nPos1200], (cAliasQry)->CE6_TOTTRA)				//05 - CRED_RECEB 
				aAdd (aReg1200[nPos1200], (cAliasQry)->CE6_TOTUTI)				//06 - CRED_UTIL 
				aAdd (aReg1200[nPos1200], (cAliasQry)->CE6_SALDO)				//07 - SLD_CRED_FIM 						 

			Elseif (nPos1200 := aScan(aReg1200, {|aZ| aZ[2] == cCodLan })) > 0 .And. cChaveCE6 <> (cAliasQry)->CE6_FILIAL+cCodLan+cPeriodo
				aReg1200[nPos1200,4]	+= (cAliasQry)->CE6_TOTCRE				//04 - CRED_APR
				aReg1200[nPos1200,5]	+= (cAliasQry)->CE6_TOTTRA				//05 - CRED_RECEB 
				aReg1200[nPos1200,6]	+= (cAliasQry)->CE6_TOTUTI				//06 - CRED_UTIL 
				aReg1200[nPos1200,7]	+= (cAliasQry)->CE6_SALDO				//07 - SLD_CRED_FIM
			Endif
			
			cChaveCE6	:=	(cAliasQry)->CE6_FILIAL+cCodLan+cPeriodo
			lNf		:= .T.			
			If aSPDSX3[FP_CDO_NFDET] .AND. CDO->(MsSeek(aSPDFil[PFIL_CDO]+cCodLan))  
				//verifica na CDO se deseja ou não gerar as iformações da ntoa fiscal
				lNf	:= Iif(CDO->CDO_NFDET == '2' ,.F. , .T. )
			EndIF 
			
			
			While !(cAliasCE5)->(Eof()) .And. (cAliasCE5)->CE5_FILIAL+(cAliasCE5)->CE5_CODLAN+(cAliasCE5)->CE5_PERIOD == cChaveCE6                                  
			
				If (cAliasQry)->CE6_TOTUTI > 0 .And. (cAliasQry)->CE5_TPMOV == "U"

					nPos1210 := aScan(aReg1210, {|aY| aY[1] == nPos1200 .And.  aY[3] == (cAliasCE5)->CE5_CODUTI .And. Iif(lNf ,alltrim(aY[4]) == Alltrim((cAliasCE5)->CE5_NUMDOC)  , .T. ) .And. Iif(cVersao >= "011" .And. lNf , alltrim(aY[6]) == Alltrim((cAliasCE5)->CE5_CHVNFE),.T.) })
					If nPos1210 == 0
						aAdd (aReg1210, {})
						nPos1210	:=	Len(aReg1210)
						aAdd (aReg1210[nPos1210], nPos1200)							//Relacionamento com Registro Pai - 1200
						aAdd (aReg1210[nPos1210], "1210")							//01 - REG
						aAdd (aReg1210[nPos1210], (cAliasQry)->CE5_CODUTI)			//02 - TIPO_UTIL
						aAdd (aReg1210[nPos1210], Iif (lNf ,(cAliasQry)->CE5_NUMDOC , ""))			//03 - NR_DOC
						aAdd (aReg1210[nPos1210], (cAliasQry)->CE5_VALOR)			//04 - VL_CRED_UTIL
						IF cVersao >= "011"
							aAdd (aReg1210[nPos1210], Iif(aSPDSX3[FP_CE5_CHVNFE] .AND. lNf ,(cAliasQry)->CE5_CHVNFE,''))			//05 - CHV_DOCe
						Endif
					Else
						aReg1210[nPos1210,5]	+=	(cAliasQry)->CE5_VALOR			//04 - VL_CRED_UTIL
					Endif
				
				EndIf
				
				(cAliasCE5)->(DbSkip())
				lSkip1200 := .F.
			End

			//Quando não achar registros 1210 executa DBSkip do registro 1200
			If lSkip1200 
				(cAliasQry)->(DbSkip())
			Endif
		End
		SPEDFFiltro(2,,cAliasQry)
	Endif

	SM0->(dbSkip())
End		

//³Restauro a area do SM0³
RestArea(aAreaSM0)
cFilAnt := FWGETCODFILIAL
aSPDFil	:= fGetSpdFil() // Refazendo o cache xFilial

if !lExtratTaf
	GrRegDep(cAlias,aReg1200,aReg1210)
else
	aRegT067   :=  aReg1200
	aRegT067AA :=  aReg1210
endif

Return


/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³SPDReg1400³ Autor ³Gustavo G. Rueda       ³ Data ³15.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±³          ³            INFORMACAO SOBRE VALORES AGREGADOS              ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao e gravacao do Registro 1400                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com as informacoe contidas no array    ³±±
±±³          ³ aReg1400.                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³2(varios por arquivo)                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³aReg1400-> Array a ser retornado com a estrutura do registro³±±
±±³          ³cProd   -> Codigo do produto montado pela rotina            ³±±
±±³          ³cCodMun -> Codigo do municipio do participante              |±±
±±³          ³cAliasSFT-> Alias da tabela SFT                             |±±
±±³          ³cAliasSF4-> Alias da tabela SF4                             |±±
±±³          ³lExtTaf  -> Indica se a chamada da Funcao eh o Extrator TAF |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nil                                                         ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function SPDReg1400(aReg1400,cProd,cCodMun,cAliasSFT,cAliasSF4,lExtTaf,lGr2001400,cMVEstado)

Local	nPos		:= 0
Local	cIte		:= AllTrim(cProd)
Local   lMensal		:= .T.
Local	lF09		:= aSPDSX2[AI_F09]	

Default lExtTaf		:= .F.
Default lGr2001400	:= .F.
Default cMVEstado 	:= aSPDSX6[MV_ESTADO]

If lF09
	DbSelectArea("F09")
	F09->(DbSetOrder(1))
	DbSelectArea("CLN")
	CLN->(DbSetOrder(1))	
EndIF

//Código do item - Tabela própria da unidade da federação - Participação dos Municípios
//Versão 2.0.15 do guia pratico EFD             
If cVersao == "008"
	cIte :=	cProd
ElseIf cMVEstado=="SP" .And. !Empty((cAliasSF4)->F4_IPMSP)
	//Este Tratamento foi mantido por conta do legado
	cIte := AllTrim((cAliasSF4)->F4_IPMSP)
ElseIf cMVEstado=="MG" .And. !Empty((cAliasSF4)->F4_IPMMG)
	//Este Tratamento foi mantido por conta do legado
	cIte := AllTrim((cAliasSF4)->F4_IPMMG)     
ElseIF lF09 .AND. aSPDSX6[MV_ESTADO] $ aSPDSX6[MV_UFIPM] .And. F09->(MsSeek(aSPDFil[PFIL_F09]+(cAliasSF4)->F4_CODIGO+aSPDSX6[MV_ESTADO])) 
	//Este tratamento é para todos os estados que tiverem configurados IPM para o registro 1400
	cIte	:= AllTrim(F09->F09_CODIPM)      
Endif   
     
If lF09
	If aSPDSX3[FP_CLN_TIPO] .And. CLN->(MsSeek(aSPDFil[PFIL_CLN]+cMVEstado+cIte)) //Melhoria de performance
		lMensal := IIF(CLN->CLN_TIPO == '1' .Or. Empty(CLN->CLN_TIPO),.T.,.F.)
	Endif
Endif
	
If lMensal
	If (nPos := aScan(aReg1400, {|aX| AllTrim(aX[2])== Alltrim(cIte) .And. aX[3]==cCodMun})) == 0
		aAdd(aReg1400, {})
		nPos	:=	Len(aReg1400)   
		aAdd (aReg1400[nPos], Iif(!lExtTaf, "1400", "T072"))	//01 - REG
		aAdd (aReg1400[nPos], cIte)								//02 - COD_ITEM
		If AllTrim((cAliasSF4)->FT_CFOP) $ "5949|6949|7949"
			aAdd (aReg1400[nPos], Alltrim(SM0->M0_CODMUN))
		Else
			aAdd (aReg1400[nPos], cCodMun)							//03 - MUN
		EndIf
	  	aAdd (aReg1400[nPos], 0)	                            //04 - VALOR
	Endif

	If (cAliasSF4)->F4_VLAGREG=="D"
		aReg1400[nPos][4] -= (cAliasSFT)->FT_VALCONT		
	Else
		aReg1400[nPos][4] += (cAliasSFT)->FT_VALCONT		
	EndIf
	
	//Caso item tenha sido alterado para codigo, não sera gerado registro 0200
	lGr2001400 := aReg1400[nPos][4] > 0 .And. (cIte == AllTrim(cProd) .Or. cIte ==	cProd)
Endif
	  	
Return
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³Reg1500   ³ Autor ³Gustavo G. Rueda       ³ Data ³09.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±³          ³     NOTA FISCAL CONTA DE ENERGIA ELETRICA (MODELO 06)      ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao e gravacao do Registro 1500                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com as informacoe contidas no array    ³±±
±±³          ³ aRegC100 para o Modelo 06.                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³2(varios por arquivo)                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cAlias   -> Alias do arquivo de trabalho                    ³±±
±±³          ³nRelac   -> Variavel de relacionamento do registro          ³±±
±±³          ³aRegC100 -> Array com as informacoes jah processadas        |±±
±±³          ³aTotaliza-> Array com os totalizadores por documento        |±±
±±³          ³lAchouSFU-> Flag de seek da tabela SFU                      |±±
±±³          ³lGrava0150-> Flag de geracao do registro 0150               |±±
±±³          ³aCmpAntSFT-> Campos do documento processados (registro      |±±
±±³          ³             anterior)                                      |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nil                                                         ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function Reg1500(cAlias,nRelac,aRegC100,aTotaliza,lAchouSFU,lGrava0150,aCmpAntSFT,aWizard)
Local	nPos		:=	0
Local	cCodCons	:=	""
Local	nVlTerc  	:=	0
Local	aReg1500	:=	{}
Local   cTpLiga     :=  ""
Local   cGrpTens    :=  ""
Default aWizard		:= {}

If lAchouSFU
	cCodCons := SFU->FU_CLASCON
	nVlTerc  := SFU->FU_VALTERC
	cGrpTens := If(aSPDSX3[FP_FU_GRUPT], SFU->FU_GRUPT, "")
	If aSPDSX3[FP_FU_TIPLIGA]
		Do Case
			Case SFU->FU_TIPLIGA == '0'
				cTpLiga := "1"
			Case SFU->FU_TIPLIGA == '1'
				cTpLiga := "2"
			Case SFU->FU_TIPLIGA == '2'
				cTpLiga := "3"
		EndCase
	EndIf
EndIf

aAdd(aReg1500, {})
nPos	:=	Len (aReg1500)
aAdd (aReg1500[nPos], "1500")	 	   										//01 - REG
aAdd (aReg1500[nPos], aRegC100[1][2])	   			  						//02 - IND_OPER
aAdd (aReg1500[nPos], aRegC100[1][3])	   			  						//03 - IND_EMIT
aAdd (aReg1500[nPos], aRegC100[1][4])	   			  						//04 - COD_PART
aAdd (aReg1500[nPos], aRegC100[1][5])	   			  						//05 - COD_MOD
aAdd (aReg1500[nPos], aRegC100[1][6])	   			   						//06 - COD_SIT
aAdd (aReg1500[nPos], aRegC100[1][7])	   									//07 - SER
aAdd (aReg1500[nPos], "")	   						   						//08 - SUB
aAdd (aReg1500[nPos], cCodCons )					   						//09 - COD_CONS
aAdd (aReg1500[nPos], aRegC100[1][8])	   			   						//10 - NUM_DOC
aAdd (aReg1500[nPos], aCmpAntSFT[6])	   			   						//11 - DT_DOC
aAdd (aReg1500[nPos], aRegC100[1][11])	   									//12 - DT_E_S
aAdd (aReg1500[nPos], aRegC100[1][12])	   			   						//13 - VL_DOC
aAdd (aReg1500[nPos], aRegC100[1][14])	   				   					//14 - VL_DESC
aAdd (aReg1500[nPos], aRegC100[1][16])	   									//15 - VL_FORN
aAdd (aReg1500[nPos], IIF(!(aRegC100[1][6]$"02#04#05"),aTotaliza[7],""))	//16 - VL_SERV_NT
aAdd (aReg1500[nPos], IIF(!(aRegC100[1][6]$"02#04#05"),nVlTerc,""))		//17 - VL_TERC
aAdd (aReg1500[nPos], aRegC100[1][20])	   				  					//18 - VL_DA
aAdd (aReg1500[nPos], aRegC100[1][21])	   									//19 - VL_BC_ICMS
aAdd (aReg1500[nPos], aRegC100[1][22])	   									//20 - VL_ICMS
aAdd (aReg1500[nPos], aRegC100[1][23])				   						//21 - VL_BC_ICMS_ST
aAdd (aReg1500[nPos], aRegC100[1][24])	   									//22 - VL_ICMS_ST
aAdd (aReg1500[nPos], "" )	   												//23 - COD_INF
aAdd (aReg1500[nPos], Iif("1"$aWizard[1][15],aRegC100[1][26],0))	   									//24 - VL_PIS
aAdd (aReg1500[nPos], Iif("1"$aWizard[1][15],aRegC100[1][27],0))	   									//25 - VL_COFINS
If cVersao >= "003"
	aAdd (aReg1500[nPos], cTpLiga)		   									//26 - TP_LIGACAO - LAYOUT 2010
	aAdd (aReg1500[nPos], cGrpTens)		   									//27 - COD_GRUPO_TENSAO - LAYOUT 2010
EndIf

GrvRegTrS(cAlias,RetRD(nRelac),aReg1500)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³No registro C100, quando este campo estiver em branco, eh pq nao deve       ³
//³ ser enviado o codigo do participante, assim nao precisa gerar tambem o 0150³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !Empty(aRegC100[1][4])
	lGrava0150 := .T.
EndIf

Return
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³Reg1510   ³ Autor ³Gustavo G. Rueda       ³ Data ³09.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±³          ³               ITENS DO DOCUMENTO (MODELO 06)               ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao e gravacao do Registro 1510                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com as informacoe contidas no array    ³±±
±±³          ³ aRegC170 para o Modelo 06.                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³3(1:N) Para cada C500                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cAlias -> Alias do arquivo de trabalho em processamento     ³±±
±±³          ³nRelac -> Flag de relacionamento por documento              ³±±
±±³          ³aRegC170 -> Array com as informacoes jah processadas.       |±±
±±³          ³aPartDoc -> array com as informacoes do participante        ³±±
±±³          ³nItem    -> Numero do item em processamento                 ³±±
±±³          ³lAchouSFU-> Flag que determina se encontrou a tabela SFU    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nil                                                         ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function Reg1510(cAlias,nRelac,aRegC170,aPartDoc,nItem,lAchouSFU,aWizard)
Local	nPos		:=	0
Local	cCodClas	:=	""
Local	aReg1510	:=	{}
Default aWizard		:= {}

If lAchouSFU
	If TamSx3("FU_GRPCLAS")[1] == 2
		cCodClas	:= SFU->FU_GRPCLAS+IIf(aSPDSX3[FP_FU_CLASSIF],SFU->FU_CLASSIF,"")
	Else
		cCodClas	:= "0"+SFU->FU_GRPCLAS+IIf(aSPDSX3[FP_FU_CLASSIF],SFU->FU_CLASSIF,"")
	EndIf
EndIf

aAdd(aReg1510,{})
nPos	:=	Len(aReg1510)
aAdd(aReg1510[nPos], "1510")	 	   					//01 - REG
aAdd(aReg1510[nPos], aRegC170[1][2])	   				//02 - NUM_ITEM
aAdd(aReg1510[nPos], aRegC170[1][3])	   				//03 - COD_ITEM
aAdd(aReg1510[nPos], cCodClas)							//04 - COD_CLASS
aAdd(aReg1510[nPos], aRegC170[1][5][1])				//05 - QTD
aAdd(aReg1510[nPos], aRegC170[1][6])	   				//06 - UNID
aAdd(aReg1510[nPos], aRegC170[1][7])	   				//07 - VL_ITEM
aAdd(aReg1510[nPos], aRegC170[1][8])	   				//08 - VL_DESC
aAdd(aReg1510[nPos], aRegC170[1][10])	   				//09 - CST_ICM
aAdd(aReg1510[nPos], aRegC170[1][11])	   				//10 - CFOP
aAdd(aReg1510[nPos], aRegC170[1][13])	   				//11 - VL_BC_ICMS
aAdd(aReg1510[nPos], aRegC170[1][14])	   				//12 - ALIQ_ICMS
aAdd(aReg1510[nPos], aRegC170[1][15])	   				//13 - VL_ICMS
aAdd(aReg1510[nPos], aRegC170[1][16])	   				//14 - VL_BC_ICMS_ST
aAdd(aReg1510[nPos], aRegC170[1][17])	   				//15 - ALIQ_ICMS_ST
aAdd(aReg1510[nPos], aRegC170[1][18])	   				//16 - VL_ICMS_ST
aAdd(aReg1510[nPos], "0")			   					//17 - IND_REC
aAdd(aReg1510[nPos], aPartDoc[1])	   					//18 - COD_PART
aAdd(aReg1510[nPos], Iif("1"$aWizard[1][15],Iif(aRegC170[1][30]>0,aRegC170[1][30],0),0))	   				//19 - VL_PIS
aAdd(aReg1510[nPos], Iif("1"$aWizard[1][15],Iif(aRegC170[1][36]>0,aRegC170[1][36],0),0))	   				//20 - VL_COFINS
aAdd(aReg1510[nPos], aRegC170[1][37])					//21 - COD_CTA

GrvRegTrS(cAlias,nRelac,aReg1510,nItem)           
Return

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  |OrgTxt    ³ Autor ³Gustavo G. Rueda       ³ Data ³16.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±³          ³             GRAVACAO DO TRB EM MEIO-MAGNETICO              ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Funcao de gravacao do meio-magnetico de acordo com o TRB.   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³Nenhum                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³lRet -> .T.                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros|cAlias -> Alias do TRB gerado na funcao principal.          ³±±
±±³          |cFile -> Nome do meio-magnetico a ser gerado.               ³±±
±±³          |oProcess -> Objeto da nova barra de progressao              ³±±
±±³          |lEnd     -> Flag de cancelamento de processamento           ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function OrgTxt(cAlias,cFile,oProcess,lEnd,lTop,nRetCpy)
Local lRet		:= .T.
Local nHandle	:= -1
Local cTrab	    := CriaTrab(,.F.)+".TXT"
Local cStartPath:= GetStartP()

	//³Tratamento para consistir o arquivo caso exista³
	If (File(cTrab))
		FErase (cTrab)
	Endif
	nHandle	:=	MsFCreate(cTrab)
	
	fGrvBloco(nHandle, cAlias) //Gravação dos registros no TXT

	If (nHandle>=0)
		FClose(nHandle)		
	Endif

	__oORGTXT := Nil //Limpa Objeto Query fGrvBloco
	
	OrgTXTFile(cFile, cTrab, cStartPath, @nRetCpy)

Return (lRet)

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³SPDAPICMS | Autor ³Gustavo G. Rueda 			   ³ Data ³22.03.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡ao ³                        GERACAO DO BLOCO E                         ³±± 
±±³          ³REGISTRO E100 - PERIODO DA APURACAO DO ICMS                        ³±± 
±±³          ³REGISTRO E110 - APURACAO DE ICMS - OPERACOES PROPRIAS              ³±± 
±±³          ³REGISTRO E111 - AJUSTES/BENEFICIOS/INCENTIVO DA APURACAO DE ICMS   ³±± 
±±³          ³REGISTRO E112 - INFORMACOES ADICIONAIS DOS AJUSTES DE APURACAO DO  ³±± 
±±³          ³                ICMS                                               ³±± 
±±³          ³REGISTRO E115- INF. ADICIONAIS DA APURACAO DO ICMS                 ³±± 
±±³          ³REGISTRO E116 - OBRIGACOES DO ICMS A RECOLHER - OPERACOES PROPRIAS ³±± 
±±³          ³REGISTRO E200 - PERIODO DA APURACAO DO ICMS ST                     ³±± 
±±³          ³REGISTRO E210 - APURACAO DO ICMS - SUBSTITUICAO TRIBUTARIA         ³±±  
±±³          ³REGISTRO E220 - AJUSTES/BENEFICIOS/INCENTIVOS DA APURACAO DO ICMS  ³±± 
±±³          ³                SUBSTITUICAO TRIBUTARIA                            ³±±  
±±³          ³REGISTRO E230 - INFORMACOES ADICIONAIS DOS AJUSTES DE APURACAO DO  ³±± 
±±³          ³                ICMS SUBSTITUICAO TRIBUTARIA                       ³±±  
±±³          ³REGISTRO E250 - OBRIGACOES DO ICMS A RECOLHER - SUBSTITUICAO       ³±± 
±±³          ³                TRIBUTARIA                                         ³±± 
±±³          ³REGISTRO E520 - APURACAO DO IPI                                    ³±±
±±³          ³REGISTRO E500 - PERIODO DA APURACAO DO IPI                         ³±± 
±±³          ³REGISTRO E510 - CONSOLIDACAO DOS VALROES DE IPI POR CFOP E CODIGO  ³±±
±±³          ³                DE TRIBUTACAO DO IPI                               ³±±
±±³          ³Funcao utilizada para montar a estrutura dos registros acima e     ³±±
±±³          ³  gravar no TRB para geracao do TXT                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1 -> Identifica se houve movimento no periodo ou nao           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cFilDe   - Filial inicial para processament multifilial            ³±±
±±³          ³cFilAte  - Filial final para processament multifilial              ³±±
±±³          ³nApuracao -> Tipo de apuracao, padrao 3                            ³±±
±±³          ³nPeriodo  -> Periodo de apuracao, padrao 1                         ³±±
±±³          ³cNrLivro  -> Numero do livro selecionado no wizard                 ³±±
±±³          ³cImp -> imposto de processamento. IC=ICMS,ST=SUBST. TRIBUTARIA     ³±±
±±³          ³cAlias   - Alias do TRB                                            ³±±
±±³          ³dDataDe -> Data inicio de processamento inf. no wizard             ³±±
±±³          ³dDataAte -> Data final de processamento inf. no wizard             ³±±
±±³          ³lTop     - Flag para identificar ambiente TOP                      ³±±
±±³          ³lImpCrdST -> Flago de processamento do CredST conforme wizard      ³±±
±±³          ³cArqAnt- Arquivo de apuraao do periodo anterior inf. no wizard     ³±±
±±³          ³oProcess - Objeto do novo controle de processamento                ³±±
±±³          ³aVlrMovST- Valores de apuracao obtidos durante o processamento dos ³±±
±±³          ³           documentos                                              ³±±
±±³          |aIcmPago - Informacoes das GNREs de documentos fiscais para o E250 ³±±
±±³          |cMVSUBTRIB -> Conteudo do parametro MV_SUBTRIB 					 ³±±
±±³			 |aLanCDA -> Array contendo a tabela CDA.		                     ³±±
±±³			 |aLanCDA2 -> Array contendo a tabela CDA. (Totalizador)             ³±±
±±³			 |cMVSTNIEUF - Conteudo do parametro MV_STNIEUF, auxilia do MV_SUBTRIB³±±
±±³			 |aLanCDA2 -> Array contendo a tabela CDA. (Totalizador)             ³±±
±±³			 |lExtratTAF -> Indica se a chamada da funcao eh o Extrator TAF      ³±±
±±³			 |aRegT020 -> Gera informacoes do Registro T020 do TAF               ³±±
±±³			 |aRegT020AA -> Gera informacoes do Registro T020AA do TAF           ³±±
±±³			 |aRegT020AB -> Gera informacoes do Registro T020AB do TAF           ³±±
±±³			 |aRegT020AC -> Gera informacoes do Registro T020AC do TAF           ³±±
±±³			 |aRegT020AE -> Gera informacoes do Registro T020AE do TAF           ³±±
±±³			 |cVerSPDFis -> Versao do Sped Fiscal                                ³±± 
±±³			 |cMvSFUfGnr - UF's que geram Classe de Vencimento no campo 05 		 ³±±
±±³			 |				do registro E116									 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGAFIS - SPEDFISCAL                                              ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function SPDAPICMS(	cFilDe,		cFilAte,	nApuracao,	nPeriodo,		cNrLivro,	cImp,		cAlias,		dDataDe,;
					dDataAte,	cMVEstado,	lTop,		lImpCrdST,		cArqAnt,	oProcess,	aVlrMovST,	aIcmPago,;
					cMVSUBTRIB,	aLanCDA,	aLanCDA2,	cMVSTNIEUF,		lOldLan,	lExtratTAF,	aRegT020,	aRegT020AA,;
					aRegT020AB,	aRegT020AC, aRegT020AE,	aRegT021Val,	aRegT021Est,aRegT021AA,	aRegT021AB,	aRegT021AC,;
					aRegT021AD,	cVerSPDFis,	aReg0200,	aReg0190,		aReg0220,	cMvSFUfGnr, aRegT020AG, aWizard, aRegT020AD,aStruCDA )

Local 	cChave	 	:= 	STR(nApuracao,1)+STR(nPeriodo,1)+DTOS(dDataDe)+cNrLivro
Local 	lRet		:= 	.T.
Local	lAjusteNF 	:= 	.F.
Local	nPosAj	 	:= 	0
Local	nUf		 	:= 	0
Local 	nPos		:= 	0
Local 	lGNREF3    	:= 	aSPDSX3[FP_CDH_GNREF3]
Local 	cSomaSeq	:= 	""
Local 	cSequen	 	:= 	""
Local	nRecnoSF6	:=	Nil
Local	aParametros	:=	{}
Local   aParCda		:=  {}
Local 	cUf		 	:= 	cMvEstado
Local 	cCodAjApur 	:= 	""
Local 	lCmpsE112	:=	aSPDSX3[FP_F6_NUMPROC] .And. aSPDSX3[FP_F6_INDPROC] .And. aSPDSX3[FP_F6_DESCOMP]
Local 	lProcE112	:=	aSPDSX3[FP_CDH_PROCES] .And. aSPDSX3[FP_CDH_PROCTP] .And. aSPDSX3[FP_CDH_PROIND] .And. aSPDSX3[FP_CDH_ITPROC]
Local	lAchouSF6	:=	.F.
Local	lAchouCCF	:=	.F.
Local	cAliasCDH	:=	"CDH"
Local 	nPosE111	:=	0
Local  	nPosT020AG 	:= 	0
Local	aProd		:=	Nil
Local	aRegE110	:=	{"E110",0,0,0,0,0,0,0,0,0,0,0,0,0,0}
Local	aRegE111 	:= 	{}
Local	aRegE112 	:= 	{}
Local	aRegE113	:=	{}
Local	aRegE240 	:= 	{}    
Local	aRegE116 	:= 	{}
Local	aRegE200 	:= 	{}
Local	aRegE210 	:= 	{}
Local	aRegE220 	:= 	{}
Local	aRegE230 	:= 	{}
Local	aRegE250 	:= 	{}
Local	nX			:=	0
Local   nPosE220	:=  0
Local 	lCmpsE113	:=	cUf $ aSPDSX6[MV_ESTE113]
Local 	lCmpsE240	:=	cUf $ aSPDSX6[MV_ESTE240]	
Local	cCodE240	:=	""
Local	cProd		:=	""
Local	aRegE115	:=	{}
Local	cModelo		:=	""
Local	cSerie		:=	""
Local	cTamProd 	:=	TamSx3("B1_COD")[1]
Local	nTamCdhDes 	:=	TamSx3("CDH_DESC")[1]
Local 	nPosE113	:= 0
Local 	nPosE240	:= 0
Local	nScanE11	:= 0
Local 	lCdoIndiv	:= .F.
Local 	cDescAj		:= ""
Local   lConfig		:= .F.
Local   lMsgCjl		:= .F.
Local   nI			:= 0
Local   aCodlan		:= {}

Default aVlrMovST	:=	{}
Default aLanCDA		:=	{}          
Default	lOldLan	 	:= 	(aSPDSX2[AI_CC6] .And. aSPDSX3[FP_CC6_TIPOAJ])
Default aRegT020    :=  {}	 
Default aRegT020AA  :=  {}  
Default aRegT020AB  :=  {}  
Default aRegT020AC  :=  {} 
Default aRegT020AD  :=  {} 
Default aRegT020AE  :=  {}
Default aRegT020AG  :=  {}

Default aRegT021Val :=  {} 
Default aRegT021Est :=  {} 
Default aRegT021AA  :=  {} 
Default aRegT021AB  :=  {} 
Default aRegT021AC  :=  {}
Default aRegT021AD  :=  {}  
Default aReg0200    :=  {} 
Default aReg0190    :=  {} 
Default aReg0220    :=  {}
Default lExtratTAF  := .F.
Default cVerSPDFis  := cVersao
Default	cMvSFUfGnr	:=	aSPDSX6[MV_SFUFGNR]

//³Para ambiente TOP nao preciso pegar a ultima sequencia, pois isso eh resolvido na propria query³
If !lTop
	If CDH->(MsSeek(aSPDFil[PFIL_CDH]+cImp+cChave))
		cSomaSeq  := CDH->CDH_SEQUEN
		While CDH->(MsSeek(aSPDFil[PFIL_CDH]+cImp+cChave+cSomaSeq)) // Posiciona na ultima sequencia
			cSequen  := CDH->CDH_SEQUEN
			cSomaSeq := Soma1(cSequen)
		EndDo
	EndIf
EndIf

//³Montando parametros para a query ou indregua³
aAdd(aParametros,cImp)
aAdd(aParametros,STR(nApuracao,1))
aAdd(aParametros,STR(nPeriodo,1))
aAdd(aParametros,DTOS(dDataDe))
aAdd(aParametros,cNrLivro)
aAdd(aParametros,cSequen)

aAdd(aParCda,dDataDe)
aAdd(aParCda,dDataAte)

If SPEDFFiltro(1,"CDH",@cAliasCDH,aParametros,,,@lMsgCjl)
	//³REGISTRO E110 - APURACAO DE ICMS - OPERACOES PROPRIAS³
	If lMsgCjl .And. oJRetCda == Nil  
		TempCDA(@oJRetCda,aParCda,lBuild,@aStruCDA)
	Endif	
	If cImp=="IC"
		//³ Carrega ajustes na apuracao ICMS ³
		While !(cAliasCDH)->(Eof())
			
			cCodAjApur 	:= 	(cAliasCDH)->CDH_CODLAN
			nPosE111	:= 0
			nPosT020AG := 0
			lGeraE111	:=	.F.
			lGeraE116	:=	.F.
			nRecnoSF6	:=	Iif(lTop,(cAliasCDH)->SF6RECNO,Nil)
			lAchouSF6	:=	.F.
			lAchouCCF	:=	.F.
			lConfig		:=  .F.
			
			If Alltrim((cAliasCDH)->CDH_TPLANC) == "CF - Config Tributo"
				lConfig := .T.
			Endif                   
			
			//³Posicionamento da tabela SF6, tanto para TOP (RECNO) quanto para DBF/ADS    ³
			If !Empty((cAliasCDH)->(CDH_ESTGNR+CDH_GNRE))
				lAchouSF6	:=	SPEDSeek("SF6",1,aSPDFil[PFIL_SF6]+(cAliasCDH)->(CDH_ESTGNR+CDH_GNRE),nRecnoSF6)
			EndIf
			
			//Verifica se existe Processo referenciado informado na apuração
			If lProcE112 .And. !Empty((cAliasCDH)->(CDH_PROCES+CDH_PROCTP+CDH_PROIND+CDH_ITPROC))
				lAchouCCF	:=	SPEDSeek("CCF",1,aSPDFil[PFIL_CCF]+(cAliasCDH)->(CDH_PROCES+CDH_PROCTP+CDH_PROIND+CDH_ITPROC))
			EndIf
			
			Do Case
				//³Case que determina o calculo do (2)VL_TOT_DEBITOS = Valor total dos debitos  ³
				//³     por "SAIDAS E PRESTACOES COM DEBITO DO IMPOSTO"                         ³
				Case (cAliasCDH)->CDH_LINHA == "001"
					aRegE110[2] += (cAliasCDH)->CDH_VALOR
					
				//³Case que determina o calculo de 2 lancamentos:                               |
				//|- (3)VL_AJ_DEBITOS = Valor total dos ajustes a debitos provenitentes de NF   ³
				//³- (4)VL_TOT_AJ_DEBITOS = Valor total dos ajustes a debitos                   ³
				Case (cAliasCDH)->CDH_LINHA $ "002" .And. Alltrim((cAliasCDH)->CDH_SUBITE) <> "002.00" .And. !Empty((cAliasCDH)->CDH_CODLAN)	//Lancamentos a outros debitos
					//³Tratamento para o codigo no formato antigo (NAO SE UTILIZA MAIS) ou para o novo de 10 posicoes³
					If (lOldLan .And. SubStr((cAliasCDH)->CDH_CODLAN,1,1)=="1") .Or.;	//No formato antigo, os que iniciam por 1 sao lancamentos de NF
					   (!lOldLan .And. Len(Alltrim((cAliasCDH)->CDH_CODLAN))==10)		//Tamanho 10 eh soh os lancamentos de NF
						//³Se for ajuste com origem em NF, ja vai estar lancado no C197³
						aRegE110[3] += (cAliasCDH)->CDH_VALOR
					Else
						//³Conforme cadastro de ajuste manual, quando a terceira posicao do codigo for ³
						//³   0=ICMS e a quarta for 0=Outros Debitos, considero este valor.            ³
						If SubStr((cAliasCDH)->CDH_CODLAN,3,1)=="0" .And. SubStr((cAliasCDH)->CDH_CODLAN,4,1)== "0"
							aRegE110[4] += (cAliasCDH)->CDH_VALOR
						EndIf
						
						lGeraE111	:=	.T.
						
						//³Se for ajuste de apuracao precisa lancar no E111³
						If lOldLan	//Codigo de lancamento antigo tem outro formato, e precisa ser convertido para um DEFAULT para nao apresentar erro de validacao
							cCodAjApur := cUf+"0"+"0"+"9999"
						EndIf
					EndIf

				//³Case que determina o calculo de 2 lancamentos:                               |
				//|- (3)VL_AJ_DEBITOS = Valor total dos ajustes a debitos provenitentes de NF   ³
				//³- (5)VL_ESTORNOS_CRED = Valor total dos ajustes "ESTORNO DE CREDITOS"        ³
				Case (cAliasCDH)->CDH_LINHA $ "003" .And. Alltrim((cAliasCDH)->CDH_SUBITE) <> "003.00" .And. !Empty((cAliasCDH)->CDH_CODLAN)
					//³Tratamento para o codigo no formato antigo (NAO SE UTILIZA MAIS) ou para o novo de 10 posicoes³
					If (lOldLan .And. SubStr((cAliasCDH)->CDH_CODLAN,1,1)=="1") .Or.;	//No formato antigo, os que iniciam por 1 sao lancamentos de NF
					   (!lOldLan .And. Len(Alltrim((cAliasCDH)->CDH_CODLAN))==10)		//Tamanho 10 eh soh os lancamentos de NF
						//³Se for ajuste com origem em NF, ja vai estar lancado no C197³
						//|                                                            |
						//|Um lancacamento a ESTORNO DE CREDITO proveniente de NF,     |
						//|  tambem entra como DEBITO(3)                               |
						aRegE110[3] += (cAliasCDH)->CDH_VALOR
					Else
						//³Conforme cadastro de ajuste manual, quando a terceira posicao do codigo for ³
						//³   0=ICMS e a quarta for 1=Estorno de Credito, considero este valor.        ³
						If SubStr((cAliasCDH)->CDH_CODLAN,3,1)=="0" .And. SubStr((cAliasCDH)->CDH_CODLAN,4,1)== "1"
							aRegE110[5] += (cAliasCDH)->CDH_VALOR
						EndIf
						
						lGeraE111	:=	.T.

						//³Se for ajuste de apuracao precisa lancar no E111³
						If lOldLan
							cCodAjApur := cUf+"0"+"1"+"9999"
						EndIf
					EndIf

				//³Case que determina o calculo do (6)VL_TOT_CREDITOS = Valor total dos creditos³
				//³     por "ENTRADAS E AQUISICOES COM CREDITO DO IMPOSTO"                      ³
				Case (cAliasCDH)->CDH_LINHA == "005"
					aRegE110[6] += (cAliasCDH)->CDH_VALOR

				//³Case que determina o calculo de 2 lancamentos:                               |
				//|- (7)VL_AJ_CREDITOS = Valor total dos ajustes a creditos provenitentes de NF ³
				//³- (8)VL_TOT_AJ_CREDITOS = Valor total dos "AJUSTES A CREDITO"                ³
				Case (cAliasCDH)->CDH_LINHA $ "006" .And. Alltrim((cAliasCDH)->CDH_SUBITE) <> "006.00" .And. !Empty((cAliasCDH)->CDH_CODLAN)
					//³Tratamento para o codigo no formato antigo (NAO SE UTILIZA MAIS) ou para o novo de 10 posicoes³
					If (lOldLan .And. SubStr((cAliasCDH)->CDH_CODLAN,1,1)=="1") .Or.;	//No formato antigo, os que iniciam por 1 sao lancamentos de NF
					   (!lOldLan .And. Len(Alltrim((cAliasCDH)->CDH_CODLAN))==10)		//Tamanho 10 eh soh os lancamentos de NF
						//³Se for ajuste com origem em NF, ja vai estar lancado no C197³
						aRegE110[7] += (cAliasCDH)->CDH_VALOR
					Else
						//³Conforme cadastro de ajuste manual, quando a terceira posicao do codigo for ³
						//³   0=ICMS e a quarta for 2=Outros Creditos, considero este valor.           ³
					    If SubStr((cAliasCDH)->CDH_CODLAN,3,1)=="0" .And. SubStr((cAliasCDH)->CDH_CODLAN,4,1)== "2"
							aRegE110[8] += (cAliasCDH)->CDH_VALOR
						EndIf
						
						lGeraE111	:=	.T.

						//³Se for ajuste de apuracao precisa lancar no E111³
						
						If lOldLan
							cCodAjApur := cUf+"0"+"2"+"9999"
						EndIf
					EndIf

				//³Case que determina o calculo de 2 lancamentos:                               |
				//|- (7)VL_AJ_CREDITOS = Valor total dos ajustes a creditos provenitentes de NF ³
				//³- (9)VL_ESTORNOS_DEB = Valor total dos ajustes "ESTORNO DE DEBITOS"          ³
			
				Case (cAliasCDH)->CDH_LINHA $ "007" .And. Alltrim((cAliasCDH)->CDH_SUBITE) <> "007.00" .And. !Empty((cAliasCDH)->CDH_CODLAN)
					//³Tratamento para o codigo no formato antigo (NAO SE UTILIZA MAIS) ou para o novo de 10 posicoes³
					If (lOldLan .And. SubStr((cAliasCDH)->CDH_CODLAN,1,1)=="1") .Or.;	//No formato antigo, os que iniciam por 1 sao lancamentos de NF
					   (!lOldLan .And. Len(Alltrim((cAliasCDH)->CDH_CODLAN))==10)		//Tamanho 10 eh soh os lancamentos de NF
						//³Se for ajuste com origem em NF, ja vai estar lancado no C197³
						aRegE110[7] += (cAliasCDH)->CDH_VALOR
					Else
						//Conforme cadastro de ajuste manual, quando a terceira posicao do codigo for
						//0=ICMS e a quarta for 3=Estorno de debitos, considero este valor.
						If SubStr((cAliasCDH)->CDH_CODLAN,3,1)=="0" .And. SubStr((cAliasCDH)->CDH_CODLAN,4,1)=="3"
							aRegE110[9] += (cAliasCDH)->CDH_VALOR
						EndIf
						
						lGeraE111	:=	.T.

						//Se for ajuste de apuracao precisa lancar no E111
						If lOldLan
							cCodAjApur := cUf+"0"+"3"+"9999"
						EndIf
					EndIf

				//Case que determina o calculo do (10)VL_SLD_CREDOR_ANT = Valor total do "SALDO CREDOR DO PERIODO ANTERIOR"
				Case (cAliasCDH)->CDH_LINHA == "009"
					aRegE110[10] += (cAliasCDH)->CDH_VALOR
					
				//Case que determina o calculo do (10)VL_SLD_APURADO = Valor do saldo devedor apurado                                                                    ³
				Case (cAliasCDH)->CDH_LINHA == "011"
					aRegE110[11] += (cAliasCDH)->CDH_VALOR

				//Case que determina o calculo de 2 lancamentos:
				//- (7)VL_AJ_CREDITOS = Valor total dos ajustes a creditos provenitentes de NF
				//- (12)VL_TOT_DED = Valor total de "DEDUCOES"
				Case (cAliasCDH)->CDH_LINHA $ "012" .And. Alltrim((cAliasCDH)->CDH_SUBITE) <> "012.00" .And. !Empty((cAliasCDH)->CDH_CODLAN)
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//Tratamento para o codigo no formato antigo (NAO SE UTILIZA MAIS) ou para o novo de 10 posicoes
					//O valor informado deve corresponder ao somatorio do campo VL_ICMS dos registros C197 e D197,se
					//o terceiro caractere do codigo de ajuste dos registros C197 ou D197 for '0', '1' ou '2' e o
					//quarto caractere for '0', '3', '4' ou '5'.
					If (lOldLan .And. SubStr((cAliasCDH)->CDH_CODLAN,1,1)=="1") .Or.;	//No formato antigo, os que iniciam por 1 sao lancamentos de NF
					   (!lOldLan .And. Len(Alltrim((cAliasCDH)->CDH_CODLAN))==10 .And. SubStr((cAliasCDH)->CDH_CODLAN,3,1)$'012' .And. SubStr((cAliasCDH)->CDH_CODLAN,4,1)$'0345' ) //Tamanho 10 eh soh os lancamentos de NF
						//³Se for ajuste com origem em NF, ja vai estar lancado no C197³
						aRegE110[7] += (cAliasCDH)->CDH_VALOR
					
					//³Conforme cadastro de ajuste manual, quando a terceira posicao do codigo for 0=ICMS e a quarta		³
					//³for 4=Deducoes, considero este valor.               												    ³
					Elseif ( Len(Alltrim((cAliasCDH)->CDH_CODLAN))==8 .And. SubStr((cAliasCDH)->CDH_CODLAN,3,1)=="0" .And. SubStr((cAliasCDH)->CDH_CODLAN,4,1)=="4" )
						aRegE110[12] += (cAliasCDH)->CDH_VALOR
						//³Se for ajuste de apuracao precisa lancar no E111³
						lGeraE111	:=	.T.
						If lOldLan
							cCodAjApur := cUf+"0"+"4"+"9999"
						EndIf
					
					//Quando se tratar dos codigos de 10 posicoes (documento):
					//o valor informado deve corresponder ao somatorio do campo VL_ICMS dos registros C197 e D197, se o 
					//terceiro caractere do codigo de ajuste do registro C197 ou D197, for '6' e o quarto caractere for '0'
					Elseif	( Len(Alltrim((cAliasCDH)->CDH_CODLAN))==10 .And. SubStr((cAliasCDH)->CDH_CODLAN,3,1)$'6' .And. SubStr((cAliasCDH)->CDH_CODLAN,4,1)$'0' ) //Tamanho 10 eh soh os lancamentos de NF
						aRegE110[12] += (cAliasCDH)->CDH_VALOR
					Endif	
					
				//Case que determina o calculo do (13)VL_ICMS_RECOLHER = Valor total de "ICMS A RECOLHER"
				Case (cAliasCDH)->CDH_LINHA == "013"
					aRegE110[13] += (cAliasCDH)->CDH_VALOR
					
				//Case que determina o calculo do (14)VL_SLD_CREDOR_TRANSPORTAR = Valor total
				//de "SALDO CREDOR A TRANSPORTAR PARA O PERIODO SEGUINTE"
				Case (cAliasCDH)->CDH_LINHA == "014"
					aRegE110[14] += (cAliasCDH)->CDH_VALOR 				
					
				//Case que determina o calculo de 2 lancamentos:
				//-(15)DEB_ESP = valores recolhidos ou a recolher extra-apuracao
				Case (cAliasCDH)->CDH_LINHA$"900" .And. Alltrim((cAliasCDH)->CDH_SUBITE)<>"900.00" .And. !Empty((cAliasCDH)->CDH_CODLAN)
					//³Tratamento para o codigo no formato antigo (NAO SE UTILIZA MAIS) ou para o novo de 10 posicoes³
					If (lOldLan .And. SubStr((cAliasCDH)->CDH_CODLAN,1,1)=="1") .Or.;	//No formato antigo, os que iniciam por 1 sao lancamentos de NF
					   (!lOldLan .And. Len(Alltrim((cAliasCDH)->CDH_CODLAN))==10)		//Tamanho 10 eh soh os lancamentos de NF
						//³Se for ajuste com origem em NF, ja vai estar lancado no C197³
						aRegE110[15] += (cAliasCDH)->CDH_VALOR
					Else
						//Conforme cadastro de ajuste manual, quando a terceira posicao do codigo for
						//0=ICMS e a quarta for 5=Debitos especiais, considero este valor.
						If SubStr((cAliasCDH)->CDH_CODLAN,3,1)=="0" .And. SubStr((cAliasCDH)->CDH_CODLAN,4,1)=="5"
							aRegE110[15] += (cAliasCDH)->CDH_VALOR
						EndIf
						
						lGeraE111	:=	.T.

						//Se for ajuste de apuracao precisa lancar no E111
						If lOldLan
							cCodAjApur := cUf+"0"+"5"+"9999"
						EndIf
					
					EndIf
				
			EndCase   

			//REGISTRO E111 - AJUSTES/BENEFICIOS/INCENTIVO DA APURACAO DE ICMS
			//Tratamento para gerar a estrutura do retgistro E111 conforme condicoes acima
			If lGeraE111

				If !lConfig
					//Utiliza CDO para compor a descrição se estiver preenchida								
					cDescAj	:= DescCDO((cAliasCDH)->CDH_DESC, nTamCdhDes, cCodAjApur)
					if lExtratTAF  
						nScanE11 := aScan(aRegE111,{|x| x[03] == cCodAjApur .and. substr(x[04],1,12) == substr(cDescAj,1,12) .and. substr(x[06],1,6) == substr(Alltrim((cAliasCDH)->CDH_SUBITE ),1,6) })    
					endif 						
					if nScanE11 == 0 
						aAdd(aRegE111, {})
						nPosE111	:=	Len(aRegE111)
						aAdd (aRegE111[nPosE111], 1)								//01 - REG
						aAdd (aRegE111[nPosE111], "E111")							//01 - REG
						aAdd (aRegE111[nPosE111], cCodAjApur)						//02 - COD_AJ_APUR
						aAdd (aRegE111[nPosE111], cDescAj)							//03 - DESCR_COMPL_AJ
						aAdd (aRegE111[nPosE111], (cAliasCDH)->CDH_VALOR)			//04 - VL_AJ_APUR
					else
						aRegE111[nScanE11][05]	+= (cAliasCDH)->CDH_VALOR 
					endif 	
				Else
					If lMsgCjl 
						aCodLan :=	oJRetCda[Alltrim(cCodAjApur)]
						If Valtype(aCodLan) =='A' .And. Len(aCodLan) > 0
							For nI := 1 To Len(aCodLan)
								cDescAj := aCodLan[nI,9]						
								If AllTrim(aCodLan[nI,6]) = "01"
									nScanE11 := aScan(aRegE111,{|x| Alltrim(x[03]) == Alltrim(cCodAjApur)})    
								ElseIf AllTrim(aCodLan[nI,6]) = "02"
									nScanE11 := aScan(aRegE111,{|x| AllTrim(x[03]) == Alltrim(cCodAjApur) .and. substr(x[04],1,12) == substr(cDescAj,1,12) })      
								Else
									nScanE11 := 0
								Endif
								If nScanE11 == 0 
									aAdd(aRegE111, {})
									nPosE111	:=	Len(aRegE111)
									aAdd (aRegE111[nPosE111], 1)								//01 - REG
									aAdd (aRegE111[nPosE111], "E111")							//01 - REG
									aAdd (aRegE111[nPosE111], cCodAjApur)						//02 - COD_AJ_APUR
									aAdd (aRegE111[nPosE111], cDescAj)							//03 - DESCR_COMPL_AJ
									aAdd (aRegE111[nPosE111], aCodLan[nI,1]+aCodLan[nI,4])			//04 - VL_AJ_APUR
								Else
									aRegE111[nScanE11][05]	+= aCodLan[nI,1]+aCodLan[nI,4]
								Endif 
							Next	 				
						Endif	
					Endif	
				Endif
				
				If lExtratTAF
					if nScanE11 == 0 
						aAdd (aRegE111[nPosE111], substr(Alltrim((cAliasCDH)->CDH_SUBITE ),1,6))			//05 - SUBITEM  
					endif 	
					
					//creditos acumulados-
					If substr(Alltrim((cAliasCDH)->CDH_SUBITE ),1,6) $ ("002.20|002.21|007.40|007.41|002.23|007.44|007.45|007.49")
						aAdd(aRegT020AG, {})
						nPosT020AG	:=	Len(aRegT020AG)
						aAdd (aRegT020AG[nPosT020AG], cDescAj)						//01 - COD_AUTO
						aAdd (aRegT020AG[nPosT020AG], (cAliasCDH)->CDH_VALOR)						//02 - VALOR 
						aAdd (aRegT020AG[nPosT020AG], cCodAjApur + substr(Alltrim((cAliasCDH)->CDH_SUBITE ),1,6)) // chave de comparação  
					Endif
					
				Endif
			nScanE11	:=	0  				
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³REGISTRO E112 - INFORMACOES ADICIONAIS DOS AJUSTES DE APURACAO DO ICMS³
			//|                                                                      |
			//|Segundo o manuel, eh necessario haver um DA (Documento de arrecadacao |
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lCmpsE112 .And. nPosE111>0 .And. lAchouSF6
				aAdd(aRegE112, {})
				nPos	:=	Len (aRegE112)
				aAdd (aRegE112[nPos], nPosE111)					   			//RELACIONAMENTO COM O E111
				aAdd (aRegE112[nPos], "E112")								//01 - REG
				aAdd (aRegE112[nPos], SF6->F6_NUMERO)						//02 - NUM_DA
				aAdd (aRegE112[nPos], SF6->F6_NUMPROC)						//03 - NUM_PROC
				aAdd (aRegE112[nPos], SF6->F6_INDPROC)						//04 - IND_PROC
				aAdd (aRegE112[nPos], (cAliasCDH)->CDH_DESC)				//05 - PROC
				aAdd (aRegE112[nPos], SF6->F6_DESCOMP)						//06 - TXT_COMPL
				If lExtratTAF
					aAdd (aRegE112[nPos], IIF(Empty(SF6->F6_NUMERO),"",IIF(SF6->F6_TIPOIMP=="0","0","1")))		
				Endif
			EndIf
			
			//E112 via processo referenciado
			If nPosE111>0 .And. lProcE112 .And. lAchouCCF
				aAdd(aRegE112, {})
				nPos	:=	Len (aRegE112)
				aAdd (aRegE112[nPos], nPosE111)					   			//RELACIONAMENTO COM O E111
				aAdd (aRegE112[nPos], "E112")								//01 - REG
				aAdd (aRegE112[nPos], "")									//02 - NUM_DA
				aAdd (aRegE112[nPos], (cAliasCDH)->CDH_PROCES)				//03 - NUM_PROC
				aAdd (aRegE112[nPos], (cAliasCDH)->CDH_PROCTP)				//04 - IND_PROC
				aAdd (aRegE112[nPos], (cAliasCDH)->CDH_DESC)				//05 - PROC
				aAdd (aRegE112[nPos], CCF->CCF_DESCJU)						//06 - TXT_COMPL
			EndIf
			
			nPosE113	:= 1
			lCdoIndiv	:= .F.			
			//Posicionar na CDO e verificar se é eindividualizado
			If nPosE111 > 0 .AND. aSPDSX3[FP_CDO_AGRUPA] .AND. CDO->(dbSeek(aSPDFil[PFIL_CDO]+cCodAjApur)) .AND. CDO->CDO_AGRUPA == '2'
				nPosE113 	:=  aScan ( aLanCDA2, { |aX| alltrim(aX[18]) == alltrim(SubStr( (cAliasCDH)->CDH_TPLANC,3, Len((cAliasCDH)->CDH_TPLANC) )) .AND. alltrim(ax[1]) == alltrim(cCodAjApur ) }) 
				If nPosE113 > 0
					lCdoIndiv	:= .T.
				EndIF
			EndIF

			//REGISTRO E113: INFORMACOES ADICIONAIS DOS AJUSTES DA APURACAO DO ICMS
			//IDENTIFICACAO DOS DOCUMENTOS FISCAIS.
			If (lCmpsE113 .OR. lCdoIndiv) .And. nPosE111>0 .And. Len(aLanCDA2)>0				
								
				For nX := nPosE113  To Len(aLanCDA2)
					//Vai percorrer todo o Array aLanCDA2 (Totalizador CDA) em busca dos registro referentes ao Codigo de Ajuste do E111
					//e Filtrando por ICMS proprio, terceiro digito do Codigo de Ajuste = 0 e assim Gerar um E113 por documento.
						If AllTrim(aLanCDA2[nX][1]) == AllTrim(cCodAjApur) .And. SubStr(AllTrim(aLanCDA2[nX][1]),3,1) == "0" .AND. Iif(lCdoIndiv ,alltrim(aLanCDA2[nX][18]) == alltrim(SubStr( (cAliasCDH)->CDH_TPLANC,3, Len((cAliasCDH)->CDH_TPLANC) ))   , .T. ) 
							If ((cAliasCDH)->(FieldPos("CDH_TPLANC")) > 0 .And. substr((cAliasCDH)->CDH_TPLANC,1,1) <> "M") .Or. ((cAliasCDH)->(FieldPos("CDH_TPLANC")) == 0)

								cModelo	:=	AModNot(aLanCDA2[nX][8])
								cSerie	:=	SpedSerie(aLanCDA2[nX][9],cModelo)

								aAdd(aRegE113, {})
								nPos :=	Len(aRegE113)
								aAdd (aRegE113[nPos], nPosE111)																								//RELACIONAMENTO COM O E111
								aAdd (aRegE113[nPos], "E113")																								//01 - REG
								If !(AllTrim(cModelo) $ '65|63')																								
									aAdd (aRegE113[nPos], aLanCDA2[nX][15])																					//02 - COD_PART
								Else
									aAdd (aRegE113[nPos], "")                           																	//02 - COD_PART
								Endif
								aAdd (aRegE113[nPos], cModelo)																								//03 - COD_MOD
								aAdd (aRegE113[nPos], cSerie)																								//04 - SER
								aAdd (aRegE113[nPos], aLanCDA2[nX][20])																						//05 - SUB
								aAdd (aRegE113[nPos], aLanCDA2[nX][10])																						//06 - NUM_DOC 
								aAdd (aRegE113[nPos], StrZero(Day(aLanCDA2[nX][16]),2)+StrZero(Month(aLanCDA2[nX][16]),2)+StrZero(Year(aLanCDA2[nX][16]),4))//07 - DT_DOC
								aAdd (aRegE113[nPos], IIf(cUf<>"MS",aLanCDA2[nX][13],""))																	//08 - COD_ITEM						
								aAdd (aRegE113[nPos], Iif(!lConfig, aLanCDA2[nX][5], aLanCDA2[nX][5]+aLanCDA2[nX][6]))										//09 - VL_AJ_ITEM														
								
								IF cVersao >= "011"
									aAdd (aRegE113[nPos], aLanCDA2[nX][17])																					//10 - CHV_DOCe
								Endif
								//Caso exista produto incluo no 0200
								If !Empty(aLanCDA2[nX,13]) .And. cUf<>"MS" .And. !lExtratTAF
									If aScan ( aReg0200, { |aX| aX[2] == aLanCDA2[nX][13] }) == 0
									     //CH: TRQFF0 - Neste momento não tenho as informações do aProd pra passar nas posições 6 e 7 da SFRG0200()
									     //Como a SB1 já está aberta, porém desposicionada (está posicionada no primeiro registro da tabela)
									     //Monto um seek apenas para posicionar no produto que será carregado para 0200, assim o 0200 ficará em acordo com o E113
									    SPEDSeek("SB1",,aSPDFil[PFIL_SB1]+AllTRIM(Substr(aLanCDA2[nX][13],1,cTamProd)))
									    
									    //Ponto de entrada para tratamento da informação de produtos quando o mesmo estah fora do padrao do sistema
										cProd	:=	aLanCDA2[nX][13]
										
										If aExistBloc[05] 
											aProd := Execblock("SPEDPROD", .F., .F., {"SB1","E113"})
											If Len(aProd)>=11
												cProd 	:= 	aProd[1]						
											Else 
												aProd := {"","","","","","","","","","","",""}
											EndIf					
										EndIf			
										    						
										SFRG0200( cAlias, @aReg0200, @aReg0190, dDataDe, dDataAte, aProd, cProd, @aReg0220,,,,,,,,,,,,,,,,,,,aWizard )
									EndIf								
								EndIf													
							EndIf	
						EndIf
				Next(nX)
			EndIf        
			//REGISTRO E116 - OPERACOES DO ICMS A RECOLHER - OPERACOES PROPRIAS
        	If lAchouSF6 .And. !Empty((cAliasCDH)->CDH_CODLAN)
				//Condicao para tratar GNRE(Outros Debito) lancada manualmente na apuracao para gravar registro E116
        		If (cAliasCDH)->(Len(Alltrim(CDH_CODLAN))==8 .And. SubStr(CDH_CODLAN,4,1)=="0")
        			lGeraE116	:=	.T.
				//Condicao para tratar GNRE(Debito) lancada atraves do NF na apuracao para gravar registro E116
        		ElseIf (cAliasCDH)->(Len(Alltrim(CDH_CODLAN))==10 .And. SubStr(CDH_CODLAN,3,1)=="4")
        			lGeraE116	:=	.T.
				//Condicao para tratar GNRE(Debitos especiais) gerada pela apuracao atraves de um lancamento
				//manual ou por NF, para gravar registro E116
				ElseIf	(cAliasCDH)->(Len(Alltrim(CDH_CODLAN))==08 .And.  SubStr(CDH_CODLAN,4,1)=="5") .Or.;		//Manual
						(cAliasCDH)->(Len(Alltrim(CDH_CODLAN))==10 .And.  SubStr(CDH_CODLAN,3,1)=="7")			//Por NF
						lGeraE116	:=	.T.
				EndIf
			//Condicao para tratar GNRE(ICMS a recolher) gerada pela apuracao para gravar registro E116
			ElseIf lAchouSF6 .And. lGNREF3 .And. (cAliasCDH)->(CDH_LINHA=="GNR" .And. Alltrim(Substr(CDH_GNREF3,1,8))$"/RECSALDO/RDBESP/RDBESPST/RICDIF/RFECP/RICDIFRJ/RECIC/RECST")
        		lGeraE116	:=	.T.
    		EndIf
    		
    		//Verifico se a UF de Recolhimento do ICMS Proprio deve apresentar o campo 05 - COD_REC
			//considerando o Codigo da Receita + Classe de Vencimento ( F6_CODREC + F6_CLAVENC )
			cCodRec	:=	Iif( cMvEstado $ cMvSFUfGnr , "SF6->( Alltrim( F6_CODREC ) + Alltrim( F6_CLAVENC ) )" , "SF6->F6_CODREC" )
        		
			//Se algumas das condicoes acima mandar gerar a GNRE, faco isso neste momento
   			If lGeraE116
				aAdd(aRegE116, {})
				nPos	:=	Len(aRegE116)
				aAdd(aRegE116[nPos], 1)								//01 - REG //Como no E111 se faz necessario criar campo de amarração entre E111 e E116
				aAdd(aRegE116[nPos], "E116")							//01 - REG
				aAdd(aRegE116[nPos], Iif(aSPDSX3[FP_F6_COBREC] .And. !Empty(SF6->F6_COBREC) ,SF6->F6_COBREC,"000"))								//02 - COD_OR
				aAdd(aRegE116[nPos], SF6->F6_VALOR)					//03 - VL_OR
				aAdd(aRegE116[nPos], SF6->F6_DTVENC)					//04 - DT_VCTO
				aAdd(aRegE116[nPos], &( cCodRec ))						//05 - COD_REC
				aAdd(aRegE116[nPos], "")									//06 - NUM_PROC
				aAdd(aRegE116[nPos], "")									//07 - IND_PROC
				aAdd(aRegE116[nPos], "")									//08 - PROC
				aAdd(aRegE116[nPos], SF6->F6_OBSERV)					//09 - TXT_COMPL 
				
				If cVerSPDFis >= "004"
					aAdd(aRegE116[nPos],SF6->(StrZero(F6_MESREF,2)+cValToChar(F6_ANOREF)))//10 - MES_REF
				EndIf
				
				//Para o extrator fiscal preciso levar o número e o Tipo (0=Doc. Arrecad. 1= GNRE) da GNRE para amarrar no TAF
				if lExtratTAF
					aAdd(aRegE116[nPos], SF6->F6_NUMERO)					//11-Numero da Guia
					aAdd(aRegE116[nPos], IIF(Empty(SF6->F6_NUMERO),"",IIF(SF6->F6_TIPOIMP=="0","0","1")))	
				endif
			EndIf
		
			(cAliasCDH)->(dbSkip())		
		EndDo	//Fim do processamento da Apuracao de ICMS

		//³GRAVACAO DO REGISTRO E115- INF. ADICIONAIS DA APURACAO DO ICMS                          ³
		aRegE115 := RegE115(cAlias,dDataDe,dDataAte,lExtratTAF)

		If !lExtratTAF
			//³GRAVACAO DO REGISTRO E100 - PERIODO DA APURACAO DO ICMS                                 ³
			RegE100(cAlias,dDataDe,dDataAte)	
	
			//³GRAVACAO DO REGISTRO E110 - APURACAO DE ICMS - OPERACOES PROPRIAS                       ³			
			//|GRAVACAO DO REGISTRO E111 - AJUSTES/BENEFICIOS/INCENTIVO DA APURACAO DE ICMS            |
			//³GRAVACAO DO REGISTRO E112 - INFORMACOES ADICIONAIS DOS AJUSTES DE APURACAO DO ICMS      ³
			SPEDRegs(cAlias,{{aRegE110},aRegE111, {aRegE115, 1}, {aRegE116, 1} ,{aRegE112, 2}, {aRegE113,2}})
		endif
					
	//³REGISTRO E210 - APURACAO DO ICMS - SUBSTITUICAO TRIBUTARIA³
	ElseIf cImp == "ST"

		//Funcao responsavel pela geracao das informacoes do registro E200 e E210
		If !lExtratTAF		
			PrcE200E210(@aRegE200,@aRegE210,cMVSUBTRIB,cAlias,aVlrMovST,dDataDe,dDataAte,cMVSTNIEUF,cMVEstado)
		Else		
			PrcE200E210(@aRegE200,@aRegE210,cMVSUBTRIB,,aVlrMovST,dDataDe,dDataAte,cMVSTNIEUF,cMVEstado,lExtratTAF)
		EndIf	

		//Carrega ajustes na apuracao ICMS/ST
		While !(cAliasCDH)->(Eof())

			nRecnoSF6	:=	Iif(lTop,(cAliasCDH)->SF6RECNO,Nil)
			lAchouSF6	:=	.F.
			lAchouCCF	:=	.F.
			nUf 		:= 	0
			cUF 		:= 	Left((cAliasCDH)->CDH_CODLAN,2)
			cCodAjApur 	:= 	(cAliasCDH)->CDH_CODLAN
			nPosAj		:=	0
			cCodE240	:=	""
			lConfig		:=  .F.
			
			If Alltrim((cAliasCDH)->CDH_TPLANC) == "CF - Config Tributo"
				lConfig := .T.
			Endif    

			//Posicionamento da tabela SF6, tanto para TOP (RECNO) quanto para DBF/ADS
			If !Empty((cAliasCDH)->(CDH_ESTGNR+CDH_GNRE))
				lAchouSF6	:=	SPEDSeek("SF6",1,aSPDFil[PFIL_SF6]+(cAliasCDH)->(CDH_ESTGNR+CDH_GNRE),nRecnoSF6)
			EndIf
			
			//Verifica se existe Processo referenciado informado na apuração
			If lProcE112 .And. !Empty((cAliasCDH)->(CDH_PROCES+CDH_PROCTP+CDH_PROIND+CDH_ITPROC))
				lAchouCCF	:=	SPEDSeek("CCF",1,aSPDFil[PFIL_CCF]+(cAliasCDH)->(CDH_PROCES+CDH_PROCTP+CDH_PROIND+CDH_ITPROC))
			EndIf
			
			//³Processamento de subitens que tenha codigo de lancamento conforme manual SPED Fiscal³
            If !Empty((cAliasCDH)->CDH_CODLAN) .And. (nUf := aScan(aRegE200,{|x|x[2]==cUf}))>0

				//³Tratamento para verificar se o lancamento em processamento se refere a³
				//³  lancamento de NF ou manual na apuracao                              ³
				If lOldLan
					lAjusteNF  := SubStr((cAliasCDH)->CDH_CODLAN,1,1)=="1"
				Else
					If Len(Alltrim((cAliasCDH)->CDH_CODLAN))==8 .And. aSPDSX2[AI_CDO]
						lAjusteNF  := .F.

					ElseIf Len(Alltrim((cAliasCDH)->CDH_CODLAN))==10 
						lAjusteNF := .T.
                      
						//Se existir codigo de ajuste da CDH associado com
						//a tabela CC6, este valor deve ser utilizado para a
						//montagem do registro E240
						
						If aSPDSX3[FP_CC6_CLANAP].And.;
							CC6->(MsSeek(aSPDFil[PFIL_CC6]+(cAliasCDH)->CDH_CODLAN)) .And. !Empty(CC6->CC6_CLANAP)
							cCodE240	:=	CC6->CC6_CLANAP
						EndIf
					EndIf
				EndIf
			
		   		Do Case

					//Processamento dos subitens de "OUTROS DEBITOS", para gerar os campos:
					//(9)VL_OUT_DEB_ST = Valor total de ajustes "OUTROS DEBITOS ST ou ESTORNO DE CREDITOS ST"              ³
					//(10)VL_AJ_DEBITOS_ST =  Valor total dos ajustes a debitos de ST, provenientes de NF                                ³
					Case (cAliasCDH)->(CDH_LINHA$"002" .And. Alltrim(CDH_SUBITE)<>"002.00") .Or.;
						(cAliasCDH)->(CDH_LINHA$"003" .And. Alltrim(CDH_SUBITE)<>"003.00")
						
						//³Definicao de qual coluna o valor estara composto³
						nPosAj := Iif(lAjusteNF,11,10)
	
						//Para o codigo no formato antigo, devo remontar para o novo formato para nao
						//apresentar erro de validacao
						If !lAjusteNF .And. lOldLan
							If (cAliasCDH)->CDH_LINHA$"002"
								cCodAjApur := cMvEstado+"1"+"0"+"9999"
							Else
								cCodAjApur := cMvEstado+"1"+"1"+"9999"
							EndIf
						EndIf
	
					//Processamento dos subitens de "OUTROS CREDITOS", para gerar os campos:
					//(6)VL_OUT_CRED_ST = Valor total de ajustes "OUTROS CREDITOS ST ou ESTORNO DE DEBITOS ST"
					//(7)VL_AJ_CREDITOS_ST = Valor total dos ajustes a creditos de ST, provenientes de NF                                ³
					Case (cAliasCDH)->(CDH_LINHA$"007" .And. Alltrim(CDH_SUBITE)<>"007.00") .Or.;
						(cAliasCDH)->(CDH_LINHA$"008" .And. Alltrim(CDH_SUBITE)<>"008.00")
						//Definicao de qual coluna o valor estara composto
						nPosAj 	:= 	Iif(lAjusteNF,8,7)
	
						//Para o codigo no formato antigo, devo remontar para o novo formato para nao
						//apresentar erro de validacao
						If !lAjusteNF .And. lOldLan
							If (cAliasCDH)->CDH_LINHA$"007"
								cCodAjApur := cMvEstado+"1"+"2"+"9999"
							Else
								cCodAjApur := cMvEstado+"1"+"3"+"9999"
							EndIf
						EndIf
						
					//Processamento dos subitens de "ESTORNO DE DEBITOS", para gerar os campos:
					//(6)VL_OUT_CRED_ST = Valor total de ajustes "OUTROS CREDITOS ST ou ESTORNO DE DEBITOS ST"
					//(7)VL_AJ_CREDITOS_ST =  Valor total dos ajustes a creditos de ST, provenientes de NF                                ³
					Case (cAliasCDH)->(CDH_LINHA$"008" .And. Alltrim(CDH_SUBITE)<>"008.00")
						//³Definicao de qual coluna o valor estara composto³
						nPosAj 	:= 	Iif(lAjusteNF,8,7)
	
						//Para o codigo no formato antigo, devo remontar para o novo formato para nao
						//apresentar erro de validacao
						If !lAjusteNF .And. lOldLan
							cCodAjApur := cMvEstado+"1"+"3"+"9999"
						EndIf
	
					//Processamento dos subitens de "DEDUCOES", para gerar o campo:
					//(12)VL_DEDUCOES_ST = Valor total dos ajustes "DEDUCOES ST"
					//ESTORNO DE DEBITOS ST"
					Case (cAliasCDH)->(CDH_LINHA$"014" .And. Alltrim(CDH_SUBITE)<>"014.00")
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Definicao de qual coluna o valor estara composto³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						nPosAj := 13
	 
						//Para o codigo no formato antigo, devo remontar para o novo formato para nao
						//apresentar erro de validacao 
						If !lAjusteNF .And. lOldLan    
							cCodAjApur := cMvEstado+"1"+"4"+"9999" 
						EndIf   
	
					//Processamento dos subitens de "DEBITOS ESPECIAIS", para gerar o campo:
					//(15)DEB_ESP_ST = Valores recolhidos ou a recolher extra-apuracao
					Case (cAliasCDH)->(CDH_LINHA$"901" .And. Alltrim(CDH_SUBITE)<>"901.00") 
						//³Definicao de qual coluna o valor estara composto³
						nPosAj := 16 
						//Para o codigo no formato antigo, devo remontar para o novo formato para nao 
						//apresentar erro de validacao
						If !lAjusteNF .And. lOldLan        
							cCodAjApur := cMvEstado+"1"+"5"+"9999"  
						EndIf
						
				EndCase
			
				//³Gero quando achar um registro correspondente e quando o valor for maior que ZERO³
				If nUf>0 .And. nPosAj>0 .And. (cAliasCDH)->CDH_VALOR>0 .And. Substr((cAliasCDH)->CDH_CODLAN,3,1) <> "9"
					//REGISTRO E210 - APURACAO DO ICMS - SUBSTITUICAO TRIBUTARIA
					//Atualizo o valor do lancamento selecionado nas condicoes acima
					aRegE210[nUf][nPosAj] 	+= 	(cAliasCDH)->CDH_VALOR

					//REGISTRO E220 - AJUSTES/BENEFICIOS/INCENTIVOS DA APURACAO DO ICMS SUBSTITUICAO TRIBUTARIA
					//Para lancamentos manuais, devo gerar o registro E220
					If (!lAjusteNF) .Or. (!Empty(cCodE240) .And. lCmpsE240)

						If !lConfig
							//Utiliza CDO para compor a descrição se estiver preenchida
							cDescAj	:= DescCDO((cAliasCDH)->CDH_DESC, nTamCdhDes, Iif(!Empty(cCodE240),cCodE240,cCodAjApur))						

							aAdd(aRegE220, {})	
							nPosE220	:=	Len (aRegE220)
							aAdd (aRegE220[nPosE220], nUF)							   				//Relacionamento com o registro E210
							aAdd (aRegE220[nPosE220], "E220")						   				//01 - REG
							aAdd (aRegE220[nPosE220], Iif(!Empty(cCodE240),cCodE240,cCodAjApur))	//02 - COD_AJ_APUR
							aAdd (aRegE220[nPosE220], cDescAj)										//03 - DESCR_COMPL_AJ
							aAdd (aRegE220[nPosE220], (cAliasCDH)->CDH_VALOR)						//04 - VL_AJ_APUR
							If lExtratTAF
								aAdd (aRegE220[nPosE220], (cAliasCDH)->CDH_SUBITE)					//05 - VL_AJ_APUR
							Endif
						Else
							If lMsgCjl 
								aCodLan :=	oJRetCda[Alltrim(cCodAjApur)]
								If Valtype(aCodLan) =='A' .And. Len(aCodLan) > 0
									For nI := 1 To Len(aCodLan)						
										cDescAj := aCodLan[nI,9]
										If Alltrim(aCodLan[nI,6]) = "01"
											nPosE220 := aScan(aRegE220,{|x| x[03] == Iif(!Empty(cCodE240),cCodE240,cCodAjApur)})    
										//ElseIf Alltrim(aCodLan[nI,6]) = "02"
										//	nPosE220 := aScan(aRegE220,{|x| Alltrim(x[03]) == Alltrim(cCodAjApur) .and. substr(x[04],1,12) == substr(cDescAj,1,12) })      
										Else
											nPosE220 := 0
										Endif
										If nPosE220 = 0
											aAdd(aRegE220, {})	
											nPosE220	:=	Len (aRegE220)
											aAdd (aRegE220[nPosE220], nUF)							   					//Relacionamento com o registro E210
											aAdd (aRegE220[nPosE220], "E220")						   					//01 - REG
											aAdd (aRegE220[nPosE220], Iif(!Empty(cCodE240),cCodE240,cCodAjApur))		//02 - COD_AJ_APUR
											aAdd (aRegE220[nPosE220], cDescAj)											//03 - DESCR_COMPL_AJ
											aAdd (aRegE220[nPosE220], aCodLan[nI,1]+aCodLan[nI,4])	//04 - VL_AJ_APUR
										Else
											aRegE220[nPosE220,5] +=  aCodLan[nI,1]+aCodLan[nI,4]       	//04 - VL_AJ_APUR	
										Endif	
									Next	
								Endif	
							Endif							
						Endif
					EndIf
					
					//REGISTRO E230 - INFORMACOES ADICIONAIS DOS AJUSTES DE APURACAO DO ICMS SUBSTITUICAO TRIBUTARIA
					//Segundo o manuel, eh necessario haver um DA (Documento de arrecadacao
					If nPosE220>0 .And. lAchouSF6
						aAdd(aRegE230, {})
						nPos	:=	Len (aRegE230)
						aAdd (aRegE230[nPos], nPosE220)	 						   			//RELACIONAMENTO COM O E220
						aAdd (aRegE230[nPos], "E230")										//01 - REG
						aAdd (aRegE230[nPos], SF6->F6_NUMERO)								//02 - NUM_DA
						aAdd (aRegE230[nPos], SF6->F6_NUMPROC)								//03 - NUM_PROC
						aAdd (aRegE230[nPos], SF6->F6_INDPROC)								//04 - IND_PROC
						aAdd (aRegE230[nPos], (cAliasCDH)->CDH_DESC)						//05 - PROC
						aAdd (aRegE230[nPos], SF6->F6_DESCOMP)								//06 - TXT_COMPL
						If lExtratTAF
							aAdd (aRegE230[nPos], IIF(Empty(SF6->F6_NUMERO),"",IIF(SF6->F6_TIPOIMP=="0","0","1")))		//07 - COD_DA
						Endif
					EndIf

					//E230 via Processo referenciado
					If nPosE220>0 .And. lProcE112 .And. lAchouCCF
						aAdd(aRegE230, {})
						nPos	:=	Len (aRegE230)
						aAdd (aRegE230[nPos], nPosE220)	 						   			//RELACIONAMENTO COM O E220
						aAdd (aRegE230[nPos], "E230")										//01 - REG
						aAdd (aRegE230[nPos], "")											//02 - NUM_DA
						aAdd (aRegE230[nPos], (cAliasCDH)->CDH_PROCES)						//03 - NUM_PROC
						aAdd (aRegE230[nPos], (cAliasCDH)->CDH_PROCTP)						//04 - IND_PROC
						aAdd (aRegE230[nPos], (cAliasCDH)->CDH_DESC)						//05 - PROC
						aAdd (aRegE230[nPos], CCF->CCF_DESCJU)								//06 - TXT_COMPL
						If lExtratTAF
							aAdd (aRegE230[nPos], IIF(Empty(SF6->F6_NUMERO),"",IIF(SF6->F6_TIPOIMP=="0","0","1")))		//07 - COD_DA
						Endif
					EndIf

					nPosE240	:= 1
					lCdoIndiv	:= .F.			
					//Posicionar na CDO e verificar se é eindividualizado
					If nPosE220 > 0 .AND. aSPDSX3[FP_CDO_AGRUPA] .AND. CDO->(dbSeek(aSPDFil[PFIL_CDO]+cCodAjApur)) .AND. CDO->CDO_AGRUPA == '2'
						nPosE240 	:=  aScan ( aLanCDA2, { |aX| alltrim(aX[18]) == alltrim(SubStr( (cAliasCDH)->CDH_TPLANC,3, Len((cAliasCDH)->CDH_TPLANC) ))  .AND. alltrim(ax[1]) == alltrim(cCodAjApur ) }) 
						If nPosE240 > 0
							lCdoIndiv	:= .T.
						EndIF
					EndIF

					//REGISTRO E240 - INFORMACOES ADICIONAIS DOS AJUSTES DE APURACAO DO ICMS SUBSTITUICAO TRIBUTARIA
					//Este registro deve ser apresentado para identificação dos documentos fiscais relacionados ao ajuste
					If (lCmpsE240 .OR. lCdoIndiv) .And. nPosE220>0 .And. Len(aLanCDA2)>0
						For nX := nPosE240 To Len(aLanCDA2)
							//Vai percorrer todo o Array aLanCDA2 (Totalizador CDA) em busca dos registro referentes ao Codigo de Ajuste do E111
							//e Filtrando por ICMS Solidario, terceiro digito do Codigo de Ajuste = 0 e assim Gerar um E113 por documento.
							If AllTrim(aLanCDA2[nX][1]) == AllTrim(cCodAjApur) .And. SubStr(AllTrim(aLanCDA2[nX][1]),3,1) == "1" .AND. Iif(lCdoIndiv ,alltrim(aLanCDA2[nX][18]) == alltrim(SubStr( (cAliasCDH)->CDH_TPLANC,3, Len((cAliasCDH)->CDH_TPLANC) ))  , .T. ) 
								If ((cAliasCDH)->(FieldPos("CDH_TPLANC")) > 0 .And. substr((cAliasCDH)->CDH_TPLANC,1,1) <> "M") .Or. ((cAliasCDH)->(FieldPos("CDH_TPLANC")) == 0)

									cModelo	:=	AModNot(aLanCDA2[nX][8])
									cSerie	:=	SpedSerie(aLanCDA2[nX][9],cModelo)

									aAdd(aRegE240, {})
									nPos :=	Len(aRegE240)
									aAdd (aRegE240[nPos], nPosE220)								//RELACIONAMENTO COM O E111
									aAdd (aRegE240[nPos], "E240")								//01 - REG
									aAdd (aRegE240[nPos], aLanCDA2[nX][15])						//02 - COD_PART
									aAdd (aRegE240[nPos], cModelo)								//03 - COD_MOD
									aAdd (aRegE240[nPos], cSerie)								//04 - SER
									aAdd (aRegE240[nPos], aLanCDA2[nX][20])						//05 - SUB
									aAdd (aRegE240[nPos], aLanCDA2[nX][10])						//06 - NUM_DOC 
									aAdd (aRegE240[nPos], StrZero(Day(aLanCDA2[nX][16]),2)+StrZero(Month(aLanCDA2[nX][16]),2)+StrZero(Year(aLanCDA2[nX][16]),4))	//07 - DT_DOC
									aAdd (aRegE240[nPos], aLanCDA2[nX][13])						//08 - COD_ITEM
									aAdd (aRegE240[nPos], Iif(!lConfig, aLanCDA2[nX][5], aLanCDA2[nX][5]+aLanCDA2[nX][6]))	//09 - VL_AJ_ITEM
									IF cVersao >= "011"
										aAdd (aRegE240[nPos], aLanCDA2[nX][17])					//10 - CHV_DOCe
									Endif
									IF aScan ( aReg0200, { |aX| aX[2] == aLanCDA2[nX][13] }) == 0									     
										SPEDSeek("SB1",,aSPDFil[PFIL_SB1]+AllTRIM(Substr(aLanCDA2[nX][13],1,cTamProd)))
										SFRG0200( cAlias, @aReg0200, @aReg0190, dDataDe, dDataAte, , , @aReg0220,,,,,,,,,,,,,,,,,,,aWizard )
									EndIf
										
								EndIf
							EndIf
						Next(nX)
					EndIf 
				EndIf
			//REGISTRO E250 - OBRIGACOES DO ICMS A RECOLHER - SUBSTITUICAO TRIBUTARIA
			//Gero registro E250 para todas as GNREs geradas pela Apuracao de ICMS/ST
			ElseIf (cAliasCDH)->CDH_LINHA=="GNR" .And. lAchouSF6 .And. (nUf := aScan(aRegE200,{|x|x[2]==SF6->F6_EST}))>0

				//Verifico se a UF de Recolhimento do ICMS Proprio deve apresentar o campo 05 - COD_REC
				//considerando o Codigo da Receita + Classe de Vencimento ( F6_CODREC + F6_CLAVENC )
				cCodRec	:=	Iif( cMvEstado $ cMvSFUfGnr , "SF6->( Alltrim( F6_CODREC ) + Alltrim( F6_CLAVENC ) )" , "SF6->F6_CODREC" )
								
				aAdd(aRegE250, {})
				nPos	:=	Len (aRegE250)
				aAdd(aRegE250[nPos], nUF)									//Relacionamento com o PAI - E210
				aAdd(aRegE250[nPos], "E250")								//01 - REG

				//³Definindo o codigo da obrigacao a recolher³
				If SF6->F6_OPERNF == "1"
					aAdd (aRegE250[nPos], "001")							//02 - COD_OR - Entradas
					
				ElseIf SF6->F6_EST==cMvEstado
					aAdd (aRegE250[nPos], "002")							//02 - COD_OR - Saidas p/ Estado
					
				Else	
					aAdd (aRegE250[nPos], "999")							//02 - COD_OR - Saidas fora Estado
					
				EndIf
			
				aAdd(aRegE250[nPos], SF6->F6_VALOR)							//03 - VL_OR
				aAdd(aRegE250[nPos], SF6->F6_DTVENC)						//04 - DT_VCTO
				aAdd(aRegE250[nPos], &( cCodRec ))							//05 - COD_REC				
				aAdd(aRegE250[nPos], SF6->F6_NUMPROC)						//06 - NUM_PROC
				aAdd(aRegE250[nPos], SF6->F6_INDPROC)						//07 - IND_PROC
				aAdd(aRegE250[nPos], SF6->F6_DESCOMP)						//08 - PROC
				aAdd(aRegE250[nPos], SF6->F6_OBSERV)						//09 - TXT_COMPL    
			
				If cVerSPDFis >= "004" //A partir de janeiro de 2011 incluir o campo 10 mmaaaa
					aAdd(aRegE250[nPos], SF6->(StrZero(F6_MESREF,2)+cValToChar(F6_ANOREF)))//10 - MES_REF
				EndIf
				
				//Para o extrator fiscal preciso levar o número da GNRE para amarrar no TAF
				if lExtratTAF
					aAdd(aRegE250[nPos], SF6->F6_NUMERO)					//11-Numero da Guia	
					aAdd(aRegE250[nPos], IIF(Empty(SF6->F6_NUMERO),"",iIF(SF6->F6_TIPOIMP=="0","0","1")) )//12 - COD_DA	
				endif

			EndIf

			(cAliasCDH)->(dbSkip())			
	    EndDo
         
		//Apos o fim do processamento das informacoes da apuracao, eh necessario
		//complementa-los com algumas que faltaram
		SpedApE200(aRegE200,@aRegE210,@aRegE250,aVlrMovST,nApuracao,nPeriodo,cNrLivro,cArqAnt,cMVEstado,aIcmPago,cMVSUBTRIB,lExtratTAF)

		If !lExtratTAF
			SPEDRegs(cAlias,{aRegE200,aRegE210,aRegE220,{aRegE250,2}, {aRegE230,3},{aRegE240,3}})
		EndIF    

	EndIf          
	
	//Alimento os Arrays de Retorno do Extrator TAF
	If lExtratTAF
		If cImp=="IC"
			aRegT020   := aRegE110 
			aRegT020AA := aRegE111 
			aRegT020AB := aRegE112 
			aRegT020AC := aRegE113 
			aRegT020AD := aRegE115 
			aRegT020AE := aRegE116 
			
		Elseif cImp=="ST"
			aRegT021Est := aRegE200
			aRegT021Val := aRegE210     
			aRegT021AA  := aRegE220   
			aRegT021AB  := aRegE230
			aRegT021AC  := aRegE240	
			aRegT021AD  := aRegE250			
		endif
	EndIf		
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Fecho query ou indregua criada³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	SPEDFFiltro(2,,cAliasCDH)
Else
	lRet := .F.
EndIf

Return lRet
/*ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³PrcE200E21| Autor ³Gustavo G. Rueda 			   ³ Data ³04.05.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡ao ³                        GERACAO DO BLOCO E                         ³±± 
±±³          ³REGISTRO E200 - PERIODO DA APURACAO DO ICMS ST                     ³±± 
±±³          ³REGISTRO E210 - APURACAO DO ICMS - SUBSTITUICAO TRIBUTARIA         ³±±  
±±³          ³Funcao utilizada para montar a estrutura dos registros acima       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1 -> Identifica se houve movimento no periodo ou nao           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³aRegE200 -> Array com as informacoes do registro E200              ³±±
±±³          ³aRegE210 -> Array com as informacoes do registro E210              ³±±
±±³          ³cMVSUBTRIB -> Conteudo do parametro MV_SUBTRIB                     ³±±
±±³          ³cAlias   -> Alias do TRB                                           ³±±
±±³          ³aVlrMovST- Valores de apuracao obtidos durante o processamento dos ³±±
±±³          ³           documentos                                              ³±±
±±³			 |dDataDe -> Data inicial do periodo base do arquivo.                ³±±
±±³			 |dDataAte -> Data final do periodo base do arquivo.                 ³±±
±±³			 |cMVSTNIEUF - Conteudo do parametro MV_STNIEUF, auxilia do MV_SUBTRIB³±±
±±³			 |cMVEstado -> Conteudo do parametro MV_ESTADO                       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function PrcE200E210(aRegE200,aRegE210,cMVSUBTRIB,cAlias,aVlrMovST,dDataDe,dDataAte,cMVSTNIEUF,cMVEstado,lExtratTAF )
Local	aReg0015	:=	{}
Local	nX			:=	0
Local	cUf			:=	""
Local	nUf			:=	0  

Default lExtratTAF := .F.

//0015 - DADOS DO CONTRIBUINTE SUBSTITUTO
//Verifico todas as UFs onde ha inscricao, porem nao houve movimentacao
aReg0015	:=	Reg0015(cMVSUBTRIB,cAlias,lExtratTAF)

//Montando os registros E200 e E210 conforme parametro MV_SUBTRIB
//Este parametro determina os estados que pago o ICMS/ST, portanto
//sao os estados que posso vender com ICMS/ST retido
//O registro E200 soh posso ter 1 por UF + PERIODO 
//O registro E210 soh posso ter 1 para cada E200
For nX := 1 To Len(aReg0015)
	cUF	:=	aReg0015[nX,2]
	If aScan(aRegE200,{|x|x[2]==cUf})==0
		//³Crio uma entrada no array E200
		aAdd(aRegE200,{"E200",cUf,dDataDe,dDataAte})				

		//Crio um relacionamento com o filho, E210
		nUf := Len(aRegE200)			
		aAdd(aRegE210,{nUf,"E210","0",0,0,0,0,0,0,0,0,0,0,0,0,0})			
	EndIf	
Next nX

//Montando os registros E200 e E210 conforme movimento de documentos
//O registro E200 soh posso ter 1 por UF + PERIODO
//O registro E210 soh posso ter 1 para cada E200
For nX := 1 To Len(aVlrMovST)
	cUF	:=	aVlrMovST[nX,1]			
	If aScan(aRegE200,{|x|x[2]==cUf})==0
		//³Crio uma entrada no array E200
		aAdd(aRegE200,{"E200",cUf,dDataDe,dDataAte})				

		//Crio um relacionamento com o filho, E210
		nUf := Len(aRegE200)			
		aAdd(aRegE210,{nUf,"E210","0",0,0,0,0,0,0,0,0,0,0,0,0,0})			
	EndIf		
Next nX
//Parametro MV_STNIEUF
//Tratamento para acordo entre os estados preenchidos no parametro MV_STNIEUF, quando em
//um movimento com ICMS-ST nao e' necessario ter incscricao estadual. 
//Este tratamento foi feito a partir da necessidade das UF de MG p/ PR,onde existe esse 
// acordo PROTOCOLO ICMS CONSELHO NACIONAL DE POLÍTICA FAZENDÁRIA - CONFAZ Nº 191 DE 11.12.2009

If Len(cMVSTNIEUF)>=4 
	For nX := 1 To Len(cMVSTNIEUF) Step 5
		cUF	:=	SubStr(cMVSTNIEUF,nX,2)
		If cUF==cMVEstado
			cUF	:=	SubStr(cMVSTNIEUF,nX+2,2)
			If aScan(aRegE200,{|x|x[2]==cUf})==0
				//³Crio uma entrada no array E200
				aAdd(aRegE200,{"E200",cUf,dDataDe,dDataAte})				
		
				//Crio um relacionamento com o filho, E210
				nUf := Len(aRegE200)			
				aAdd(aRegE210,{nUf,"E210","0",0,0,0,0,0,0,0,0,0,0,0,0,0})			
			EndIf
		EndIf
	Next
EndIf
Return

/*ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³RegEcf    ³ Autor ³ Vendas e CRM          ³ Data ³ 29/01/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Efetua a carga dos arrays dos registros de ECF             ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function RegEcf (aRegC400, aRegC405, aRegC410,	aRegC420,;
						aRegC425, aRegC460, aRegC470,	aRegC490,;
						aRegC495, aProdB1,  dDataDe,	dDataAte,;
						cPerfil,  cAlias,   aReg0200,	aReg0190,;
						aReg0220, aReg1600, aReg0150,	aWizard,;
						lTop,     cUf,		lLegisPer,	cNrlivro, aRegC430 )

Local   aAreaSFT    :=  SFT->(GetArea())
Local 	lRet   		:= 	.T.
Local 	nPos400		:= 	0
Local 	nPos405		:= 	0
Local 	aPos420		:= 	{}
Local 	aTotaliz	:= 	{}
Local 	nX			:= 	0
Local 	lGer490		:= 	.F.
Local   lGer410		:= .F.

//Novos
Local 	aParametros	:=	{}
Local	cAliasSFI	:=	"SFI"
Local	nRecSFI		:=	0
Local 	nValCof 	:= 0
Local	nValPis 	:= 0
Local 	nQuantD   	:= Min(TAMSX3("FT_QUANT")[2],3)
Local  	aSLX 		:= {}
Local  cEspecie 	:= PadR("CF",TamSX3("FT_ESPECIE")[1])

Local 	cHierC400	:= "" 
Local   cHierC405	:= ""

SLG->(MsSeek (cFilAnt,.T.))
While SLG->(!Eof() .AND. cFilAnt==LG_FILIAL)

	aParametros	:=	{}
	aAdd(aParametros,DToS(dDataDe))
	aAdd(aParametros,DToS(dDataAte))
	aAdd(aParametros,SLG->LG_PDV)
	aAdd(aParametros,SLG->LG_SERPDV)
	If SPEDFFiltro(1,"SFI",@cAliasSFI,aParametros,,1)

		While !(cAliasSFI)->(Eof())

			//Tratamento para armazenar o recno da tabela SFI para um processamento seguinte, e
			//no caso de TOP, posiciono o SFI de acordo com o RECNO do SELECT
			If lTop
				nRecSFI := (cAliasSFI)->SFIRECNO
				SPEDSeek("SFI",,,nRecSFI)
			EndIf
			nRecSFI := SFI->(Recno())
			
			DbSelectArea("SFT")
			SFT->(DbSetOrder(7))
			If SFT->(DbSeek( aSPDFil[PFIL_SFT]+"S"+SFI->FI_PDV+cEspecie+DToS(SFI->FI_DTMOVTO)))//FT_FILIAL, FT_TIPOMOV, FT_PDV, FT_ESPECIE, FT_ENTRADA, R_E_C_N_O_, D_E_L_E_T_
				
				If SFT->FT_NRLIVRO == cNrlivro .OR. Alltrim(cNrlivro) == "*"

					cHierC400 := ""

					RegC400 (@aRegC400, SLG->LG_IMPFISC, SLG->LG_SERPDV, AllTrim(SLG->LG_PDV),;
							@nPos400, @cHierC400) 

					cHierC405 := cHierC400
	
					RegC405 (@aRegC405		, nPos400, 			SFI->FI_DTMOVTO, 	SFI->FI_CRO, ;
							 SFI->FI_NUMREDZ, SFI->FI_NUMFIM, 	SFI->FI_GTFINAL, 	(SFI->FI_VALCON+SFI->FI_ISS),;
							 @nPos405		, SFI->FI_DESC, 	SFI->FI_CANCEL, 	@cHierC405) 
	
					If lLegisPer
						lGer410 := .F.
					Else
						lGer410 := .T.
					EndIf
	
					//³Carrego todos os codigos e valores que foram contabilizados no SFI
					aTotaliz := TotalizSFI(nRecSFI, .T.)
					lGer490	 := .F.
	
					RegC420 (@aRegC420, 	nPos405,   	SFI->FI_CRO, 		SFI->FI_NUMREDZ,;
							 aTotaliz,		@aPos420,	cHierC405) 
	
					If cUf <> "BA" .OR. (cUf == 'BA' .AND. cVersao >= '008')  
						If cPerfil == "B"
							If !RegC425(@aRegC425	, @aProdB1	, SFI->FI_DTMOVTO, SFI->FI_PDV	,;
										aPos420		, cAlias	, @aReg0200	, @aReg0190	,;
										@aReg0220	, @lGer490	, @aRegC490	, nPos405	,;
										dDataDe		, dDataAte	, aWizard	, nQuantD	, lTop, cHierC405)

								//Se nao for encontrado registro 425 para o 420, remove a ultima linha 
								//dos registros 405, 410 e 420
								If Len(aRegC405) > 0 
									aDel(aRegC405, nPos405)
									aSize(aRegC405, nPos405 -1)
								EndIf
	
								// No caso do C420 possui varias linhas para serem excluidas
								nX := 1
								While( Len(aRegC420) >= nX )
									If aRegC420[nX][1] == nPos405
										aDel(aRegC420, nX)
										aSize(aRegC420, Len(aRegC420)-1)
									Else
										nX++
									EndIf		
								End
								lGer410 := .F.
							EndIf
						ElseIF !cPerfil$"B/C"
							RegC460470 (@aRegC460, @aRegC470	,;
										SFI->FI_DTMOVTO, SFI->FI_PDV,;
										@aProdB1 , SFI->FI_COO	,;
										nPos405  , cAlias		,;
										@aReg0200, @aReg0190	,;
										@aReg0220, @lGer490		,;
										@aRegC490, dDataDe		,;
										dDataAte , aWizard 		,;
										nQuantD  , lTop			, cHierC405 )
						EndIf
					EndIf
	
					nValCof := 0
					nValPis := 0
	
					RegC490(@aRegC490	, SFI->FI_DTMOVTO,	nPos405,;
							SFI->FI_PDV	, @aProdB1,			nPos405,;
							@aReg0200	, cAlias,;
							@AREG0190	, @AREG0220,;
							@nValCof	, @nValPis, cHierC405  )
	
					//Perfil C nao deve gerar C410
					If lGer410 .And. cPerfil<>"C" .And. "1"$aWizard[1][15]// Depois de ter os valores de PIS e COFINS gera o C410
						RegC410 (  @aRegC410	   , nPos405 	 , nValCof 	, nValPis  ,;
								   SFI->FI_DTMOVTO , SFI->FI_PDV , lTop		, cHierC405 ) 					 
					EndIf				                                                         
				EndIf
			EndIf				 
			(cAliasSFI)->(dbSkip())		
		End
		//Encerro o alias criado anteriormente
		SPEDFFiltro(2,,cAliasSFI)
	EndIf	
	
	If cUf == "BA"  .And. cPerfil <> "C" .AND. cVersao < '008'
		If nPos400 > 0 //So gera o Registro C495, caso tenha gerado tambem o Registro C400
			RegC495 (@aRegC495	, @aProdB1				, nPos400	, dDataDe	,;
					 dDataAte	, AllTrim(SLG->LG_PDV)	, @aReg0200	, cAlias 	,;
					 @aReg0190 	, @aReg0220 			, @aSLX 	, aSPDFil[PFIL_SB1], aWizard, cHierC400 )
		EndIf
	EndIf
			
	SLG->(dbSkip()) 		
End 

//Verifica se deve gerar registro 1600
If "1"$aWizard[4][7]
	GerDad1600(@aReg1600,@aReg0150,dDataDe,dDataAte,cAlias,aWizard)
EndIf

RestArea(aAreaSFT)

Return(lRet)
/*ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³LjNaoTrib ³ Autor ³ Vendas e CRM				   ³ Data ³ 09/09/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Tratamento especial quando for o tipo de tributacao for "N" ou "O"³±±
±±³          ³ Nao tributado ou Outros.											 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function LjNaoTrib( aLinhaPai , dDtMovim , cPdv 		, aProdB1  ,;
							cAlias	 , aReg0200	, aReg0190	, aReg0220 ,;
							aRegC425 , dDataDe	, dDataAte  , aWizard  , cHierarq )

Local cSituaTrib := "" 					 // Situacao Tributaria
Local nTamFTItem := TamSx3("FT_ITEM")[1] // Tamamanho do FT_ITEM
Local nPosAux	 := 0					 // Posicao Auxiliar
Local nPos		 := 0					 // Posicao do array
Local lRet		 := .F.					 // Retorno Logico
Local cProd		 := ""
Local aProd		 := {}

DEFAULT dDatade  := dDtMovim
DEFAULT dDataAte := dDtMovim
DEFAULT aWizard  := {}

DbSelectArea("SF2")
DbSetOrder(3)   //F2_FILIAL+F2_ECF+DTOS(F2_EMISSAO)+F2_PDV+F2_SERIE+F2_MAPA+F2_DOC
If MsSeek(aSPDFil[PFIL_SF2]+"S"+DtoS(dDtMovim)+cPdv)     
	
	While !SF2->(Eof()) .AND. aSPDFil[PFIL_SF2] == SF2->F2_FILIAL .AND.;
			dDtMovim = SF2->F2_EMISSAO .AND. cPdv == SF2->F2_PDV
	
		DbSelectArea("SD2")			         
		DbSetOrder(3)		// D2_DOC+D2_SERIE+D2_CLIENTE+D2_LOJA+D2_COD+D2_ITEM
		If MsSeek(aSPDFil[PFIL_SD2]+SF2->F2_DOC+SF2->F2_SERIE+SF2->F2_CLIENTE+SF2->F2_LOJA)  
			   
			While !SD2->(Eof()) .AND.(aSPDFil[PFIL_SD2] == SD2->D2_FILIAL) .AND.;
				   (SD2->D2_FILIAL+ SD2->D2_DOC+SD2->D2_SERIE+SD2->D2_CLIENTE+SD2->D2_LOJA) ==;
				   (SF2->F2_FILIAL+ SF2->F2_DOC+SF2->F2_SERIE+SF2->F2_CLIENTE+SF2->F2_LOJA)
				
				cSituaTrib := LjSitTrib("SD2",.T.)	  // Retorna a Situacao Tributaria 
				If cSituaTrib == "N"	// Nao Tributado					
					cProd	:= SD2->D2_COD+Iif(lConcFil,cFilAnt,"")
					If aExistBloc[05]
						aProd := Execblock("SPEDPROD", .F., .F., {"SD2","C425"})
						If Len(aProd)>=11
							cProd 	:= 	aProd[1]
						Else
							aProd := {"","","","","","","","","","","",""}
						EndIf
					EndIf									
					//³Preenchimento do registro 425
					nPosAux := Ascan(aRegC425, {|x| x[3] == cProd .AND. x[1] == aLinhaPai[1]})
									
					If nPosAux ==  0			
						aAdd(aRegC425, {})        
						nPos :=	Len (aRegC425)
			
						aAdd (aRegC425[nPos], aLinhaPai[1]							)	 	   	//00 - POSICAO DO REG. PAI
						aAdd (aRegC425[nPos], "C425"		 						)	 	   	//01 - REG
						aAdd (aRegC425[nPos], cProd									)	 	   	//02 - COD_ITEM
						aAdd (aRegC425[nPos], SD2->D2_QUANT							)	 	   	//03 - QTD
						aAdd (aRegC425[nPos], RetUMProd(@aProdB1, SD2->D2_COD)[1]	)	 	   	//04 - UNID
						aAdd (aRegC425[nPos], SD2->D2_TOTAL							)			//05 - VL_ITEM  	
						aAdd (aRegC425[nPos], 0										)	 	   	//06 - VL_PIS
						aAdd (aRegC425[nPos], 0										)	 	   	//07 - VL_COFINS 

						aAdd (aRegC425[nPos], cHierarq + "C420" + StrZero(aLinhaPai[1], nTTRBITEM, 0) + "C425" + StrZero(nPos, nTTRBITEM, 0) )				//08 - Posicao de Hierarquia, utilizada para organizacao dos registros		
					Else 
						aRegC425[nPosAux][4] += SD2->D2_QUANT			   						//03 - QTD			
						aRegC425[nPosAux][6] += SD2->D2_TOTAL									//05 - VL_ITEM
					EndIf
					
					If aScan (aReg0200, {|aX| aX[2]==cProd}) == 0
						SFRG0200(cAlias, @aReg0200, @aReg0190, dDataDe, dDataAte,,cProd,@aReg0220,,,,,,,,,,,,,,,,,,,aWizard)
					EndIf
		
					lRet := .T.
					
				ElseIf cSituaTrib == "O"           // Outros
					//³Preenchimento do registro 425
					DbSelectArea("SFT")
					DbSetOrder(1) //FT_FILIAL+FT_TIPOMOV+FT_SERIE+FT_NFISCAL+FT_CLIEFOR+FT_LOJA+FT_ITEM+FT_PRODUTO
					If MsSeek( aSPDFil[PFIL_SFT] + "S"+ SF2->F2_SERIE+SF2->F2_DOC+SF2->F2_CLIENTE+SF2->F2_LOJA+;
								Padr(SD2->D2_ITEM,nTamFTItem) + SD2->D2_COD )					
					
						cProd	:= SFT->FT_PRODUTO+Iif(lConcFil,cFilAnt,"")
						If aExistBloc[05]
							aProd := Execblock("SPEDPROD", .F., .F., {"SFT","C425"})
							If Len(aProd)>=11
								cProd 	:= 	aProd[1]
							Else
								aProd := {"","","","","","","","","","","",""}
							EndIf
						EndIf					    
					
						nPosAux := Ascan(aRegC425, {|x| x[3] == cProd .AND. x[1] == aLinhaPai[1]})
										
						If nPosAux ==  0			
							aAdd(aRegC425, {})        
							nPos :=	Len (aRegC425)
				
							aAdd (aRegC425[nPos], aLinhaPai[1]							 )	 	   	//00 - POSICAO DO REG. PAI
							aAdd (aRegC425[nPos], "C425"		 						 )	 	   	//01 - REG
							aAdd (aRegC425[nPos], cProd									 )	 	   	//02 - COD_ITEM
							aAdd (aRegC425[nPos], SFT->FT_QUANT							 )	 	   	//03 - QTD
							aAdd (aRegC425[nPos], RetUMProd(@aProdB1, SFT->FT_PRODUTO)[1])	 	   	//04 - UNID
							aAdd (aRegC425[nPos], SFT->FT_OUTRICM						 )			//05 - VL_ITEM  	
							aAdd (aRegC425[nPos], Iif("1"$aWizard[1][15],SFT->FT_VALPIS,0))	 	   	//06 - VL_PIS
							aAdd (aRegC425[nPos], Iif("1"$aWizard[1][15],SFT->FT_VALCOF,0))	 	   	//07 - VL_COFINS 

							aAdd (aRegC425[nPos], cHierarq + "C420" + StrZero(aLinhaPai[1], nTTRBITEM, 0) + "C425" + StrZero(nPos, nTTRBITEM, 0) )				//08 - Posicao de Hierarquia, utilizada para organizacao dos registros		

						Else 
							aRegC425[nPosAux][4] += SFT->FT_QUANT			   						//03 - QTD			
							aRegC425[nPosAux][6] += SFT->FT_OUTRICM									//05 - VL_ITEM
							aRegC425[nPosAux][7] += Iif("1"$aWizard[1][15],SFT->FT_VALPIS,0)							 	   	//06 - VL_PIS
							aRegC425[nPosAux][8] += Iif("1"$aWizard[1][15],SFT->FT_VALCOF,0)							 	   	//07 - VL_COFINS 
						EndIf
						
						If aScan (aReg0200, {|aX| aX[2]==cProd}) == 0
							SFRG0200(cAlias, @aReg0200, @aReg0190, dDataDe, dDataAte,,cProd,@aReg0220,,,,,,,,,,,,,,,,,,,aWizard)
						EndIf      
						
						lRet := .T.
					EndIf	
				EndIf
				   
				SD2->(dbSkip())				
            End	
        EndIf
		SF2->(dbSkip())
	End
EndIf	
Return (lRet)	  
/*±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³GerDad1600  ³ Autor ³ Vendas e CRM           ³ Data ³ 08/01/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Gera os Dados do Cadastro das Administradoras de Cartao para  ³±±
±±³          ³ gravacao do Registro 150 e o Registro 1600                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ PARAM01 - Array com os Dados das Vendas dos Cartoes           ³±±   
±±³          ³ PARAM02 - Array com o Cadastro de Clientes para a gravacao    ³±± 
±±³          ³ do Registro 150						                         ³±±  
±±³          ³ PARAM03 - Variavel data com a data inicial			         ³±±
±±³          ³ PARAM04 - Variavel data com a data final                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function GerDad1600(aReg1600,aReg0150,dDataDe,dDataAte,cAlias,aWizard) 
Local aArea := GetArea()
Local cQuery    := ""
Local cAliasTrb := ""
Local cCodADM   := ""      				 // Cod da administradora
Local cDesADM   := ""       			 // Descricao da administradora
Local nValCC    := 0        			 // Valor do CC
Local nValCD    := 0       				 // Valor do CD    
Local cCodReg   := ""      				 // Codigo cartao        
Local nCodSAE   := TamSx3("AE_COD")[1]  // Tamanho do codigo do SAE     
Local nI        := 0                     // tamanho do array para adicinar os itens
Local nCount    := 0                                          
Local nIniFor 	:= 1
Local cRede     := ""                    // Nome da Administradora da rede de Cartoes  
Local nPosRede  := 0                     // Posicao da Administradora da Rede     
Local aCampos   := {}                    // Array para criar os campo p/ tabela temporaria
Local cSL4      := ""                    // Campo para Verificar se houve troca do registro. 
Local cArqTrab1 := ""                    // variavel auxiliar para criacao de tabela temporaria.
Local cLoja		:= ""
Local nA1Loja	:= TamSX3("A1_LOJA")[1]
Local aRedeX5   := {}

#IFDEF TOP
   If TcSrvType() != "AS/400"
		cQuery   := "SELECT SL4.L4_FILIAL,SL4.L4_ADMINIS,SL4.L4_FORMA,SUM(L4_VALOR) VALOR "
		cQuery   += "FROM " + RetSQLTab('SL4') 
		cQuery   += "LEFT JOIN " + RetSQLTab('SL1') + " ON SL4.L4_NUM = SL1.L1_NUM AND "
		cQuery   += "SL4.L4_FILIAL = SL1.L1_FILIAL "
		cQuery   += "WHERE SL1.L1_EMISNF >= '" + DToS (dDataDe) + "'" 
		cQuery   += " AND SL1.L1_EMISNF <= '" + DToS (dDataAte) + "'"
		cQuery   += " AND SL1.L1_FILIAL = '" + cFilAnt + "'"
		cQuery   += " AND SL1.L1_PDV <> '' " 
		cQuery   += " AND SL1.L1_DOC <> '' "    
		cQuery   += " AND (SL1.L1_CARTAO > 0 OR SL1.L1_VLRDEBI > 0 ) "
		cQuery   += " AND (SL4.L4_FORMA = 'CC' OR SL4.L4_FORMA = 'CD' )"
		cQuery   += " AND SL1.D_E_L_E_T_ = ' ' " 
		cQuery   += " AND SL4.D_E_L_E_T_ = ' '  "
		cQuery   += " GROUP BY SL4.L4_FILIAL,SL4.L4_ADMINIS,SL4.L4_FORMA "
		
		cAliasTrb := GetNextAlias()
		cQuery    := ChangeQuery( cQuery )
		DbUseArea( .T., 'TOPCONN', TcGenQry(,,cQuery), cAliasTrb, .T., .F. )
		(cAliasTrb)->(DbGoTop() )   
   ELSE	
#ENDIF
	    AADD(aCampos,{ "L4_FILIAL"	,"C",02,0 } )
		AADD(aCampos,{ "L4_ADMINIS"	,"C",20,0 } )
		AADD(aCampos,{ "L4_FORMA"	,"C",15,0 } )
		AADD(aCampos,{ "VALOR"	    ,"N",16,2 } )
	    cAliasTrb := "CRT"
		cArqTrab1 := CriaTrab(aCampos)
		USE &cArqTrab1 ALIAS CRT NEW  
		IndRegua(cAliasTrb,"indece","L4_FILIAL+L4_ADMINIS",,,"") //"Selecionando Registros..."
	    SL1->(DbSelectarea("SL1"))
	    SL1->(DbSetOrder(4))
	    SL1->(MsSeek(cFilAnt + DToS(dDataDe),.T.))
	    While !SL1->(Eof()) .AND. (SL1->L1_EMISSAO <= dDataAte .AND. SL1->L1_EMISSAO >= dDataDe )
	        If !Empty (AllTrim(SL1->L1_DOC))
				SL4->(DbSelectArea("SL4"))
				SL4->(DbSetOrder(1) )
				SL4->(MsSeek(aSPDFil[PFIL_SL4] + SL1->L1_NUM) )  
				cSL4 := aSPDFil[PFIL_SL4] + SL1->L1_NUM  
				While cSL4 == aSPDFil[PFIL_SL4] + SL4->L4_NUM 
					If AllTrim(SL4->L4_FORMA) $ "CC|CD"    
						(cAliasTrb)->(MsSeek("", .T.) )	 
						If (cAliasTrb)->(MsSeek(aSPDFil[PFIL_SL4] + SL4->L4_ADMINIS ) )
							Reclock( cAliasTrb ,.F.)
							(cAliasTrb)->VALOR := (cAliasTrb)->VALOR + SL4->L4_VALOR   
							(cAliasTrb)->(MsUnLock())						
						Else
							Reclock( cAliasTrb ,.T.)
						    (cAliasTrb)->L4_FILIAL  := SL4->L4_FILIAL
						    (cAliasTrb)->L4_ADMINIS := SL4->L4_ADMINIS
						    (cAliasTrb)->L4_FORMA   := SL4->L4_FORMA
						    (cAliasTrb)->VALOR      := SL4->L4_VALOR 
						    (cAliasTrb)->(MsUnLock())	
	 					EndIf  
	 					(cAliasTrb)->(DbCommit())								
					EndIf
					SL4->(DbSkip())
				End	
			EndIf
			SL1->(DbSkip())
		End	   
		(cAliasTrb)->(MsSeek("",.T.) )  
#IFDEF TOP
    Endif
#ENDIF				

//Define a proxima posicao do array a ser considerada no FOR, para garantir que nao vai reprocessar registros da filial anterior que ja foram processados. 
//Este tratamento eh necessario no caso de processar mais de uma filial.
nIniFor := Len(aReg1600)+1 
While !(cAliasTrb)->( Eof() )
	cLoja	:= "01"
	cCodADM := PadR( SubStr( (cAliasTrb)->L4_ADMINIS, 1, nCodSAE ) ,nCodSAE   )	
	cDesADM := SubStr((cAliasTrb)->L4_ADMINIS, nCodSAE +3 , Len((cAliasTrb)->L4_ADMINIS) ) 
	cCodReg := "SA1" + Iif(lConcFil,cFilAnt,"") + AllTrim(cCodADM) + cLoja // AllTrim(cEmpAnt) + AllTrim(cFilDoc) + AllTrim(cCodADM)						
	nValCC  := If( AllTrim( (cAliasTrb)->L4_FORMA ) == "CC",(cAliasTrb)->VALOR, 0 )
	nValCD  := If( AllTrim( (cAliasTrb)->L4_FORMA ) == "CD",(cAliasTrb)->VALOR, 0 )	
	
	SAE->(DbSetOrder(1) )	
	If SAE->(MsSeek(aSPDFil[PFIL_SAE] + cCodADM )  ) 
		If  Len(aReg1600) == 0 .OR. (nPosRede := aScan(aReg1600, { |x| x[7] == SAE->AE_CODCLI }) )  == 0  
		    SX5->(DbSetOrder(1) )
			// Correção de debito tecnico acesso SX5;
			aRedeX5 := FwGetSX5("L9", ALLTRIM(SAE->AE_REDE))
			If len(aRedeX5) > 0
				cRede := aRedeX5[1][4]
			Endif
		    If Empty(cRede)
		       cRede := cDesADM
		    EndIf

			If !Empty(SAE->AE_CODCLI) //Aqui passo a assumir o codigo do CLiente e Loja da tabela SAE
				cCodADM := Alltrim(SAE->AE_CODCLI)
				cLoja	:= Padr( IIF(!Empty(SAE->AE_LOJCLI), AllTrim(SAE->AE_LOJCLI), cLoja), nA1Loja )
				cCodReg := "SA1" + Iif(lConcFil,cFilAnt,"") + AllTrim(cCodADM) + cLoja
			EndIf

		    Aadd(aReg1600, {} )
			nI := Len(aReg1600)
			AAdd(aReg1600[nI], (cAliasTrb)->L4_FILIAL )   // Filial
			AAdd(aReg1600[nI], cCodReg 			       )   // CodAdm
			AAdd(aReg1600[nI], cRede				   )   // Descicao da Administradora
			AAdd(aReg1600[nI], nValCC				   )   // Valor de CC 
			AAdd(aReg1600[nI], nValCD				   )   // Valor do CD     
			AAdd(aReg1600[nI], SAE->AE_REDE			   )   // Rede dos Cartoes     
			AAdd(aReg1600[nI], cCodADM				   )   // Rede dos Cartoes     			 
		Else 
	    	aReg1600[nPosRede][5] += nValCD  
			aReg1600[nPosRede][4] += nValCC  		    	
		EndIf                       
	EndIf  	 
	(cAliasTrb)->(DbSkip() )				
End                          
If Len(aReg1600) > 0 
   	For nCount := nIniFor to Len(aReg1600) 
   		CriCliCC(aReg1600[nCount][7],(cAliasTrb)->L4_FILIAL, SubStr(aReg1600[nCount][2], Len(aReg1600[nCount][2])-2, Len(aReg1600[nCount][2]) ),@aReg0150,aReg1600[nCount][3],cAlias,aWizard)
   	Next nCount  	
EndIf
RestArea(aArea) 
(cAliasTrb)->(DbCloseArea() )
Return(NIL)

/*±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³CriCliCC  ³ Autor ³ Vendas e CRM           ³ Data ³ 08/01/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Gera o Cadastro das Administradoras de Cartao para gravacao ³±±
±±³          ³ do Registro 150                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ PARAM01 - Codigo do cartao na tabela SA1                    ³±±   
±±³          ³ PARAM02 - Filial onde foi feita a venda                     ³±±
±±³          ³ PARAM03 - Loja onde foi feita a venda                       ³±± 
±±³          ³ PARAM04 - Array com o Cadastro de Clientes para a gravacao  ³±± 
±±³          ³ do Registro 150						                       ³±±  
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/		
Static Function CriCliCC(cCodcli,cFilCli,cloja,aReg0150,cAdmin,cAlias,aWizard) 
Local lRet     := .F.
Local aArea    := GetArea()
Local aDadCli  := {}          // Array para gravacao das Administradoras no Registro 150 
Local cCodReg  := ""          // Campo 02 Cod Reg partic.
Local cNome    := ""          // Nome da empresa ou participante  
Local cCodPais := "01058"     // Cod do Pais Valor fixo da tabela
Local cCNPJ    := ""          // CNPJ do cliente
Local cCPF     := ""          // CPF do cliente 
Local cUF      := ""          // Estado do Cliente
Local cIE      := ""          // Inscricao Estadual
Local cCodMuni := ""          // Codigo do Municipio
Local cCodSufr := ""          // Codigo de inscricao do participante na SuFrama  
Local cEnd     := ""          // Endereco  
Local cNum     := ""          // Numero   
Local cComple  := ""          // Complemento do endereco   
Local aEnderc  := {}          // Array para retorno do enderco e numero e complemento 
Local cBairro  := ""          // Bairro
Local cClient  := ""

Default cCodCli := ""
Default cFilCli := ""  
Default cloja   := ""   

cClient := PadR(cCodCli,TamSX3("A1_COD")[1] )
DbSelectArea("SA1")
DbSetorder(1)
If MsSeek(aSPDFil[PFIL_SA1] + cClient + cLoja )
	cCodReg  	:= 	"SA1" + Iif(lConcFil,cFilAnt,"") + AllTrim(cClient) + cLoja //AllTrim(SA1->A1_LOJA)   //AllTrim(cEmpAnt) + AllTrim(cFilCli) + AllTrim(cCodCli )
	cNome    	:= 	If(AllTrim(cAdmin) <> "", cAdmin ,  SA1->A1_NOME )
	cCNPJ    	:= 	SA1->A1_CGC
	cUF      	:= 	SA1->A1_EST  
	cIE      	:= 	SPEDVldIE(SA1->A1_INSCR)
	cCodMuni 	:= 	Iif (Upper(SA1->A1_EST) == "EX","9999999",IIF(Len(SA1->A1_COD_MUN) <= 5,UfCodIBGE(SA1->A1_EST),"") + SA1->A1_COD_MUN)
	cCodSufr 	:= 	SA1->A1_SUFRAMA  
	aEnderc  	:= 	FisGetEnd(SA1->A1_END,SA1->A1_EST)  //{cEnderec,nNumero,cNumero,cComplemen} 
    cEnd     	:= 	aEnderc[1]
	cNum     	:= 	str(aEnderc[2])
	cComple  	:= 	aEnderc[4]  
	cBairro  	:= 	SA1->A1_BAIRRO
    aDadCli  	:= 	{cCodReg,cNome,cCodPais,cCNPJ,cCPF,cIE,cCodMuni,cCodSufr,cEnd,cNum,cComple,cBairro }  
   	SDPF150175(@aReg0150,aDadCli,cAlias,aWizard)
EndIf
Restarea(aArea)
Return(lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³GrReg1600 ³ Autor ³ Vendas e CRM           ³ Data ³ 08/01/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Gera o Registro 1600 - Total das Operacoes com cartao de    ³±±
±±³          ³ Credito  Cartao de Debito                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cAlias - cAlias   - Alias do TRB   						   ³±±   
±±³          ³ aReg1600 - Array para geracao do registro 1600   		   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/	
Static Function GrReg1600(cAlias,aReg1600,dDataDe,dDataAte,aReg0150,aWizard)  
Local aRet      := {}     // Array para gravaco no Alias
Local nI        := 0      // Auxiliar do For
Local nRelac    := 0      // Relacionamento Com outras Tabelas  
Local nItem     := 0      // Item para gravaco no alias
Local cCodCli	:= ""
Local cLoja		:= ""
Local aPE1600	:= {}	  // Array utilizado para processar informacoes do ponto de entrada SPDFIS10  
Local cFil1600 	:= ""	  // Filial		
Local nIndexReg := 0

Default aReg1600 := {}

If aExistBloc[17]
	aPE1600 :=	ExecBlock("SPDFIS10", .F., .F., {dDataDe,dDataAte})
	For nI:= 1 to Len(aPE1600)
		//Composicao do codigo do cliente
		cFil1600 :=	Substr ( aPE1600[nI][2] , 3 + 1 ,Len(cFilAnt) )
		//Composicao do codigo do cliente
		cCodCli :=	AllTrim(Substr ( aPE1600[nI][2] , 3 + Len(cFilAnt) + 1 , TamSX3("A1_COD")[1] ))
		//Composicao da loja do cliente
		cLoja	:=	AllTrim(Substr ( aPE1600[nI][2] , 3 + Len(cFilAnt) + TamSX3("A1_COD")[1] + 1 , TamSX3("A1_LOJA")[1] ))
		
		nIndexReg := AScan(aReg1600, {|aX| AllTrim(aX[2]) == "SA1"+Iif(lConcFil,cFil1600,"")+cCodCli+cLoja})
		
		// Se o registro já existir, soma os créditos e débitos p/ n duplicar o reg. 1600
		If nIndexReg > 0
			aReg1600[nIndexReg][4] += aPE1600[nI][4]
			aReg1600[nIndexReg][5] += aPE1600[nI][5]		 
		Else		   
			AADD(aReg1600,{,"SA1"+Iif(lConcFil,cFil1600,"")+cCodCli+cLoja,,aPE1600[nI][4],aPE1600[nI][5],,})			
			//Chamada da funcao para gerar o registro 0150
		 	CriCliCC(cCodCli,NIL ,cLoja,@aReg0150,,cAlias,aWizard)
		EndIf		   
	Next nI	 
EndIf

If Len(aReg1600) > 0
	// filial - CodCli - Admin - ValorCC -ValorCD 		
	For nI:= 1 to Len(aReg1600)
		AADD(aRet,{"1600",aReg1600[nI][2],aReg1600[nI][4],aReg1600[nI][5]} )
	Next nI
		    
	GrvRegTrS (cAlias, nRelac, aRet, nItem)	
EndIf
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³GrReg1601 ³ Autor ³ Livros Fiscais         ³ Data ³ 22/11/21 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Gera o Registro 1601 - Operações com instrumentos de        ³±±
±±³          ³ pagamentos eletrônicos                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cAlias - cAlias   - Alias do TRB   						   ³±±   
±±³          ³ aReg1601 - Array para geracao do registro 1601   		   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/	
Static Function GrReg1601(cAlias,aReg1601,dDataDe,dDataAte,aReg0150,aWizard,lCmpA1U)  
Local aRet      := {}     // Array para gravaco no Alias
Local nI        := 0      // Auxiliar do For
Local nRelac    := 0      // Relacionamento Com outras Tabelas  
Local nItem     := 0      // Item para gravaco no alias
Local cCodCli	:= ""
Local nTamCli	:= 0
Local cLoja		:= ""
Local nTamLoja	:= 0
Local cCodIt	:= ""
Local aPE1601	:= {}	  // Array utilizado para processar informacoes do ponto de entrada SPED1601 
Local cFil1601 	:= ""	  // Filial		
Local nIndexReg := 0
Local lPE1601	:= .F.

Default aReg1601 := {}

If aExistBloc[33] 
		aPE1601  :=	ExecBlock("SPED1601", .F., .F., {dDataDe,dDataAte}) 
		lPE1601  := .T.
		nTamCli  := FWSX3Util():GetFieldStruct("A1_COD")[3]
		nTamLoja := FWSX3Util():GetFieldStruct("A1_LOJA")[3]

		For nI:= 1 to Len(aPE1601)
		
			cFil1601 :=	aPE1601[nI][1] 
			//Composicao do codigo do cliente junto com o código da loja
			cCodCli :=	PadR(aPE1601[nI][2], nTamCli)
			//Composicao da loja do cliente		
			cLoja	:=	PadR(Right(aPE1601[nI][2], nTamLoja), nTamLoja)
			
			cCodIt := Alltrim(aPE1601[nI][3])
			
			nIndexReg := AScan(aReg1601, {|aX| aX[2] == "SA1" + Iif(lConcFil,cFil1601,"") + AllTrim(cCodCli) + cLoja})
			
		// Se o registro já existir, soma os créditos e débitos p/ n duplicar o reg. 1601
		If nIndexReg > 0
			aReg1601[nIndexReg][4] += aPE1601[nI][4]
			aReg1601[nIndexReg][5] += aPE1601[nI][5]	
			aReg1601[nIndexReg][6] += aPE1601[nI][6]		 
		Else		   
			AADD(aReg1601,{,"SA1"+Iif(lConcFil,cFil1601,"")+AllTrim(cCodCli)+cLoja,Iif(!Empty(cCodIt),"A1U"+Iif(lConcFil,cFil1601,"")+cCodIt,""),aPE1601[nI][4],aPE1601[nI][5],aPE1601[nI][6]})	
				
				//Chamada da funcao para gerar o registro 0150
				CriCliCC(cCodCli,NIL,cLoja,@aReg0150,,cAlias,aWizard)
				
				// Só preenche o registro 0150, caso o cliente preencha o 3° Campo (CODIGO_INTERMEDIADOR) no PE SPED1601
				If !Empty(cCodIT) 
					//Cadastro das Intermediadoras de Venda para gravacao do Registro 150
					SPDFA1U(cCodIT,@aReg0150,cAlias,aWizard,cAlias,lConcFil,lPE1601,lCmpA1U)
				EndIf
			EndIf		   
	Next nI	 
EndIf

If Len(aReg1601) > 0
	// COD_PART_IP - COD_PART_IT - TOT_VS - TOT_ISS - TOT_OUTROS	
	For nI:= 1 to Len(aReg1601)
		AADD(aRet,{"1601",aReg1601[nI][2],aReg1601[nI][3],aReg1601[nI][4],aReg1601[nI][5],aReg1601[nI][6]} )
	Next nI
		    
	GrvRegTrS (cAlias, nRelac, aRet, nItem)	
EndIf
Return 

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ³±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³±±
±±³Programa  ³Grupo1900 ³ Autor ³Caio Oliveira               ³ 20.12.2011 		 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³±±
±±³Descri‡ao ³         GERACAO DO REGISTRO 1900 E FILHOS                         ³±± 
±±³          ³REGISTRO 1910 - PERIODO DA APURACAO DO ICMS                        ³±± 
±±³          ³REGISTRO 1920 - APURACAO DE ICMS - OPERACOES PROPRIAS              ³±± 
±±³          ³REGISTRO 1921 - AJUSTES/BENEFICIOS/INCENTIVO DA APURACAO DE ICMS   ³±± 
±±³          ³REGISTRO 1922 - INFORMACOES ADICIONAIS DOS AJUSTES DE APURACAO DO  ³±± 
±±³          ³                ICMS                                               ³±± 
±±³          ³REGISTRO 1923 - INF. ADICIONAIS DA APURACAO DO ICMS                ³±± 
±±³          ³REGISTRO 1926 - OBRIGACOES DO ICMS A RECOLHER - OPERACOES PROPRIAS ³±±
±±³          ³                                                                   ³±±
±±³          ³Funcao utilizada para montar a estrutura dos registros acima e     ³±±
±±³          ³  gravar no TRB para geracao do TXT                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³lTabComp - Flag de existencia das tabelas complementares           ³±±
±±³          ³aWizard  - Informacoes do assistente da rotina                     ³±±
±±³          ³cFilDe   - Filial inicial para processament multifilial            ³±±
±±³          ³cFilAte  - Filial final para processament multifilial              ³±±
±±³          ³cAlias   - Alias do TRB                                            ³±±
±±³          ³cMVEstado- Conteudo do parametro MV_ESTADO                         ³±±
±±³          ³lTop     - Flag para identificar ambiente TOP                      ³±±
±±³          |oProcess -> Objeto da nova barra de progressao                     ³±±
±±³			 |aLanCDA  - Array com informacoes da tabela CDA.                    ³±±
±±³			 |aLanCDA2 - Array com informacoes da tabela CDA (Totalizador).		 ³±±
±±³			 |aLiv1900 - Contém os números de Livro para buscar a SubApuração	 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function Grupo1900(lTabComp,aWizard,cFilDe,cFilAte,cAlias,cMVEstado,lTop,oProcess,aLanCDA,aLanCDA2,aLiv1900,lOldLan,lExtratTAF,aRegsT020,aReg0190,aReg0220,aReg0200,aReg0150,aStruCDA)

Local	aReg1900	:=  {}
Local	aReg1910	:=	{}
Local	aReg1920	:=	{}
Local	aReg1921 	:= 	{}
Local	aReg1922 	:= 	{}
Local	aReg1923	:=	{}
Local	aReg1925	:=  {}
Local	aReg1926 	:= 	{}
Local	aApICM		:=	{}

Local	cICMGNR	:=	""
Local	cMvSFUfGnr	:=	aSPDSX6[MV_SFUFGNR]
Local	cCodRec	:=	""

Local	dDataDe	    :=	''
Local	dDataAte	:=	''

Local	lSeekCDH	:=	.F.

Local	nYY			:=  0
Local	nPos		:=	0
Local	nPos1900	:=	0
Local	nPos1920	:=	0 
Local	nPos1925	:=  0
Local	nPeriodo	:=	1
Local	nApuracao	:=	3
Local	nZZ			:=  0
Local	nCnt		:=  1
Local   cPeriodo    :=	''
Local   cCompl		:=  ""
Local   lNewCDV		:=  aSPDSX3[FP_CDV_TXTDSC] .And. aSPDSX3[FP_CDV_CODCPL] .And. aSPDSX3[FP_CDV_CODMSG] .And. aSPDSX3[FP_CDV_VLOUTR] .And. aSPDSX3[FP_CDV_REGCAL];
					 .And. aSPDSX3[FP_CDV_OPBASE] .And. aSPDSX3[FP_CDV_OPALIQ] .And. aSPDSX3[FP_CDV_IDMSG]

Default lExtratTAF  := .F.
Default aRegsT020   :=  {}	 

aSort(aLiv1900,,,{|x, y| x[1]<y[1]})

If !lExtratTAF
	dDataDe  	:=	SToD(aWizard[1][1])
	dDataAte	:=	STod(aWizard[1][2])		
	cPeriodo    :=	StrZero(Year(dDataDe),4)+StrZero(Month(dDataDe),2)
	
else	
	dDataDe		:=	aWizard[1][3]
	dDataAte	:=	aWizard[1][4]
	cPeriodo    :=	StrZero(Year(dDataDe),4)+StrZero(Month(dDataAte),2)

EndIf

For nYY := 1 to Len(aLiv1900)
	
	lSeekCDH	:=	.F.
	aApICM		:=	{}
	cICMGNR		:=	""
	
	If lTabComp //Flag de existencia das tabelas complementares do SPED
		lSeekCDH	:=	AP1900ICM(cFilDe,cFilAte,nApuracao,nPeriodo,aLiv1900[nYY][2],"IC",cAlias,dDataDe,dDataAte,cMVEstado,lTop,,aLanCDA,@aLanCDA2, {aLiv1900[nYY][1],aLiv1900[nYY][3]},@aReg1900,@aReg1910,@aReg1920,@aReg1921,@aReg1922,@aReg1923,@aReg1926,lOldLan,,,lExtratTAF,aWizard,@aReg0190,@aReg0220,@aReg0200,@aReg0150,@aStruCDA)
	EndIf
	
	If !lSeekCDH
		//Leio o arquivo de apuracao ICMS
		aApICM			:=	FisApur("IC",Year(dDataAte),Month(dDataAte),nApuracao,nPeriodo,aLiv1900[nYY][2],.F.,{},1,.F.,"")
		
		If Len(aApICM)>0
			//GRAVACAO DO REGISTRO 1900 - INDICAÇÃO DA SUB-APURACAO
			aAdd (aReg1900, {})
			nPos1900	:=	Len (aReg1900)
			aAdd (aReg1900[nPos1900], "1900")								//01 - REG
			aAdd (aReg1900[nPos1900], aLiv1900[nYY][1])						//02 - IND_APUR_ICM
			aAdd (aReg1900[nPos1900], aLiv1900[nYY][3])					   	//03 - DESCR_COMPL_OUT_APUR
			
			//GRAVACAO DO REGISTRO 1910 - PERIODO DA APURACAO DO ICMS
			aAdd (aReg1910, {})
			nPos	:=	Len (aReg1910)
			aAdd (aReg1910[nPos], nPos1900)								//01 - REG
			aAdd (aReg1910[nPos], "1910")								//01 - REG
			aAdd (aReg1910[nPos], dDataDe)								//02 - DT_INI
			aAdd (aReg1910[nPos], dDataAte)								//03 - DT_FIN
			
			aAdd(aReg1920, {nPos,"1920",0,0,0,0,0,0,0,0,0,0,0,0})
			nPos1920	:= Len(aReg1920)
			
			aReg1920[nPos1920][3]		:=	Iif (aScan(aApICM, {|a| a[1]=="001"}   )<>0, aApICM[aScan(aApICM, {|a| a[1]=="001"   })][3],0)
			aReg1920[nPos1920][4]		:=	Iif (aScan(aApICM, {|a| a[4]=="002.00"})<>0, aApICM[aScan(aApICM, {|a| a[4]=="002.00"})][3],0)
			aReg1920[nPos1920][5]		:=	Iif (aScan(aApICM, {|a| a[4]=="003.00"})<>0, aApICM[aScan(aApICM, {|a| a[4]=="003.00"})][3],0)
			aReg1920[nPos1920][6]		:=	Iif (aScan(aApICM, {|a| a[1]=="005"   })<>0, aApICM[aScan(aApICM, {|a| a[1]=="005"   })][3],0)
			aReg1920[nPos1920][7]		:=	Iif (aScan(aApICM, {|a| a[4]=="006.00"})<>0, aApICM[aScan(aApICM, {|a| a[4]=="006.00"})][3],0)
			aReg1920[nPos1920][8]		:=	Iif (aScan(aApICM, {|a| a[4]=="007.00"})<>0, aApICM[aScan(aApICM, {|a| a[4]=="007.00"})][3],0)
			aReg1920[nPos1920][9]		:=	Iif (aScan(aApICM, {|a| a[1]=="009"   })<>0, aApICM[aScan(aApICM, {|a| a[1]=="009"   })][3],0)
			aReg1920[nPos1920][10]		:=	Iif (aScan(aApICM, {|a| a[1]=="011"   })<>0, aApICM[aScan(aApICM, {|a| a[1]=="011"   })][3],0)
			aReg1920[nPos1920][11]		:=	Iif (aScan(aApICM, {|a| a[4]=="012.00"})<>0, aApICM[aScan(aApICM, {|a| a[4]=="012.00"})][3],0)
			aReg1920[nPos1920][12]		:=	Iif (aScan(aApICM, {|a| a[1]=="013"   })<>0, aApICM[aScan(aApICM, {|a| a[1]=="013"   })][3],0)
			aReg1920[nPos1920][13]		:=	Iif (aScan(aApICM, {|a| a[1]=="014"   })<>0, aApICM[aScan(aApICM, {|a| a[1]=="014"   })][3],0)
			aReg1920[nPos1920][14]		:=	Iif (aScan(aApICM, {|a| a[4]=="900.00"})<>0, aApICM[aScan(aApICM, {|a| a[4]=="900.00"})][3],0)
			
			If aReg1920[nPos1920][13]>0
				cICMGNR			:=	Iif(aScan(aApICM,{|a| a[1]=="GNR" .And. AllTrim(a[4])==AllTrim(aReg1920[nPos1920][13])})<>0, aApICM[aScan(aApICM, {|a| a[1]=="GNR" .And. AllTrim(a[4])==AllTrim(aReg1920[nPos1920][13])})][2],"")
				cICMGNR			:=	SubStr(cICMGNR,1,At("/",cICMGNR)-3)
				
				//  Verifico se a UF de Recolhimento do ICMS Proprio deve apresentar o campo 05 - COD_REC
				//  considerando o Codigo da Receita + Classe de Vencimento ( F6_CODREC + F6_CLAVENC )
				cCodRec	:=	Iif( cMvEstado $ cMvSFUfGnr , "SF6->( Alltrim( F6_CODREC ) + Alltrim( F6_CLAVENC ) )" , "SF6->F6_CODREC" )
								
				//³Posicionamento da tabela SF6, conforme dados do .IC0
				If SPEDSeek("SF6",1,aSPDFil[PFIL_SF6]+cMVESTADO+cICMGNR)
					aAdd(aReg1926, {})
					nPos	:=	Len (aReg1926)
					aAdd(aReg1926[nPos], nPos1920 )									//01 - RELACIONAMENTO
					aAdd(aReg1926[nPos], "1926")									//01 - REG
					aAdd(aReg1926[nPos], Iif(aSPDSX3[FP_F6_COBREC] .And. !Empty(SF6->F6_COBREC),SF6->F6_COBREC,"000"))			   							//02 - COD_OR
					aAdd(aReg1926[nPos], SF6->F6_VALOR)  							//03 - VL_OR
					aAdd(aReg1926[nPos], SF6->F6_DTVENC)  							//04 - DT_VCTO
					aAdd(aReg1926[nPos], &( cCodRec ))								//05 - COD_REC
					aAdd(aReg1926[nPos], "")										//06 - NUM_PROC
					aAdd(aReg1926[nPos], "")										//07 - IND_PROC
					aAdd(aReg1926[nPos], "")										//08 - PROC
					aAdd(aReg1926[nPos], SF6->F6_OBSERV)							//09 - TXT_COMPL
					
					If cVersao >= "004"
						aAdd(aReg1926[nPos],SF6->(StrZero(F6_MESREF,2)+cValToChar(F6_ANOREF)))//10 - MES_REF
					EndIf           

					//Para o extrator fiscal preciso levar o número e o Tipo (0=Doc. Arrecad. 1= GNRE) da GNRE para amarrar no TAF
					if lExtratTAF
						aAdd(aReg1926[nPos], SF6->F6_NUMERO)						//11-Numero da Guia
						aAdd(aReg1926[nPos], IIF(Empty(SF6->F6_NUMERO),"",IIF(SF6->F6_TIPOIMP=="0","0","1")))			
					EndIf
										
				EndIf
			EndIf
		EndIf
	EndIf 
	
	//Grava no array do extrator
	If lExtratTAF
			If(Len(aReg1920) > 0)
				aAdd(aReg1920[1], aReg1900[1][2])
				aAdd(aReg1920[1], aReg1900[1][3])
				aAdd(aRegsT020,{aReg1920,;
							    aReg1921,;
								aReg1922,;
								aReg1923,;
								aReg1925,;
								aReg1926})	
								 
				//Limpo os arrays
				aReg1920 := {}
				aReg1921 := {}
				aReg1922 := {}
				aReg1923 := {}
				aReg1925 := {}
				aReg1926 := {}
			EndIf				 
			
												 
	EndIf	
	
Next nYY
If Len(aReg1900)>0
	If aSPDSX2[AI_CDV] 	.OR. lExtratTAF
		dbSelectArea("CDV")
	    CDV->(DbSetOrder(2)) 
	    For nYY := 1 To Len(aLiv1900)
			CDV->(MsSeek(aSPDFil[PFIL_CDV]+cPeriodo+aLiv1900[nYY][2]))
			While !CDV->(Eof()) .And. CDV->CDV_FILIAL==aSPDFil[PFIL_CDV] .And. CDV->CDV_PERIOD==cPeriodo .And. CDV->CDV_LIVRO == aLiv1900[nYY][2]
				cDados:= RetQCDV(CDV->CDV_DOC,CDV->CDV_SERIE,CDV->CDV_CLIFOR,CDV->CDV_LOJA)
                nZZ += 1
				If !lNewCDV .Or. Empty(CDV->CDV_REGCAL)
					aAdd (aReg1925, {})
					nPos1925 :=Len(aReg1925)
					aAdd (aReg1925[nPos1925], nZZ )
					aAdd (aReg1925[nPos1925], "1925")					//01 - REG
					aAdd (aReg1925[nPos1925], CDV->CDV_CODAJU)			//02 - COD_INF_ADIC
					aAdd (aReg1925[nPos1925], CDV->CDV_VALOR)						//03 - VL_INF_ADIC						
					aAdd (aReg1925[nPos1925], AllTrim(CDV->CDV_DESCR)+" "+ cDados)	//04 - DESCR_COMPL_AJ				
				Else
					If !Empty(CDV->CDV_IDMSG) .And. CJL->(MsSeek(aSPDFil[PFIL_CDV]+CDV->CDV_IDMSG))
						cCompl := SubStr(Alltrim(CJL->CJL_MENSG),0,200) 
					Endif						
					If Empty(cCompl)
						cCompl := AllTrim(CDV->CDV_DESCR)+" "+ cDados
					Endif	
					If CDV->CDV_AGRLAN == "01"
						nPos1925 := aScan(aReg1925, {|aX| aX[3]==CDV->CDV_CODAJU})	
					ElseIf CDV->CDV_AGRLAN == "02"
						nPos1925 := aScan(aReg1925, {|aX| aX[3]==CDV->CDV_CODAJU .And. Alltrim(aX[5]) == Alltrim(cCompl)})
					Else
						nPos1925 := 0	
					Endif
					If nPos1925 == 0							
						aAdd (aReg1925, {})
						nPos1925 :=Len(aReg1925)
						aAdd (aReg1925[nPos1925], nZZ )
						aAdd (aReg1925[nPos1925], "1925")					//01 - REG
						aAdd (aReg1925[nPos1925], CDV->CDV_CODAJU)			//02 - COD_INF_ADIC					
						aAdd (aReg1925[nPos1925], CDV->CDV_VALOR + CDV->CDV_VLOUTR)	//03 - VL_INF_ADIC
						aAdd (aReg1925[nPos1925], cCompl)							//04 - DESCR_COMPL_AJ
					Else
						aReg1925[nPos1925,4] += CDV->CDV_VALOR + CDV->CDV_VLOUTR	//03 - VL_INF_ADIC
					Endif	
				Endif	
				
	    			//Grava no array do extrator
					If lExtratTAF
	    				//sobreponhe o array aRegs1925 usado no extrator
	    				aAdd(aRegsT020[nCnt][5], aReg1925[nPos1925])				
	    			EndIf				
    	
				CDV->(DbSkip())
			EndDo
			If !Empty(aLiv1900[nYY][1]) .AND. lExtratTAF
				nCnt++
			EndIf
		Next nYY
	Endif	
	SPEDRegs(cAlias,{aReg1900,aReg1910,aReg1920,aReg1921,{aReg1925,3},{aReg1926,3},{aReg1922,4},{aReg1923,4}})
EndIf

Return


/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³AP1900ICM | Autor ³Caio Oliveira	 			   ³ Data ³20.12.2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡ao ³                        GERACAO DO BLOCO E                         ³±± 
±±³          ³REGISTRO 1910 - PERIODO DA APURACAO DO ICMS                        ³±± 
±±³          ³REGISTRO 1920 - APURACAO DE ICMS - OPERACOES PROPRIAS              ³±± 
±±³          ³REGISTRO 1921 - AJUSTES/BENEFICIOS/INCENTIVO DA APURACAO DE ICMS   ³±± 
±±³          ³REGISTRO 1922 - INFORMACOES ADICIONAIS DOS AJUSTES DE APURACAO DO  ³±± 
±±³          ³                ICMS                                               ³±± 
±±³          ³REGISTRO 1923- INF. ADICIONAIS DA APURACAO DO ICMS                 ³±± 
±±³          ³REGISTRO 1926 - OBRIGACOES DO ICMS A RECOLHER - OPERACOES PROPRIAS ³±± 
±±³          ³                                                                   ³±±
±±³          ³Funcao utilizada para montar a estrutura dos registros acima e     ³±±
±±³          ³  gravar no TRB para geracao do TXT                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1 -> Identifica se houve movimento no periodo ou nao           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cFilDe   - Filial inicial para processament multifilial            ³±±
±±³          ³cFilAte  - Filial final para processament multifilial              ³±±
±±³          ³nApuracao -> Tipo de apuracao, padrao 3                            ³±±
±±³          ³nPeriodo  -> Periodo de apuracao, padrao 1                         ³±±
±±³          ³cNrLivro  -> Numero do livro selecionado no wizard                 ³±±
±±³          ³cImp -> imposto de processamento. IC=ICMS,ST=SUBST. TRIBUTARIA     ³±±
±±³          ³cAlias   - Alias do TRB                                            ³±±
±±³          ³dDataDe -> Data inicio de processamento inf. no wizard             ³±±
±±³          ³dDataAte -> Data final de processamento inf. no wizard             ³±±
±±³          ³cMVEstado-> Conteúdo do MV_ESTADO						             ³±±
±±³          ³lTop     - Flag para identificar ambiente TOP                      ³±±
±±³          ³oProcess - Objeto do novo controle de processamento                ³±±
±±³			 |aLanCDA -> Array contendo a tabela CDA.		                     ³±±
±±³			 |aLanCDA2 -> Array contendo a tabela CDA. (Totalizador)             ³±±
±±³			 |a1900	  -> Array contendo o número do livro para buscar a apuração ³±±
±±³			 |aReg1900  -> Array para geração do registro 1900					 ³±±
±±³			 |aReg1910  -> Array para geração do registro 1910					 ³±±
±±³			 |aReg1920  -> Array para geração do registro 1920					 ³±±
±±³			 |aReg1921  -> Array para geração do registro 1921					 ³±±
±±³			 |aReg1922  -> Array para geração do registro 1922					 ³±±
±±³			 |aReg1923  -> Array para geração do registro 1923					 ³±±
±±³			 |aReg1926  -> Array para geração do registro 1926					 ³±±   
±±³			 |cExtVer   -> Versao do Sped Que o Extrator TAF considera    		 ³±±   
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function AP1900ICM(cFilDe,cFilAte,nApuracao,nPeriodo,cNrLivro,cImp,cAlias,dDataDe,dDataAte,cMVEstado,lTop,oProcess,aLanCDA,aLanCDA2,a1900,aReg1900,aReg1910,aReg1920,aReg1921,aReg1922,aReg1923,aReg1926,lOldLan,cExtVer,aRegT020AG,lExtratTAF,aWizard,aReg0190,aReg0220,aReg0200,aReg0150,aStruCDA)

Local 	cChave	 	:= 	STR(nApuracao,1)+STR(nPeriodo,1)+DTOS(dDataDe)+cNrLivro
Local 	cSomaSeq	:= 	""
Local 	cSequen	 	:= 	""
Local 	cUf		 	:= 	cMvEstado
Local 	cCodAjApur 	:= 	""
Local	cAliasCDH	:=	"CDH"
Local   aCodLan		:=  {}
Local	cModelo		:=	""
Local	cSerie		:=	""

Local 	nPos		:= 	0
Local 	nPos1921	:=	0
Local	nX			:=	0
Local	nPos1920	:=	0
Local	nRecnoSF6	:=	Nil

Local 	lRet		:= 	.T.
Local	lAchouSF6	:=	.F.

Local 	lGNREF3    	:= 	aSPDSX3[FP_CDH_GNREF3]
Local 	lCmps1922	:=	aSPDSX3[FP_F6_NUMPROC] .And. aSPDSX3[FP_F6_INDPROC] .And. aSPDSX3[FP_F6_DESCOMP]
Local 	lCmps1923	:=	cUf $ aSPDSX6[MV_ESTE113]

Local	aParametros	:=	{}
Local   aParCda		:=  {}
Local 	cDescAj		:= ""
Local	nTamCdhDes 	:=	TamSx3("CDH_DESC")[1]

Local nTamCli := TAMSX3("A2_LOJA")[1]+TAMSX3("A2_COD")[1]
Local nTamSPED := nTamCli - 1 

Local cCodResRS		:= ""
Local lCodResRS		:= aSPDSX2[AI_F3T] .and. aSPDSX2[AI_F3R] .And. aSPDSX3[FP_F3R_DOCENT] .And.aSPDSX3[FP_F3R_FORNE] .And.;
					   aSPDSX3[FP_F3R_SERENT] .And. aSPDSX3[FP_F3R_LOJENT] .And. aSPDSX3[FP_F3R_QTDENT] .And.; 
					   aSPDSX3[FP_F3R_CHVENT] .And. aSPDSX3[FP_F3R_ITENFE] .And. aSPDSX3[FP_F3R_ID] .And.;
					   aSPDSX3[FP_F3R_MODENT] .And. aSPDSX3[FP_F3R_DTENT]

Local cTamProd   	:=	TamSx3("B1_COD")[1]
Local aProd	     	:=	Nil
Local cProd  		:=	""
Local aAreaSA2 		:=	SA2->(GetArea ())
Local aPartDoc 		:= {}
Local cMvSFUfGnr	:=	aSPDSX6[MV_SFUFGNR]
Local cCodRec		:= ""
Local lConfig		:= .F.
Local lMsgCjl		:= .F.
Local nI			:= 0

Default aLanCDA		:=	{}
Default a1900		:=	{}
Default	aReg1900	:=	{}
Default	aReg1910	:=	{}
Default	aReg1920	:=	{0,"1920",0,0,0,0,0,0,0,0,0,0,0,0}
Default	aReg1921 	:= 	{}
Default	aReg1922 	:= 	{}
Default	aReg1923	:=	{}
Default	aReg1926 	:= 	{}    
Default lOldLan	 	:= 	(aSPDSX2[AI_CC6] .And. aSPDSX3[FP_CC6_TIPOAJ])  
Default	aReg0150 	:= 	{}    

Default cExtVer  := ""
Default lExtratTAF	:=  .F.

//Para ambiente TOP nao preciso pegar a ultima sequencia, pois isso eh resolvido na propria query
If !lTop
	If CDH->(MsSeek(aSPDFil[PFIL_CDH]+cImp+cChave))
		cSomaSeq  := CDH->CDH_SEQUEN
		While CDH->(MsSeek(aSPDFil[PFIL_CDH]+cImp+cChave+cSomaSeq)) // Posiciona na ultima sequencia
			cSequen  := CDH->CDH_SEQUEN
			cSomaSeq := Soma1(cSequen)
		EndDo
	EndIf
EndIf  

If !Empty( cExtVer )
	cVersao := cExtVer
EndIf

//Carrega os códigos de ajuste para registro 1923
If lCodResRS .and. lCmps1923
	DbSelectArea("F3T")
	
	F3T->(MsSeek(aSPDFil[PFIL_F3T]+"03")) // Vajerista Estorno 
	cCodResRS := F3T->F3T_CODIGO 
	
	F3T->(MsSeek(aSPDFil[PFIL_F3T]+"07")) // Não varejista - Presumido
	cCodResRS += "#"+ F3T->F3T_CODIGO 
	
	//Caso não exista regras com codigos não faz seek com F3R
	If cCodResRS == "#"
		lCodResRS := .F.
	Endif
Endif



//Montando parametros para a query ou indregua
aAdd(aParametros,cImp)
aAdd(aParametros,STR(nApuracao,1))
aAdd(aParametros,STR(nPeriodo,1))
aAdd(aParametros,DTOS(dDataDe))
aAdd(aParametros,cNrLivro)
aAdd(aParametros,cSequen)

aAdd(aParCda,dDataDe)
aAdd(aParCda,dDataAte)

If SPEDFFiltro(1,"CDH",@cAliasCDH,aParametros,,,@lMsgCjl)

	If lMsgCjl .And. oJRetCda == Nil
		TempCDA(@oJRetCda,aParCda,lBuild,@aStruCDA)
	Endif	
	//REGISTRO E110 - APURACAO DE ICMS - OPERACOES PROPRIAS
	aAdd (aReg1900, {})
	nPos1900	:=	Len (aReg1900)
	aAdd (aReg1900[nPos1900], "1900")								//01 - REG
	aAdd (aReg1900[nPos1900], a1900[1])								//02 - IND_APUR_ICM
	aAdd (aReg1900[nPos1900], a1900[2])							   	//03 - DESCR_COMPL_OUT_APUR
	
	aAdd (aReg1910, {})
	nPos	:=	Len (aReg1910)
	aAdd (aReg1910[nPos], nPos1900)								//01 - REG
	aAdd (aReg1910[nPos], "1910")								//01 - REG
	aAdd (aReg1910[nPos], dDataDe)								//02 - DT_INI
	aAdd (aReg1910[nPos], dDataAte)								//03 - DT_FIN
	
	aAdd(aReg1920, {nPos,"1920",0,0,0,0,0,0,0,0,0,0,0,0})
	nPos1920	:= Len(aReg1920)
	//³ Carrega ajustes na apuracao ICMS ³

	While !(cAliasCDH)->(Eof())
		
		cCodAjApur 	:= 	(cAliasCDH)->CDH_CODLAN
		nPos1921	:=	0
		lGera1921	:=	.F.
		lGera1926	:=	.F.
		nRecnoSF6	:=	Iif(lTop,(cAliasCDH)->SF6RECNO,Nil)
		lAchouSF6	:=	.F.
		lConfig		:= 	.F.
		
		If Alltrim((cAliasCDH)->CDH_TPLANC) == "CF - Config Tributo"
			lConfig := .T.
		Endif    
		//Posicionamento da tabela SF6, tanto para TOP (RECNO) quanto para DBF/ADS
		
		If !Empty((cAliasCDH)->(CDH_ESTGNR+CDH_GNRE))
			lAchouSF6	:=	SPEDSeek("SF6",1,aSPDFil[PFIL_SF6]+(cAliasCDH)->(CDH_ESTGNR+CDH_GNRE),nRecnoSF6)
		EndIf
		
		Do Case
			
			//Case que determina o calculo do (2)VL_TOT_DEBITOS = Valor total dos debitos  
			//por "SAIDAS E PRESTACOES COM DEBITO DO IMPOSTO"                         
			
			Case (cAliasCDH)->CDH_LINHA == "001"
				aReg1920[nPos1920][3] += (cAliasCDH)->CDH_VALOR
				
				//Case que determina o calculo de 2 lancamentos:                               
				//(3)VL_AJ_DEBITOS = Valor total dos ajustes a debitos provenitentes de NF   
				//(4)VL_TOT_AJ_DEBITOS = Valor total dos ajustes a debitos                   
				
			Case (cAliasCDH)->CDH_LINHA $ "002" .And. Alltrim((cAliasCDH)->CDH_SUBITE) <> "002.00" .And. !Empty((cAliasCDH)->CDH_CODLAN)	//Lancamentos a outros debitos
				
				//Tratamento para o codigo no formato antigo (NAO SE UTILIZA MAIS) ou para o novo de 10 posicoes
				
				If !(lOldLan .And. SubStr((cAliasCDH)->CDH_CODLAN,1,1)=="1") .And.;	//No formato antigo, os que iniciam por 1 sao lancamentos de NF
					!(!lOldLan .And. Len(Alltrim((cAliasCDH)->CDH_CODLAN))==10)		//Tamanho 10 eh soh os lancamentos de NF
					
					//Se for ajuste com origem em NF, ja vai estar lancado no C197
					
					//Conforme cadastro de ajuste manual, quando a terceira posicao do codigo for
					//0=ICMS e a quarta for 0=Outros Debitos, considero este valor.
					
					If SubStr((cAliasCDH)->CDH_CODLAN,3,1)=="0" .And. SubStr((cAliasCDH)->CDH_CODLAN,4,1)== "0"
						aReg1920[nPos1920][4] += (cAliasCDH)->CDH_VALOR
					EndIf
					
					lGera1921	:=	.T.
					
					//³Se for ajuste de apuracao precisa lancar no 1921³
					
					If lOldLan	//Codigo de lancamento antigo tem outro formato, e precisa ser convertido para um DEFAULT para nao apresentar erro de validacao
						cCodAjApur := cUf+"0"+"0"+"9999"
					EndIf
				EndIf
				
				//Case que determina o calculo de 2 lancamentos:                              
				//- (3)VL_AJ_DEBITOS = Valor total dos ajustes a debitos provenitentes de NF   
				//- (5)VL_ESTORNOS_CRED = Valor total dos ajustes "ESTORNO DE CREDITOS"       
				
			Case (cAliasCDH)->CDH_LINHA $ "003" .And. Alltrim((cAliasCDH)->CDH_SUBITE) <> "003.00" .And. !Empty((cAliasCDH)->CDH_CODLAN)
				//³Tratamento para o codigo no formato antigo (NAO SE UTILIZA MAIS) ou para o novo de 10 posicoes³
				
				If !(lOldLan .And. SubStr((cAliasCDH)->CDH_CODLAN,1,1)=="1") .And.;	//No formato antigo, os que iniciam por 1 sao lancamentos de NF
					!(!lOldLan .And. Len(Alltrim((cAliasCDH)->CDH_CODLAN))==10)		//Tamanho 10 eh soh os lancamentos de NF
					//Se for ajuste com origem em NF, ja vai estar lancado no C197
					//Um lancacamento a ESTORNO DE CREDITO proveniente de NF, tambem entra como DEBITO(3)                               
					
					//Conforme cadastro de ajuste manual, quando a terceira posicao do codigo for 
					//0=ICMS e a quarta for 1=Estorno de Credito, considero este valor.        
					
					If SubStr((cAliasCDH)->CDH_CODLAN,3,1)=="0" .And. SubStr((cAliasCDH)->CDH_CODLAN,4,1)== "1"
						aReg1920[nPos1920][5] += (cAliasCDH)->CDH_VALOR
					EndIf
					
					lGera1921	:=	.T.
					
					//³Se for ajuste de apuracao precisa lancar no E111³

					If lOldLan
						cCodAjApur := cUf+"0"+"1"+"9999"
					EndIf
				EndIf
				
				//Case que determina o calculo do (6)VL_TOT_CREDITOS = Valor total dos creditos
				//por "ENTRADAS E AQUISICOES COM CREDITO DO IMPOSTO"           
				           
			Case (cAliasCDH)->CDH_LINHA == "005"
				aReg1920[nPos1920][6] += (cAliasCDH)->CDH_VALOR
				
				//Case que determina o calculo de 2 lancamentos:
				//- (7)VL_AJ_CREDITOS = Valor total dos ajustes a creditos provenitentes de NF
				//- (8)VL_TOT_AJ_CREDITOS = Valor total dos "AJUSTES A CREDITO"
				
			Case (cAliasCDH)->CDH_LINHA $ "006" .And. Alltrim((cAliasCDH)->CDH_SUBITE) <> "006.00" .And. !Empty((cAliasCDH)->CDH_CODLAN)
				
				//Tratamento para o codigo no formato antigo (NAO SE UTILIZA MAIS) ou para o novo de 10 posicoes
				
				If !(lOldLan .And. SubStr((cAliasCDH)->CDH_CODLAN,1,1)=="1") .And.;	//No formato antigo, os que iniciam por 1 sao lancamentos de NF
					!(!lOldLan .And. Len(Alltrim((cAliasCDH)->CDH_CODLAN))==10)		//Tamanho 10 eh soh os lancamentos de NF
					
					//Se for ajuste com origem em NF, ja vai estar lancado no C197³
					//Conforme cadastro de ajuste manual, quando a terceira posicao do codigo for
					//0=ICMS e a quarta for 2=Outros Creditos, considero este valor.
					
					If SubStr((cAliasCDH)->CDH_CODLAN,3,1)=="0" .And. SubStr((cAliasCDH)->CDH_CODLAN,4,1)== "2"
						aReg1920[nPos1920][7] += (cAliasCDH)->CDH_VALOR
					EndIf
					
					lGera1921	:=	.T.
					
					//Se for ajuste de apuracao precisa lancar no E111
					
					If lOldLan
						cCodAjApur := cUf+"0"+"2"+"9999"
					EndIf
				EndIf
				
				//Case que determina o calculo de 2 lancamentos:
				//- (7)VL_AJ_CREDITOS = Valor total dos ajustes a creditos provenitentes de NF
				//- (9)VL_ESTORNOS_DEB = Valor total dos ajustes "ESTORNO DE DEBITOS"
				
			Case (cAliasCDH)->CDH_LINHA $ "007" .And. Alltrim((cAliasCDH)->CDH_SUBITE) <> "007.00" .And. !Empty((cAliasCDH)->CDH_CODLAN)
				
				//³Tratamento para o codigo no formato antigo (NAO SE UTILIZA MAIS) ou para o novo de 10 posicoes³
				
				If !(lOldLan .And. SubStr((cAliasCDH)->CDH_CODLAN,1,1)=="1") .And.;	//No formato antigo, os que iniciam por 1 sao lancamentos de NF
					!(!lOldLan .And. Len(Alltrim((cAliasCDH)->CDH_CODLAN))==10)		//Tamanho 10 eh soh os lancamentos de NF
					
					//³Se for ajuste com origem em NF, ja vai estar lancado no C197³
					
					//Conforme cadastro de ajuste manual, quando a terceira posicao do codigo for
					//0=ICMS e a quarta for 3=Estorno de debitos, considero este valor.
					
					If SubStr((cAliasCDH)->CDH_CODLAN,3,1)=="0" .And. SubStr((cAliasCDH)->CDH_CODLAN,4,1)=="3"
						aReg1920[nPos1920][8] += (cAliasCDH)->CDH_VALOR
					EndIf
					
					lGera1921	:=	.T.
										
					//³Se for ajuste de apuracao precisa lancar no E111³
					
					If lOldLan
						cCodAjApur := cUf+"0"+"3"+"9999"
					EndIf
				EndIf
				
				//Case que determina o calculo do (10)VL_SLD_CREDOR_ANT = Valor total do "SALDO CREDOR DO PERIODO ANTERIOR"
				
			Case (cAliasCDH)->CDH_LINHA == "009"
				aReg1920[nPos1920][9] += (cAliasCDH)->CDH_VALOR
				
				//Case que determina o calculo do (10)VL_SLD_APURADO = Valor do saldo devedor apurado
				
			Case (cAliasCDH)->CDH_LINHA == "011"
				aReg1920[nPos1920][10] += (cAliasCDH)->CDH_VALOR				
				
				//Case que determina o calculo de 2 lancamentos:
				//- (7)VL_AJ_CREDITOS = Valor total dos ajustes a creditos provenitentes de NF
				//- (12)VL_TOT_DED = Valor total de "DEDUCOES"
				
			Case (cAliasCDH)->CDH_LINHA $ "012" .And. Alltrim((cAliasCDH)->CDH_SUBITE) <> "012.00" .And. !Empty((cAliasCDH)->CDH_CODLAN)
				
				//³Tratamento para o codigo no formato antigo (NAO SE UTILIZA MAIS) ou para o novo de 10 posicoes³
				
				If !(lOldLan .And. SubStr((cAliasCDH)->CDH_CODLAN,1,1)=="1") .And.;	//No formato antigo, os que iniciam por 1 sao lancamentos de NF
					!(!lOldLan .And. Len(Alltrim((cAliasCDH)->CDH_CODLAN))==10)		//Tamanho 10 eh soh os lancamentos de NF
					
					//³Se for ajuste com origem em NF, ja vai estar lancado no C197³
					
					//Conforme cadastro de ajuste manual, quando a terceira posicao do codigo for
					//0=ICMS e a quarta for 4=Deducoes, considero este valor.
					
					If SubStr((cAliasCDH)->CDH_CODLAN,3,1)=="0" .And. SubStr((cAliasCDH)->CDH_CODLAN,4,1)=="4"
						aReg1920[nPos1920][11] += (cAliasCDH)->CDH_VALOR
					EndIf
					
					lGera1921	:=	.T.
					
					//³Se for ajuste de apuracao precisa lancar no E111³
					
					If lOldLan
						cCodAjApur := cUf+"0"+"4"+"9999"
					EndIf
				EndIf
				
				//Case que determina o calculo do (13)VL_ICMS_RECOLHER = Valor total de
				//"ICMS A RECOLHER"
				
			Case (cAliasCDH)->CDH_LINHA == "013"
				aReg1920[nPos1920][12] += (cAliasCDH)->CDH_VALOR				
				//Case que determina o calculo do (14)VL_SLD_CREDOR_TRANSPORTAR = Valor total
				//de "SALDO CREDOR A TRANSPORTAR PARA O PERIODO SEGUINTE"				
			Case (cAliasCDH)->CDH_LINHA == "014"
				aReg1920[nPos1920][13] += (cAliasCDH)->CDH_VALOR
				
				//Case que determina o calculo de 2 lancamentos:
				//(15)DEB_ESP = valores recolhidos ou a recolher extra-apuracao
				
			Case (cAliasCDH)->CDH_LINHA$"900" .And. Alltrim((cAliasCDH)->CDH_SUBITE)<>"900.00" .And. !Empty((cAliasCDH)->CDH_CODLAN)
				//³Tratamento para o codigo no formato antigo (NAO SE UTILIZA MAIS) ou para o novo de 10 posicoes
				If (lOldLan .And. SubStr((cAliasCDH)->CDH_CODLAN,1,1)=="1") .Or.;	//No formato antigo, os que iniciam por 1 sao lancamentos de NF
					(!lOldLan .And. Len(Alltrim((cAliasCDH)->CDH_CODLAN))==10)		//Tamanho 10 eh soh os lancamentos de NF
					//Se for ajuste com origem em NF, ja vai estar lancado no C197
					aReg1920[nPos1920][14] += (cAliasCDH)->CDH_VALOR
				Else
					//³Conforme cadastro de ajuste manual, quando a terceira posicao do codigo for
					//0=ICMS e a quarta for 5=Debitos especiais, considero este valor.
					
					If SubStr((cAliasCDH)->CDH_CODLAN,3,1)=="0" .And. SubStr((cAliasCDH)->CDH_CODLAN,4,1)=="5"
						aReg1920[nPos1920][14] += (cAliasCDH)->CDH_VALOR
					EndIf
					
					lGera1921	:=	.T.
					
					//³Se for ajuste de apuracao precisa lancar no E111³
					If lOldLan
						cCodAjApur := cUf+"0"+"5"+"9999"
					EndIf
					
				EndIf
				
		EndCase

		//|REGISTRO 1921 - AJUSTES/BENEFICIOS/INCENTIVO DA APURACAO DE ICMS            |
		//|                                                                            |
		//³Tratamento para gerar a estrutura do retgistro E111 conforme condicoes acima³
		If lGera1921

			If !lConfig			
				//Utiliza CDO para compor a descrição se estiver preenchida
				cDescAj	:= DescCDO((cAliasCDH)->CDH_DESC, nTamCdhDes, cCodAjApur)

				aAdd(aReg1921, {})
				nPos1921	:=	Len(aReg1921)
				aAdd (aReg1921[nPos1921], nPos1920)							//01 - RELACIONAMENTO
				aAdd (aReg1921[nPos1921], "1921")							//02 - REG
				aAdd (aReg1921[nPos1921], cCodAjApur)						//03 - COD_AJ_APUR
				aAdd (aReg1921[nPos1921], cDescAj)							//04 - DESCR_COMPL_AJ
				aAdd (aReg1921[nPos1921], (cAliasCDH)->CDH_VALOR)			//05 - VL_AJ_APUR

			Else
				If lMsgCjl 
					aCodLan :=	oJRetCda[Alltrim(cCodAjApur)]
					If Valtype(aCodLan) =='A' .And. Len(aCodLan) > 0
						For nI := 1 To Len(aCodLan)
							cDescAj := aCodLan[nI,9]
							If AllTrim(aCodLan[nI,6]) = "01"
								nPos1921 := aScan(aReg1921,{|x| Alltrim(x[03]) == Alltrim(cCodAjApur)})    
							ElseIf AllTrim(aCodLan[nI,6]) = "02"
								nPos1921 := aScan(aReg1921,{|x| Alltrim(x[03]) == Alltrim(cCodAjApur) .and. substr(x[04],1,12) == substr(cDescAj,1,12) })      
							Else
								nPos1921 := 0
							Endif

							If nPos1921 = 0 
								aAdd(aReg1921, {})
								nPos1921	:=	Len(aReg1921)
								aAdd (aReg1921[nPos1921], nPos1920)							//01 - RELACIONAMENTO
								aAdd (aReg1921[nPos1921], "1921")							//02 - REG
								aAdd (aReg1921[nPos1921], cCodAjApur)						//03 - COD_AJ_APUR
								aAdd (aReg1921[nPos1921], cDescAj)							//04 - DESCR_COMPL_AJ
								aAdd (aReg1921[nPos1921], aCodLan[nI,1]+aCodLan[nI,4]) 	//05 - VL_AJ_APUR
							Else
								aReg1921[nPos1921,5] += aCodLan[nI,1]+aCodLan[nI,4]		//05 - VL_AJ_APUR
							Endif
						Next
					Endif
				Endif	
			Endif

			If !Empty(cExtVer)
				aAdd (aReg1921[nPos1921], (cAliasCDH)->CDH_SUBITE)		//06 - SUBITEM				
					
				//creditos acumulados
				If Alltrim((cAliasCDH)->CDH_SUBITE) $ ("002.20|002.21|007.40|007.41|002.23|007.44|007.45|007.49")
					aAdd(aRegT020AG, {})
					nPosT020AG	:=	Len(aRegT020AG)
					aAdd (aRegT020AG[nPosT020AG], cDescAj)						//01 - COD_AUTO
					aAdd (aRegT020AG[nPosT020AG], (cAliasCDH)->CDH_VALOR)						//02 - VALOR
				Endif
			Endif			

		EndIf
		
		//REGISTRO 1922 - INFORMACOES ADICIONAIS DOS AJUSTES DE APURACAO DO ICMS
		//Segundo o manuel, eh necessario haver um DA (Documento de arrecadacao
		If lCmps1922 .And. nPos1921>0 .And. lAchouSF6
			aAdd(aReg1922, {})
			nPos	:=	Len (aReg1922)
			aAdd (aReg1922[nPos], nPos1921)					   			//RELACIONAMENTO COM O E111
			aAdd (aReg1922[nPos], "1922")								//01 - REG
			aAdd (aReg1922[nPos], SF6->F6_NUMERO)						//02 - NUM_DA
			aAdd (aReg1922[nPos], SF6->F6_NUMPROC)						//03 - NUM_PROC
			aAdd (aReg1922[nPos], SF6->F6_INDPROC)						//04 - IND_PROC
			aAdd (aReg1922[nPos], (cAliasCDH)->CDH_DESC)				//05 - PROC
			aAdd (aReg1922[nPos], SF6->F6_DESCOMP)						//06 - TXT_COMPL
			If lExtratTAF
				aAdd (aReg1922[nPos], IIF(Empty(SF6->F6_NUMERO),"",IIF(SF6->F6_TIPOIMP=="0","0","1")))		
			Endif			
		EndIf
		
		//REGISTRO E113: INFORMACOES ADICIONAIS DOS AJUSTES DA APURACAO DO ICMS
		// IDENTIFICACAO DOS DOCUMENTOS FISCAIS.
		If lCmps1923 .And. nPos1921>0 .And. Len(aLanCDA2)>0
			For nX := 1 To Len(aLanCDA2)
				//Vai percorrer todo o Array aLanCDA2 (Totalizador CDA) em busca dos registro referentes ao Codigo de Ajuste do E111
				//e Filtrando por ICMS proprio, terceiro digito do Codigo de Ajuste = 0 e assim Gerar um E113 por documento.
				
				If AllTrim(aLanCDA2[nX][1]) == AllTrim(cCodAjApur) .And. SubStr(AllTrim(aLanCDA2[nX][1]),3,1) == "0"				

					cModelo	:=	AModNot(aLanCDA2[nX][8])
					cSerie	:=	SpedSerie(aLanCDA2[nX][9],cModelo)

					aAdd(aReg1923, {})
					nPos :=	Len(aReg1923)
					aAdd (aReg1923[nPos], nPos1921)							//RELACIONAMENTO COM O E111
					aAdd (aReg1923[nPos], "1923")							//01 - REG
					If !(AllTrim(cModelo) $ '65')
						aAdd (aReg1923[nPos], aLanCDA2[nX][15])				//02 - COD_PART
					Else
						aAdd (aReg1923[nPos], "")                           //02 - COD_PART
					Endif
					aAdd (aReg1923[nPos], cModelo)							//03 - COD_MOD
					aAdd (aReg1923[nPos], cSerie)							//04 - SER
					aAdd (aReg1923[nPos], "")								//05 - SUB
					aAdd (aReg1923[nPos], aLanCDA2[nX][10])					//06 - NUM_DOC
					aAdd (aReg1923[nPos], StrZero(Day(aLanCDA2[nX][16]),2)+;
					StrZero(Month(aLanCDA2[nX][16]),2)+;
					StrZero(Year(aLanCDA2[nX][16]),4))						//07 - DT_DOC
					aAdd (aReg1923[nPos], aLanCDA2[nX][13])					//08 - COD_ITEM
					aAdd (aReg1923[nPos], Iif(!lConfig, aLanCDA2[nX][5], aLanCDA2[nX][5]+aLanCDA2[nX][6]))//09 - VL_AJ_ITEM
					IF cVersao >= "011"
						aAdd (aReg1923[nPos], aLanCDA2[nX][17])				//10 - CHV_DOCe
					Endif
					
					//Carrega Dados da nota de Entrada
					If lCodResRS .And. AllTrim(cCodAjApur) $ cCodResRS
						DbSelectArea("F3R")
						F3R->(DbSetOrder(1))
						If F3R->(MsSeek(aSPDFil[PFIL_F3R]+StrZero(Month(dDataDe),2)+StrZero(Year(dDataDe),4)+aLanCDA2[nX][11]+PadR(aLanCDA2[nX][9], 3)+aLanCDA2[nX][10]+SubStr(aLanCDA2[nX][15],len(aLanCDA2[nX][15])-nTamSPED ,nTamCli)+aLanCDA2[nX][14]+aLanCDA2[nX][13]))						
		
							If !Empty(AllTrim(F3R->F3R_SERENT)) .And. !Empty(AllTrim(F3R->F3R_DOCENT)) .And. !Empty(AllTrim(DtoS(F3R->F3R_DTENT)))							
								cModelo  :=  AModNot(F3R->F3R_MODENT)
								
								//Gera registro 0150 com fornecedor utilizado na entrada								
								IF !(AllTrim(cModelo) $ '65')
									If SA2->(MsSeek(aSPDFil[PFIL_SA2]+F3R->(F3R_FORNE+F3R_LOJENT)))										
										aPartDoc :=	InfPartDoc("SA2")
										IF Len(aPartDoc)>0
											SDPF150175(@aReg0150,aPartDoc,cAlias,aWizard,aExistBloc)
											aReg1923[nPos][03] := aPartDoc[1]					//02 - COD_PART											
										Endif
									EndIf
								Endif								
							
								aReg1923[nPos][04] := cModelo                       		//03 - COD_MOD							
								aReg1923[nPos][05] :=  SpedSerie(F3R->F3R_SERENT,cModelo)	//04 - SER
								aReg1923[nPos][07] := F3R->F3R_DOCENT						//06 - NUM_DOC
								aReg1923[nPos][08] := StrZero(Day(F3R->F3R_DTENT),2)+StrZero(Month(F3R->F3R_DTENT),2)+StrZero(Year(F3R->F3R_DTENT),4)						//07 - DT_DOC
								IF cVersao >= "011"
									aReg1923[nPos][11] := F3R->F3R_CHVENT					//10 - CHV_DOCe
								Endif
							EndIf

						EndIf
					Endif

					//Caso exista produto incluo no 0200
					If !Empty(aLanCDA2[nX,13]) .And. cUf<>"MS" .And. !lExtratTAF
						If aScan ( aReg0200, { |aX| aX[2] == aLanCDA2[nX][13] }) == 0
							 //CH: TRQFF0 - Neste momento não tenho as informações do aProd pra passar nas posições 6 e 7 da SFRG0200()
							 //Como a SB1 já está aberta, porém desposicionada (está posicionada no primeiro registro da tabela)
							 //Monto um seek apenas para posicionar no produto que será carregado para 0200, assim o 0200 ficará em acordo com o 1923
							SPEDSeek("SB1",,aSPDFil[PFIL_SB1]+AllTRIM(Substr(aLanCDA2[nX][13],1,cTamProd)))
									    
							//Ponto de entrada para tratamento da informação de produtos quando o mesmo estah fora do padrao do sistema
							cProd	:=	aLanCDA2[nX][13]
							
							If aExistBloc[05]
								aProd := Execblock("SPEDPROD", .F., .F., {"SB1","1923"})
								If Len(aProd)>=11
									cProd 	:= 	aProd[1]						
								Else 
									aProd := {"","","","","","","","","","","",""}
								EndIf					
							EndIf			
							    						
							SFRG0200( cAlias, @aReg0200, @aReg0190, dDataDe, dDataAte, aProd, cProd, aReg0220,,,,,,,,,,,,,,,,,,,aWizard )
						EndIf								
					EndIf

					
				EndIf
			Next(nX)
		EndIf

		//REGISTRO E116 - OPERACOES DO ICMS A RECOLHER - OPERACOES PROPRIAS
		If lAchouSF6 .And. !Empty((cAliasCDH)->CDH_CODLAN)

			//Condicao para tratar GNRE(Outros Debito) lancada manualmente na apuracao para gravar registro E116
			If (cAliasCDH)->(Len(Alltrim(CDH_CODLAN))==8 .And. SubStr(CDH_CODLAN,4,1)=="0")
				lGera1926	:=	.T.
		
				//Condicao para tratar GNRE(Debito) lancada atraves do NF na apuracao para gravar registro E116
			ElseIf (cAliasCDH)->(Len(Alltrim(CDH_CODLAN))==10 .And. SubStr(CDH_CODLAN,3,1)=="4")
				lGera1926	:=	.T.
				
				//Condicao para tratar GNRE(Debitos especiais) gerada pela apuracao atraves de um lancamento 
				//manual ou por NF, para gravar registro E116
			ElseIf	(cAliasCDH)->(Len(Alltrim(CDH_CODLAN))==08 .And.  SubStr(CDH_CODLAN,4,1)=="5") .Or.;		//Manual
				(cAliasCDH)->(Len(Alltrim(CDH_CODLAN))==10 .And.  SubStr(CDH_CODLAN,3,1)=="7")			//Por NF
				lGera1926	:=	.T.
				
			EndIf
			
			//³Condicao para tratar GNRE(ICMS a recolher) gerada pela apuracao para gravar registro E116

		ElseIf lAchouSF6 .And. lGNREF3 .And. (cAliasCDH)->(CDH_LINHA=="GNR" .And. Alltrim(Substr(CDH_GNREF3,1,8)) $ "/RECSALDO/RDBESP/RDBESPST/RICDIF/RFECP")  
			lGera1926	:=	.T.
		EndIf
		
		//  Verifico se a UF de Recolhimento do ICMS Proprio deve apresentar o campo 05 - COD_REC
		//  considerando o Codigo da Receita + Classe de Vencimento ( F6_CODREC + F6_CLAVENC )
		cCodRec	:=	Iif( cUf $ cMvSFUfGnr , "SF6->( Alltrim( F6_CODREC ) + Alltrim( F6_CLAVENC ) )" , "SF6->F6_CODREC" )
				
		//³Se algumas das condicoes acima mandar gerar a GNRE, faco isso neste momento³
		If lGera1926
			aAdd(aReg1926, {})
			nPos	:=	Len (aReg1926)
			aAdd(aReg1926[nPos], nPos1920)						//01 - RELACIONAMENTO
			aAdd(aReg1926[nPos], "1926")							//01 - REG
			aAdd(aReg1926[nPos], Iif(aSPDSX3[FP_F6_COBREC] .And. !Empty(SF6->F6_COBREC),SF6->F6_COBREC,"000"))								//02 - COD_OR
			aAdd(aReg1926[nPos], SF6->F6_VALOR)						//03 - VL_OR
			aAdd(aReg1926[nPos], SF6->F6_DTVENC)					//04 - DT_VCTO
			aAdd(aReg1926[nPos], &( cCodRec ))					    //05 - COD_REC 
			aAdd(aReg1926[nPos], "")								//06 - NUM_PROC
			aAdd(aReg1926[nPos], "")								//07 - IND_PROC
			aAdd(aReg1926[nPos], "")								//08 - PROC
			aAdd(aReg1926[nPos], SF6->F6_OBSERV)					//09 - TXT_COMPL
			
			If cVersao >= "004"
				aAdd(aReg1926[nPos],SF6->(StrZero(F6_MESREF,2)+cValToChar(F6_ANOREF)))//10 - MES_REF
			EndIf              

			//Para o extrator fiscal preciso levar o número e o Tipo (0=Doc. Arrecad. 1= GNRE) da GNRE para amarrar no TAF
			if lExtratTAF
				aAdd(aReg1926[nPos], SF6->F6_NUMERO)						//11-Numero da Guia
				aAdd(aReg1926[nPos], IIF(Empty(SF6->F6_NUMERO),"",IIF(SF6->F6_TIPOIMP=="0","0","1")))			
			EndIf			
			
		EndIf
		
		(cAliasCDH)->(dbSkip())
	EndDo
	//³Fecho query ou indregua criada³
	SPEDFFiltro(2,,cAliasCDH)
Else
	lRet := .F.
EndIf

RestArea(aAreaSA2)

Return lRet

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³Programa  ³D195D197  ³ Autor ³Luccas Curcio          ³ Data ³25.07.2012³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³     REGISTRO D195 - OBSERVACOES DO LANCAMENTO FISCAL       ³±±
±±³          ³                    				                          ³±±
±±³          ³REGISTRO D197 - OUTRAS OBRIGACOES TRIBUTARIAS, AJUSTES E    ³±±
±±³          ³                INFORMACOES DE VALORES                      ³±±
±±³          ³                                                            ³±±
±±³          ³- Geracao e gravacao dos Registros D195 e D197              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Atribui em um array o conteudo a ser gravado no TRB atraves ³±±
±±³          ³ da funcao GrvRegTrS com o embasamento legal para tais      ³±±
±±³          ³ observacoes                                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Nivel Hier³3(1:N) Para cada D100                                       ³±±
±±³          ³4(1:N) Para cada D195                                       ³±±
±±³Parametros³cAlias -> Alias do TRB que recebera as informacoes          ³±±
±±³          ³nRelac -> Flag de relacionamento com os sub-registros       ³±±
±±³          ³aLanCDA-> Array com os lancamentos da tabela CDA            ³±±
±±³          ³aReg0460-> Array com a estrutura do registro 0460           ³±±
±±³          ³aCmpAntSFT-> Campos da tabela SFT do documento em           ³±±
±±³          ³             processamento                                  ³±±
±±³          ³cEspecie-> Especie do document fiscal                       ³±±
±±³          ³aD195aux-> Array auxiliar com o codigo da observacao do     ³±±
±±³			 ³lancamento fiscal (F4_CODOBSE)           					  ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function D195D197(cAlias,nRelac,aLanCDA,aReg0460,aCmpAntSFT,cEspecie,aD195aux, lLegisPer)
Local	nPos		:=	0
Local	nPosD195	:=	0
Local	nX		:=	0
Local	nPos195		:=	0
Local	aRegD195	:=	{}
Local	aRegD197	:=	{}
Local	cCodItem	:=	""
Local	lShowVlBC   := .T.
Local	lShowAliq   := .T.
Local	lShowVlOut  := .T.

Default lLegisPer	:= .F.
//³Processando lancamentos do documento fiscal relacionados no CDA³

For nX := 1 to len(aLanCDA)

	//Campo 04 - Preenchimento: deve ser informado se o ajuste/benefício for relacionado ao servico. 
 	//Porém,quando não houver registro D110 o COD_ITEM nao devera ser informado.
	
	cCodItem	:=	""
	If (aCmpAntSFT[26]=="0" .And. cEspecie=="07")
		cCodItem	:=	aLanCDA[nX,13]
	EndIf

	If !aLanCDA[nX][24]
		lShowVlBC   := .T.
		lShowAliq   := .T.
		lShowVlOut  := .T.
		IF aLanCDA[nX,1] $ "SP90090104/SP90090278"
			cCodItem	:=	""
			lShowVlBC   := .F.
			lShowAliq   := Iif(aLanCDA[nX,1] == "SP90090104" .And. aLanCDA[nX,5] == 0 .And. aLanCDA[nX,6] == 0, .T., .F.)
			lShowVlOut  := Iif(aLanCDA[nX,1] == "SP90090104", .T., .F.)
		EndIF
	Endif

	//³Geracao do REGISTRO D195
	If (nPosD195 := aScan(aRegD195,{|aX| aX[2]==aLanCDA[nX][07]}))==0
		aAdd(aRegD195, {})
		nPosD195	:=	Len (aRegD195)
		aAdd (aRegD195[nPosD195], "D195")		 	   					//01 - REG
		aAdd (aRegD195[nPosD195], aLanCDA[nX][07])						//02 - COD_OBS
		aAdd (aRegD195[nPosD195], aLanCDA[nX][17])		   				//03 - TXT_COMPL	

		aAdd (aRegD195[nPosD195], RetRD(GetRelacPr())+strzero(nPosD195,nTamFT_IT)) //04 - - Posição de Hierarquia
		
		//³REGISTRO 0460 - TABELA DE OBSERVACOES DO LANCAMENTO FISCAL
		Reg0460(@aReg0460,{aLanCDA[nX][7],aLanCDA[nX][20]})
	EndIf

	If !aLanCDA[nX][24]
		If aLanCDA[nX,1]$"SP90090104/SP90090278"
			nPos := aScan(aRegD197,{|x| x[1] == nPosD195 .And. x[3]==aLanCDA[nX,1] .And. x[4]==aLanCDA[nX][2] })
		Else
			nPos := aScan(aRegD197,{|x| x[1] == nPosD195 .And. x[5]==cCodItem .And. x[3]==aLanCDA[nX,1] })
		EndIf
	Else
		If aLanCDA[nX,23] == "01"
			nPos := aScan(aRegD197,{|x| x[1] == nPosD195 .And. x[3]==aLanCDA[nX,1] })
		ElseIf aLanCDA[nX,23] == "02"
			nPos := aScan(aRegD197,{|x| x[1] == nPosD195 .And. x[3]==aLanCDA[nX,1] .And. x[4]==aLanCDA[nX][2] })
		Elseif aLanCDA[nX,23] == "03"
			nPos := aScan(aRegD197,{|x| x[1] == nPosD195 .And. x[5]==cCodItem .And. x[3]==aLanCDA[nX,1] })
		Else
			nPos := aScan(aRegD197,{|x| x[1] == nPosD195 .And. x[5]==cCodItem .And. x[3]==aLanCDA[nX,1] })
		Endif	
	Endif
	//³Geracao do REGISTRO D197
		If !lLegisPer
			If nPos == 0
				aAdd(aRegD197, {})
				nPos	:=	Len (aRegD197)
				aAdd (aRegD197[nPos], nPosD195)									//01 - RELACIONAMENTO COM D195 (PAI)
				aAdd (aRegD197[nPos], "D197")	   								//02 - REG
				aAdd (aRegD197[nPos], aLanCDA[nX,1])				       		//03 - COD_AJ
				aAdd (aRegD197[nPos], aLanCDA[nX][2])					   		//04 - DESCR_COMPL_AJ
				aAdd (aRegD197[nPos], cCodItem)									//05 - COD_ITEM
				aAdd (aRegD197[nPos], Iif(!aLanCDA[nX][24], Iif(lShowVlBC, aLanCDA[nX][3], ''),aLanCDA[nX][3]))		//06 - VL_BC_ICMS
				aAdd (aRegD197[nPos], Iif(!aLanCDA[nX][24], Iif(lShowAliq, aLanCDA[nX][4], ''),aLanCDA[nX][4]))	 	//07 - ALIQ_ICMS
				aAdd (aRegD197[nPos], aLanCDA[nX][5])																//08 - VL_ICMS
				aAdd (aRegD197[nPos], Iif(!aLanCDA[nX][24], Iif(lShowVlOut, aLanCDA[nX][6], ''),aLanCDA[nX][6]))	//09 - VL_OUTROS

				aAdd (aRegD197[nPos], RetRD(GetRelacPr())+strzero(nPosD195,nTamFT_IT)) //10 - - Posição de Hierarquia
			Else
			    aRegD197[nPos][6]	+= Iif(!aLanCDA[nX][24], Iif(lShowVlBC, aLanCDA[nX][3], ''),aLanCDA[nX][3])			//06 - VL_BC_ICMS
				aRegD197[nPos][8]	+= aLanCDA[nX][5]																	//08 - VL_ICMS
				aRegD197[nPos][9]	+= Iif(!aLanCDA[nX][24], Iif(lShowVlOut, aLanCDA[nX][6], ''),aLanCDA[nX][6])		//09 - VL_OUTROS
			EndIf
		EndIf
Next

//³Geracao do REGISTRO D195
For nX := 1 To Len(aD195aux)  
	IF !(EMPTY(aD195aux[nX][3]))
		If (nPos195 := aScan(aRegD195,{|aX| aX[2]==aD195aux[nX][1]}))==0
			aAdd(aRegD195, {})
			nPos195	:=	Len (aRegD195)
			aAdd (aRegD195[nPos195], "D195")		 	   					//01 - REG
			aAdd (aRegD195[nPos195], aD195aux[nX][1])						//02 - COD_OBS
			aAdd (aRegD195[nPos195], aD195aux[nX][3])		   				//03 - TXT_COMPL

			aAdd (aRegD195[nPos195], RetRD(GetRelacPr())+strzero(nPos195,nTamFT_IT)) //04 - - Posição de Hierarquia
			
			//³REGISTRO 0460 - TABELA DE OBSERVACOES DO LANCAMENTO FISCAL  
			Reg0460(@aReg0460,{aD195aux[nX][1],aD195aux[nX][2]})
		Endif
	ENDIF
Next nX

//GrRegDep(cAlias,aRegD195,aRegD197,,,,nRelac)
GrRegDep(cAlias, aRegD195, aRegD197,,,,,,.T.,.T.)

Return


/*/{Protheus.doc} RegEcfTOP
@description Efetua a carga dos arrays dos registros de ECF-Cupom Fiscal
@since 31/01/2013
@Alison Leonardo Gonçalves
@version 11.90
/*/
Static Function RegEcfTOP(	aRegC400	, aRegC405	, aRegC410	, aRegC420	,;
							aRegC425	, aRegC460	, aRegC470	, aRegC490	,;
							aRegC495	, aProdB1	, dDataDe	, dDataAte	,;
							cPerfil		, cAlias	, aReg0200	, aReg0190	,;
							aReg0220	, aReg1600	, aReg0150	, aWizard	,;
							lTop		, cUf		, nQtReg0200, lJob		,;
							lLegisPer	, cNrLivro	, aArq		, lRefazInd	, oSay, aRegC430, aReg1601 )

Do Case
	Case cPerfil == "A"

		// Processa Registros Perfil A
		SPDFCFPrfA( @aRegC400,	@aRegC405,	@aRegC410,	@aRegC420,;	
					@aRegC425,	@aRegC460,	@aRegC470,	@aRegC490,;
					@aRegC495,	@aProdB1,	dDataDe,	dDataAte,;
					cPerfil,	cAlias,		@aReg0200,	@aReg0190,;
					@aReg0220,	@aReg1600,	@aReg0150,	aWizard,;
					lTop,cUf,	@nQtReg0200,lJob,		lLegisPer,;
					cNrLivro,	aArq,	oSay , @aReg1601)

		lRefazInd := .T. //Seta para que seja reconstruido o indice do TRB

	Case cPerfil == "B"

		// Processa Registros Perfil B
		SPDFCFPrfB( @aRegC400,	@aRegC405,	@aRegC410,	@aRegC420,;
					@aRegC425,	@aRegC460,	@aRegC470,	@aRegC490,;
					@aRegC495,	@aProdB1,	dDataDe,	dDataAte,;
					cPerfil,	cAlias,		@aReg0200,	@aReg0190,;
					@aReg0220,	@aReg1600,	@aReg0150,	aWizard,;
					lTop,		cUf,		@nQtReg0200,lJob,;
					lLegisPer,	cNrLivro,	oSay, @aRegC430, @aReg1601 )

	Case cPerfil == "C"

		// Processa Registros Perfil C
		SPDFCFPrfC( @aRegC400,	@aRegC405,	@aRegC410,	@aRegC420,;
					@aRegC425,	@aRegC460,	@aRegC470,	@aRegC490,;
					@aRegC495,	@aProdB1,	dDataDe,	dDataAte,;
					cPerfil, 	cAlias,		@aReg0200,	@aReg0190,;
					@aReg0220,	@aReg1600,	@aReg0150,	aWizard,;
					lTop,cUf,	@nQtReg0200,lJob,		lLegisPer,;
					cNrLivro,	oSay, @aReg1601 )

EndCase

Return
/*/{Protheus.doc} RegD300
@description REGISTRO D300 - REGISTRO ANALÍTICO DOS BILHETES CONSOLIDADOS DE PASSAGEM RODOVIÁRIO (CÓDIGO 13),
DE PASSAGEM AQUAVIÁRIO (CÓDIGO 14), DE PASSAGEM E NOTA DE BAGAGEM (CÓDIGO 15) E DE PASSAGEMFERROVIÁRIO (CÓDIGO 16).
@author Simone Oliveira
@since 30/07/2014
@version 11.90
/*/
Static Function RegD300(aRegD300,cEspecie,cSituaDoc,nRedBSICM,lNotaD300,cAliasSFT,aLanCDA,aReg0460,aLancFis)

Local nPosD300	:= 0
Local nVlOutrDes	:= 0
Local cNotaD300	:= ""
Local lNovo		:= .F.
Local cSerie	:= ""
Local cContCtb	:= RetCOD_CTA(cAliasSFT, "D300")

If Len(AllTrim((cAliasSFT)->FT_NFISCAL)) > 6 .And.  Val(Left(AllTrim((cAliasSFT)->FT_NFISCAL),Len(AllTrim((cAliasSFT)->FT_NFISCAL))-6)) > 0
	lNotaD300   := .F.
EndIf

cSerie	:=	SpedSerie((cAliasSFT)->FT_SERIE,cEspecie)

cNotaD300	:= Right(AllTrim((cAliasSFT)->FT_NFISCAL),6)
nVlOutrDes	:= (cAliasSFT)->(FT_DESPESA-(FT_SEGURO+FT_FRETE))	//Totaliza as outras despesas do documento fiscal. Este tratamento se faz necessario porque FRETE e SEGURO incorporam o valor da despesa no sistema

nPosD300 := aScan(aRegD300,{|aX| aX[7]==(cAliasSFT)->FT_CLASFIS .And. aX[8]==(cAliasSFT)->FT_CFOP .And. aX[9]== (cAliasSFT)->FT_ALIQICM .And. ;
            aX[2]==cEspecie .And. aX[3]==cSerie .And. aX[10]==(cAliasSFT)->FT_EMISSAO })	

lNovo := nPosD300 == 0

IF lNovo
	aAdd(aRegD300, {})
	nPosD300	:=	Len (aRegD300)
	aAdd (aRegD300[nPosD300], "D300")												//01 - REG
	aAdd (aRegD300[nPosD300], cEspecie)							              //02 - COD_MOD
	aAdd (aRegD300[nPosD300], cSerie) //03 - SER
	aAdd (aRegD300[nPosD300], "")													//04 - SUB
	aAdd (aRegD300[nPosD300], cNotaD300)											//05 - NUM_DOC_INI 
	aAdd (aRegD300[nPosD300], cNotaD300)											//06 - NUM_DOC_FIN
	aAdd (aRegD300[nPosD300], (cAliasSFT)->FT_CLASFIS)							//07 - CST_ICMS 
	aAdd (aRegD300[nPosD300], (cAliasSFT)->FT_CFOP)								//08 - CFOP 
	aAdd (aRegD300[nPosD300], (cAliasSFT)->FT_ALIQICM)    						//09 - ALIQ_ICMS
	aAdd (aRegD300[nPosD300], (cAliasSFT)->FT_EMISSAO)							//10 - DT_DOC
	aAdd (aRegD300[nPosD300], 0)													//11 - VL_OPR 
	aAdd (aRegD300[nPosD300], 0)													//12 - VL_DESC 
	aAdd (aRegD300[nPosD300], 0)													//13 - VL_SERV
	aAdd (aRegD300[nPosD300], 0)													//14 - VL_SEG
	aAdd (aRegD300[nPosD300], 0)													//15 - VL_OUT DESP
	aAdd (aRegD300[nPosD300], 0)													//16 - VL_BC_ICMS
	aAdd (aRegD300[nPosD300], 0)													//17 - VL_ICMS 
	aAdd (aRegD300[nPosD300], 0)													//18 - VL_RED_BC 
	aAdd (aRegD300[nPosD300], "")													//19 - COD_OBS 
	aAdd (aRegD300[nPosD300], Iif(!Empty(cContCtb),cContCtb,(cAliasSFT)->FT_CONTA))								//20 - COD_CTA
EndIf

If !cSituaDoc$"02#03"	//02=Situacao de cancelada
	aRegD300[nPosD300][11]	+= (cAliasSFT)->FT_VALCONT								//11 - VL_OPR
	aRegD300[nPosD300][12]	+= (cAliasSFT)->FT_DESCONT								//12 - VL_DESC
	aRegD300[nPosD300][13]	+= (cAliasSFT)->FT_TOTAL									//13 - VL_SERV
	aRegD300[nPosD300][14]	+= (cAliasSFT)->FT_SEGURO								//14 - VL_SEG
	aRegD300[nPosD300][15]	+= nVlOutrDes 											//15 - VL_OUT DESP					
	aRegD300[nPosD300][16]	+= (cAliasSFT)->FT_BASEICM								//16 - VL_BC_ICMS
	aRegD300[nPosD300][17]	+= (cAliasSFT)->FT_VALICM								//17 - VL_ICMS
	aRegD300[nPosD300][18]	+= IIf(nRedBSICM < 0, 0 ,nRedBSICM)					//18 - VL_RED_BC
EndIf

//Código observação 
	If Len(aLancFis)>=1
   		aRegD300[nPosD300][19]  := aLancFis[1,1]

		//³REGISTRO 0460 - TABELA DE OBSERVACOES DO LANCAMENTO FISCAL      
   		Reg0460(@aReg0460,{aLancFis[1,1],aLancFis[1,2]})
	EndIf	

//³Range de Numero de Documentos
If cNotaD300 < aRegD300[nPosD300][5]
	aRegD300[nPosD300][5]	:=	cNotaD300		//05 - NUM_DOC_INI
EndIf

If cNotaD300 > aRegD300[nPosD300][6]
	aRegD300[nPosD300][6]	:=	cNotaD300		//06 - NUM_DOC_FIN
EndIf

Return nPosD300
/*/{Protheus.doc} RegD301
@description REGISTRO D301 - DOCUMENTOS CANCELADOS DOS BILHETES CONSOLIDADOS DE PASSAGEM RODOVIÁRIO (CÓDIGO 13),
DE PASSAGEM AQUAVIÁRIO (CÓDIGO 14), DE PASSAGEM E NOTA DE BAGAGEM (CÓDIGO 15) E DE PASSAGEMFERROVIÁRIO (CÓDIGO 16)
@author Simone Oliveira
@since 30/07/2014
@version 11.90
/*/
Static Function RegD301(nPosD300,aRegD301,cAliasSFT)

Local	nPosD301	:=	0
Local 	cNFiscal  	:= Right(AllTrim((cAliasSFT)->FT_NFISCAL),6)

If (nPosD301:= aScan(aRegD301,{|aX| aX[1]==nPosD300 .And. aX[3]==cNFiscal}))==0
	aAdd(aRegD301, {})
	nPosD301	:=	Len (aRegD301)
	aAdd (aRegD301[nPosD301], nPosD300)			//CHAVE PARA RELACIONAMENTO COM REGISRO PAI
	aAdd (aRegD301[nPosD301], "D301")			//01 - REG
	aAdd (aRegD301[nPosD301], cNFiscal)			//02 - NUM_DOC_CANC
EndIf

Return
/*/{Protheus.doc} RegD310
@description REGISTRO D310 - COMPLEMENTO DOS BILHETES (CÓDIGO 13, 14, 15 E 16)
@author Simone Oliveira
@since 30/07/2014
@version 11.90
/*/
Static Function RegD310(nPosD300,aRegD310,cAliasSFT,cSituaDoc,cAlsSD,lTop)

Local	nPosD310	:=	0
Local  cMunOrig	:= ""
Local 	cMvD310MUN	:= Alltrim(aSPDSX6[MV_D310MUN])

If lTop
	If (cAliasSFT)->(FieldPos(cMvD310MUN))>0  
		cMunOrig := (cAliasSFT)->(&cMvD310MUN)
	EndIf

	// Se os campos F2_UFORIG e F2_CMUNOR existirem e estiverem preenchidos, pego as informações de lá.
	If (cAliasSFT)->(FieldPos("F2_UFORIG")) > 0 .And. (cAliasSFT)->(FieldPos("F2_CMUNOR")) > 0 .And. !Empty((cAliasSFT)->F2_UFORIG) .And. !Empty((cAliasSFT)->F2_CMUNOR)
		cMunOrig := UFCodIBGE((cAliasSFT)->F2_UFORIG) + (cAliasSFT)->F2_CMUNOR
	EndIf
Else
	If (cAlsSD)->(FieldPos(cMvD310MUN))>0  
		cMunOrig := (cAlsSD)->(&cMvD310MUN)
	EndIf
EndIf

If cSituaDoc$"02#03"
	cMunOrig:=  Alltrim(SM0->M0_CODMUN)
EndIf
	
If (nPosD310:= aScan(aRegD310,{|aX| aX[1]==nPosD300 .And. aX[3]==cMunOrig}))==0
	aAdd(aRegD310, {})
	nPosD310	:=	Len (aRegD310)
	aAdd (aRegD310[nPosD310], nPosD300)	 	   			//CHAVE PARA RELACIONAMENTO COM REGISRO PAI
	aAdd (aRegD310[nPosD310], "D310")						//01 - REG
	aAdd (aRegD310[nPosD310], cMunOrig)					//02 - COD_MUN_ORIG
	aAdd (aRegD310[nPosD310], 0)							//03 - VL_SERV
	aAdd (aRegD310[nPosD310], 0)							//04 - VL_BC_ICMS
	aAdd (aRegD310[nPosD310], 0)							//05 - VL_ICMS
EndIf

If !cSituaDoc$"02#03"
	aRegD310[nPosD310][4]	+= (cAliasSFT)->FT_TOTAL			//03 - VL_SERV
	aRegD310[nPosD310][5]	+= (cAliasSFT)->FT_BASEICM		//04 - VL_BC_ICMS	
	aRegD310[nPosD310][6]	+= (cAliasSFT)->FT_VALICM		//05 - VL_ICMS
EndIf

Return


//-------------------------------------------------------------------
/*/{Protheus.doc} REGC800
@description REGISTRO C800: CUPOM FISCAL ELETRÔNICO – SAT (CF-E-SAT) (CÓDIGO 59) - Perfil A
@author Mauro A. Gonçalves 
@since 06/08/2015
@version 11.90
/*/
//-------------------------------------------------------------------
Static Function RegC800(aRegC800,cAliasSFT,cSituaDoc,aPartDoc,aWizard, cHiC800_60)
Local cNF  	:= Right(AllTrim((cAliasSFT)->FT_NFISCAL),6)
Local nPos	:= 0 
Local cChave	:= ''
Local cCgcCli := ""

If cSituaDoc$"02/03"
	
	// Se build superior a "7.00.131227A" faz a busca no HashMap para ganho de performance.
	If lBuild
		cChave	:= "59"+cSituaDoc+cNF+(cAliasSFT)->FT_SERSAT
		nPos	:= FisFindHash(oHashC800, cChave)
	Else
		nPos := Ascan(aRegC800, {|x| x[2]=="59" .AND. x[3]==cSituaDoc .AND. x[4]==cNF .AND. x[10]==(cAliasSFT)->FT_SERSAT})
	EndIf

	If nPos == 0
		cHiC800_60 := ""

		aAdd(aRegC800, {})
		nPos := Len(aRegC800)                  
		aAdd(aRegC800[nPos], "C800") 						//01 - REG
		aAdd(aRegC800[nPos], "59") 						//02 - Modelo
		aAdd(aRegC800[nPos], cSituaDoc)						//03 - Sit Doc
		aAdd(aRegC800[nPos], cNF) 						//04 - Nr Cupom 
		aAdd(aRegC800[nPos], "") 						//05 - Data Cupom         
		aAdd(aRegC800[nPos], "")						//06 - Vl Cupom     
		aAdd(aRegC800[nPos], "")						//07 - Vl PIS
		aAdd(aRegC800[nPos], "")						//08 - Vl COFINS
		aAdd(aRegC800[nPos], "")						//09 - CNPJ/CPF dest.
		aAdd(aRegC800[nPos], (cAliasSFT)->FT_SERSAT)				//10 - Nr Série SAT   
		aAdd(aRegC800[nPos], (cAliasSFT)->FT_CHVNFE)				//11 - Chave Cupom
		aAdd(aRegC800[nPos], "") 						//12 - Vl descontos 
		aAdd(aRegC800[nPos], "")						//13 - Vl merc/serv         
		aAdd(aRegC800[nPos], "")						//14 - Vl despesas/acréscimos     
		aAdd(aRegC800[nPos], "")						//15 - Vl ICMS
		aAdd(aRegC800[nPos], "")						//16 - Vl PIS ret ST ???? (cAliasSFT)->FT_VRETPIS
		aAdd(aRegC800[nPos], "")						//17 - Vl COF ret ST ???? (cAliasSFT)->FT_VRETCOF

		cHiC800_60 :=  cFilAnt + "2" + "C800" + StrZero(nPos, nTTRBITEM, 0)
	
		aAdd(aRegC800[nPos], cHiC800_60 )					//18 - Posicao de Hierarquia, utilizada para organizacao dos registros	

		If lBuild
			FisAddHash(oHashC800,cChave,nPos)
		EndIf
	Endif

Else

	// Se build superior a "7.00.131227A" faz a busca no HashMap para ganho de performance.
	If lBuild
		cChave	:= "59"+cSituaDoc+cNF+(cAliasSFT)->FT_SERSAT+Dtos((cAliasSFT)->FT_EMISSAO)
		nPos	:= FisFindHash(oHashC800, cChave)
	Else
		nPos := Ascan(aRegC800, {|x| x[2]=="59" .AND. x[3]==cSituaDoc .AND. x[4]==cNF .AND. x[10]==(cAliasSFT)->FT_SERSAT .AND. x[5]==(cAliasSFT)->FT_EMISSAO})	
	EndIf

	If nPos == 0
	 	cCgcCli := Iif(Empty(aPartDoc[04]),aPartDoc[05],aPartDoc[04])
	 	
	 	// Ajuste conforme a DSERFIS1-162 - Vitor Ribeiro (vitor.e@totvs.com.br)
	 	DbSelectArea("SL1")		// ORCAMENTO
		SL1->(DbSetOrder(2))	// L1_FILIAL+L1_SERIE+L1_DOC+L1_PDV 
		If SL1->(MsSeek(aSPDFil[PFIL_SL1]+(cAliasSFT)->FT_SERIE+(cAliasSFT)->FT_NFISCAL)) 
			cCgcCli := AllTrim(SL1->L1_CGCCLI)
		EndIf
		
		cHiC800_60 := ""
		aAdd(aRegC800, {})        
		nPos := Len(aRegC800)                  
		aAdd(aRegC800[nPos], "C800") //01 - REG
		aAdd(aRegC800[nPos], "59") //02 - Modelo
		aAdd(aRegC800[nPos], cSituaDoc) //03 - Sit Doc
		aAdd(aRegC800[nPos], cNF) //04 - Nr Cupom 
		aAdd(aRegC800[nPos], (cAliasSFT)->FT_EMISSAO)	//05 - Data Cupom         
		aAdd(aRegC800[nPos], (cAliasSFT)->FT_VALCONT)	//06 - Vl Cupom     
		aAdd(aRegC800[nPos], Iif("1"$aWizard[1][15],(cAliasSFT)->FT_VALPIS,'')) //07 - Vl PIS
		aAdd(aRegC800[nPos], Iif("1"$aWizard[1][15],(cAliasSFT)->FT_VALCOF,'')) //08 - Vl COFINS
		aAdd(aRegC800[nPos], cCgcCli) //09 - CNPJ/CPF dest.
		aAdd(aRegC800[nPos], (cAliasSFT)->FT_SERSAT) //10 - Nr Série SAT   
		aAdd(aRegC800[nPos], (cAliasSFT)->FT_CHVNFE) //11 - Chave Cupom
		aAdd(aRegC800[nPos], (cAliasSFT)->FT_DESCONT)//12 - Vl descontos 
		aAdd(aRegC800[nPos], (cAliasSFT)->FT_TOTAL) //13 - Vl merc/serv         
		aAdd(aRegC800[nPos], (cAliasSFT)->FT_DESPESA) //14 - Vl despesas/acréscimos     
		aAdd(aRegC800[nPos], (cAliasSFT)->FT_VALICM) //15 - Vl ICMS
		aAdd(aRegC800[nPos], Iif("1"$aWizard[1][15],(cAliasSFT)->FT_VALPS3,'')) //16 - Vl PIS ret ST  ???? (cAliasSFT)->FT_VRETPIS
		aAdd(aRegC800[nPos], Iif("1"$aWizard[1][15],(cAliasSFT)->FT_VALCF3,'')) //17 - Vl COF ret ST  ???? (cAliasSFT)->FT_VRETCOF

		cHiC800_60 :=  cFilAnt + "2" + "C800" + StrZero(nPos, nTTRBITEM, 0)
	
		aAdd(aRegC800[nPos], cHiC800_60 )					//18 - Posicao de Hierarquia, utilizada para organizacao dos registros		

		If lBuild
			FisAddHash(oHashC800,cChave,nPos)
		EndIf
	Else
		aRegC800[nPos][06] += (cAliasSFT)->FT_VALCONT	//06 - Vl Cupom		   
		aRegC800[nPos][07] += Iif("1"$aWizard[1][15],(cAliasSFT)->FT_VALPIS,'')	//07 - Vl PIS     
		aRegC800[nPos][08] += Iif("1"$aWizard[1][15],(cAliasSFT)->FT_VALCOF,'')	//08 - Vl COFINS
		aRegC800[nPos][12] += (cAliasSFT)->FT_DESCONT	//12 - Vl descontos
		aRegC800[nPos][13] += (cAliasSFT)->FT_TOTAL	//13 - Vl merc/serv     
		aRegC800[nPos][14] += (cAliasSFT)->FT_DESPESA	//14 - Vl despesas/acréscimos          
		aRegC800[nPos][15] += (cAliasSFT)->FT_VALICM	//15 - Vl ICMS
		aRegC800[nPos][16] += Iif("1"$aWizard[1][15],(cAliasSFT)->FT_VALPS3,'')	//16 - Vl PIS ret ST
		aRegC800[nPos][17] += Iif("1"$aWizard[1][15],(cAliasSFT)->FT_VALCF3,'')	//17 - Vl COF ret ST     
	EndIf
EndIf

Return nPos

//-------------------------------------------------------------------
/*/{Protheus.doc} REGC850
@description REGISTRO C850: REGISTRO ANALÍTICO DO CF-E-SAT (CODIGO 59) - Perfil A
@author Mauro A. Gonçalves 
@since 06/08/2015
@version 11.90
/*/
//-------------------------------------------------------------------
Static Function RegC850(nPosC800,aRegC850,cAliasSFT,cSituaDoc,aClasFis, cHierarq)

Local nPos := 0
Local cChave	:= ''

If cSituaDoc$"02/03"
	Return .T.
Endif	

// Se build superior a "7.00.131227A" faz a busca no HashMap para ganho de performance.
If lBuild
	cChave	:= str(nPosC800)+aClasFis[1]+(cAliasSFT)->FT_CFOP+str((cAliasSFT)->FT_ALIQICM)
	nPos	:= FisFindHash(oHashC850, cChave)
Else
	nPos := Ascan(aRegC850, {|x| x[1]==nPosC800 .AND. x[3]==aClasFis[1] .AND. x[4]==(cAliasSFT)->FT_CFOP .AND. x[5]==(cAliasSFT)->FT_ALIQICM})
EndIf

If nPos == 0
	aAdd(aRegC850, {})
	nPos := Len(aRegC850)

	aAdd(aRegC850[nPos], nPosC800) //00 - RELACIONAMENTO
	aAdd(aRegC850[nPos], "C850") //01 - REG
	aAdd(aRegC850[nPos], aClasFis[1]) //02 - CST ICMS
	aAdd(aRegC850[nPos], (cAliasSFT)->FT_CFOP) //03 - CFOP
	aAdd(aRegC850[nPos], (cAliasSFT)->FT_ALIQICM)	//04 - Alíq ICMS 
	aAdd(aRegC850[nPos], (cAliasSFT)->FT_VALCONT)	//05 - Valor CF-e  ????
	aAdd(aRegC850[nPos], (cAliasSFT)->FT_BASEICM)	//06 - Base ICMS     
	aAdd(aRegC850[nPos], (cAliasSFT)->FT_VALICM) //07 - Valor ICMS
	aAdd(aRegC850[nPos], "")	 //08 - Código observação

	cHierarq :=  cHierarq + "C850" + StrZero(nPos, nTTRBITEM, 0)
	
	aAdd (aRegC850[nPos], cHierarq )	//09 - Posicao de Hierarquia, utilizada para organizacao dos registros	

	If lBuild
		FisAddHash(oHashC850,cChave,nPos)
	EndIf
Else
	aRegC850[nPos][06] += (cAliasSFT)->FT_VALCONT	//06 - Valor total CF-e		   
	aRegC850[nPos][07] += (cAliasSFT)->FT_BASEICM	//07 - Base ICMS     
	aRegC850[nPos][08] += (cAliasSFT)->FT_VALICM	//08 - Valor ICMS
EndIf

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc}
@description C855C857
@author allef.souza
@since 23/11/2022
@version 12.1.2210
/*/
//-------------------------------------------------------------------
Static Function C855C857(cAlias, aLanCDA, aReg0460, aCmpAntSFT, cHierarq, aReg0200, aReg0190, aReg0220, dDataDe, dDataAte, aWizard)

	Local	nPos		:=	0
	Local	nPosC855	:=	0
	Local	nX			:=	0
	Local	aRegC855	:=	{}
	Local	aRegC857	:=	{}
	Local	cCodItem	:=	""
	Local   nTamCDA		:= Len(aLanCDA)

	For nX := 1 to nTamCDA
		
		cCodItem :=	""
		If (aCmpAntSFT[26]=="0")
			cCodItem :=	aLanCDA[nX,13]
		EndIf

		//Registro C855
		If (nPosC855 := aScan(aRegC855,{|aX| aX[2]==aLanCDA[nX][07]}))==0
			aAdd(aRegC855, {})
			nPosC855 :=	Len(aRegC855)
			aAdd(aRegC855[nPosC855], "C855")		 	   					//01 - REG
			aAdd(aRegC855[nPosC855], aLanCDA[nX][07])						//02 - COD_OBS
			aAdd(aRegC855[nPosC855], aLanCDA[nX][17])		   				//03 - TXT_COMPL
			aAdd(aRegC855[nPosC855], cHierarq + "C855" + strzero(nPosC855,nTamFT_IT)) //Posição de Hierarquia		
			Reg0460(@aReg0460,{aLanCDA[nX][7],aLanCDA[nX][20]})
		EndIf

		If !aLanCDA[nX][24]
			nPos := aScan(aRegC857,{|x| x[1] == nPosC855 .And. x[5]==cCodItem .And. x[3]==aLanCDA[nX,1] })
		Else
			If aLanCDA[nX,23] == "01"
				nPos := aScan(aRegC857,{|x| x[1] == nPosC855 .And. x[3]==aLanCDA[nX,1] })
			ElseIf aLanCDA[nX,23] == "02"
				nPos := aScan(aRegC857,{|x| x[1] == nPosC855 .And. x[3]==aLanCDA[nX,1] .And. x[4]==aLanCDA[nX][2] })
			Elseif aLanCDA[nX,23] == "03"
				nPos := aScan(aRegC857,{|x| x[1] == nPosC855 .And. x[5]==cCodItem .And. x[3]==aLanCDA[nX,1] })
			Else
				nPos := aScan(aRegC857,{|x| x[1] == nPosC855 .And. x[5]==cCodItem .And. x[3]==aLanCDA[nX,1] })
			Endif	
		Endif
		
		//Registro C857		
		If nPos == 0
			aAdd(aRegC857, {})
			nPos := Len(aRegC857)
			aAdd(aRegC857[nPos], nPosC855)									//01 - RELACIONAMENTO COM C855
			aAdd(aRegC857[nPos], "C857")	   								//02 - REG
			aAdd(aRegC857[nPos], aLanCDA[nX,1])				       			//03 - COD_AJ
			aAdd(aRegC857[nPos], aLanCDA[nX][2])					   		//04 - DESCR_COMPL_AJ
			aAdd(aRegC857[nPos], cCodItem)									//05 - COD_ITEM
			aAdd(aRegC857[nPos], aLanCDA[nX][3])							//06 - VL_BC_ICMS
			aAdd(aRegC857[nPos], aLanCDA[nX][4])							//07 - ALIQ_ICMS
			aAdd(aRegC857[nPos], aLanCDA[nX][5])							//08 - VL_ICMS
			aAdd(aRegC857[nPos], aLanCDA[nX][6])							//09 - VL_OUTROS

			aAdd(aRegC857[nPos], cHierarq + "C855" + strzero(nPosC855,nTamFT_IT) + "C857") //Posição de Hierarquia
		Else
			aRegC857[nPos][6]	+= aLanCDA[nX][3]							 //06 - VL_BC_ICMS
			aRegC857[nPos][8]	+= aLanCDA[nX][5]							 //08 - VL_ICMS
			aRegC857[nPos][9]	+= aLanCDA[nX][6]							 //09 - VL_OUTROS
		EndIf

		//Tratamento para que os itens utilizados seja gerados no 0200
		If !Empty(cCodItem) .And. aScan(aReg0200, { |aX| aX[2] == cCodItem }) == 0
			SPEDSeek("SB1",,aSPDFil[PFIL_SB1]+cCodItem)
			SFRG0200(cAlias, @aReg0200, @aReg0190, dDataDe, dDataAte, ,cCodItem, @aReg0220,,,,,,,,,,,,,,,,,,,aWizard)
		EndIf

	Next

	GrRegDep(cAlias, aRegC855, aRegC857,.F.,,,,,.T.)

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} REGC860
@description REGISTRO C860: IDENTIFICAÇÃO DO EQUIPAMENTO SAT-CF-E - Perfil B
@author Mauro A. Gonçalves 
@since 06/08/2015
@version 11.90
/*/
//-------------------------------------------------------------------
Static Function RegC860(aRegC860,cAliasSFT,cSituaDoc, cHiC800_60)

Local cNF	:= ''   
Local nPos		:= 0
Local cChave	:= ''

If cSituaDoc$"02/03"
	Return 0
Endif	

cNF	:= Right(AllTrim((cAliasSFT)->FT_NFISCAL),6)

// Se build superior a "7.00.131227A" faz a busca no HashMap para ganho de performance.
If lBuild
	cChave	:= "59"+(cAliasSFT)->FT_SERSAT+DToS((cAliasSFT)->FT_EMISSAO)
	nPos	:= FisFindHash(oHashC860, cChave)
Else
	nPos := Ascan(aRegC860, {|x| x[2]=="59" .AND. x[3]==(cAliasSFT)->FT_SERSAT .AND. x[4]==(cAliasSFT)->FT_EMISSAO})
EndIf

IF nPos == 0
	cHiC800_60 := ""
	aAdd(aRegC860, {})
	nPos := Len(aRegC860)
	aAdd(aRegC860[nPos], "C860") //01 - REG
	aAdd(aRegC860[nPos], "59") //02 - Código modelo documento
	aAdd(aRegC860[nPos], (cAliasSFT)->FT_SERSAT)	//03 - Nr Série SAT   
	aAdd(aRegC860[nPos], (cAliasSFT)->FT_EMISSAO)	//04 - Data de emissão
	aAdd(aRegC860[nPos], cNF) //05 - Número documento inicial         
	aAdd(aRegC860[nPos], cNF) //06 - Número documento final

	cHiC800_60 :=  cFilAnt + "2" + "C860" + StrZero(nPos, nTTRBITEM, 0)
	
	aAdd(aRegC860[nPos], cHiC800_60 )					//07 - Posicao de Hierarquia, utilizada para organizacao dos registros				

	If lBuild
		FisAddHash(oHashC860,cChave,nPos)
	EndIf
Else
	If Val((cAliasSFT)->FT_NFISCAL) < Val(aRegC860[nPos][5])
		aRegC860[nPos][5] := cNF 
	Endif

	If Val((cAliasSFT)->FT_NFISCAL) > Val(aRegC860[nPos][6])
		aRegC860[nPos][6] := cNF
	Endif
Endif

Return nPos

//-------------------------------------------------------------------
/*/{Protheus.doc} REGC890
@description REGISTRO C890: RESUMO DIÁRIO DO CF-E-SAT (CÓDIGO 59) POR EQUIPAMENTO SAT-CF-E - Perfil B
@author Mauro A. Gonçalves
@since 06/08/2015
@version 11.90
/*/
Static Function RegC890(nPosC860,aRegC890,cAliasSFT,cSituaDoc,aClasFis, cHierarq, cChv890)

Local nPos 		:= 0
Local cChave	:= ''

Default cChv890 := ""

If cSituaDoc$"02/03"
	Return .t.
Endif

// Se build superior a "7.00.131227A" faz a busca no HashMap para ganho de performance.
If lBuild
	cChave	:= str(nPosC860)+aClasFis[1]+(cAliasSFT)->FT_CFOP+str((cAliasSFT)->FT_ALIQICM)
	nPos	:= FisFindHash(oHashC890, cChave)
Else
	nPos := Ascan(aRegC890, {|x| x[1]==nPosC860 .AND. x[3]==aClasFis[1] .AND. x[4]==(cAliasSFT)->FT_CFOP .AND. x[5]==(cAliasSFT)->FT_ALIQICM})
EndIf

If nPos == 0
	aAdd(aRegC890, {})
	nPos := Len(aRegC890)
	aAdd(aRegC890[nPos], nPosC860) //00 - RELACIONAMENTO COM REGISTRO PAI
	aAdd(aRegC890[nPos], "C890") //01 - REG
	aAdd(aRegC890[nPos], aClasFis[1]) //02 - CST ICMS
	aAdd(aRegC890[nPos], (cAliasSFT)->FT_CFOP) //03 - Código CFOP
	aAdd(aRegC890[nPos], (cAliasSFT)->FT_ALIQICM)	//04 - Alíq ICMS 
	aAdd(aRegC890[nPos], (cAliasSFT)->FT_VALCONT)	//05 - Valor CF-e  ????
	aAdd(aRegC890[nPos], (cAliasSFT)->FT_BASEICM)	//06 - Base ICMS     
	aAdd(aRegC890[nPos], (cAliasSFT)->FT_VALICM) //07 - Valor ICMS
	aAdd(aRegC890[nPos], "")	//08 - Código observação

	cChv890 := cHierarq + "C890" + StrZero(nPos, nTTRBITEM, 0)
	
	aAdd(aRegC890[nPos], cChv890 )					//07 - Posicao de Hierarquia, utilizada para organizacao dos registros					
		
	If lBuild
		FisAddHash(oHashC890,cChave,nPos)
	EndIf
Else
	aRegC890[nPos][06] += (cAliasSFT)->FT_VALCONT	//06 - Valor total CF-e		   
	aRegC890[nPos][07] += (cAliasSFT)->FT_BASEICM	//07 - Base ICMS     
	aRegC890[nPos][08] += (cAliasSFT)->FT_VALICM	//08 - Valor ICMS
EndIf
	
Return nPos


//-------------------------------------------------------------------
/*/{Protheus.doc} ApurDifal
Função para geração do registro E313
@param dDtIni 		- Data inicial de processamento
@param dDtFim 		- Data final de processamento
@param cLivro 		- Livro processado
@param aInfRgE313 - Array com informações de documento com ajuste da apuração
@param cAlias  	- alias do arquivo temporário
@param aMovSemIe  - Array com UF de destino sem IE que tiveram movimentações em C101/D101


@author Erick G Dias
@since 20/01/2016
@version 1.0
/*/
//-------------------------------------------------------------------
Function ApurDifal (dDtIni, dDtFim, cLivro, aInfRgE313,cAlias,aMovSemIe,aIcmPago,aT051_300,aT051_310,aT051_311,aT051_312,aT051_313,aT051_316,lExtratTAF,lE300Ori)

Local cAliasF0I	:= 'F0I'
Local cSlctF0I	:= ''
Local cFiltro		:= ''
Local cTabela		:= ''
Local aRegE300	:= {}
Local aRegE310	:= {}
Local aRegE311	:= {}
Local aRegE312	:= {}
Local aRegE313	:= {}
Local aRegE316	:= {}
Local nX			:= 0
Local nIcmPg		:= 0
Local nPosE300	:= 0
Local cMVSUBTRIB	:=	GetSubTrib("",.T.)//SpedPrSeq("MV_SUBTRI")
Local aUf			:=	UfCodIBGE("",.F.)
Local cCodRec		:= ''
Local cMesRef		:= ''
local nPosUfPg		:= 0
Local lDIFCamp		:= aSPDSX3[FP_F0I_OUTDBF] .And. aSPDSX3[FP_F0I_OUTCRF] .And. aSPDSX3[FP_F0I_DEVFCP] .And. aSPDSX3[FP_F0I_DEDFCP] .And. aSPDSX3[FP_F0I_DBESPF] .And. aSPDSX3[FP_F0I_ESTDBF] .And. aSPDSX3[FP_F0I_ESTCRF]

Default aMovSemIe	:= {}
Default lExtratTAF  := .F.
Default lE300Ori	:= .F.

cSlctF0I:= '%'
cSlctF0I+= 'F0I.F0I_DEBDIF,		F0I.F0I_OUTDEB,		F0I.F0I_ESTCRD,		F0I.F0I_OUTCRE,'
cSlctF0I+= 'F0I.F0I_SADIF ,		F0I.F0I_CRDDIF,		F0I.F0I_ESTDEB,		F0I.F0I_DEVDIF,'
cSlctF0I+= 'F0I.F0I_DEDDIF ,	F0I.F0I_DIFREC,		F0I.F0I_SPDIF ,		F0I.F0I_DEBESP,'
cSlctF0I+= 'F0I.F0I_DEBFCP ,	F0I.F0I_SAFCP ,		F0I.F0I_CRDFCP ,	F0I.F0I_FCPREC,'
cSlctF0I+= 'F0I.F0I_SPFCP ,		F0I_UF '
// Novos campos Difal
IF lDIFCamp
	cSlctF0I+= ', F0I_OUTDBF , F0I_OUTCRF, F0I_DEVFCP, F0I_DEDFCP, F0I_DBESPF, F0I_ESTDBF, F0I_ESTCRF'
Endif

cSlctF0I+= '%'

cTabela := '% ' +RetSqlName('F0I')+ ' F0I %'

cFiltro := "%"
cFiltro += "F0I.F0I_FILIAL= '"+ aSPDFil[PFIL_F0I]+ "' AND "
cFiltro += "F0I.F0I_PER>= '" + %Exp:DToS (dDtIni)% + "' AND "
cFiltro += "F0I.F0I_PER<= '" + %Exp:DToS (dDtFim)% + "' AND "
If !lExtratTAF
	cFiltro += "F0I.F0I_LIVRO = '"+ cLivro+ "' AND "
Endif
cFiltro += "F0I.D_E_L_E_T_ = '' "
cFiltro += 'ORDER BY F0I.F0I_UF '
cFiltro += "%"

cAliasF0I := GetNextAlias()
BeginSql Alias cAliasF0I
	SELECT
		%Exp:cSlctF0I%
	FROM
		%Exp:cTabela%
	WHERE
		%Exp:cFiltro%
EndSql

DbSelectArea (cAliasF0I)
(cAliasF0I)->(DbGoTop ())
Do While !(cAliasF0I)->(Eof ())
	RegE300310(@aRegE300, @aRegE310, cAliasF0I, dDtIni, dDtFim,'1',(cAliasF0I)->F0I_UF, , ,lExtratTAF,lDIFCamp)
	(cAliasF0I)->(DbSkip ())
EndDo
DbSelectArea (cAliasF0I)
(cAliasF0I)->(DbCloseArea())

//Aqui serão processados os ajustes de apuração realizados
For nX := 1 to Len(aRegE310)

	RegE311312 (@aRegE311, @aRegE312, aRegE300[ aRegE310[nX][1] ][2], dDtIni, dDtFim ,cLivro, nX, lExtratTaf,aInfRgE313,@aRegE313)

	RegE316(@aRegE316, aRegE300[ aRegE310[nX][1] ][2], dDtIni, dDtFim ,cLivro, nX, lExtratTAF)			

Next nX

For nX := 1 to Len(aRegE311)

	RegE313(@aRegE313, aInfRgE313, nX, aRegE311[nX][3])

next nX

For nX := 1 to Len(aUf)

	If At (aUf[nX][1], cMVSUBTRIB)>0 .or. (lE300Ori .and. aUf[nX][1] == aSPDSX6[MV_ESTADO] )	//Se tiver inscricao no estado 
																							    //ou possuir movimentos de difal imprime estado origem quando não possuir IE no estado de origem (DSERFIS1-14517)
		nPosE300 := aScan(aRegE300,{|aX| aX[2]==aUf[nX][1] }) 
		If nPosE300 == 0
			//Se não existir E300 para UF, então será adicionado E300 e E310 com valores zerados
			//e indicador de sem movimentação. Caso existir não fará nenhuma ação
			RegE300310(@aRegE300, @aRegE310, cAliasF0I, dDtIni, dDtFim,'0',aUf[nX][1],,,lExtratTaf,lDIFCamp)
		EndIF

	EndIf

Next nX

//Ordeno por UF
aIcmPago := Asort(aIcmPago,,,{|x,y|x[1]<y[1]})

For nX := 1 to len(aMovSemIe)

	If !Empty(aMovSemIe[nX][1])

		nPosE300 := aScan(aRegE300,{|aX| aX[2]==aMovSemIe[nX][1]})
		If nPosE300 == 0
			//Se não existir E300 para UF, então será adicionado E300 e E310 com valores zerados
			//e indicador de sem movimentação. Caso existir não fará nenhuma ação
			RegE300310(@aRegE300, @aRegE310, cAliasF0I, dDtIni, dDtFim,'0',aMovSemIe[nX][1],aMovSemIe[nX][2],aMovSemIe[nX][3],lExtratTaf,lDIFCamp)

			nPosUfPg	:= aScan(aIcmPago,{|aX| aX[1]==aMovSemIe[nX][1] })
			//Gera E316 com as GNRE geradas no documento fiscal
			If nPosUfPg > 0 .AND. nPosUfPg <= Len(aIcmPago)

				For nIcmPg := nPosUfPg To Len(aIcmPago)

					If aIcmPago[nIcmPg][1]==aMovSemIe[nX][1] .AND. aIcmPago[nIcmPg][12] == 'B' //Considera valores do Difal em E316

						If SPEDSeek("SF6",1,aSPDFil[PFIL_SF6]+aIcmPago[nIcmPg][1]+aIcmPago[nIcmPg][3])

							cCodRec	:= Alltrim( SF6->F6_CODREC ) + Iif(aIcmPago[nIcmPg][1] $ aSPDSX6[MV_SFUFGNR], Alltrim( SF6->F6_CLAVENC ) , '')
							cMesRef	:= Alltrim( STRzero( SF6->F6_MESREF,2 ) ) + Alltrim(STR(SF6->F6_ANOREF))
							nPosE300 := aScan(aRegE300,{|aX| aX[2]==aMovSemIe[nX][1] })

							AddE316(@aRegE316,nPosE300,cCodRec,cMesRef, ;
									 SF6->F6_COBREC, SF6->F6_DTVENC , SF6->F6_NUMPROC ,;
									 SF6->F6_INDPROC, SF6->F6_DESCOMP, SF6->F6_OBSERV  ,;
									 SF6->F6_VALOR )
						EndIf

					ElseIf aIcmPago[nIcmPg][1]<>aMovSemIe[nX][1]
						Exit
					EndIF

				Next nIcmPg
			EndIf
			
		EndIF
	EndIF

Next nX

If !lExtratTAF
	SPEDRegs(cAlias,{aRegE300,aRegE310,aRegE311,{aRegE316,2},{aRegE312,3},{aRegE313,3}})
Else
	aT051_300 := aRegE300
	aT051_310 := aRegE310
	aT051_311 := aRegE311
	aT051_312 := aRegE312
	aT051_313 := aRegE313
	aT051_316 := aRegE316
EndIF

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} RegE300310
Função para geração do registro E313
@param aRegE300 	- array com registros E300
@param aRegE310 	- array com registros E310
@param cAliasF0I 	- Alias com informações da tabela F0i apuração do DIFAL
@param dDtIni  	- Data inicial de processamento
@param dDtFim  	- Data final de processamento
@param cIndMov   	- Indicador de movimentação
@param cUf   		- UF processada

@author Erick G Dias
@since 20/01/2016
@version 1.0
/*/
//-------------------------------------------------------------------
Static Function RegE300310(aRegE300, aRegE310, cAliasF0I,dDtIni, dDtFim, cIndMov, cUf, nDifSemIe, nFcpSemIe, lExtratTAF,lDIFCamp)

Local nPos	:= 0
Local nE300	:= 0

Default nDifSemIe		:= 0
Default nFcpSemIe		:= 0
Default lExtratTAF		:= .F.
Default	lDIFCamp		:= .F.


//Adiciona registro E300
aAdd(aRegE300, {})
nE300	:=	Len (aRegE300)
aAdd (aRegE300[nE300], "E300")				 				//01 - REG
aAdd (aRegE300[nE300], cUf)	   								//02 - UF
aAdd (aRegE300[nE300], dDtIni)				   				//03 - DT_INI
aAdd (aRegE300[nE300], dDtFim)				   				//04 - DT_FIN

//Adiciona registro E310 filho com valores zerados e com indicador sem movimentação.
aAdd(aRegE310, {})
nPos	:=	Len (aRegE310)
aAdd (aRegE310[nPos], nE300)				 									//Relacionamento com registro Pai
aAdd (aRegE310[nPos], "E310")	//01 - REG

If !lExtratTaf //Monta o array com base no layout da Receita
	aAdd (aRegE310[nPos],'0')  		//02 - IND_MOV_DIFAL
	aAdd (aRegE310[nPos],0)			//03 - VL_SLD_CRED_ANT_DIFAL
	aAdd (aRegE310[nPos],0)	   		//04 - VL_TOT_DEBITOS_DIFAL
	aAdd (aRegE310[nPos],0)			//05 - VL_OUT_DEB_DIFAL
	aAdd (aRegE310[nPos],0)	   		//06 - VL_TOT_DEB_FCP
	aAdd (aRegE310[nPos],0)	   		//07 - VL_TOT_CREDITOS_DIFAL
	aAdd (aRegE310[nPos],0)	   		//08 - VL_TOT_CRED_FCP
	aAdd (aRegE310[nPos],0)			//09 - VL_OUT_CRED_DIFAL
	aAdd (aRegE310[nPos],0)	   		//10 - VL_SLD_DEV_ANT_DIFAÇ
	aAdd (aRegE310[nPos],0)	   		//11 - VL_DEDUCOES_DIFAL
	aAdd (aRegE310[nPos],0)			//12 - VL_RECOL
	aAdd (aRegE310[nPos],0)  		//13 - VL_SLD_CRED_TRANSPORTAR
	aAdd (aRegE310[nPos],0)	   		//14 - DEB_ESP_DIFAL
	
	IF cVersao >= "011"
		aAdd (aRegE310[nPos],0)			//15
		aAdd (aRegE310[nPos],0)			//16
		aAdd (aRegE310[nPos],0)			//17
		aAdd (aRegE310[nPos],0)			//18
		aAdd (aRegE310[nPos],0)			//19
		aAdd (aRegE310[nPos],0)			//20
		aAdd (aRegE310[nPos],0)			//21	
		aAdd (aRegE310[nPos],0)			//22
	Endif

Else //Monta o array com base no Layout do TAF
	aAdd (aRegE310[nPos],0)			//05 - VL_SLD_CRED_ANT_DIFAL = Posicao do array -> 03
	aAdd (aRegE310[nPos],0)			//06 - VL_TOT_DEBITOS_DIFAL = Posicao do array -> 04
	aAdd (aRegE310[nPos],0)			//07 - VL_OUT_DEB_DIFAL = Posicao do array -> 05
	aAdd (aRegE310[nPos],0)			//08 - VL_EST_CRED_DIFAL = Posicao do array -> 06
	aAdd (aRegE310[nPos],0)			//09 - VL_TOT_CREDITOS_DIFAL = Posicao do array -> 07
	aAdd (aRegE310[nPos],0)			//10 - VL_OUT_CRED_DIFAL = Posicao do array -> 08
	aAdd (aRegE310[nPos],0)			//11 - VL_EST_DEB_DIFAL = Posicao do array -> 09
	aAdd (aRegE310[nPos],0)			//12 - VL_SLD_DEV_ANT_DIFAL = Posicao do array -> 10
	aAdd (aRegE310[nPos],0)			//13 - VL_DEDUÇÕES_DIFAL = Posicao do array -> 11
	aAdd (aRegE310[nPos],0)			//14 - VL_RECOL_DIFAL = Posicao do array -> 12
	aAdd (aRegE310[nPos],0) 			//15 - VL_SLD_CRED_TRANSPORTAR_DIFAL = Posicao do array -> 13
	aAdd (aRegE310[nPos],0)			//16 - DEB_ESP_DIFAL = Posicao do array -> 14
	aAdd (aRegE310[nPos],0)        	//17 - VL_SLD_CRED_ANT_FCP = Posicao do array -> 15
	aAdd (aRegE310[nPos],0)			//18 - VL_TOT_DEB_FCP  = Posicao do array -> 16
	aAdd (aRegE310[nPos],0)        	//19 - VL_OUT_DEB_FCP = Posicao do array -> 17
	aAdd (aRegE310[nPos],0)			//20 - VL_EST_CRE_FCP = Posicao do array -> 18
	aAdd (aRegE310[nPos],0)			//21 - VL_TOT_CRED_FCP = Posicao do array -> 19
	aAdd (aRegE310[nPos],0)			//22 - VL_OUT_CRED_FCP = Posicao do array -> 20
	aAdd (aRegE310[nPos],0) 			//23 - VL_EST_DEB_FCP = Posicao do array -> 21
	aAdd (aRegE310[nPos],0)			//24 - VL_SLD_DEV_ANT_FCP = Posicao do array -> 22
	aAdd (aRegE310[nPos],0)			//25 - VL_DEDUÇÕES_FCP = Posicao do array -> 23
	aAdd (aRegE310[nPos],0)			//26 - VL_RECOL_FCP = Posicao do array -> 24
	aAdd (aRegE310[nPos],0)			//27 - VL_SLD_CRED_TRANSPORTAR_FCP = Posicao do array -> 25
	aAdd (aRegE310[nPos],0)			//28 - DEB_ESP_FCP = Posicao do array -> 26

Endif

If nDifSemIe + nFcpSemIe > 0 //Gera operações sem IE
	
	If !lExtratTaf	
		IF cVersao >= "011"
			aRegE310[nPos][3]	:= '1'
			aRegE310[nPos][5]	:= nDifSemIe				//04 - VL_TOT_DEBITOS_DIFAL
			aRegE310[nPos][15]	:= nFcpSemIe				//14 - VL_TOT_DEB_FCP
			aRegE310[nPos][09]	:= nDifSemIe 				//08 - VL_SLD_DEV_ANT_DIFAL
			aRegE310[nPos][19]	:= nFcpSemIe 				//18 - VL_SLD_DEV_ANT_FCP
			aRegE310[nPos][11]	:= nDifSemIe				//10 - VL_RECOL_DIFAL
			aRegE310[nPos][21]	:= nFcpSemIe				//20 - VL_RECOL_FCP 
		Else
			aRegE310[nPos][3]	:= '1'
			aRegE310[nPos][5]	:= nDifSemIe				//04 - VL_TOT_DEBITOS_DIFAL
			aRegE310[nPos][7]	:= nFcpSemIe				//06 - VL_TOT_DEB_FCP
			aRegE310[nPos][11]	:= nDifSemIe + nFcpSemIe	//10 - VL_SLD_DEV_ANT_DIFAL
			aRegE310[nPos][13]	:= nDifSemIe + nFcpSemIe	//12 - VL_RECOL
		Endif
	Else
		aRegE310[nPos][4]	:= nDifSemIe				//06 - VL_TOT_DEBITOS_DIFAL
		aRegE310[nPos][16]	:= nFcpSemIe				//18 - VL_TOT_DEB_FCP
		aRegE310[nPos][10]	:= nDifSemIe 				//12 - VL_SLD_DEV_ANT_DIFAL
		aRegE310[nPos][22]	:= nFcpSemIe				//24 - VL_SLD_DEV_ANT_FCP
		aRegE310[nPos][12]	:= nDifSemIe 				//14 - VL_RECOL_DIFAL
		aRegE310[nPos][24]	:= nFcpSemIe				//26 - VL_RECOL_FCP
	Endif

ElseIf cIndMov == '1'
	
	If !lExtratTaf
		//Se houver apuração para o Estado, então o registro E310 será atualizado com valores
		IF cVersao >= "011"
			aRegE310[nPos][3]	:= cIndMov
			aRegE310[nPos][4]	:= (cAliasF0I)->F0I_SADIF 					//03 - VL_SLD_CRED_ANT_DIFAL
			aRegE310[nPos][5]	:= (cAliasF0I)->F0I_DEBDIF					//04 - VL_TOT_DEBITOS_DIFAL
			aRegE310[nPos][6]	:= (cAliasF0I)->(F0I_OUTDEB + F0I_ESTCRD)	//05 - VL_OUT_DEB_DIFAL
			aRegE310[nPos][7]	:= (cAliasF0I)->F0I_CRDDIF					//06 - VL_TOT_CREDITOS_DIFAL
			aRegE310[nPos][8]	:= (cAliasF0I)->(F0I_OUTCRE + F0I_ESTDEB)	//07 - VL_OUT_CRED_DIFAL
			aRegE310[nPos][9]	:= (cAliasF0I)->F0I_DEVDIF					//08 - VL_SLD_DEV_ANT_DIFAÇ
			aRegE310[nPos][10]	:= (cAliasF0I)->F0I_DEDDIF					//09 - VL_DEDUCOES_DIFAL
			aRegE310[nPos][11]	:= (cAliasF0I)->F0I_DIFREC  				//10 - VL_RECOL_DIFAL
			aRegE310[nPos][12]	:= (cAliasF0I)->F0I_SPDIF   				//11 - VL_SLD_CRED_TRANSPORTAR_DIFAL
			aRegE310[nPos][13]	:= (cAliasF0I)->F0I_DEBESP					//12 - DEB_ESP_DIFAL  
			aRegE310[nPos][14]	:= (cAliasF0I)->F0I_SAFCP 					//13 - VL_SLD_CRED_ANT_FCP		
			aRegE310[nPos][15]	:= (cAliasF0I)->F0I_DEBFCP 						//14 - VL_TOT_DEB_FCP
			aRegE310[nPos][16]	:= IF(lDIFCamp,(cAliasF0I)->(F0I_OUTDBF + F0I_ESTCRF),0)		//15 - VL_OUT_DEB_FCP
			aRegE310[nPos][17]	:= (cAliasF0I)->F0I_CRDFCP 						//16 - VL_TOT_CRED_FCP
			aRegE310[nPos][18]	:= IF(lDIFCamp,(cAliasF0I)->(F0I_OUTCRF + F0I_ESTDBF),0)		//17 - VL_OUT_CRED_FCP
			aRegE310[nPos][19]	:= IF(lDIFCamp,(cAliasF0I)->F0I_DEVFCP,0) 		//18 - VL_SLD_DEV_ANT_FCP
			aRegE310[nPos][20]	:= IF(lDIFCamp,(cAliasF0I)->F0I_DEDFCP,0)		//19 - VL_DEDUÇÕES_FCP
			aRegE310[nPos][21]	:= (cAliasF0I)->F0I_FCPREC						//20 - VL_RECOL_FCP ( 18-19)
			aRegE310[nPos][22]	:= (cAliasF0I)->F0I_SPFCP						//21 - VL_SLD_CRED_TRANSPORTAR_FCP
			aRegE310[nPos][23]	:= IF(lDIFCamp,(cAliasF0I)->F0I_DBESPF,0)		//22 - DEB_ESP_FCP
		Else
			aRegE310[nPos][3]	:= cIndMov
			aRegE310[nPos][4]	:= (cAliasF0I)->F0I_SADIF   + (cAliasF0I)->F0I_SAFCP 		//03 - VL_SLD_CRED_ANT_DIFAL
			aRegE310[nPos][5]	:= (cAliasF0I)->F0I_DEBDIF									//04 - VL_TOT_DEBITOS_DIFAL
			aRegE310[nPos][6]	:= (cAliasF0I)->F0I_OUTDEB  +  (cAliasF0I)->F0I_ESTCRD		//05 - VL_OUT_DEB_DIFAL
			aRegE310[nPos][7]	:= (cAliasF0I)->F0I_DEBFCP									//06 - VL_TOT_DEB_FCP
			aRegE310[nPos][8]	:= (cAliasF0I)->F0I_CRDDIF									//07 - VL_TOT_CREDITOS_DIFAL
			aRegE310[nPos][9]	:= (cAliasF0I)->F0I_CRDFCP									//08 - VL_TOT_CRED_FCP
			aRegE310[nPos][10]	:= (cAliasF0I)->F0I_OUTCRE  + (cAliasF0I)->F0I_ESTDEB		//09 - VL_OUT_CRED_DIFAL
			aRegE310[nPos][11]	:= (cAliasF0I)->F0I_DEVDIF  + (cAliasF0I)->F0I_FCPREC		//10 - VL_SLD_DEV_ANT_DIFAÇ
			aRegE310[nPos][12]	:= (cAliasF0I)->F0I_DEDDIF									//11 - VL_DEDUCOES_DIFAL
			aRegE310[nPos][13]	:= (cAliasF0I)->F0I_DIFREC  + (cAliasF0I)->F0I_FCPREC		//12 - VL_RECOL
			aRegE310[nPos][14]	:= (cAliasF0I)->F0I_SPDIF   + (cAliasF0I)->F0I_SPFCP		//13 - VL_SLD_CRED_TRANSPORTAR
			aRegE310[nPos][15]	:= (cAliasF0I)->F0I_DEBESP									//14 - DEB_ESP_DIFAL  
		Endif 
		
	Else
		aRegE310[nPos][3]	:= (cAliasF0I)->F0I_SADIF					 //05 - VL_SLD_CRED_ANT_DIFAL
		aRegE310[nPos][4]	:= (cAliasF0I)->F0I_DEBDIF      			 //06 - VL_TOT_DEBITOS_DIFAL
		aRegE310[nPos][5]	:= (cAliasF0I)->F0I_OUTDEB					 //07 - VL_OUT_DEB_DIFAL
		aRegE310[nPos][6]	:= (cAliasF0I)->F0I_ESTCRD					 //08 - VL_EST_CRED_DIFAL
		aRegE310[nPos][7]	:= (cAliasF0I)->F0I_CRDDIF					 //09 - VL_TOT_CREDITOS_DIFAL
		aRegE310[nPos][8]	:= (cAliasF0I)->F0I_OUTCRE					 //10 - VL_OUT_CRED_DIFAL
		aRegE310[nPos][9]	:= (cAliasF0I)->F0I_ESTDEB					 //11 - VL_EST_DEB_DIFAL
		aRegE310[nPos][10]	:= (cAliasF0I)->F0I_DEVDIF				 //12 - VL_SLD_DEV_ANT_DIFAL
		aRegE310[nPos][11]	:= (cAliasF0I)->F0I_DEDDIF				 //13 - VL_DEDUÇÕES_DIFAL
		aRegE310[nPos][12]	:= (cAliasF0I)->F0I_DIFREC				 //14 - VL_RECOL_DIFAL
		aRegE310[nPos][13]	:= (cAliasF0I)->F0I_SPDIF 					 //15 - VL_SLD_CRED_TRANSPORTAR_DIFAL
		aRegE310[nPos][14]	:= (cAliasF0I)->F0I_DEBESP					 //16 - DEB_ESP_DIFAL
		aRegE310[nPos][15]	:= (cAliasF0I)->F0I_SAFCP 					 //17 - VL_SLD_CRED_ANT_FCP
		aRegE310[nPos][16]	:= (cAliasF0I)->F0I_DEBFCP					 //18 - VL_TOT_DEB_FCP
		aRegE310[nPos][17]	:= 0         					 			 //19 - VL_OUT_DEB_FCP - Ainda não foi criado o campo para no Protheus, pois será utilizado apenas a partide de 01/01/2017
		aRegE310[nPos][18]	:= 0										 //20 - VL_EST_CRE_FCP
		aRegE310[nPos][19]	:= (cAliasF0I)->F0I_CRDFCP					 //21 - VL_TOT_CRED_FCP 
		aRegE310[nPos][20]	:= 0         					 			 //22 - VL_OUT_CRED_FCP - Ainda não foi criado o campo para no Protheus, pois será utilizado apenas a partide de 01/01/2017
		aRegE310[nPos][21]	:= 0										 //23 - VL_EST_DEB_FCP
		aRegE310[nPos][22]	:= (cAliasF0I)->F0I_FCPREC 	 			 //24 - VL_SLD_DEV_ANT_FCP - Ainda não foi criado o campo para no Protheus, pois será utilizado apenas a partide de 01/01/2017
		aRegE310[nPos][23]	:= 0         								 //25 - VL_DEDUÇÕES_FCP - Ainda não foi criado o campo para no Protheus, pois será utilizado apenas a partide de 01/01/2017
		aRegE310[nPos][24]	:= (cAliasF0I)->F0I_FCPREC					 //26 - VL_RECOL_FCP
		aRegE310[nPos][25]	:= (cAliasF0I)->F0I_SPFCP 					 //27 - VL_SLD_CRED_TRANSPORTAR_FCP
		aRegE310[nPos][26]	:= 0               				 			 //28 - DEB_ESP_FCP - Ainda não foi criado o campo para no Protheus, pois será utilizado apenas a partide de 01/01/2017
	Endif
			 	
EndIF							

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} RegE311312
Função para geração do registro E313
@param aRegE311 	- array com registros E311
@param aRegE312 	- array com registros E312
@param cUf 		- UF processada
@param dDtIni  	- Data inicial de processamento
@param dDtFim  	- Data final de processamento
@param cLivro   	- livro processado
@param nPaiE310   - relação com registro pai E310

@author Erick G Dias
@since 20/01/2016
@version 1.0
/*/
//-------------------------------------------------------------------
Static Function RegE311312 (aRegE311, aRegE312, cUf, dDtIni, dDtFim ,cLivro, nPaiE310, lExtratTaf,aInfE313,aRegE313)

Local cSlctF0K	:= ''
local cJoin		:= ''
Local cFiltro	:= ''
Local nPosE311	:= 0
Local nPosE312	:= 0
Local nPosE313	:= 0
Local lCdoIndiv	:= .F.
Local cDescAj	:= ""
Local nTamF0KDes :=	TamSx3("F0K_DESCR")[1]
Local lProcE112	:= aSPDSX3[FP_F0K_PROCES] .And. aSPDSX3[FP_F0K_PROCTP] .And. aSPDSX3[FP_F0K_PROIND] .And. aSPDSX3[FP_F0K_ITPROC]
Default lExtratTAF	:= .F.
Default aInfE313	:= {}


cSlctF0K+= 'F0K.F0K_CODAPU,		F0K.F0K_VALOR ,		F0K.F0K_DESCR ,		F0K.F0K_GNRE, F0K.F0K_TPLANC,  '
cSlctF0K+= 'SF6.F6_NUMERO,		SF6.F6_NUMPROC ,		SF6.F6_INDPROC ,		SF6.F6_DESCOMP, SF6.F6_TIPOIMP'

If lProcE112
	cSlctF0K+= ' ,F0K.F0K_PROCES,	F0K.F0K_PROCTP , F0K.F0K_PROIND , F0K.F0K_ITPROC '
Endif

cJoin	:="LEFT JOIN "+RetSqlName("SF6")+" SF6 ON (SF6.F6_FILIAL='"+aSPDFil[PFIL_SF6]+"' AND SF6.F6_EST = F0K.F0K_UF AND SF6.F6_NUMERO=F0K.F0K_GNRE AND SF6.F6_EST=F0K.F0K_UF AND SF6.D_E_L_E_T_=' ')"
cJoin	:= '%' + cJoin + '%' 

cFiltro := "%"
cFiltro += "F0K.F0K_FILIAL		= '"+ aSPDFil[PFIL_F0K]+ "' AND "
cFiltro += "F0K.F0K_PER			>= '" + %Exp:DToS (dDtIni)% + "' AND "
cFiltro += "F0K.F0K_PER			<= '" + %Exp:DToS (dDtFim)% + "' AND "
If !lExtratTaf
	cFiltro += "F0K.F0K_LIVRO 		= '"+ cLivro+ "' AND "
Endif
cFiltro += "F0K.F0K_UF 			= '"+ cUf+ "' AND "
cFiltro += "F0K.D_E_L_E_T_		= ' ' "
cFiltro += 'ORDER BY F0K.F0K_UF, F0K.F0K_GNRE '
cFiltro += "%"

cSlctF0K := "%" + cSlctF0K + "%"

cAliasF0K	:=	GetNextAlias()
BeginSql Alias cAliasF0K	

	SELECT
		%Exp:cSlctF0K%
	FROM
		%Table:F0K% F0K
		%Exp:cJoin%
	WHERE
		%Exp:cFiltro%	
			
EndSql

DbSelectArea (cAliasF0K)
(cAliasF0K)->(DbGoTop ())
Do While !(cAliasF0K)->(Eof ())

	lCdoIndiv	:= !Empty((cAliasF0K)->F0K_CODAPU) .AND. aSPDSX3[FP_CDO_AGRUPA] .AND. CDO->(dbSeek(aSPDFil[PFIL_CDO]+(cAliasF0K)->F0K_CODAPU)) .AND. CDO->CDO_AGRUPA == '2'
	
	nPosE311 := aScan(aRegE311,{|aX| aX[1]==nPaiE310 .AND. Iif(lCdoIndiv , .F. , aX[3]==(cAliasF0K)->F0K_CODAPU ) })
	If nPosE311 == 0	

		//Utiliza CDO para compor a descrição se estiver preenchida	
		cDescAj := DescCDO((cAliasF0K)->F0K_DESCR, nTamF0KDes, (cAliasF0K)->F0K_CODAPU)	

		aAdd(aRegE311, {})
		nPosE311	:=	Len (aRegE311)
		aAdd (aRegE311[nPosE311], nPaiE310)				 			//Relacionamento com registro Pai
		aAdd (aRegE311[nPosE311], "E311")				 			//01 - REG	
		aAdd (aRegE311[nPosE311], (cAliasF0K)->F0K_CODAPU)			//02 - COD_AJ_APUR	
		aAdd (aRegE311[nPosE311], cDescAj)							//03 - DESCR_COMPL_AJ	
		aAdd (aRegE311[nPosE311], (cAliasF0K)->F0K_VALOR)			//04 - VL_AJ_APUR
	Else
		aRegE311[nPosE311][5]	+=  (cAliasF0K)->F0K_VALOR			//04 - VL_AJ_APUR
	EndIF
	
	If !Empty(Alltrim((cAliasF0K)->F0K_GNRE))
		//Irá gerar registro E312
		
		nPosE312 := aScan(aRegE312,{|aX| aX[1]==nPosE311 .AND. aX[3]==(cAliasF0K)->F0K_GNRE})
		If nPosE312 == 0
			//Somente adiciona a GNRE se ainda não existir para este código de lançamento no registro E311
			aAdd(aRegE312, {})
			nPosE312	:=	Len (aRegE312)
			aAdd (aRegE312[nPosE312], nPosE311)				 		//Relacionamento com registro Pai E311
			aAdd (aRegE312[nPosE312], "E312")				 			//01 - REG	
			aAdd (aRegE312[nPosE312], (cAliasF0K)->F6_NUMERO)		//02 - NUM_DA	
			aAdd (aRegE312[nPosE312], (cAliasF0K)->F6_NUMPROC)		//03 - NUM_PROC	
			aAdd (aRegE312[nPosE312], (cAliasF0K)->F6_INDPROC)		//04 - IND_PROC
			aAdd (aRegE312[nPosE312], (cAliasF0K)->F0K_DESCR)		//05 - PROC
			aAdd (aRegE312[nPosE312], (cAliasF0K)->F6_DESCOMP)		//06 - TXT_COMPL
			
			If lExtratTaf
				aAdd(aRegE312[nPosE312], IIF(Empty((cAliasF0K)->F6_NUMERO),"",IIF((cAliasF0K)->F6_TIPOIMP=="0","0","1"))) //07 - COD_DA
			Endif
			
		EndIF
	
	EndIF
	
	
	//E312 Via processo referenciado
	If lProcE112 .And. !Empty(Alltrim((cAliasF0K)->F0K_PROCES)) .And. CCF->(dbSeek(aSPDFil[PFIL_CCF]+(cAliasF0K)->F0K_PROCES+(cAliasF0K)->F0K_PROCTP+(cAliasF0K)->F0K_PROIND+(cAliasF0K)->F0K_ITPROC))
		//Irá gerar registro E312
		
		nPosE312 := aScan(aRegE312,{|aX| aX[1]==nPosE311 .AND. aX[3]==(cAliasF0K)->F0K_PROCES})
		If nPosE312 == 0			
			aAdd(aRegE312, {})
			nPosE312	:=	Len (aRegE312)
			aAdd (aRegE312[nPosE312], nPosE311)				 		//Relacionamento com registro Pai E311
			aAdd (aRegE312[nPosE312], "E312")						//01 - REG	
			aAdd (aRegE312[nPosE312], "")							//02 - NUM_DA	
			aAdd (aRegE312[nPosE312], (cAliasF0K)->F0K_PROCES)		//03 - NUM_PROC	
			aAdd (aRegE312[nPosE312], (cAliasF0K)->F0K_PROCTP)		//04 - IND_PROC
			aAdd (aRegE312[nPosE312], (cAliasF0K)->F0K_DESCR)		//05 - PROC
			aAdd (aRegE312[nPosE312], CCF->CCF_DESCJU)				//06 - TXT_COMPL			
		EndIF
	
	EndIF
					
	//Posicionar na CDO e verificar se é eindividualizado
	If nPosE311 > 0 .AND. aSPDSX3[FP_CDO_AGRUPA] .AND. CDO->(dbSeek(aSPDFil[PFIL_CDO]+(cAliasF0K)->F0K_CODAPU)) .AND. CDO->CDO_AGRUPA == '2'
	
		nPosE313 	:=  aScan ( aInfE313, { |aX| aX[11] == SubStr( (cAliasF0K)->F0K_TPLANC,3) .AND. alltrim(ax[2]) == alltrim((cAliasF0K)->F0K_CODAPU ) }) 
		If nPosE313 > 0				
			RegE313(aRegE313, aInfE313, nPosE311, alltrim((cAliasF0K)->F0K_CODAPU ) , SubStr( (cAliasF0K)->F0K_TPLANC,3),.T.)
		EndIF
	EndIF
		
	(cAliasF0K)->(DbSkip ())
EndDo
DbSelectArea (cAliasF0K)
(cAliasF0K)->(DbCloseArea())

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} RegE316
Função para geração do registro E313
@param aRegE316 	- array com registros E316
@param cUf 		- UF processada
@param dDtIni 		- Data de início de processamento
@param dDtFim  	- Data final de processamento
@param cLivro  	- número do livro processado
@param nPaiE310   - relação com registro pai E310

@author Erick G Dias
@since 20/01/2016
@version 1.0
/*/
//-------------------------------------------------------------------
Static Function RegE316(aRegE316, cUf, dDtIni, dDtFim ,cLivro, nPaiE310, lExtratTAF)

Local cSlctF0J	:= ''
local cJoin		:= ''
Local cFiltro		:= ''
Local cCodRec		:= ''
Local cMesRef		:= ''
Local cMvSFUfGnr	:=	aSPDSX6[MV_SFUFGNR]
Default lExtratTAF:= .F.

cSlctF0J:= '%'
cSlctF0J+= 'F0J.F0J_GNRE, 	SF6.F6_CODREC,	SF6.F6_CLAVENC,		SF6.F6_COBREC,		SF6.F6_DTVENC, 	SF6.F6_NUMPROC,'
cSlctF0J+= 'SF6.F6_INDPROC, SF6.F6_DESCOMP , 		SF6.F6_OBSERV,  	   SF6.F6_MESREF, 	SF6.F6_ANOREF, SF6.F6_VALOR, SF6.F6_NUMERO, SF6.F6_TIPOIMP'
cSlctF0J+= '%'

cJoin	+="%INNER JOIN "+RetSqlName("SF6")+" SF6 ON (Sf6.F6_FILIAL='"+aSPDFil[PFIL_SF6]+"' AND SF6.F6_EST = F0J.F0J_UF AND SF6.F6_NUMERO=F0J.F0J_GNRE AND SF6.F6_EST=F0J.F0J_UF AND SF6.D_E_L_E_T_=' ') "
cJoin 	+= '%'

cFiltro := "%"
cFiltro += "F0J.F0J_FILIAL		= '"	+ aSPDFil[PFIL_F0J]		+ "' AND "
cFiltro += "F0J.F0J_PER			>= '" 	+ %Exp:DToS (dDtIni)% 		+ "' AND "
cFiltro += "F0J.F0J_PER			<= '" 	+ %Exp:DToS (dDtFim)% 		+ "' AND "
If !lExtratTAF
	cFiltro += "F0J.F0J_LIVRO 		= '"	+ cLivro						+ "' AND "
Endif
cFiltro += "F0J.F0J_UF 			= '"	+ cUf							+ "' AND "
cFiltro += "F0J.F0J_TIPO 		IN	   ('1','2','3')							 AND " //Traz somente guias geradas a pagar do FECP e do DIFAL
cFiltro += "F0J.D_E_L_E_T_		= '' "
cFiltro += 'ORDER BY F0J.F0J_UF, F0J.F0J_GNRE '
cFiltro += "%"

cAliasF0J	:=	GetNextAlias()
BeginSql Alias cAliasF0J
	COLUMN F6_DTVENC AS DATE
	SELECT
		%Exp:cSlctF0J%
	FROM
		%Table:F0J% F0J
		%Exp:cJoin%
	WHERE
		%Exp:cFiltro%		
EndSql

DbSelectArea (cAliasF0J)
(cAliasF0J)->(DbGoTop ())
Do While !(cAliasF0J)->(Eof ())	
	cCodRec	:= Alltrim((cAliasF0J)->F6_CODREC) + Iif(cUf $ cMvSFUfGnr,Alltrim((cAliasF0J)->F6_CLAVENC) , '')
	cMesRef	:= Alltrim( STRzero( (cAliasF0J)->F6_MESREF,2 ) ) + Alltrim(STR((cAliasF0J)->F6_ANOREF))
		
	AddE316(@aRegE316,nPaiE310,cCodRec,cMesRef, ;
			 (cAliasF0J)->F6_COBREC, (cAliasF0J)->F6_DTVENC , (cAliasF0J)->F6_NUMPROC ,;
			 (cAliasF0J)->F6_INDPROC, (cAliasF0J)->F6_DESCOMP, (cAliasF0J)->F6_OBSERV  ,;
			 (cAliasF0J)->F6_VALOR, (cAliasF0J)->F6_NUMERO,lExtratTAF,(cAliasF0J)->F6_TIPOIMP) 	

		
	(cAliasF0J)->(DbSkip ())
	
EndDo
DbSelectArea (cAliasF0J)
(cAliasF0J)->(DbCloseArea())

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} AddE316
Função que adiciona novo registro E316.

@author Erick G Dias
@since 04/02/2016
@version 11.80
/*/
//-------------------------------------------------------------------

Static Function AddE316(aRegE316,nPaiE310,cCodRec,cMesRef, cCOBREC, cDTVENC , cNUMPROC ,cINDPROC, cDESCOMP, cOBSERV ,nVALOR,cNunGnre,lExtratTaf, cTPimp )

Local nPosE316	:= 0  
nPosE316 := aScan(aRegE316,{|aX| aX[1] ==nPaiE310 	.AND. ;
								  aX[3] ==cCOBREC 	.AND. ;
								  aX[5] ==cDTVENC 	.AND. ;
								  aX[6] ==cCodRec    .AND. ;
								  aX[7] ==cNUMPROC 	.AND. ;
								  aX[8] ==cINDPROC 	.AND. ;
								  aX[9] ==cDESCOMP 	.AND. ;
								  aX[10]==cOBSERV 	.AND. ;										  										  										  										  										  
								  aX[10]==cMesRef  })
If nPosE316 == 0	
	aAdd(aRegE316, {})
	nPosE316	:=	Len (aRegE316)
	aAdd (aRegE316[nPosE316], nPaiE310)				//Relacionamento com registro Pai
	aAdd (aRegE316[nPosE316], "E316")				//01 - REG
	aAdd (aRegE316[nPosE316], cCOBREC)				//02 - COD_OR
	aAdd (aRegE316[nPosE316], nVALOR)				//03 - VL_OR
	aAdd (aRegE316[nPosE316], cDTVENC)				//04 - DT_VCTO
	aAdd (aRegE316[nPosE316], cCodRec)				//05 - COD_REC
	aAdd (aRegE316[nPosE316], cNUMPROC)				//06 - NUM_PROC
	aAdd (aRegE316[nPosE316], cINDPROC)				//07 - IND_PROC
	aAdd (aRegE316[nPosE316], cDESCOMP)				//08 - PROC
	aAdd (aRegE316[nPosE316], cOBSERV)				//09 - TXT_COMPL
	aAdd (aRegE316[nPosE316], cMesRef )				//10 - MES_REF
	If lExtratTaf
		aAdd (aRegE316[nPosE316], IIF(cTPimp=="0","0","1")) //12 - COD_DA
		aAdd (aRegE316[nPosE316], cNunGnre)					//13 - NUM_DA
		aAdd (aRegE316[nPosE316], cNUMPROC)					//14 - NUM_PROC
		aAdd (aRegE316[nPosE316], cINDPROC)					//15 - IND_PROC
	Endif
Else
	If !lExtratTaf
		aRegE316[nPosE316][4]	+= nVALOR				//03 - VL_OR	
	Endif
EndIF

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} RegE313
Função para geração do registro E313
@param aRegE313 - array com registros E313
@param aInfE313 - Array com informações do documento fiscal que possui ajuste de apuração
@param nPaiE311 - Relação com registro pai E311
@param cCodAju  - código de ajuste da apuração

@author Erick G Dias
@since 20/01/2016
@version 1.0
/*/
//-------------------------------------------------------------------

Static Function RegE313(aRegE313, aInfE313, nPaiE311, cCodAju,cChaveNf, lIndivid)

Local nPosE313	:= 0
local nPosNfE313	:= 0
Local nX			:= 0
Local cSerie		:= ""
Default cChaveNf	:= ''
Default lIndivid	:= .F.

nPosNfE313 := aScan(aInfE313,{|aX| aX[2]==cCodAju .AND. Iif( lIndivid , aX[11] ==cChaveNf  , .T. ) })

If nPosNfE313 > 0
	For nX	:= nPosNfE313 to Len(aInfE313)
		If aInfE313[nX][2] == cCodAju .AND. Iif( lIndivid , aInfE313[nX][11] == cChaveNf , .T.) .AND. !aInfE313[nX][12] 

			cSerie	:=	SpedSerie(aInfE313[nX][5 ],aInfE313[nX][4 ])

			nPosE313 := aScan(aRegE313,{|aX| aX[1 ]==nPaiE311        .AND. ;
												 aX[3 ]==aInfE313[nX][3 ] .AND.;
												 aX[4 ]==aInfE313[nX][4 ] .AND.;
												 aX[5 ]==cSerie			  .AND.;
												 aX[7 ]==aInfE313[nX][6 ] .AND.;
												 aX[8 ]==aInfE313[nX][7 ] .AND.;
												 aX[9 ]==aInfE313[nX][8 ] })
												 //aX[10]==aInfE313[nX][9] })
			
			If nPosE313 == 0
			
				aAdd(aRegE313, {})
				nPosE313	:=	Len (aRegE313)
				aAdd (aRegE313[nPosE313], nPaiE311)					//Relacionamento com registro Pai
				aAdd (aRegE313[nPosE313], "E313")					//01 - REG	
				aAdd (aRegE313[nPosE313], aInfE313[nX][3 ])			//02 - COD_PART	
				aAdd (aRegE313[nPosE313], aInfE313[nX][4 ])			//03 - COD_MOD
				aAdd (aRegE313[nPosE313], cSerie)					//04 - SER
				aAdd (aRegE313[nPosE313], "")						//05 - SUB
				aAdd (aRegE313[nPosE313], aInfE313[nX][6 ])			//06 - NUM_DOC
				aAdd (aRegE313[nPosE313], aInfE313[nX][7 ])			//07 - CHV_DOCE
				aAdd (aRegE313[nPosE313], aInfE313[nX][8 ])			//08 - DT_DOC
				aAdd (aRegE313[nPosE313], ''/*aInfE313[nX][9]*/)	//09 - COD_ITEM
				aAdd (aRegE313[nPosE313], aInfE313[nX][10])			//10 - VL_AJ_ITEM							
			Else
				aRegE313[nPosE313][11] += aInfE313[nX][10]			//10 - VL_AJ_ITEM				
			EndIf
			
			//Indica que já processou a informação do E313 individualizado por nota fiscal e código de lançamento
			aInfE313[nX][12] := .T.				
		Else
			Exit
		EndIF
	
	Next nX
EndIF

Return

/*/{Protheus.doc} SpedSerie
Função que irá alterar serie do documento
Tratamento para Loja Cem que importa notas com mesma chave (numero, serie, cliente, fornecedor)
TSF altera serie na imporação acresentando letra na Serie do documento
Com serie alterada ocorre erro de chave nos arquivos SPED Fiscal e Contribuições na chave do cte e nfe

@author Rafael S Oliveira
@since 15/04/2016
/*/
Static Function SpedSerie( cSerie, cModelo)

Local cNovSerie

Default cModelo:= ''

IF aExistBloc[32]
	cNovSerie := ExecBlock("SPDFIS11", .F., .F., {cSerie,cModelo})
	If valtype(cNovSerie)== "C"
		cSerie := cNovSerie
	Endif
Endif

//Tira qualquer espaço para o tratamento abaixo
cSerie:= alltrim(cSerie)

If cModelo$"55#57#65#67" .and. (Empty(cSerie) .or. len(cSerie) < 3)// criado conforme validação dos registros C100/G130/D100/E113/1105
	//Tratamento para adequar o campo com 3 posições conforme Guia EFD
	if empty( cSerie )
		cSerie :="000"
	else
		cSerie := StrZero(Val(cSerie),3)
	endif
Endif

Return cSerie

//-------------------------------------------------------------------
/*/{Protheus.doc} SpdGnreDoc
Função responsável por alimentar o array aIcmPago com as informacoes das
GNREs geradas e vinculadas aos documentos fiscais. Estas informacoes
serao utilizadas na geracao dos registros E250 e E316.

@author Joao Victor Pellegrini
@since 05/05/2016
/*/
//-------------------------------------------------------------------
Static Function SpdGnreDoc(aIcmPago, cAliasSF6, cAliasCDC, cCDCChv)

Local nPIcmPago := 0

DEFAULT cCDCChv := ""

// Caso nao seja passado o parametro da chave da tabela CDC, nao irei percorrer
// os registros e adicionarei as informacoes com base nos registros ja posicionados.

If !Empty(cCDCChv)
	While !(cAliasCDC)->(Eof()) .AND. ((cAliasCDC)->(CDC_FILIAL+CDC_TPMOV+CDC_DOC+CDC_SERIE+CDC_CLIFOR+CDC_LOJA)==cCDCChv)
		If SpedSeek( cAliasSF6,1,aSPDFil[PFIL_SF6]+(cAliasCDC)->(CDC_UF+CDC_GUIA))
			
			nPIcmPago := Ascan(aIcmPago,{|x| x[1]+x[3] == (cAliasCDC)->(CDC_UF+CDC_GUIA) })
			
			If Empty(nPIcmPago)
				aAdd(aIcmPago,{(cAliasCDC)->CDC_UF,;
					(cAliasSF6)->F6_VALOR,;
					(cAliasCDC)->CDC_GUIA,;
					(cAliasSF6)->F6_DTVENC,;
					(cAliasSF6)->F6_CODREC,;
					(cAliasSF6)->F6_OBSERV,;
					(cAliasSF6)->F6_MESREF,;
					(cAliasSF6)->F6_ANOREF,;
					(cAliasSF6)->F6_NUMPROC,;
					(cAliasSF6)->F6_INDPROC,;
					(cAliasSF6)->F6_DESCOMP,;
					(cAliasSF6)->F6_TIPOIMP})
			EndIf
		EndIf
		(cAliasCDC)->(DbSkip())
	Enddo	
Else
	If SpedSeek( cAliasSF6,1,aSPDFil[PFIL_SF6]+(cAliasCDC)->(CDC_UF+CDC_GUIA)) 
		
		nPIcmPago := Ascan(aIcmPago,{|x| x[1]+x[3] == (cAliasCDC)->(CDC_UF+CDC_GUIA) })
		
		If Empty(nPIcmPago)
			aAdd(aIcmPago,{(cAliasCDC)->CDC_UF,;
				(cAliasSF6)->F6_VALOR,;
				(cAliasCDC)->CDC_GUIA,;
				(cAliasSF6)->F6_DTVENC,;
				(cAliasSF6)->F6_CODREC,;
				(cAliasSF6)->F6_OBSERV,;
				(cAliasSF6)->F6_MESREF,;
				(cAliasSF6)->F6_ANOREF,;
				(cAliasSF6)->F6_NUMPROC,;
				(cAliasSF6)->F6_INDPROC,;
				(cAliasSF6)->F6_DESCOMP,;
				(cAliasSF6)->F6_TIPOIMP})
		EndIf
	EndIf
EndIf

Return nil

//-------------------------------------------------------------------
/*
Rotina que retorna o codigo da conta do P.E SPDFIS27 caso exista.
*/
Function RetCOD_CTA(cAlias, cReg, aCmpAntSFT)
Local	cCod_Cta 	:= ""

Default cAlias 		:= ""
Default	cReg		:= ""
Default	aCmpAntSFT 	:= {}

If Len(aExistBloc) >= 27 .And. aExistBloc[27] 

	If !Empty(cAlias) .And. cReg $ "C170|C300|D300"
   
		cCod_Cta := ExecBlock("SPDFIS27", .F., .F., {cReg,;
									(cAlias)->FT_FILIAL,;
									(cAlias)->FT_TIPOMOV,;
									(cAlias)->FT_SERIE,;
									(cAlias)->FT_NFISCAL,;
									(cAlias)->FT_CLIEFOR,;
									(cAlias)->FT_LOJA,;
									(cAlias)->FT_ITEM,;
									(cAlias)->FT_PRODUTO})

	ElseIf !Empty(cAlias) .And. cReg == "0300"

		cCod_Cta := ExecBlock("SPDFIS27", .F., .F., {cReg,;
								(cAlias)->FA_FILIAL,;
								(cAlias)->FA_CODIGO,;
								(cAlias)->FA_DATA,;
								(cAlias)->FA_TIPO}) 
							
	ElseIf !Empty(aCmpAntSFT) .And. cReg $ "D500|D100|C350|C500"
	
		cCod_Cta := ExecBlock("SPDFIS27", .F., .F., {cReg,;
								aCmpAntSFT[22],; // FT_FILIAL
								aCmpAntSFT[43],; //FT_TIPOMOV
								aCmpAntSFT[2],;  //FT_SERIE
								aCmpAntSFT[1],;  //FT_NFISCAL
								aCmpAntSFT[3],;  //FT_CLIEFOR
								aCmpAntSFT[4],;  //FT_LOJA
								aCmpAntSFT[46],; //FT_ITEM
								aCmpAntSFT[45]})  //FT_PRODUTO
	Endif
EndIf


Return cCod_Cta


/*/{Protheus.doc} FisAddHash
@author Graziele Mendonça Paro
@since 02.12.2016
/*/
//-------------------------------------------------------------------

Function FisAddHash(oHash,cChave,nPos)
Local cSet  := "HMSet"

&cSet.(oHash, cChave, nPos)

Return

//-------------------------------------------------------------------
/*/
{Protheus.doc} FisFindHash

@author Graziele Mendonça Paro
@since 02.12.2016

/*/
//-------------------------------------------------------------------
Function FisFindHash(oHash, cChave, lFind)
Local nPosRet	:= 0
Local cGet   	:= "HMGet"
Default lFind	:= .F.

lFind	:= &cGet.( oHash , cChave  , @nPosRet )

Return nPosRet

/*/{Protheus.doc} FisAddHM
Adiciona valores a um Hash, a função FisAddHash acima não atende pois só seta valores ao Hash
@author ricardo.paulino
@since 28.08.2019
/*/
//-------------------------------------------------------------------

Function FisAddHM(oHash, aVal)
Local cAdd  := "HMAdd"

&cAdd.(oHash,aVal)

Return

//-------------------------------------------------------------------
/*/
{Protheus.doc} FisRetHash
@description Retorna Array do objeto oHash
@author Thiago Yoshiaki Miyabara Nascimento - Shiny
@since 13.06.2021
/*/
//-------------------------------------------------------------------
Function FisRetHash(oHash, cChave, aRet)
Local cGet   	:= "HMGet"

Default aRet	:= {}

&cGet.( oHash , cChave  , @aRet )

Return aRet

//-------------------------------------------------------------------
/*/
{Protheus.doc} FisAtoHash
@description Converte uma matriz de dados (Array) em um tHashMap, podendo combinar as colunas para a chave de busca do objeto oHash
@author Thiago Yoshiaki Miyabara Nascimento - Shiny
@since 13.06.2021
/*/
//-------------------------------------------------------------------
Function FisAtoHash(oHash, aMatriz)
Local cGet   	:= "ATOHM"

oHash := &cGet.( aMatriz, 1, 0 , 5, 0) //Duas colunas na busca, Primeira e Quinta colunas de chave 

Return oHash

//-------------------------------------------------------------------
/*/{Protheus.doc} SpedBanner

( SOMENTE BRASIL ) Funcao responsavel para efetuar a chamada de um banner para a rotina

@param Nil

@return Nil

@author Gustavo G. Rueda
@since 09/09/2016
/*/
//-------------------------------------------------------------------
Static Function SpedBanner()

If cPaisLoc == 'BRA' .And. FindFunction( 'FISBannerTAF' )
	FISBannerTAF()
Endif
	
Return
//-------------------------------------------------------------------
/*/{Protheus.doc} RetStSpd
Função responsável por retornar o valor do ICMS ST validando o parâmetro MV_RESF3FT
@author Henrique Pereira
@since 27/07/2016
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Apesar dos valores de SF3 e SFT serem os mesmos, a gravacao das tabelas nao sao,|
//|e se for considerado os campos correspondentes, os valores apresentados serao   |
//|diferentes, e para resolver isso preciso temos que saber qual tabela esta sendo |
//|considerada na apuracao de ICMS, para isso faco o tratamento abaixo.            |
//|Se o parametro MV_RESF3FT estiver configurado para considerar a tabela SFT,     |
//| tenho que somar os campos de retido+isento+outros, pois nao eh gravado conforme|
//| conforme a SF3, que grava sempre o ICMS retido independente da escrituracao.   |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
/*/
//-------------------------------------------------------------------
Static Function RetStSpd(lResF3FT, cAliasSFT)
Local nRet := 0
Default lResF3FT := .F.
Default cAliasSFT := ''

	If lResF3FT .And. !Empty(cAliasSFT)
		//Na tabela SFT o valor de ICMS Retido pode alternar nas colunas dependendo da escrituracao
		nRet := (cAliasSFT)->(FT_ICMSRET+FT_OUTRRET+FT_ISENRET)

	Else
		//Na tabela SF3 o valor do ICMS Retido sempre eh gravado em ICMSRET, independente da escrituracao
		nRet := (cAliasSFT)->(FT_ICMSRET)

	EndIf

Return nRet


//-------------------------------------------------------------------
/*/{Protheus.doc} RegE531
Função para geração do registro E531

@Rafael.soliveira
@since 08/11/2017
@version 1.0
/*/
//-------------------------------------------------------------------
Static Function RegE531(aRegE531, aInfE531, nPaiE530, cCodAju,cAlias,aWizard,aReg0190,aReg0200,aReg0220,dDataDe,dDataAte,cTipLan)

Local nPosE531	 := 0
local nPosNfE531 := 0
Local nX		 := 0
Local cSerie	 := ""
Local cTamProd	 :=	TamSx3("B1_COD")[1]


aSort(aInfE531,,,{|x, y| x[1]<y[1]})

nPosNfE531 := aScan(aInfE531,{|aX| aX[1]==cCodAju})

If nPosNfE531 > 0
	For nX	:= nPosNfE531 to Len(aInfE531)
	
		If aInfE531[nX][1] == cCodAju .And.;
			( (cTipLan == '3' .And. aInfE531[nX][12] == 'CONFIG' .And. Len(aInfE531[nX]) > 12 .And. !Empty(aInfE531[nX][13])) .Or.;
		   		(cTipLan == '1' .And. !aInfE531[nX][12] == 'CONFIG' ))  
		   
			cSerie	:=	SpedSerie(aInfE531[nX][4 ],aInfE531[nX][3 ])
			
			nPosE531 := aScan(aRegE531,{|aX| aX[1 ]==nPaiE530        .AND. ;
												 aX[3 ]==aInfE531[nX][2 ] .AND.;
												 aX[4 ]==aInfE531[nX][3 ] .AND.;
												 aX[5 ]==cSerie			  .AND.;
												 aX[7 ]==aInfE531[nX][5 ] .AND.;
												 aX[8 ]==aInfE531[nX][6 ] .AND.;
												 aX[9 ]==aInfE531[nX][7 ] })
			If nPosE531 == 0
				aAdd(aRegE531, {})
				nPosE531	:=	Len (aRegE531)
				aAdd (aRegE531[nPosE531], nPaiE530)			//Relacionamento com registro Pai
				aAdd (aRegE531[nPosE531], "E531")			//01 - REG	
				aAdd (aRegE531[nPosE531], aInfE531[nX][2])	//02 - COD_PART	
				aAdd (aRegE531[nPosE531], aInfE531[nX][3])	//03 - COD_MOD
				aAdd (aRegE531[nPosE531], cSerie)			//04 - SER
				aAdd (aRegE531[nPosE531], "")				//05 - SUB
				aAdd (aRegE531[nPosE531], aInfE531[nX][5])	//06 - NUM_DOC
				aAdd (aRegE531[nPosE531], aInfE531[nX][6])	//07 - DT_DOC
				aAdd (aRegE531[nPosE531], aInfE531[nX][7])	//08 - COD_ITEM
				aAdd (aRegE531[nPosE531], aInfE531[nX][8])	//09 - VL_AJ_ITEM
				aAdd (aRegE531[nPosE531], aInfE531[nX][9])	//10 - CHV_NFE
				
				//Grava registro 0200
				IF aScan ( aReg0200, { |aX| aX[2] == aInfE531[nX][7] }) == 0									     
					SPEDSeek("SB1",,aSPDFil[PFIL_SB1]+AllTRIM(Substr(aInfE531[nX][7],1,cTamProd)))
					SFRG0200( cAlias, @aReg0200, @aReg0190, dDataDe, dDataAte, , , @aReg0220,,,,,,,,,,,,,,,,,,,aWizard )
				EndIf
			Else
				aRegE531[nPosE531][10] += aInfE531[nX][8]	//09 - VL_AJ_ITEM
			EndIf			
		EndIF	
	Next nX
EndIF

Return
//-------------------------------------------------------------------
/*/{Protheus.doc} DescCDO
Se o começo da descrição for igual entre CDH/F0K e CDO significa que usuário não alterou a 
descrição e que poderá complementar com a descrição completa do cadastro do código de lançamento.
Caso seja diferente significa que o usuário alterou a descrição na apuração e neste caso 
manteremos a descrição informada por ele.
@Erick G Dias
@since 01/10/2018
@version 12.1.17
/*/
//-------------------------------------------------------------------
Static Function DescCDO(cDESC, nTamDes, cCodLanc)
Local cRet		 	:= cDESC
Local cDescrCDO  	:= ""

IF !Empty(cCodLanc) .AND. SPEDSeek("CDO",1,aSPDFil[PFIL_CDO]+cCodLanc)
	cDescrCDO  := MSMM(CDO->CDO_DESCR2)	
	nTamDes	:= Min(nTamDes, Len(cDescrCDO))
    cCodDeclar := Iif(aSPDSX3[FP_CDO_DECLAR],CDO->CDO_DECLAR,"")
	If !Empty(cCodDeclar)
		//Quando campo de Codigo declaratorio estiver peenchido, consider este como descrição do ajuste na apuraçao de ICMS
		cRet := cCodDeclar
	ElseIf !Empty(cDescrCDO) .AND. Padr(cDESC, nTamDes) == Padr(cDescrCDO, nTamDes)		
		If Len(cDescrCDO) > 255		
			cRet	:= SUBSTR( cDescrCDO,1,255) //Validador aceita até 255 caracteres // 4/2/2019 - versão 2.5.1
		Else
			cRet	:= cDescrCDO
		Endif
	EndIF
EndIF
Return cRet


//-------------------------------------------------------------------
/*/{Protheus.doc} GrupoGIAF

Processamento dos registros da GIAF Prodepe
Registros:
1960 - GIAF 1 - Guia de informação e apuração de incentivos fiscais e financeiros: indústria (crédito presumido)
1970 - GIAF 3 - Guia de informação e apuração de incentivos fiscais e financeiros: importação (diferimento na entrada e crédito presumido na saída subsequente)
1975 - GIAF 3 - Guia de informação e apuração de incentivos fiscais e financeiros: importação(saídas internas por faixa de alíquota)
1980 - GIAF 4 - Guia de informação e apuração de incentivos fiscais e financeiros: central de distribuição (entradas/saídas)


//1- Livro Protheus // 2 - Indicador da sub-apuração por tipo de benefício  // 3 - Tipo:  industria ou CD ou importação
@Rafael Oliveira
@since 29/10/2018
@version 12.1.17
/*/
//-------------------------------------------------------------------

Static Function GrupoGIAF(aWizard,cAlias,aLivGIAF,aBloco8,lExtratTAF,aRegsT020)

Local	aApICM		:=	{}

Local	dDataDe	    :=	''
Local	dDataAte	:=	''

Local	nPos		:=  0
Local	nPeriodo	:=	1
Local	nApuracao	:=	3

Default lExtratTAF  := .F.
Default aRegsT020   :=  {}

aSort(aLivGIAF,,,{|x, y| x[2]<y[2]})

If !lExtratTAF
	dDataDe  	:=	SToD(aWizard[1][1])
	dDataAte	:=	STod(aWizard[1][2])	
Else	
	dDataDe		:=	aWizard[1][3]
	dDataAte	:=	aWizard[1][4]	
EndIf

//Processa livros
For nPos := 1 to Len(aLivGIAF)
	
	aApICM	:= {}	
	lLivro	:=  (nLivro := aScan(aBloco8, {|aX|aX[1]==aLivGIAF[nPos][1]})) > 0

	If aLivGIAF[nPos][3] == '1' .And. "1"$aWizard[4][11]
		//1960 - GIAF 1 - Guia de informação e apuração de incentivos fiscais e financeiros: indústria (crédito presumido)
		aApICM	:=	FisApur("IC",Year(dDataAte),Month(dDataAte),nApuracao,nPeriodo,aLivGIAF[nPos][1],.F.,{},1,.F.,"")		

		If Len(aApICM)>0 .And. lLivro
			Reg1960(cAlias,aApICM,aLivGIAF[nPos],aBloco8[nLivro],lExtratTAF)
		Endif
	Endif

	If aLivGIAF[nPos][3] == '3' .And. "1"$aWizard[4][12]
		//1970 - GIAF 3 - Guia de informação e apuração de incentivos fiscais e financeiros: importação (diferimento na entrada e crédito presumido na saída subsequente)
		//1975 - GIAF 3 - Guia de informação e apuração de incentivos fiscais e financeiros: importação(saídas internas por faixa de alíquota)
		aApICM		:=	FisApur("IC",Year(dDataAte),Month(dDataAte),nApuracao,nPeriodo,aLivGIAF[nPos][1],.F.,{},1,.F.,"")
		If Len(aApICM)>0 .And. lLivro
			Reg1970(cAlias,aApICM,aLivGIAF[nPos],aBloco8[nLivro],dDataDe,dDataAte,lExtratTAF)
		Endif
	endif

	If aLivGIAF[nPos][3] == '4'  .And. "1"$aWizard[4][13]
		//1980 - GIAF 4 - Guia de informação e apuração de incentivos fiscais e financeiros: central de distribuição (entradas/saídas)
		aApICM		:=	FisApur("IC",Year(dDataAte),Month(dDataAte),nApuracao,nPeriodo,aLivGIAF[nPos][1],.F.,{},1,.F.,"")
		If Len(aApICM)>0 .And. lLivro
			Reg1980(cAlias,aApICM,aLivGIAF[nPos],aBloco8[nLivro],lExtratTAF)
		Endif
	Endif			

Next nPos

Return
//-------------------------------------------------------------------
/*/{Protheus.doc} Reg1960

Processamento dos registros da GIAF Prodepe
Registros:
1960 - GIAF 1 - Guia de informação e apuração de incentivos fiscais e financeiros: indústria (crédito presumido)

@Rafael Oliveira
@since 29/10/2018
@version 12.1.17
/*/
//-------------------------------------------------------------------
Static Function Reg1960(cAlias,aApICM,aLivGIAF,aBloco8,lExtratTAF)

Local cINDAP	:=	aLivGIAF[2]

Local aReg1960	:=	{}
Local nPos		:=	0 	

Local nG1_01	:=	0
Local nG1_02	:=	0
Local nG1_03	:=	0
Local nG1_04	:=	0
Local nG1_05	:=	0
Local nG1_06	:=	0
Local nG1_07	:=	0
Local nG1_08	:=	0
Local nG1_09	:=	0
Local nG1_10	:=	0
Local nG1_11	:=	0

//Função que filtra notas equivalente ao aBloco8
nG1_01 := aBloco8[6]
nG1_02 := aBloco8[15]
nG1_03 := aBloco8[3]
nG1_04 := aBloco8[12]
nG1_06 := aBloco8[17]+aBloco8[18]+aBloco8[7]
nG1_07 := aBloco8[10]

//Apuração do livro
nG1_05	:=	Iif (aScan (aApICM, {|a| a[1]=="011"})<>0, aApICM[aScan (aApICM, {|a| a[1]=="011"})][3], 0) 
nG1_08	:=	nG1_06 - nG1_07 

nG1_09	+=	Iif (aScan (aApICM, {|a| a[4]=="012.02"})<>0, aApICM[aScan (aApICM, {|a| a[4]=="012.02"})][3], 0)
nG1_09	+=	Iif (aScan (aApICM, {|a| a[4]=="012.03"})<>0, aApICM[aScan (aApICM, {|a| a[4]=="012.03"})][3], 0)	
nG1_09	+=	Iif (aScan (aApICM, {|a| a[4]=="012.01"})<>0, aApICM[aScan (aApICM, {|a| a[4]=="012.01"})][3], 0)

//nG1_09	:= nG1_08 * (nG1_01/100)

nG1_09  := nG1_09 - nG1_07
nG1_10	:= nG1_07 + nG1_09

// Verifico este valor pois se não tiver valor suficiente de saldo devedor contém 0 Zero	
If nG1_05 > nG1_10 					
	nG1_11	:=	nG1_05 - nG1_10
Endif

//Registro

aAdd(aReg1960, {})
nPos	:=	Len (aReg1960)		
aAdd (aReg1960[nPos], "1960")	//01 - REG	
aAdd (aReg1960[nPos], cINDAP)	//02 - IND_AP - Indicador da sub-apuração por tipo de benefício
aAdd (aReg1960[nPos], nG1_01)	//03 - G1_01 - Percentual de crédito presumido 
aAdd (aReg1960[nPos], nG1_02)	//04 - G1_02 - Saídas não incentivadas de PI 
aAdd (aReg1960[nPos], nG1_03)   //05 - G1_03 - Saídas incentivadas de PI 
aAdd (aReg1960[nPos], nG1_04)	//06 - G1_04 - Saídas incentivadas de PI para fora do Nordeste
aAdd (aReg1960[nPos], nG1_05)	//07 - G1_05 - Saldo devedor do ICMS antes das deduções do incentivo
aAdd (aReg1960[nPos], nG1_06)	//08 - G1_06 - Saldo devedor do ICMS relativo à faixa incentivada de PI 
aAdd (aReg1960[nPos], nG1_07)	//09 - G1_07 - Crédito presumido nas saídas incentivadas de PI para fora do Nordeste
aAdd (aReg1960[nPos], nG1_08)	//10 - G1_08 - Saldo devedor relativo à faixa incentivada de PI após o crédito presumido nas saídas para fora do Nordeste
aAdd (aReg1960[nPos], nG1_09)	//11 - G1_19 - Crédito presumido
aAdd (aReg1960[nPos], nG1_10)	//12 - G1_10 - Dedução de incentivo da Indústria (crédito presumido)
aAdd (aReg1960[nPos], nG1_11)	//13 - G1_11 - Saldo devedor do ICMS após deduções

//Gravação
If !lExtratTAF
	GrvRegTrS (cAlias,,aReg1960)
Endif

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} Reg1970

Processamento dos registros da GIAF Prodepe
Registros:
1970 - GIAF 3 - Guia de informação e apuração de incentivos fiscais e financeiros: importação (diferimento na entrada e crédito presumido na saída subsequente)
1975 - GIAF 3 - Guia de informação e apuração de incentivos fiscais e financeiros: importação(saídas internas por faixa de alíquota)

@Rafael Oliveira
@since 29/10/2018
@version 12.1.17
/*/
//-------------------------------------------------------------------
Static Function Reg1970(cAlias,aApICM,aLivGIAF,aBloco8,dDataDe,dDataAte,lExtratTAF)

Local cINDAP	:=	aLivGIAF[2]
//Local cLivro	:=  aLivGIAF[1]

Local aReg1970	:=	{}
Local aReg1975	:=	{}

Local nX		:=  0
Local nPos1970	:=	0
Local nPos1975	:=	0
Local nG3_01	:=	0
Local nG3_02	:=	0
Local nG3_03	:=	0
Local nG3_04	:=	0
Local nG3_05	:=	0
Local nG3_06	:=	0
Local nG3_07	:=	0
Local nG3_08	:=	0
Local nG3_09	:=	0
Local nG3_T		:=	0
Local nG3_12	:=	0

//Utiliza dados das notas
nG3_01 := aBloco8[8]
nG3_03 := aBloco8[15]
nG3_04 := aBloco8[6]
nG3_05 := aBloco8[12]+aBloco8[2]
nG3_06 := aBloco8[18]+aBloco8[17]

//Apuração
nG3_02	:= Iif (aScan (aApICM, {|a| a[1]=="018"})<>0, aApICM[aScan (aApICM, {|a| a[1]=="018"})][3], 0)
nG3_08	:= Iif (aScan (aApICM, {|a| a[1]=="011"})<>0, aApICM[aScan (aApICM, {|a| a[1]=="011"})][3], 0)	
nG3_07	:= Iif (aScan (aApICM, {|a| a[4]=="012.06"})<>0, aApICM[aScan (aApICM, {|a| a[4]=="012.06"})][3], 0) //Saídas interestaduais
nG3_12	:= Iif (aScan (aApICM, {|a| a[4]=="012.08"})<>0, aApICM[aScan (aApICM, {|a| a[4]=="012.08"})][3], 0) //saidas internas

nG3_T := nG3_07+nG3_12

//Saldo devedor do ICMS após deduções do incentivo
IF (nG3_08 - nG3_T) > 0
	nG3_09 := nG3_08 - nG3_T
Endif

aAdd(aReg1970, {})
nPos1970	:=	Len (aReg1970)	
aAdd (aReg1970[nPos1970], "1970")	//01 - REG
aAdd (aReg1970[nPos1970], cINDAP)	//02 - IND_AP
aAdd (aReg1970[nPos1970], nG3_01)	//03 - G3_01 - Importações com ICMS diferido
aAdd (aReg1970[nPos1970], nG3_02)	//04 - G3_02 - ICMS diferido nas importações
aAdd (aReg1970[nPos1970], nG3_03)	//05 - G3_03 - Saídas não incentivadas de PI
aAdd (aReg1970[nPos1970], nG3_04)	//06 - G3_04 - Percentual de incentivo nas saídas para fora do Estado
aAdd (aReg1970[nPos1970], nG3_05)	//07 - G3_05 - Saídas incentivadas de PI para fora do Estado
aAdd (aReg1970[nPos1970], nG3_06)	//08 - G3_06 - ICMS das saídas incentivadas de PI para fora do Estado
aAdd (aReg1970[nPos1970], nG3_07)	//09 - G3_07 - Crédito presumido nas saídas para fora do Estado.
aAdd (aReg1970[nPos1970], nG3_T)	//10 - G3_T -  Dedução de incentivo da Importação (crédito presumido)
aAdd (aReg1970[nPos1970], nG3_08)	//11 - G3_08 - Saldo devedor do ICMS antes das deduções do incentivo
aAdd (aReg1970[nPos1970], nG3_09)	//12 - G3_09 - Saldo devedor do ICMS após deduções do incentivo

//Registro 1975	
For nX:= 1 to 4
	aAdd(aReg1975, {})
	nPos1975	:=	Len (aReg1975)
	aAdd (aReg1975[nPos1975], nPos1970) 	 //Reg Pai
	aAdd (aReg1975[nPos1975], "1975")		 //01 - REG
	aAdd (aReg1975[nPos1975], aBloco8[19][nX][1]) //02 - ALIQ_IMP_BASE
	aAdd (aReg1975[nPos1975], aBloco8[19][nX][2]) //03 - G3_10 - Saídas incentivadas de PI 
	aAdd (aReg1975[nPos1975], aBloco8[19][nX][3]) //04 - G3_11 - Importações-base para o crédito presumido 
	aAdd (aReg1975[nPos1975], aBloco8[19][nX][4]) //05 - G3_12 - Crédito presumido nas saídas internas	
Next

//gravação
If !lExtratTAF
	SPEDRegs(cAlias,{aReg1970,{aReg1975,1}})
Endif


Return

//-------------------------------------------------------------------
/*/{Protheus.doc} Reg1980

Processamento dos registros da GIAF Prodepe
Registros:
1980 - GIAF 4 - Guia de informação e apuração de incentivos fiscais e financeiros: central de distribuição (entradas/saídas)

@Rafael Oliveira
@since 29/10/2018
@version 12.1.17
/*/
//-------------------------------------------------------------------
Static Function Reg1980(cAlias,aApICM,aLivGIAF,aBloco8,lExtratTAF)

Local cINDAP	:=	aLivGIAF[2]

Local aReg1980	:=	{}

Local nPos		:=	0
Local nG4_01	:=	0
Local nG4_02	:=	0
Local nG4_03	:=	0
Local nG4_04	:=	0
Local nG4_05	:=	0
Local nG4_06	:=	0
Local nG4_07	:=	0
Local nG4_08	:=	0
Local nG4_09	:=	0
Local nG4_10	:=	0
Local nG4_11	:=	0
Local nG4_12	:=	0
	
//Utiliza dados das notas
nG4_01	:=  aBloco8[6]
nG4_04 	:=	nG4_01
nG4_02	:=  aBloco8[4]
nG4_03	:=	aBloco8[5]	
nG4_05	:= 	aBloco8[15]
nG4_06	:=	aBloco8[3]


//Apuração do livro
nG4_07	:=	Iif (aScan (aApICM, {|a| a[1]=="011"})<>0, aApICM[aScan (aApICM, {|a| a[1]=="011"})][3], 0)
nG4_08	:=	Iif (aScan (aApICM, {|a| a[4]=="012.04"})<>0, aApICM[aScan (aApICM, {|a| a[4]=="012.04"})][3], 0)
nG4_09	:=	Iif (aScan (aApICM, {|a| a[4]=="012.05"})<>0, aApICM[aScan (aApICM, {|a| a[4]=="012.05"})][3], 0)
//nG4_10	:=	Iif(nG4_07-(nG4_08 + nG4_09) < 0, 0,nG4_08 + nG4_09)
nG4_10	:=	(nG4_08 + nG4_09)
nG4_11	:=	Iif((nG4_07 - nG4_10) < 0, 0, nG4_07 - nG4_10)


//Registro

aAdd(aReg1980, {})
nPos	:=	Len (aReg1980)	
aAdd (aReg1980[nPos], "1980")	//01 - REG
aAdd (aReg1980[nPos], cINDAP)	//02 - IND_AP - Indicador da sub-apuração por tipo de benefício 
aAdd (aReg1980[nPos], nG4_01)	//03 - G4_01 - Entradas (percentual de incentivo)
aAdd (aReg1980[nPos], nG4_02)	//04 - G4_02 - Entradas não incentivadas de PI 
aAdd (aReg1980[nPos], nG4_03)   //05 - G4_03 - Entradas incentivadas de PI 
aAdd (aReg1980[nPos], nG4_04)	//06 - G4_04 - Saídas (percentual de incentivo)
aAdd (aReg1980[nPos], nG4_05)	//07 - G4_05 - Saídas não incentivadas de PI 
aAdd (aReg1980[nPos], nG4_06)	//08 - G4_06 - Saídas incentivadas de PI
aAdd (aReg1980[nPos], nG4_07)	//09 - G4_07 - Saldo devedor do ICMS antes das deduções do incentivo (PI e itens não incentivados)
aAdd (aReg1980[nPos], nG4_08)	//10 - G4_08 - Crédito presumido nas entradas incentivadas de PI 
aAdd (aReg1980[nPos], nG4_09)	//11 - G4_09 - Crédito presumido nas saídas incentivadas de PI
aAdd (aReg1980[nPos], nG4_10)	//12 - G4_10 - Dedução de incentivo da Central de Distribuição (entradas/saídas)
aAdd (aReg1980[nPos], nG4_11)	//13 - G4_11 - Saldo devedor do ICMS após deduções do incentivo
aAdd (aReg1980[nPos], nG4_12)	//14 - G4_12 - Índice de recolhimento da central de distribuição 


//Gravação
If !lExtratTAF
	GrvRegTrS (cAlias,,aReg1980)
Endif

Return


//-------------------------------------------------------------------
/*/{Protheus.doc} Bloco8
@Rafael Oliveira
@since 29/10/2018
@version 12.1.17


Retorna array com os valores acumulados SFT
/*/
//-------------------------------------------------------------------
Static Function Bloco8(cAliasSFT,cSituaDoc,aBloco8,lImport)
Local nLiv		:= AllTrim((cAliasSFT)->FT_NRLIVRO)
Local nPos		:= 0
Local nX		:= 0
Local nValImp	:= 0
Local nAliqIcm	:= 0
Local nLimite	:= 0

IF (nPos := aScan(aBloco8, {|aX|aX[1]==nLiv})) == 0
	aAdd(aBloco8, {})
	nPos := Len(aBloco8)
	aAdd (aBloco8[nPos],nLiv)
	For nX := 2 To 18
		aAdd (aBloco8[nPos],0)
	Next
	
	aAdd (aBloco8[nPos],{{},{},{},{}}) //dados de Importação
	aBloco8[nPos][19][1] := {'3,50',0,0,0}
	aBloco8[nPos][19][2] := {'6,00',0,0,0}
	aBloco8[nPos][19][3] := {'8,00',0,0,0}
	aBloco8[nPos][19][4] := {'10,00',0,0,0}	
Endif

If (cAliasSFT)->FT_TIPOMOV == "S"
	
	//Saidas nao incentivadas	
	If (cAliasSFT)->FT_CPPRODE == 0 
		aBloco8[nPos][15] += (cAliasSFT)->FT_VALCONT
		aBloco8[nPos][16]  += (cAliasSFT)->FT_VALICM
	//Saidas incentivadas	
	ElseIf (cAliasSFT)->FT_CPPRODE <> 0	

		//Saidas incentivadas de PI para fora do Estado
		If Val(Substr((cAliasSFT)->FT_CFOP,1,1)) == 6		
			
			//Fora do Nordeste
			If ((cAliasSFT)->FT_ESTADO $ "AL,BA,CE,MA,PB,PI,RN,SE")
				aBloco8[nPos][2] += (cAliasSFT)->FT_VALCONT 
				aBloco8[nPos][9] += (cAliasSFT)->FT_CPPRODE
				aBloco8[nPos][17]  += (cAliasSFT)->FT_VALICM
			Else
				aBloco8[nPos][10] += (cAliasSFT)->FT_CPPRODE
				aBloco8[nPos][12] += (cAliasSFT)->FT_VALCONT
				aBloco8[nPos][13] := (cAliasSFT)->F4_CPPRODE
				aBloco8[nPos][18]  += (cAliasSFT)->FT_VALICM
			Endif	
		EndIf
		
		//Saídas incentivadas de PI 		
		If (cAliasSFT)->FT_TPPRODE == '5'
			//Para CD de Saída retira ICMS ST		 	  			
			aBloco8[nPos][3] += (cAliasSFT)->FT_VALCONT -(cAliasSFT)->FT_ICMSRET
		Else
			aBloco8[nPos][3] += (cAliasSFT)->FT_VALCONT
		Endif
		// Percentual do incentivo		
		aBloco8[nPos][6] := (cAliasSFT)->F4_CPPRODE

		//Saida interna incentivadas de PI					
		If Val(Substr((cAliasSFT)->FT_CFOP,1,1)) == 5
			aBloco8[nPos][11] += (cAliasSFT)->FT_VALCONT
			aBloco8[nPos][7]  += (cAliasSFT)->FT_VALICM
			aBloco8[nPos][14] := (cAliasSFT)->F4_CPPRODE

			//processa nota internas com credito de importação
			IF ( cAliasSFT )->FT_TPPRODE == "6" .And. lImport
				nValImp :=	GiafEntPrd(( cAliasSFT )->FT_PRODUTO, ( cAliasSFT )->FT_QUANT, ( cAliasSFT )->FT_EMISSAO,nLiv)
				nAliqIcm := ( cAliasSFT )->FT_ALIQICM 
				nLimite  := 0
				Do Case
					Case nAliqIcm <= 7						
						aBloco8[nPos][19][1][2] += (cAliasSFT)->FT_VALCONT
						aBloco8[nPos][19][1][3] += nValImp
						nLimite := nValImp * 0.035
						If (cAliasSFT)->FT_CPPRODE > nLimite
							aBloco8[nPos][19][1][4] += nLimite
						Else
							aBloco8[nPos][19][1][4] += (cAliasSFT)->FT_CPPRODE
						Endif
					Case nAliqIcm > 7 .and. nAliqIcm <= 12
						aBloco8[nPos][19][2][2] += (cAliasSFT)->FT_VALCONT
						aBloco8[nPos][19][2][3] += nValImp						
						nLimite := nValImp * 0.06
						If (cAliasSFT)->FT_CPPRODE > nLimite
							aBloco8[nPos][19][2][4] += nLimite
						Else
							aBloco8[nPos][19][2][4] += (cAliasSFT)->FT_CPPRODE
						Endif	
					Case nAliqIcm > 12 .and. nAliqIcm <= 18
						aBloco8[nPos][19][3][2] += (cAliasSFT)->FT_VALCONT
						aBloco8[nPos][19][3][3] += nValImp						
						nLimite := nValImp * 0.08
						If (cAliasSFT)->FT_CPPRODE > nLimite
							aBloco8[nPos][19][3][4] += nLimite
						Else
							aBloco8[nPos][19][3][4] += (cAliasSFT)->FT_CPPRODE
						Endif
					Case nAliqIcm > 18 						
						aBloco8[nPos][19][4][2] += (cAliasSFT)->FT_VALCONT
						aBloco8[nPos][19][4][3] += nValImp						
						nLimite := nValImp * 0.10
						If (cAliasSFT)->FT_CPPRODE > nLimite
							aBloco8[nPos][19][4][4] += nLimite
						Else
							aBloco8[nPos][19][4][4] += (cAliasSFT)->FT_CPPRODE
						Endif
				EndCase
			Endif
		Endif
	EndIf		
EndIf 


If (cAliasSFT)->FT_TIPOMOV == "E"
	If (cAliasSFT)->FT_CPPRODE == 0 
		aBloco8[nPos][4] += (cAliasSFT)->FT_VALCONT //Entradas nao incentivadas de PI
	Else 
		aBloco8[nPos][5] += (cAliasSFT)->FT_VALCONT //Entradas incentivadas de PI
	EndIf

	//Importação
	If (cAliasSFT)->FT_TPPRODE == '6' .And. Val(Substr((cAliasSFT)->FT_CFOP,1,1)) == 3 .And. (cAliasSFT)->FT_ICMSDIF > 0
		aBloco8[nPos][8] += (cAliasSFT)->FT_VALCONT		
	Endif
EndIf


Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} RegEcfGTP

Função principal de processamento dos registros de bilhetes emitidos por
ECF - SIGAGTP.

@author joao.pellegrini
@since 24/01/2019
/*/
//-------------------------------------------------------------------
Static Function RegEcfGTP(aRegD350, aRegD355, aRegD360, aRegD365, aRegD370, aRegD390, dDataDe, dDataAte, cPerfil)

Local cAliasSGTP := GetNextAlias()
Local cFields	 := ''
Local aCmpAliICM := {}
Local aCmpAliISS := {}
Local cPDV 		 := ''
Local nPosD350	 := 0
Local nPosD355	 := 0
Local nVlBrt 	 := 0
Local nVlrDescto := 0
Local nVlrCancel := 0 
Local aTotaliz 	 := 0
Local nY		 := 0
Local nValPIS    := 0
Local nValCOF    := 0

cFields := 'SFI.FI_PDV, SFI.FI_DTMOVTO DTMOVTO, SFI.FI_DESC,SFI.FI_VALCON,SFI.FI_CRO,SFI.FI_NUMREDZ,SFI.FI_NUMFIM,SFI.FI_NUMINI,SFI.FI_GTFINAL,' 
cFields += 'SFI.FI_ISS,SFI.FI_CANCEL,SFI.FI_SUBTRIB,SFI.FI_ISENTO,SFI.FI_NTRIB, SFI.R_E_C_N_O_ NRECSFI,'
cFields += 'SLG.LG_SERPDV,SLG.LG_IMPFISC,'

//Busca os campos das aliquotas de ICMS e ISS.
SPDFRetAli( @aCmpAliICM, @aCmpAliISS )

//Acrescenta os campos de tributacao de ICMS (Ex: FI_BAS7, FI_BAS12, FI_BAS18...)
For nY:=1 to Len(aCmpAliICM)
	cFields += 'SFI.' + aCmpAliICM[nY][1] + ','
	If !Empty(aCmpAliICM[nY][2])
		cFields += 'SFI.' + aCmpAliICM[nY][2] + ','
	EndIf
Next nY

//Acrescenta os campos de tributacao de ISS (Ex: FI_BIS0300, FI_BIS0500, FI_BIS0700...)
For nY:=1 to Len(aCmpAliISS)
	cFields += 'SFI.' + aCmpAliISS[nY][1] + ','
	If !Empty(aCmpAliISS[nY][2])
		cFields += 'SFI.' + aCmpAliISS[nY][2] + ','
	EndIf
Next nY

//Tira a ultima virgula
cFields := Left(cFields,Len(cFields)-1)

cFields := '%' + cFields + '%' 

BeginSQL Alias cAliasSGTP
				
	SELECT 
		%EXP:cFields%		
	FROM 
		%Table:SFI% SFI
		INNER JOIN %Table:SLG% SLG ON SLG.LG_FILIAL = %xFilial:SLG% AND SFI.FI_PDV = SLG.LG_PDV AND ( SFI.FI_SERPDV = SLG.LG_IMPFISC OR SFI.FI_SERPDV = SLG.LG_SERPDV ) AND SLG.%NotDel%
	WHERE 
		FI_FILIAL = %xFilial:SFI% AND 
		SFI.%NotDel% AND 
		SFI.FI_DTMOVTO BETWEEN %exp:Dtos(dDataDe)% AND %exp:Dtos(dDataAte)% AND 
		EXISTS ( SELECT FT_NFISCAL
						FROM %Table:SFT% SFT
						WHERE SFT.FT_FILIAL = %xFilial:SFT%	
						AND SFT.FT_TIPOMOV = 'S'
						AND SFT.FT_PDV = SFI.FI_PDV
						AND SFT.FT_ESPECIE = 'BPR'
						AND (SFT.FT_ENTRADA = SFI.FI_DTMOVTO OR (SFI.FI_VALCON = 0 AND SFI.FI_CANCEL = 0))
						AND SFT.%NotDel% )
    ORDER BY SFI.FI_PDV, SFI.FI_DTMOVTO, SFI.FI_NUMREDZ
				
EndSQL

Do While !(cAliasSGTP)->(Eof())

    cPDV :=  (cAliasSGTP)->FI_PDV	

    nPosD350 := RegD350(@aRegD350, (cAliasSGTP)->LG_IMPFISC, (cAliasSGTP)->LG_SERPDV, cPDV)
    
    While !(cAliasSGTP)->(Eof()) .AND. cPDV == (cAliasSGTP)->FI_PDV

    	nVlBrt 		:= (cAliasSGTP)->FI_VALCON 	+ (cAliasSGTP)->FI_ISS 		
		nVlrDescto	:= (cAliasSGTP)->FI_DESC
		nVlrCancel	:= (cAliasSGTP)->FI_CANCEL
    	
		/* 
			Não somei o valor do cancelamento no valor bruto pois na redução Z que vem do TotalBus via integração
			o valor dos cancelamentos já está contido no valor bruto. Desta forma se somar o cancelamento ocorre
			divergência de valores. 
		*/
    	nPosD355 := RegD355(@aRegD355, nPosD350, sToD((cAliasSGTP)->DTMOVTO), (cAliasSGTP)->FI_CRO	, ;
							(cAliasSGTP)->FI_NUMREDZ, (cAliasSGTP)->FI_NUMFIM, (cAliasSGTP)->FI_GTFINAL, nVlBrt)

		aTotaliz := TotalizSFI( (cAliasSGTP)->NRECSFI)

    	RegD365(@aRegD365, @aRegD370, nPosD355, aTotaliz, sToD((cAliasSGTP)->DTMOVTO), cPDV, cPerfil)

		RegD390(@aRegD390, nPosD355, sToD((cAliasSGTP)->DTMOVTO), cPDV, @nValPIS, @nValCOF)
    	
		RegD360(@aRegD360, nPosD355, nValPIS, nValCOF)

    	(cAliasSGTP)->(DbSkip())

    EndDo
EndDo
		
If Select(cAliasSGTP)> 0 
	(cAliasSGTP)->(DbCloseArea())
EndIf

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} RegD350

Função de geração do registro D350.

@author joao.pellegrini
@since 24/01/2019
/*/
//-------------------------------------------------------------------
Static Function RegD350(aRegD350, cIMPFISC, cSERPDV, cPDV)

Local nPosD350 := 0

//Validacao para nao repetir ECF com o mesmo numero de serie
If (nPosD350 := aScan(aRegD350, {|x| x[4] == cSERPDV})) == 0

	aAdd(aRegD350, {})
	nPosD350 :=	Len(aRegD350)

	aAdd(aRegD350[nPosD350], "D350")	 													//00 - REG
	aAdd(aRegD350[nPosD350], "13")	 														//02 - COD_MOD
	aAdd(aRegD350[nPosD350], If(!Empty(Left(cIMPFISC,20)), Left(cIMPFISC,20), cSERPDV)) 	//03 - ECF_MOD
	aAdd(aRegD350[nPosD350], cSERPDV)	 													//04 - ECF_FAB
	aAdd(aRegD350[nPosD350], Left(cPDV,3))	 												//05 - ECF_CX 

EndIf 

Return nPosD350

//-------------------------------------------------------------------
/*/{Protheus.doc} RegD355

Função de geração do registro D355.

@author joao.pellegrini
@since 24/01/2019
/*/
//-------------------------------------------------------------------
Static Function RegD355(aRegD355, nRegPai, dDtMovto, cCRO, cNUMREDZ, cNUMFIM, nGTFINAL, nVlBrtTot)
					
Local nPosD355	:= 0
Local nNumFim	:= 0   

//Preenchimento do registro 355
aAdd(aRegD355, {})
nPosD355 :=	Len (aRegD355) 

nNumFim := Val(cNUMFIM) + 1

aAdd(aRegD355[nPosD355], nRegPai)										//00 - RELACIONAMENTO COM O CABECALHO D355
aAdd(aRegD355[nPosD355], "D355") 	   									//01 - REG
aAdd(aRegD355[nPosD355], dDtMovto)	 									//02 - DT_DOC
aAdd(aRegD355[nPosD355], cCRO) 	   										//03 - CRO
aAdd(aRegD355[nPosD355], cNUMREDZ)	 									//04 - CRZ
aAdd(aRegD355[nPosD355], StrZero(nNumFim,Len(AllTrim(Str(nNumFim))))) 	//05 - NUM_COO_FIN
aAdd(aRegD355[nPosD355], nGTFINAL)	 									//06 - GT_FIN
aAdd(aRegD355[nPosD355], nVlBrtTot) 									//07 - VL_BRT    

Return nPosD355

//-------------------------------------------------------------------
/*/{Protheus.doc} RegD360

Função de geração do registro D360.

@author joao.pellegrini
@since 24/01/2019
/*/
//-------------------------------------------------------------------
Static Function RegD360(aRegD360, nPosD355, nValPIS, nValCOF)

Local nPosD360 := 0

aAdd(aRegD360, {})
nPosD360 := Len(aRegD360)    

aAdd(aRegD360[nPosD360], nPosD355)
aAdd(aRegD360[nPosD360], "D360")
aAdd(aRegD360[nPosD360], nValPIS)		//02 - VL_PIS
aAdd(aRegD360[nPosD360], nValCOF) 	//03 - VL_COFINS

Return nPosD360
		
//-------------------------------------------------------------------
/*/{Protheus.doc} RegD365

Função de geração do registro D365.

@author joao.pellegrini
@since 24/01/2019
/*/
//-------------------------------------------------------------------
Static Function RegD365(aRegD365, aRegD370, nPosD355, aTotaliz, dDtMovim, cPDV, cPerfil)

Local nPosD365	:= 0
Local nI	:= 0

For nI:=1 to Len(aTotaliz) 

	aAdd(aRegD365, {})
	nPosD365 := Len(aRegD365)
	
	aAdd(aRegD365[nPosD365], nPosD355)			//00 - RELACIONA COM O REGISTRO PAI
	aAdd(aRegD365[nPosD365], "D365")  			//01 - REG
	aAdd(aRegD365[nPosD365], aTotaliz[nI][1])  	//02 - COD_TOT_PAR		
	aAdd(aRegD365[nPosD365], aTotaliz[nI][2])	//03 - VLR_ACUM_TOT
	aAdd(aRegD365[nPosD365], aTotaliz[nI][3])  	//04 - NR_TOT
	aAdd(aRegD365[nPosD365], ""	)				//05 - DESCR_NR_TOT	  
	
	If cPerfil == "A" .And. (Substr(alltrim(aTotaliz[nI][1]),1,1)  $ "T|F|I|N"  .Or. Substr(alltrim(aTotaliz[nI][1]),3,1) == 'T')
		RegD370(@aRegD370, nPosD365, dDtMovim, cPDV, aTotaliz[nI][1])	
	EndIf

Next nI      

Return NIL

//-------------------------------------------------------------------
/*/{Protheus.doc} RegD370

Função de geração do registro D370.

@author joao.pellegrini
@since 24/01/2019
/*/
//-------------------------------------------------------------------
Static Function RegD370(aRegD370, nPosD365, dDtMovim, cPDV, cSitTrib)

Local nPosD370	:=	0
Local cAlsD370	:= GetNextAlias()
Local cCodMun   := ""

BeginSQL Alias cAlsD370

	SELECT 
		SF2.F2_CMUNOR, SF2.F2_UFORIG, COUNT(DISTINCT SF2.F2_DOC) QTD_BILH, SUM(FT_VALCONT) VL_SERV, SUM(FT_BASEICM) BASEICM, SUM(FT_VALICM) VALICM	
	FROM 
		%Table:SF2% SF2
	INNER JOIN %Table:SFT%  SFT ON
        SFT.FT_FILIAL = %xFilial:SFT% 	 AND
		SFT.FT_TIPOMOV  = 'S'   	     AND
		SFT.FT_SERIE    = SF2.F2_SERIE	 AND
		SFT.FT_NFISCAL	= SF2.F2_DOC	 AND
		SFT.FT_CLIEFOR  = SF2.F2_CLIENTE AND
		SFT.FT_LOJA     = SF2.F2_LOJA    AND		
		SFT.%notDel%
	INNER JOIN %Table:SD2% SD2 ON
		SD2.D2_FILIAL = %xFilial:SD2%   AND
		SD2.D2_DOC = SFT.FT_NFISCAL     AND
		SD2.D2_SERIE = SFT.FT_SERIE     AND
		SD2.D2_CLIENTE = SFT.FT_CLIEFOR AND
		SD2.D2_LOJA = SFT.FT_LOJA       AND
		SD2.D2_ITEM = SFT.FT_ITEM       AND
		SD2.D2_SITTRIB = %Exp:cSitTrib% AND
		SD2.%NotDel%
	WHERE 
		F2_FILIAL = %xFilial:SF2% 			   AND
		SF2.F2_ECF = 'S' 					   AND
		SF2.F2_EMISSAO = %Exp:Dtos(dDtMovim)%  AND
		SF2.F2_PDV = %Exp:cPDV% 			   AND
		SF2.%NotDel%		
	GROUP BY SF2.F2_UFORIG, SF2.F2_CMUNOR 
	ORDER BY SF2.F2_UFORIG, SF2.F2_CMUNOR

EndSQL

While !(cAlsD370)->(Eof())

	cCodMun := UfCodIBGE((cAlsD370)->F2_UFORIG) + (cAlsD370)->F2_CMUNOR

	aAdd(aRegD370, {})
	nPosD370 := Len (aRegD370)
	aAdd(aRegD370[nPosD370], nPosD365)	 	   				//CHAVE PARA RELACIONAMENTO COM REGISRO PAI
	aAdd(aRegD370[nPosD370], "D370")						//01 - REG
	aAdd(aRegD370[nPosD370],  cCodMun)						//02 - COD_MUN_ORIG
	aAdd(aRegD370[nPosD370], (cAlsD370)->VL_SERV )				//03 - VL_SERV
	aAdd(aRegD370[nPosD370], cValToChar((cAlsD370)->QTD_BILH))	//04 - QTD_BILH
	aAdd(aRegD370[nPosD370], (cAlsD370)->BASEICM)		//05 - VL_BC_ICMS
	aAdd(aRegD370[nPosD370], (cAlsD370)->VALICM)		//06 - VL_ICMS
	
	(cAlsD370)->(DbSkip())

EndDo

If Select(cAlsD370) > 0 
	(cAlsD370)->(DbCloseArea())
EndIf

Return NIL

//-------------------------------------------------------------------
/*/{Protheus.doc} RegD390

Função de geração do registro D390.

@author joao.pellegrini
@since 24/01/2019
/*/
//-------------------------------------------------------------------
Static Function RegD390(aRegD390, nPosD355, dDataMov, cPDV, nValPIS, nValCOF)

Local nPosD390 := 0
Local cAlsD390 := GetNextAlias()
Local cCSTIcms := ""
Local lICMNTrib := .F.

BeginSql Alias cAlsD390
	SELECT 
		FT_FILIAL, FT_CLASFIS, FT_CFOP, FT_ALIQICM, SUM(FT_VALICM) FT_VALICM, SUM(FT_VALCONT) VLR_OPR, 
		SUM(FT_VALPIS) FT_VALPIS, SUM(FT_VALCOF) FT_VALCOF, SUM(FT_QUANT) FT_QUANT, SUM(FT_BASEICM) FT_BASEICM
	FROM %Table:SFT% SFT
	WHERE   
		SFT.FT_FILIAL   = %xFilial:SFT%  		AND
		SFT.FT_TIPOMOV  = 'S'   				AND
		SFT.FT_PDV      = %Exp:cPdv%			AND 
		SFT.FT_ESPECIE	= 'BPR'					AND
		SFT.FT_ENTRADA  = %exp:DTOS(dDataMov)%  AND
		SFT.FT_DTCANC	= ' '					AND
		SFT.%notDel%       						
	GROUP BY 
		FT_FILIAL,FT_CLASFIS,FT_CFOP,FT_ALIQICM
	ORDER BY 
		FT_FILIAL,FT_CLASFIS,FT_CFOP,FT_ALIQICM
EndSql

If !(cAlsD390)->(Eof())
	
	While !(cAlsD390)->(Eof())

		cCSTIcms := Right((cAlsD390)->FT_CLASFIS, 2)
		lICMNTrib := cCSTIcms $ "30|40|41|50|60"
		
		aAdd(aRegD390, {})
		nPosD390 := Len(aRegD390 )    
		
		aAdd(aRegD390[nPosD390], nPosD355)
		aAdd(aRegD390[nPosD390], "D390")
		aAdd(aRegD390[nPosD390], (cAlsD390)->FT_CLASFIS)					 //02 CST_ICMS
		aAdd(aRegD390[nPosD390], (cAlsD390)->FT_CFOP) 						 //03 CFOP	
		aAdd(aRegD390[nPosD390], IIf(lICMNTrib, 0, (cAlsD390)->FT_ALIQICM)) //04 ALIQ_ICMS
		aAdd(aRegD390[nPosD390], (cAlsD390)->VLR_OPR) 					 	 //05 VL_OPR	
		aAdd(aRegD390[nPosD390], 0) 										 //06 VL_BC_ISSQN
		aAdd(aRegD390[nPosD390], 0) 										 //07 ALIQ_ISSQN
		aAdd(aRegD390[nPosD390], 0) 										 //08 VL_ISSQN
		aAdd(aRegD390[nPosD390], IIf(lICMNTrib, 0, (cAlsD390)->FT_BASEICM)) //09 VL_BC_ICMS
		aAdd(aRegD390[nPosD390], IIf(lICMNTrib, 0, (cAlsD390)->FT_VALICM))  //10 VL_ICMS
		aAdd(aRegD390[nPosD390], '') 										 //11 COD_OBS

		// Valores de PIS e COFINS p/ geração do registro D360
		nValPIS += (cAlsD390)->FT_VALPIS
		nValCOF += (cAlsD390)->FT_VALCOF

		(cAlsD390)->(DbSkip())

	EndDo

EndIf

If Select(cAlsD390)> 0 
	(cAlsD390)->(DbCloseArea())
EndIf

Return NIL

//-------------------------------------------------------------------
/*/{Protheus.doc} RegD400

Função de geração do registro D400.

@author joao.pellegrini
@since 24/01/2019
/*/
//-------------------------------------------------------------------
Static Function RegD400(cAliasSFT, aRegD400, aReg0150, cAlias, aWizard, aExistBloc, nRelac)

Local nPosD400 := 0
Local aPartSM0 := InfPartDoc("SM0")

If (nPosD400 := aScan(aRegD400, {|x| x[2] == aPartSM0[1] .And. x[5] == (cAliasSFT)->GZU_SERIE .And. x[7] == (cAliasSFT)->GZU_DOC .And. x[8] == (cAliasSFT)->GZU_DTMOV})) == 0

	aAdd(aRegD400, {})
	nPosD400 := Len(aRegD400)

	aAdd(aRegD400[nPosD400], "D400")	 	          //00 - REG
	aAdd(aRegD400[nPosD400], "")	  		          //02 - COD_PART
	aAdd(aRegD400[nPosD400], '18')	 	      		  //03 - COD_MOD
	aAdd(aRegD400[nPosD400], (cAliasSFT)->GZU_SITUAC) //04 - COD_SIT
	aAdd(aRegD400[nPosD400], (cAliasSFT)->GZU_SERIE)  //05 - SER
	aAdd(aRegD400[nPosD400], "")                      //06 - SUB
	aAdd(aRegD400[nPosD400], (cAliasSFT)->GZU_DOC)    //07 - NUM_DOC
	aAdd(aRegD400[nPosD400], "")  			          //08 - DT_DOC
	aAdd(aRegD400[nPosD400], 0)	  		          	  //09 - VL_DOC
	aAdd(aRegD400[nPosD400], 0)	  		          	  //10 - VL_DESC
	aAdd(aRegD400[nPosD400], 0)	                  	  //11 - VL_SERV
	aAdd(aRegD400[nPosD400], 0)	                  	  //12 - VL_BC_ICMS
	aAdd(aRegD400[nPosD400], 0)	                  	  //13 - VL_ICMS
	aAdd(aRegD400[nPosD400], 0)                       //14 - VL_PIS
	aAdd(aRegD400[nPosD400], 0)                       //15 - VL_COFINS
	aAdd(aRegD400[nPosD400], "")                      //16 - COD_CTA
	
	If !AllTrim((cAliasSFT)->GZU_SITUAC) $ "02|03"

		 // O participante será a própria agência, filial ou posto.
		/*GRAVACAO REGISTRO 0150 - TABELA DE CADASTRO DE PARTICIPANTES
		GRAVACAO REGISTRO 0175 - ALTERACAO DA TABELA DE CADASTRO DE PARTICIPANTE*/
		SDPF150175(@aReg0150, aPartSM0, cAlias, aWizard, aExistBloc)

		aRegD400[nPosD400, 2]  := aPartSM0[1]	  		   //02 - COD_PART
		aRegD400[nPosD400, 8]  := (cAliasSFT)->GZU_DTMOV   //08 - DT_DOC
		aRegD400[nPosD400, 9]  := (cAliasSFT)->GZU_VLDOC   //09 - VL_DOC
		aRegD400[nPosD400, 10] := (cAliasSFT)->GZU_VLDESC  //10 - VL_DESC
		aRegD400[nPosD400, 11] := (cAliasSFT)->GZU_VLSERV  //11 - VL_SERV
		aRegD400[nPosD400, 12] := (cAliasSFT)->GZU_VLBASE  //12 - VL_BC_ICMS
		aRegD400[nPosD400, 13] := (cAliasSFT)->GZU_VLICMS  //13 - VL_ICMS
		aRegD400[nPosD400, 14] := (cAliasSFT)->GZU_VLPIS   //14 - VL_PIS
		aRegD400[nPosD400, 15] := (cAliasSFT)->GZU_COFINS  //15 - VL_COFINS
		aRegD400[nPosD400, 16] := (cAliasSFT)->GZU_CONTA   //16 - COD_CTA

	EndIf

EndIf

Return nPosD400

//-------------------------------------------------------------------
/*/{Protheus.doc} RegD410

Função de geração do registro D410.

@author joao.pellegrini
@since 24/01/2019
/*/
//-------------------------------------------------------------------
Static Function RegD410(nPosD400, aRegD410, cEspecie, cSituaDoc, cAliasSFT, lNotaD410)

Local nPosD410 := 0
Local cNotaD410	:= ""
Local cSerie	:= ""

// Flag p/ indicar que só serão utilizados os últimos 6 dígitos do número do documento.
// O layout do sped fiscal só permite 6 dígitos nos campos NUM_DOC_INI e NUM_DOC_FIN.
If Len(AllTrim((cAliasSFT)->FT_NFISCAL)) > 6 .And. Val(Left(AllTrim((cAliasSFT)->FT_NFISCAL), Len(AllTrim((cAliasSFT)->FT_NFISCAL))-6)) > 0
	lNotaD410   := .F.
EndIf

cSerie := SpedSerie((cAliasSFT)->FT_SERIE, cEspecie)
cNotaD410 := Right(AllTrim((cAliasSFT)->FT_NFISCAL), 6)

If (nPosD410 := aScan(aRegD410,{|aX| aX[1] == nPosD400 .And. aX[3] == cEspecie .And. aX[4] == cSerie .And. aX[9] == (cAliasSFT)->FT_CLASFIS .And. aX[10] == (cAliasSFT)->FT_CFOP .And. aX[11] == (cAliasSFT)->FT_ALIQICM})) == 0

	aAdd(aRegD410, {})
	nPosD410 := Len(aRegD410)

	aAdd(aRegD410[nPosD410], nPosD400)					//00 - RELACIONAMENTO COM O CABECALHO D400
	aAdd(aRegD410[nPosD410], "D410") 	   				//01 - REG
	aAdd(aRegD410[nPosD410], cEspecie)	 				//02 - COD_MOD
	aAdd(aRegD410[nPosD410], cSerie) 					//03 - SER
	aAdd(aRegD410[nPosD410], "")	 					//04 - SUB	
	aAdd(aRegD410[nPosD410], cNotaD410) 	 			//05 - NUM_DOC_INI
	aAdd(aRegD410[nPosD410], cNotaD410)	 				//06 - NUM_DOC_FIN
	aAdd(aRegD410[nPosD410], (cAliasSFT)->FT_EMISSAO) 	//07 - DT_DOC
	aAdd(aRegD410[nPosD410], (cAliasSFT)->FT_CLASFIS)	//08 - CST_ICMS 
	aAdd(aRegD410[nPosD410], (cAliasSFT)->FT_CFOP)		//09 - CFOP 
	aAdd(aRegD410[nPosD410], (cAliasSFT)->FT_ALIQICM)   //10 - ALIQ_ICMS
	aAdd(aRegD410[nPosD410], 0) 						//11 - VL_OPR	
	aAdd(aRegD410[nPosD410], 0) 						//12 - VL_DESC
	aAdd(aRegD410[nPosD410], 0) 						//13 - VL_SERV
	aAdd(aRegD410[nPosD410], 0) 						//14 - VL_BC_ICMS
	aAdd(aRegD410[nPosD410], 0) 						//15 - VL_ICMS

EndIf

//³Range de Numero de Documentos
If Val(cNotaD410) < Val(aRegD410[nPosD410][6])
	aRegD410[nPosD410][6] := cNotaD410		//05 - NUM_DOC_INI
EndIf

If Val(cNotaD410) > Val(aRegD410[nPosD410][7])
	aRegD410[nPosD410][7] := cNotaD410		//06 - NUM_DOC_FIN
EndIf

If !cSituaDoc $ "02|03"
	aRegD410[nPosD410, 12] += (cAliasSFT)->FT_VALCONT
	aRegD410[nPosD410, 13] += (cAliasSFT)->FT_DESCONT
	aRegD410[nPosD410, 14] += (cAliasSFT)->FT_TOTAL
	aRegD410[nPosD410, 15] += (cAliasSFT)->FT_BASEICM
	aRegD410[nPosD410, 16] += (cAliasSFT)->FT_VALICM
EndIf

Return nPosD410

//-------------------------------------------------------------------
/*/{Protheus.doc} RegD411

Função de geração do registro D411.

@author joao.pellegrini
@since 24/01/2019
/*/
//-------------------------------------------------------------------
Static Function RegD411(nPosD410,aRegD411,cAliasSFT)

Local nPosD411	:=	0

aAdd(aRegD411, {})
nPosD411 := Len(aRegD411)

aAdd(aRegD411[nPosD411], nPosD410)				  					//CHAVE PARA RELACIONAMENTO COM REGISRO PAI
aAdd(aRegD411[nPosD411], "D411")				  					//01 - REG
aAdd(aRegD411[nPosD411], Right(AllTrim((cAliasSFT)->FT_NFISCAL), 6)) //02 - NUM_DOC_CANC

Return nPosD411 

//-------------------------------------------------------------------
/*/{Protheus.doc} RegD420

Função de geração do registro D420.

@author joao.pellegrini
@since 24/01/2019
/*/
//-------------------------------------------------------------------
Static Function RegD420(nPosD400, aRegD420, cAliasSFT)

Local nPosD420 := 0
Local cMunOrig := UfCodIBGE((cAliasSFT)->F2_UFORIG) + (cAliasSFT)->F2_CMUNOR

If (nPosD420 := aScan(aRegD420,{|aX| aX[1] == nPosD400 .And. aX[3] == cMunOrig})) == 0

	aAdd(aRegD420, {})
	nPosD420 := Len(aRegD420)

	aAdd(aRegD420[nPosD420], nPosD400)	//CHAVE PARA RELACIONAMENTO COM REGISRO PAI
	aAdd(aRegD420[nPosD420], "D420")	//01 - REG
	aAdd(aRegD420[nPosD420], cMunOrig)	//02 - COD_MUN_ORIG
	aAdd(aRegD420[nPosD420], 0)			//03 - VL_SERV
	aAdd(aRegD420[nPosD420], 0)			//04 - VL_BC_ICMS
	aAdd(aRegD420[nPosD420], 0)			//05 - VL_ICMS

EndIf

aRegD420[nPosD420][4] += (cAliasSFT)->FT_TOTAL		//03 - VL_SERV
aRegD420[nPosD420][5] += (cAliasSFT)->FT_BASEICM	//04 - VL_BC_ICMS
aRegD420[nPosD420][6] += (cAliasSFT)->FT_VALICM		//05 - VL_ICMS

Return nPosD420

//--------------------------------------------------------------------------------------------------
/*/{Protheus.doc} SPDBlocoB()

Função responsável por gerar os registros: B350 / B460 / B470 / B500 / B510, além dos registros B020 
e B025 para entradas com retenção (Financeiro)

@author Ulisses P. Oliveira
@since 04/07/2019
@version 1.0
/*/
//--------------------------------------------------------------------------------------------------
Static Function SPDBlocoB(dDataDe, dDataAte, aReg0460, aRegB350, aRegB420, aRegB460, aRegB470, aRegB500, aRegB510, aRegB440, aReg0150, nVlContOMun, cAlias, aWizard, cRelacDoc)
Local cAlsFin    := ''
Local cAlsEnt    := ''
Local aParams    := ''
Local oObjSpdMov := Nil
Local aRegB020   := {}
Local aRegB025   := {}
Local cIdF1P     := ''
Local oApurISS   := Nil
Local aApurMun   := {}
Local nPosB500   := 0
Local lEmissEX 	 :=	aSPDSX6[MV_SPDBIFE]=="2" //Se os serviços tomados do EX, devem ser pela Emissão
Local nIdRelac	 := 0
Local nPercBaixa := 0
Local nIssReti   := ""
Local nTamcRel	 := len(cRelacDoc)
Local nTamB20	 := 10

//---Geração dos registros B020 e B025 para entradas com retenção---//
oObjSpdMov := SPEDMOV():New()              //---Cria objeto de movimento ---//
cAlsFin    := ISSFiscal(dDataDe, dDataAte,,,,"P") //---Componente do Financeiro que retorna retenções---//

(cAlsFin)->(DbGoTop())

While (cAlsFin)->(!Eof())
	
	aRegB020 := {}
	aRegB025 := {}
	
	If (cAlsFin)->TIPOPR == "P"			
		//cRelacDoc++ caso o cRelacDoc	vier como Caracter, a mudanca de hierarquia proposta anteriormente sera melhorada caso venha com mais informacoes no cRelacDoc
		nIssReti 		:=	Iif((cAlsFin)->(FieldPos("ISS"))>0, (cAlsFin)->ISS, ((cAlsFin)->BASEISS*(cAlsFin)->ALIQUOTA))
		nIdRelac++
		
		aParams 	:= {(cAlsFin)->NUMERO, (cAlsFin)->PREFIXO, (cAlsFin)->CLIFOR, (cAlsFin)->LOJA, dDataAte}
		cAlsEnt 	:= FSA300EQRY("ENTRADAS", aParams,,lEmissEX)[1] //---Função da apuração de ISS (FISA300E) que retorna NFs de entradas baseadas no retorno do Financeiro---//
		nPercBaixa	:= nIssReti / (cAlsEnt)->F1_ISS
		
		ProcRegB(nPercBaixa,cAlsEnt,dDataDe,dDataAte,@aRegB020,@aRegB025,@aRegB420,@aRegB440,@aReg0150,oObjSpdMov,aWizard,cAlias)

		(cAlsEnt)->(dbCloseArea())
	EndIf

	//---Grava registros B020/B025 e B030/B035---//
	If Len(aRegB020) > 0
		GrvRegTrS(cAlias,SUBSTRING(cRelacDoc,1,nTamcRel) + STRZERO(nIdRelac,nTamB20),aRegB020)
		GrvRegTrS(cAlias,SUBSTRING(cRelacDoc,1,nTamcRel) + STRZERO(nIdRelac,nTamB20),aRegB025)
	EndIf

	(cAlsFin)->(dbSkip())
EndDo
(cAlsFin)->(dbCloseArea())

if lEmissEX
	
	nIdRelac++		
		
	aRegB020	:= {}
	aRegB025	:= {}
	aParams		:= {dDataDe, dDataAte}
	cAlsEntEX	:= FSA300EQRY("ENTRADASEX", aParams,,lEmissEX)[1]
	nPercBaixa	:= 1 //Percentual de baixa, neste caso é pela emissão, 1 Significa contemplar o valor cheio

	ProcRegB(nPercBaixa,cAlsEntEX,dDataDe,dDataAte,@aRegB020,@aRegB025,@aRegB420,@aRegB440,@aReg0150,oObjSpdMov,aWizard,cAlias)
	
	(cAlsEntEX)->(dbCloseArea())

	//---Grava registros B020/B025 e B030/B035---//
	If Len(aRegB020) > 0
		GrvRegTrS(cAlias,SUBSTRING(cRelacDoc,1,nTamcRel) + STRZERO(nIdRelac,nTamB20),aRegB020)
		GrvRegTrS(cAlias,SUBSTRING(cRelacDoc,1,nTamcRel) + STRZERO(nIdRelac,nTamB20),aRegB025)
	EndIf

endif


//---FIM Geração dos registros B020 e B025 para entradas com retenção---//

//Verifico se a classe existe antes de prosseguir com os registros de apuração - FISA300G
IF FindFunction("FSA300GVLD")
	//Busca o ID da apuração conforme o período de geração da Wizard do SPED
	cIdF1P	:= FSA300EApu(dDataDe, dDataAte)
	
	If !Empty(cIdF1P)

		//Cria objeto de apuração
		oApurISS    := APURISS():New()
		
		//Faz carga dos valores da apuração
		oApurISS:LoadApur(cIdF1P)
		
		//Faz carga dos valores por código de serviço
		aApurMun := oApurISS:getApurMun( RetMunSM0() )

		//Verifica se array está preenchido
		If Len(aApurMun) > 0

			//Processa registros de instituição financeira
			RegB350(@aRegB350, @aRegB420, @aReg0460, dDataAte)

			//Processa as deduções
			RegB460(aApurMun[1]:getDeducoes(), @aRegB460, @aReg0460)
			
			//Processa registro de apuração
			RegB470(FSA300SMOV(aApurMun), aApurMun[1], @aRegB470, nVlContOMun, .F.)

			//Registros com informações de sociedade uniprofissional
			nPosB500	:= RegB500(aApurMun[1], @aRegB500)

			If nPosB500 > 0
				RegB510(dDataAte, @aRegB510, nPosB500)
			EndIf

		Else
			//Precisa gerar registro B470 gerado caso não tenha nenhuma movimentação
			RegB470(NIL, NIL, @aRegB470, nVlContOMun, .T.)
		EndIF		

		//Destroi objeto
		oApurISS:Clear()
		FreeObj(oApurISS)
		oApurISS := Nil

	Else

		//Precisa gerar registro B470 gerado caso não tenha nenhuma movimentação
		RegB470(NIL, NIL, @aRegB470, nVlContOMun, .T.)
		
	EndIF

EndIF


Return

//--------------------------------------------------------------------------------------------------
/*/{Protheus.doc} RegB020()
  
REGISTRO B020: NOTA FISCAL (CÓDIGO 01), 
               NOTA FISCAL DE SERVIÇOS (CÓDIGO 03), 
			   NOTA FISCAL DE SERVIÇOS AVULSA (CÓDIGO 3B), 
			   NOTA FISCAL DE PRODUTOR (CÓDIGO 04), 
			   CONHECIMENTO DE TRANSPORTE RODOVIÁRIO DE CARGAS (CÓDIGO 08), 
			   NF-e (CÓDIGO 55) e 
			   NFC-e (CÓDIGO 65).

@author Ulisses P. Oliveira
@since 17/06/2019
@version 1.0
/*/
//--------------------------------------------------------------------------------------------------
Static Function RegB020( aRegB020, aRegB025, aRegB420, aRegB440, lGrava0150, oObjSpdMov, cEstado )

Local lIssOutMun := .F.
Local nPosB020   := 0
Local nValCont   := 0
Local nMatTerc   := 0
Local nValSub    := 0
Local nValIsen   := 0
Local nDeducoes  := 0
Local nBaseIss   := 0
Local nBaseIsRet := 0
Local nIssRet    := 0
Local nValIss    := 0

Local cSitDoc    := ""
Local cCodMun    := ""

// Define se o ISS é devido em outro município diferente do sigamat.
// Neste caso os valores monetários devem ser zerados, com exceção do VALCONT, e o VALCONT deve ser 
// demonstrado no campo VL_ISNT_ISS pois na otica do DF estas são operações "não tributadas".
// Conforme disposto no Tutorial de Escrituração Fiscal da EFD ICMS-IPI para contribuintes do DF.
lIssOutMun := oObjSpdMov:getMunDev() <> RetMunSM0()

If lIssOutMun
	nValCont := nValIsen:=  oObjSpdMov:getVlCont()
Else
	nValCont   := oObjSpdMov:getVlCont()
	nMatTerc   := oObjSpdMov:getMatTer()
	nValSub    := oObjSpdMov:getIssSub()
	nValIsen   := oObjSpdMov:getIseOut()
	nDeducoes  := oObjSpdMov:getMatTer() + oObjSpdMov:getIssSub() +oObjSpdMov:getIseOut()
	nBaseIss   := oObjSpdMov:getBCIss()
	nValIss    := oObjSpdMov:getIss()	
	nBaseIsRet := oObjSpdMov:getBCRet()
	nIssRet    := oObjSpdMov:getIssRet()
EndIf

If (!oObjSpdMov:getSitDoc()$"02")
	cSitDoc := oObjSpdMov:getEmiss()
EndIf

cCodMun := oObjSpdMov:getMunPres()
If Empty(cCodMun) .And. cEstado == "EX" //Caso o município da prestação do serviço seja no exterior, o código do município virá em branco. Nesse caso, deverá ser preenchido com o código "9999999".
	cCodMun := "9999999"
EndIf

nPosB020 := aScan(aRegB020, {|x| x[2]  == oObjSpdMov:getIndOpe() .And.; 
								 x[5]  == oObjSpdMov:getEspeci() .And.; 
								 x[7]  == oObjSpdMov:getSerie()  .And.;
								 x[8]  == oObjSpdMov:getNumNf()  .And.;
								 x[10] == cSitDoc})

If nPosB020 == 0

	aAdd(aRegB020, {})
	nPosB020 := Len(aRegB020)
	aAdd(aRegB020[nPosB020], "B020")                	//01 - REG           Texto fixo contendo "B020"
	aAdd(aRegB020[nPosB020], oObjSpdMov:getIndOpe())	//02 - IND_OPER      Indicador do tipo de operação: 0 - Aquisição; 1 - Prestação
	aAdd(aRegB020[nPosB020], oObjSpdMov:getIndEmi())	//03 - IND_EMIT      Indicador do emitente do documento fiscal: 0 - Emissão própria; 1 - Terceiros
	aAdd(aRegB020[nPosB020], Iif(!oObjSpdMov:getSitDoc() $ "02" .AND. oObjSpdMov:getEspeci() <> "65",oObjSpdMov:getPart(),""))  	//04 - COD_PART      Código do participante (campo 02 do Registro 0150): - do prestador, no caso de declarante na condição de tomador; - do tomador, no caso de declarante na condição de prestador
	aAdd(aRegB020[nPosB020], oObjSpdMov:getEspeci())	//05 - COD_MOD       Código do modelo do documento fiscal, conforme a Tabela 4.1.3
	aAdd(aRegB020[nPosB020], oObjSpdMov:getSitDoc())	//06 - COD_SIT       Código da situação do documento conforme tabela 4.1.2
	aAdd(aRegB020[nPosB020], oObjSpdMov:getSerie()) 	//07 - SER           Série do documento fiscal
	aAdd(aRegB020[nPosB020], oObjSpdMov:getNumNf())     //08 - NUM_DOC       Número do documento fiscal
	aAdd(aRegB020[nPosB020], Iif( oObjSpdMov:getSitDoc() == "05","", oObjSpdMov:getChvNfe()) ) //09 - CHV_NFE  Chave da Nota Fiscal Eletrônica	
	
	If !oObjSpdMov:getSitDoc() $ "02"	
		aAdd(aRegB020[nPosB020], cSitDoc)												//10 - DT_DOC        Data da emissão do documento fiscal
		aAdd(aRegB020[nPosB020], cCodMun)     											//11 - COD_MUN_SERV  Código do município onde o serviço foi prestado, conforme a tabela IBGE.
		aAdd(aRegB020[nPosB020], nValCont)                                				//12 - VL_CONT       Valor contábil (valor total do documento)
		aAdd(aRegB020[nPosB020], nMatTerc)                                				//13 - VL_MAT_TERC   Valor do material fornecido por terceiros na prestação do serviço
		aAdd(aRegB020[nPosB020], nValSub)                                				//14 - VL_SUB        Valor da subempreitada
		aAdd(aRegB020[nPosB020], nValIsen)												//15 - VL_ISNT_ISS   Valor das operações isentas ou não-tributadas pelo ISS
		aAdd(aRegB020[nPosB020], nDeducoes)  											//16 - VL_DED_BC     Valor da dedução da base de cálculo
		aAdd(aRegB020[nPosB020], nBaseIss)                                				//17 - VL_BC_ISS     Valor da base de cálculo do ISS
		aAdd(aRegB020[nPosB020], nBaseIsRet)                  							//18 - VL_BC_ISS_RT  Valor da base de cálculo de retenção do ISS
		aAdd(aRegB020[nPosB020], nIssRet)                   							//19 - VL_ISS_RT     Valor do ISS retido pelo tomador
		aAdd(aRegB020[nPosB020], nValIss)                                				//20 - VL_ ISS       Valor do ISS destacado
		aAdd(aRegB020[nPosB020], "")                               						//21 - COD_INF_OBS   Código da observação do lançamento fiscal (campo 02 do Registro 0460)
	Else					
		aAdd(aRegB020[nPosB020], "")          											//10 - DT_DOC        Data da emissão do documento fiscal
		aAdd(aRegB020[nPosB020], "")                         							//11 - COD_MUN_SERV  Código do município onde o serviço foi prestado, conforme a tabela IBGE.
		aAdd(aRegB020[nPosB020], "")                                					//12 - VL_CONT       Valor contábil (valor total do documento)
		aAdd(aRegB020[nPosB020], "")                                					//13 - VL_MAT_TERC   Valor do material fornecido por terceiros na prestação do serviço
		aAdd(aRegB020[nPosB020], "")                                					//14 - VL_SUB        Valor da subempreitada
		aAdd(aRegB020[nPosB020], "")                      								//15 - VL_ISNT_ISS   Valor das operações isentas ou não-tributadas pelo ISS
		aAdd(aRegB020[nPosB020], "")  													//16 - VL_DED_BC     Valor da dedução da base de cálculo
		aAdd(aRegB020[nPosB020], "")                                					//17 - VL_BC_ISS     Valor da base de cálculo do ISS
		aAdd(aRegB020[nPosB020], "")                  									//18 - VL_BC_ISS_RT  Valor da base de cálculo de retenção do ISS
		aAdd(aRegB020[nPosB020], "")                   									//19 - VL_ISS_RT     Valor do ISS retido pelo tomador
		aAdd(aRegB020[nPosB020], "")                                					//20 - VL_ ISS       Valor do ISS destacado
		aAdd(aRegB020[nPosB020], "")                               						//21 - COD_INF_OBS   Código da observação do lançamento fiscal (campo 02 do Registro 0460)	
	EndIf

ElseIf !oObjSpdMov:getSitDoc() $ "02#04#05"
	aRegB020[nPosB020][12] += nValCont                  								//12 - VL_CONT       Valor contábil (valor total do documento)
	aRegB020[nPosB020][13] += nMatTerc                    								//13 - VL_MAT_TERC   Valor do material fornecido por terceiros na prestação do serviço
	aRegB020[nPosB020][14] += nValSub													//14 - VL_SUB        Valor da subempreitada
	aRegB020[nPosB020][15] += nValIsen                  								//15 - VL_ISNT_ISS   Valor das operações isentas ou não-tributadas pelo ISS
	aRegB020[nPosB020][16] += nDeducoes 												//16 - VL_DED_BC     Valor da dedução da base de cálculo
	aRegB020[nPosB020][17] += nBaseIss          										//17 - VL_BC_ISS     Valor da base de cálculo do ISS
	aRegB020[nPosB020][18] += nBaseIsRet                 								//18 - VL_BC_ISS_RT  Valor da base de cálculo de retenção do ISS
	aRegB020[nPosB020][19] += nIssRet                   								//19 - VL_ISS_RT     Valor do ISS retido pelo tomador
	aRegB020[nPosB020][20] += nValIss                   								//20 - VL_ ISS       Valor do ISS destacado
EndIf

If !oObjSpdMov:getSitDoc()  $ "02#04#05"

	//Para o modelo 65 não deverá gerar registro de participante 0150
	If oObjSpdMov:getEspeci() <> "65"
		lGrava0150 := .T.	
	EndIF	
	
	//Chama geração do registro B025
	RegB025(@aRegB025,nValCont,nBaseIss,nValIss,nValIsen,oObjSpdMov)	

	//Totaliza as saídas no registro B420
	//Se o ISS não for devido para o municipio do sigamat não gero B420 pois não irá bater com a apuração
	//no registro B470, já que o tratamento para demonstrar o valor contábil como isento/não tributado
	//só aplica-se ao SPED e não à apuração.
	IF oObjSpdMov:getEntSai() == '2'
		RegB420(@aRegB420,nValCont, nBaseIss, nValIsen, nValIss, oObjSpdMov:getCodIss(), oObjSpdMov:getAlqIss())					
	EndIF	
	
	//Processa registro de retenção B440
	//Não verifico se existe valor de retenção para gerar, pois segundo guia prático o registor deverá ser sempre gerado mesmo que não tenha retenção		
	//O PVA não valida registro B440 sem participante, por este motivo não estou gerando B440 para modelo 65
	If oObjSpdMov:getEspeci() <> "65"
		RegB440(@aRegB440,nValCont, oObjSpdMov)		
	EndIF

EndIf

Return

//--------------------------------------------------------------------------------------------------
/*/{Protheus.doc} RegB025()
  
REGISTRO B025: DETALHAMENTO POR COMBINAÇÃO DE ALÍQUOTA E ITEM DA LISTA DE SERVIÇOS DA LC 116/2003)

@author Ulisses P. Oliveira
@since 27/06/2019
@version 1.0
/*/
//--------------------------------------------------------------------------------------------------
Static Function RegB025(aRegB025,nValCont,nBaseIss,nValIss,nIsenIss, oObjSpdMov)

Local nPos := 0

//---Não podem ser informados, para um mesmo B020 “pai”, dois ou mais registros B025 com a mesma combinação de valores dos campos: ALIQ_ISS e COD_SERV---//
nPos := Ascan(aRegB025,{|a| a[4] == oObjSpdMov:getAlqIss() .And. a[7] == oObjSpdMov:getCodIss()})

If nPos == 0
	aAdd(aRegB025, {})
	nPos := Len(aRegB025)
	aAdd(aRegB025[nPos], "B025")     //01 - REG           Texto fixo contendo "B025" 
	aAdd(aRegB025[nPos], nValCont)   //02 - VL_CONT_P     Parcela correspondente ao "Valor Contábil" referente à combinação da alíquota e item da lista
	aAdd(aRegB025[nPos], nBaseIss)   //03 - VL_BC_ISS_P   Parcela correspondente ao "Valor da base de cálculo do ISS" referente à combinação da alíquota e item da lista
	aAdd(aRegB025[nPos], oObjSpdMov:getAlqIss())   //04 - ALIQ_ISS      Alíquota do ISS
	aAdd(aRegB025[nPos], nValIss)    //05 - VL_ISS_P      Parcela correspondente ao "Valor do ISS" referente à combinação da alíquota e item da lista 	
	aAdd(aRegB025[nPos], nIsenIss) 	 //06 - VL_ISNT_ISS_P Parcela correspondente ao "Valor das operações isentas ou nãotributadas pelo ISS" referente à combinação da alíquota e item da lista
	aAdd(aRegB025[nPos], oObjSpdMov:getCodIss())    //07 - COD_SERV      Item da lista de serviços, conforme Tabela 4.6.3
Else
	aRegB025[nPos][2] += nValCont    //02 - VL_CONT_P     Parcela correspondente ao "Valor Contábil" referente à combinação da alíquota e item da lista
	aRegB025[nPos][3] += nBaseIss    //03 - VL_BC_ISS_P   Parcela correspondente ao "Valor da base de cálculo do ISS" referente à combinação da alíquota e item da lista
	aRegB025[nPos][5] += nValIss     //05 - VL_ISS_P      Parcela correspondente ao "Valor do ISS" referente à combinação da alíquota e item da lista 	
	aRegB025[nPos][6] += nIsenIss  	 //06 - VL_ISNT_ISS_P Parcela correspondente ao "Valor das operações isentas ou nãotributadas pelo ISS" referente à combinação da alíquota e item da lista
EndIf

Return

//--------------------------------------------------------------------------------------------------
/*/{Protheus.doc} RegB030()
  
REGISTRO B030: NOTA FISCAL DE SERVIÇOS SIMPLIFICADA (CÓDIGO 3A).

@author Ulisses P. Oliveira
@since 03/07/2019
@version 1.0
/*/
//--------------------------------------------------------------------------------------------------
Static Function RegB030(aRegB030,aRegB035,aRegB420,oObjSpdMov)

Local nPosB030	:= 0
Local lIssOutMun := oObjSpdMov:getMunDev() <> RetMunSM0()
Local nValCont	:= 0
Local nIsenOut	:= 0
Local nBcIss	:= 0
Local nValIss	:= 0

If lIssOutMun
	nValCont	:= nIsenOut	:= oObjSpdMov:getVlCont()
Else
	nValCont   := oObjSpdMov:getVlCont()
	nIsenOut   := oObjSpdMov:getIseOut()
	nBcIss	   := oObjSpdMov:getBCIss()
	nValIss	   := 	oObjSpdMov:getIss()
EndIF

nPosB030 := Ascan(aRegB030,{|a|a[2] == oObjSpdMov:getEspeci() .And. ;
                               a[3] == oObjSpdMov:getSerie()  .And. ;
			    		 	   a[4] == oObjSpdMov:getNumNf()  .And. ;
						       a[6] == oObjSpdMov:getEmiss()})
If nPosB030 == 0
	aAdd(aRegB030, {})
	nPosB030 := Len(aRegB030)
	aAdd(aRegB030[nPosB030], "B030")                                  //01 - REG          Texto fixo contendo "B030"
	aAdd(aRegB030[nPosB030], oObjSpdMov:getEspeci())                 //02 - COD_MOD      Código do modelo do documento fiscal, conforme a Tabela 4.1.3
	aAdd(aRegB030[nPosB030], oObjSpdMov:getSerie())					 //03 - SER          Série do documento fiscal
	aAdd(aRegB030[nPosB030], oObjSpdMov:getNumNf())                  //04 - NUM_DOC_INI  Número do primeiro documento fiscal emitido no dia
	aAdd(aRegB030[nPosB030], oObjSpdMov:getNumNf())                  //05 - NUM_DOC_FIN  Número do último documento fiscal emitido no dia
	aAdd(aRegB030[nPosB030], oObjSpdMov:getEmiss())                  //06 - DT_DOC       Data da emissão dos documentos fiscais
	aAdd(aRegB030[nPosB030], Iif(!Empty(oObjSpdMov:getdCanc()),"1","0"))  //07 - QTD_CANC     Quantidade de documentos cancelados
	
	IF !oObjSpdMov:getSitDoc() $ "02#04#05"	
		aAdd(aRegB030[nPosB030], nValCont)                   //08 - VL_CONT      Valor contábil (valor total acumulado dos documentos)
		aAdd(aRegB030[nPosB030], nIsenOut)                   //09 - VL_ISNT_ISS  Valor acumulado das operações isentas ou não-tributadas pelo ISS
		aAdd(aRegB030[nPosB030], nBcIss)                    //10 - VL_BC_ISS    Valor acumulado da base de cálculo do ISS
		aAdd(aRegB030[nPosB030], nValIss)                   //11 - VL_ ISS      Valor acumulado do ISS destacado
	Else
		aAdd(aRegB030[nPosB030], 0)                   						//08 - VL_CONT      Valor contábil (valor total acumulado dos documentos)
		aAdd(aRegB030[nPosB030], 0)                   						//09 - VL_ISNT_ISS  Valor acumulado das operações isentas ou não-tributadas pelo ISS
		aAdd(aRegB030[nPosB030], 0)                    						//10 - VL_BC_ISS    Valor acumulado da base de cálculo do ISS
		aAdd(aRegB030[nPosB030], 0)                       					//11 - VL_ ISS      Valor acumulado do ISS destacado
	EndIF
	
	aAdd(aRegB030[nPosB030], "")                                       //12 - COD_INF_OBS  Código da observação do lançamento fiscal (campo 02 do Registro 0460)

ElseIF !oObjSpdMov:getSitDoc() $ "02#04#05"	
	aRegB030[nPosB030][08] += nValCont                //08 - VL_CONT      Valor contábil (valor total acumulado dos documentos)
	aRegB030[nPosB030][09] += nIsenOut 			    //09 - VL_ISNT_ISS  Valor acumulado das operações isentas ou não-tributadas pelo ISS
	aRegB030[nPosB030][10] += nBcIss                 //10 - VL_BC_ISS    Valor acumulado da base de cálculo do ISS
	aRegB030[nPosB030][11] += nValIss                   //11 - VL_ ISS      Valor acumulado do ISS destacado	
EndIf

IF !oObjSpdMov:getSitDoc() $ "02#04#05"
	//------------------------------
	//Chama geração do registro B035
	//------------------------------	
	RegB035(@aRegB035, nValCont, nBcIss, oObjSpdMov:getAlqIss(), nValIss, nIsenOut, oObjSpdMov:getCodIss())

	//-------------------------
	//Totaliza no registro B420
	//-------------------------
	RegB420(@aRegB420, nValCont, nBcIss, nIsenOut, nValIss, oObjSpdMov:getCodIss(), oObjSpdMov:getAlqIss())
EndiF

Return

//--------------------------------------------------------------------------------------------------
/*/{Protheus.doc} RegB035()
  
REGISTRO B035: DETALHAMENTO POR COMBINAÇÃO DE ALÍQUOTA E ITEM DA LISTA DE SERVIÇOS DA LC 116/2003)

@author Ulisses P. Oliveira
@since 03/07/2019
@version 1.0
/*/
//--------------------------------------------------------------------------------------------------
Static Function RegB035(aRegB035, nValCont, nBcIss, nAlqIss, nValIss, nIsenOut, cCodIss)

Local nPos     := 0

//---Não podem ser informados, para um mesmo B030 “pai”, dois ou mais registros B035 com a mesma combinação de valores dos campos: ALIQ_ISS e COD_SERV---//
nPos := Ascan(aRegB035,{|a|a[4] == nAlqIss.And. a[7] == cCodIss})
If nPos == 0
	aAdd(aRegB035, {})
	nPos := Len(aRegB035)	
	aAdd(aRegB035[nPos], "B035")                   //01 - REG           Texto fixo contendo "B035"
	aAdd(aRegB035[nPos], nValCont)   //02 - VL_CONT_P     Parcela correspondente ao "Valor Contábil" referente à combinação da alíquota e item da lista
	aAdd(aRegB035[nPos], nBcIss)    //03 - VL_BC_ISS_P   Parcela correspondente ao "Valor da base de cálculo do ISS" referente à combinação da alíquota e item da lista
	aAdd(aRegB035[nPos], nAlqIss)   //04 - ALIQ_ISS      Alíquota do ISS
	aAdd(aRegB035[nPos], nValIss)      //05 - VL_ISS_P      Parcela correspondente ao "Valor do ISS" referente à combinação da alíquota e item da lista
	aAdd(aRegB035[nPos], nIsenOut)   //06 - VL_ISNT_ISS_P Parcela correspondente ao "Valor das operações isentas ou nãotributadas pelo ISS" referente à combinação da alíquota e item da lista
	aAdd(aRegB035[nPos], cCodIss)   //07 - COD_SERV      Item da lista de serviços, conforme Tabela 4.6.3.
Else
	aRegB035[nPos][2] += nValCont   //02 - VL_CONT_P     Parcela correspondente ao "Valor Contábil" referente à combinação da alíquota e item da lista
	aRegB035[nPos][3] += nBcIss     //03 - VL_BC_ISS_P   Parcela correspondente ao "Valor da base de cálculo do ISS" referente à combinação da alíquota e item da lista
	aRegB035[nPos][5] += nValIss       //05 - VL_ISS_P      Parcela correspondente ao "Valor do ISS" referente à combinação da alíquota e item da lista
	aRegB035[nPos][6] += nIsenOut    //06 - VL_ISNT_ISS_P Parcela correspondente ao "Valor das operações isentas ou nãotributadas pelo ISS" referente à combinação da alíquota e item da lista
EndIf

Return

//--------------------------------------------------------------------------------------------------
/*/{Protheus.doc} RegB420()
  
REGISTRO B420: TOTALIZAÇÃO DOS VALORES DE SERVIÇOS PRESTADOS POR COMBINAÇÃO DE ALÍQUOTA E ITEM DA 
               LISTA DE SERVIÇOS DA LC 116/2003.

@author Ulisses P. Oliveira
@since 03/07/2019
@version 1.0
/*/
//--------------------------------------------------------------------------------------------------
Static Function RegB420(aRegB420, nValCont, nBaseCalc, nOutIsn, nValIss, cCodIss, nAliq)

Local nPos := Ascan(aRegB420,{|a|a[4] == nAliq .And. a[7] == cCodIss})

If nPos == 0
	aAdd(aRegB420, {})
	nPos := Len(aRegB420)
	aAdd(aRegB420[nPos], "B420")    //01 - REG         Texto fixo contendo "B420" 
	aAdd(aRegB420[nPos], nValCont)  //02 - VL_CONT     Totalização do Valor Contábil das prestações do declarante referente à combinação da alíquota e item da lista
	aAdd(aRegB420[nPos], nBaseCalc) //03 - VL_BC_ISS   Totalização do Valor da base de cálculo do ISS das prestações do declarante referente à combinação da alíquota e item da lista
	aAdd(aRegB420[nPos], nAliq)     //04 - ALIQ_ISS    Alíquota do ISS
	aAdd(aRegB420[nPos], nOutIsn)   //05 - VL_ISNT_ISS Totalização do valor das operações isentas ou não-tributadas pelo ISS referente à combinação da alíquota e item da lista
	aAdd(aRegB420[nPos], nValIss) 	//06 - VL_ISS      Totalização, por combinação da alíquota e item da lista, do Valor do ISS
	aAdd(aRegB420[nPos], cCodIss)   //07 - COD_SERV    Item da lista de serviços, conforme Tabela 4.6.3.
Else
	aRegB420[nPos][2] += nValCont   //02 - VL_CONT_P     Parcela correspondente ao "Valor Contábil" referente à combinação da alíquota e item da lista
	aRegB420[nPos][3] += nBaseCalc  //03 - VL_BC_ISS_P   Parcela correspondente ao "Valor da base de cálculo do ISS" referente à combinação da alíquota e item da lista
	aRegB420[nPos][5] += nOutIsn    //05 - VL_ISS_P      Parcela correspondente ao "Valor do ISS" referente à combinação da alíquota e item da lista
	aRegB420[nPos][6] += nValIss  	//06 - VL_ISNT_ISS_P Parcela correspondente ao "Valor das operações isentas ou nãotributadas pelo ISS" referente à combinação da alíquota e item da lista
EndIf

Return
//--------------------------------------------------------------------------------------------------
/*/{Protheus.doc} DefCodIssB()
  
Função que auxilia a definição do código de ISS para os registros do bloco B

@author erick.dias
@since 05/07/2019
@version 12.1.23
/*/
//--------------------------------------------------------------------------------------------------
Static Function DefCodIssB(aProd, cCodProd, cCdIssItem)

Local cCodIss	:= ""
Local cProdCDN	:= ""
Local aAreaSB1 := SB1->(GetArea())

//---Obtendo o código do serviço através do cadastro da tabela CDN (LC 116/03)---//
If !Empty(aProd[10])
	cCodIss  := SubStr(aProd[10], 1, 4)
	cProdCDN := aProd[1]
Else
	SB1->(DbSetOrder(1))  
	If SB1->(MsSeek(aSPDFil[PFIL_SB1] + cCodProd))
		cCodIss :=  SubStr(SB1->B1_CODISS, 1, 5) 
		cProdCDN := SB1->B1_COD
	EndIf
EndIf

//Caso o código de ISS não esteja informado no cadstro de produto, adotará o código de ISS utilizado no item
If Empty(cCodIss)
	cCodIss	:= cCdIssItem
EndIF

If aSPDSX2[AI_CDN]
	If CDN->(MsSeek(aSPDFil[PFIL_CDN]+PadR(cCodIss,8)+cProdCDN))
		cCodIss := SubStr(CDN->CDN_CODLST, 1, 4)
	Elseif CDN->(MsSeek(aSPDFil[PFIL_CDN]+PadR(cCodIss,8)))
		cCodIss := SubStr(CDN->CDN_CODLST, 1, 4)
	EndIf
EndIf

cCodIss := StrTran(cCodIss,".","")	
If Len(AllTrim(cCodIss)) < 4 .And. !Empty(AllTrim(cCodIss))
	cCodIss := "0" + cCodIss
EndIf

RestArea(aAreaSB1)

Return cCodIss


//--------------------------------------------------------------------------------------------------
/*/{Protheus.doc} RegB440()
  
REGISTRO B440: TOTALIZAÇÃO DOS VALORES RETIDOS.

@author Ulisses P. Oliveira
@since 03/07/2019
@version 1.0
/*/
//--------------------------------------------------------------------------------------------------
Static Function RegB440(aRegB440,nValCont, oObjSpdMov)
Local nPos     := 0
//---Não podem ser informados, em um mesmo arquivo, dois ou mais registros B440 com a mesma combinação de valores dos campos: IND_OPER e COD_PART---//
nPos := Ascan(aRegB440,{|a|a[2] == oObjSpdMov:getIndOpe() .And. a[3] ==  oObjSpdMov:getPart()})
If nPos == 0
	aAdd(aRegB440, {})
	nPos := Len(aRegB440)
	aAdd(aRegB440[nPos], "B440")                                   //01 - REG          Texto fixo contendo "B440"
	aAdd(aRegB440[nPos], oObjSpdMov:getIndOpe())                   //02 - IND_OPER     Indicador do tipo de operação: 0 - Aquisição; 1 - Prestação
	aAdd(aRegB440[nPos], oObjSpdMov:getPart())                                    //03 - COD_PART     Código do participante (campo 02 do Registro 0150): - do prestador, no caso de aquisição de serviço pelo declarante; - do tomador, no caso de prestação de serviço pelo declarante
	aAdd(aRegB440[nPos], nValCont)                  				//04 - VL_CONT_RT   Totalização do Valor Contábil das prestações e/ou aquisições do declarante pela combinação de tipo de operação e participante. 
	aAdd(aRegB440[nPos], oObjSpdMov:getBCRet())                    //05 - VL_BC_ISS_RT Totalização do Valor da base de cálculo de retenção do ISS das prestações e/ou aquisições do declarante pela combinação de tipo de operação e participante.
	aAdd(aRegB440[nPos], oObjSpdMov:getIssRet())                   //06 - VL_ISS_RT    Totalização do Valor do ISS retido pelo tomador das prestações e/ou aquisições do declarante pela combinação de tipo de operação e participante.
Else
	aRegB440[nPos][4] += nValCont                   		 	  //04 - VL_CONT_RT   Totalização do Valor Contábil das prestações e/ou aquisições do declarante pela combinação de tipo de operação e participante. 
	aRegB440[nPos][5] += oObjSpdMov:getBCRet()                     //05 - VL_BC_ISS_RT Totalização do Valor da base de cálculo de retenção do ISS das prestações e/ou aquisições do declarante pela combinação de tipo de operação e participante.
	aRegB440[nPos][6] += oObjSpdMov:getIssRet()                    //06 - VL_ISS_RT    Totalização do Valor do ISS retido pelo tomador das prestações e/ou aquisições do declarante pela combinação de tipo de operação e participante.
EndIf

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} RegB460

Função que fará geração do registro B460, que trata das deduções do ISS
gravadas pela apuração FISA300

@author erick.dias
@since 04/07/2019
/*/
//-------------------------------------------------------------------
Static Function RegB460(aDeducoes, aRegB460, aReg0460)

Local nPos		:= 0
Local nX		:= 0
Local cCodObs	:= ""

//Laço nas deduções
For nX	:= 1 to Len(aDeducoes)

	aAdd(aRegB460, {})
	nPos := Len(aRegB460)

	cCodObs	:= aDeducoes[nX]:getCodObs()
	aAdd(aRegB460[nPos], "B460")//01-REG
	aAdd(aRegB460[nPos], aDeducoes[nX]:getTpDed())//02-IND_REG
	aAdd(aRegB460[nPos], aDeducoes[nX]:getValor())//03-VL_DED
	aAdd(aRegB460[nPos], aDeducoes[nX]:getNumProc())//04-NUM_PROC
	aAdd(aRegB460[nPos], aDeducoes[nX]:getOriProc())//05-IND_PROC
	aAdd(aRegB460[nPos], aDeducoes[nX]:getDesProc())//06-PROC
	aAdd(aRegB460[nPos], cCodObs)//07-COD_INF_OBS
	aAdd(aRegB460[nPos], aDeducoes[nX]:getIndObr())//08-IND_OBR

	//Gera o código de observação no registro 0460
	IF !Empty(cCodObs) .AND. CCE->(DbSeek(aSPDFil[PFIL_CCE] + cCodObs))		
		Reg0460(@aReg0460, {cCodObs, CCE->CCE_DESCR})
	EndIF

Next nY //Próxima deduções

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} RegB470

Função que fará geração do registro B470, que trata do registro de apuração
do ISS processada pela apuração FISA300

@author erick.dias
@since 04/07/2019
/*/
//-------------------------------------------------------------------
Static Function RegB470(aApurServ, aApurMun, aRegB470, nVlContOMun, lSemMvto)

Local nPos		:= 0

aAdd(aRegB470, {})
nPos := Len(aRegB470)

If !lSemMvto
	//Processa registro com as informações gravadas pela apuração
	aAdd(aRegB470[nPos], "B470")//01-REG
	aAdd(aRegB470[nPos], aApurServ:getValCont() + nVlContOMun)//02-VL_CONT
	aAdd(aRegB470[nPos], aApurServ:getMatTerc())//03-VL_MAT_TERC
	aAdd(aRegB470[nPos], aApurServ:getMatProp())//04-VL_MAT_PROP
	aAdd(aRegB470[nPos], aApurServ:getSubEmp())//05-VL_SUB
	aAdd(aRegB470[nPos], aApurServ:getIsent() + nVlContOMun)//06-VL_ISNT
	aAdd(aRegB470[nPos], aApurServ:getMatTerc() + aApurServ:getMatProp() + aApurServ:getSubEmp() + aApurServ:getIsent() + nVlContOMun)//07-VL_DED_BC
	aAdd(aRegB470[nPos], aApurServ:getBsCalc())//08-VL_BC_ISS
	aAdd(aRegB470[nPos], aApurServ:getBsRetPr())//09-VL_BC_ISS_RT
	aAdd(aRegB470[nPos], aApurServ:getISSDest())//10-VL_ISS
	aAdd(aRegB470[nPos], aApurServ:getISSRetP())//11-VL_ISS_RT
	aAdd(aRegB470[nPos], aApurMun:getDedProp())//12-VL_DED
	aAdd(aRegB470[nPos], aApurMun:getISSProp())//13-VL_ISS_REC
	aAdd(aRegB470[nPos], aApurMun:getISSSub())//14-VL_ISS_ST
	aAdd(aRegB470[nPos], aApurMun:getISSUni())//15-VL_ISS_REC_UNI
Else
	//Se não houver movimentação então gera registro B470 zerado
	aAdd(aRegB470[nPos], "B470")//01-REG
	aAdd(aRegB470[nPos], nVlContOMun)//02-VL_CONT
	aAdd(aRegB470[nPos], 0)//03-VL_MAT_TERC
	aAdd(aRegB470[nPos], 0)//04-VL_MAT_PROP
	aAdd(aRegB470[nPos], 0)//05-VL_SUB
	aAdd(aRegB470[nPos], nVlContOMun)//06-VL_ISNT
	aAdd(aRegB470[nPos], nVlContOMun)//07-VL_DED_BC
	aAdd(aRegB470[nPos], 0)//08-VL_BC_ISS
	aAdd(aRegB470[nPos], 0)//09-VL_BC_ISS_RT
	aAdd(aRegB470[nPos], 0)//10-VL_ISS
	aAdd(aRegB470[nPos], 0)//11-VL_ISS_RT
	aAdd(aRegB470[nPos], 0)//12-VL_DED
	aAdd(aRegB470[nPos], 0)//13-VL_ISS_REC
	aAdd(aRegB470[nPos], 0)//14-VL_ISS_ST
	aAdd(aRegB470[nPos], 0)//15-VL_ISS_REC_UNI
EndIF

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} RegB500

Função que fará geração do registro B500, com resumo do valore de ISS
da Sociedade Uniprofissional

@author erick.dias
@since 04/07/2019
/*/
//-------------------------------------------------------------------
Static Function RegB500(aApurMun, aRegB500)

Local nPos := 0

If (aApurMun:getRecUni() + aApurMun:getProfHab() + aApurMun:getISSUni() > 0)

	aAdd(aRegB500, {})
	nPos := Len(aRegB500)

	aAdd(aRegB500[nPos], "B500")//01-REG
	aAdd(aRegB500[nPos], aApurMun:getRecUni())//02-VL_REC
	aAdd(aRegB500[nPos], Alltrim(cValtoChar(aApurMun:getProfHab())))//03-QTD_PROF 
	aAdd(aRegB500[nPos], aApurMun:getISSUniDev())//04-VL_OR

EndIf

Return nPos

//-------------------------------------------------------------------
/*/{Protheus.doc} RegB510

Função que processa registro B510

@author erick.dias
@since 05/07/2019
/*/
//-------------------------------------------------------------------
Static Function RegB510(dDtFim, aRegB510, nPosPai)

Local nPos		:= 0
Local cAlsUni 	:= FSA300EQRY("EMPREGADOS_SOCIOS", {dDtFim})[1] //Executa a query da F1S

//Laço nos sócios cadastrados
While (cAlsUni)->(!Eof())

	aAdd(aRegB510, {})
	nPos	:= Len(aRegB510)
	
	aAdd(aRegB510[nPos], nPosPai) //Relacionamento com registro B500
	aAdd(aRegB510[nPos], "B510") //01-Reg
	aAdd(aRegB510[nPos], "0" ) //02-Ind_Prof. Por padrão somente serão gerados profissionais habilitados, por conta do controle de vigência.
	aAdd(aRegB510[nPos], (cAlsUni)->F1S_ESCOL) //03-Ind_Esc
	aAdd(aRegB510[nPos], (cAlsUni)->F1S_PARSOC) //04-Ind_Soc
	aAdd(aRegB510[nPos], (cAlsUni)->F1S_CPF) //05-CPF
	aAdd(aRegB510[nPos], (cAlsUni)->F1S_NOME) //06-Nome

	(cAlsUni)->(dbSkip())

EndDo

(cAlsUni)->(dbCloseArea())

Return

//--------------------------------------------------------------------------------------------------
/*/{Protheus.doc} RegB350()
  
REGISTRO B350: SERVIÇOS PRESTADOS POR INSTITUIÇÕES FINANCEIRAS

@author joao.pellegrini
@since 04/07/2019
@version 1.0
/*/
//--------------------------------------------------------------------------------------------------
Static Function RegB350(aRegB350, aRegB420, aReg0460, dDataAte)

Local nPos := 0
Local cAlsB350 := ""
Local aParams := {}
Local cNomeCTA := ""

// Execução da query - FISA300E.PRW
aParams := {cValToChar(Year(dDataAte)) + StrZero(Month(dDataAte), 2)}
cAlsB350 := FSA300EQRY("INSTFIN", aParams)[1]

While (cAlsB350)->(!Eof())

	If (nPos := aScan(aRegB350, {|x| x[2] == (cAlsB350)->CLL_CODCTA .And. x[4] == (cAlsB350)->CLL_COSIF .And. x[6] == (cAlsB350)->CLL_CODLST .And. x[9] == (cAlsB350)->CLL_ALQISS}) == 0)
		aAdd(aRegB350, {})
		nPos := Len(aRegB350)
		aAdd(aRegB350[nPos], "B350")
		aAdd(aRegB350[nPos], (cAlsB350)->CLL_CODCTA)
		If CT1->(dbSeek(aSPDFil[PFIL_CT1]+(cAlsB350)->CLL_CODCTA))
			cNomeCTA := CT1->CT1_DESC01
		EndIf
		aAdd(aRegB350[nPos], cNomeCTA)
		aAdd(aRegB350[nPos], (cAlsB350)->CLL_COSIF)
		aAdd(aRegB350[nPos], cValToChar((cAlsB350)->CLL_QUANT))
		aAdd(aRegB350[nPos], (cAlsB350)->CLL_CODLST)
		aAdd(aRegB350[nPos], (cAlsB350)->CLL_VALCON)
		aAdd(aRegB350[nPos], (cAlsB350)->CLL_BASISS)
		aAdd(aRegB350[nPos], (cAlsB350)->CLL_ALQISS)
		aAdd(aRegB350[nPos], (cAlsB350)->CLL_VALISS)
		aAdd(aRegB350[nPos], (cAlsB350)->CLL_OBS)

		//Gera o código de observação no registro 0460
		IF !Empty((cAlsB350)->CLL_OBS) .AND. CCE->(DbSeek(aSPDFil[PFIL_CCE] + (cAlsB350)->CLL_OBS))		
			Reg0460(@aReg0460, {(cAlsB350)->CLL_OBS, CCE->CCE_DESCR})
		EndIF
	Else
		aRegB350[nPos, 7] += (cAlsB350)->CLL_VALCON
		aRegB350[nPos, 8] += (cAlsB350)->CLL_BASISS
		aRegB350[nPos, 10] += (cAlsB350)->CLL_VALISS
	EndIf

	//Acumula valores no B420	
	RegB420(@aRegB420, (cAlsB350)->CLL_VALCON, (cAlsB350)->CLL_BASISS, 0, (cAlsB350)->CLL_VALISS, (cAlsB350)->CLL_CODLST, (cAlsB350)->CLL_ALQISS)

	(cAlsB350)->(dbSkip())

EndDo

// Fecha o alias utilizado
(cAlsB350)->(dbCloseArea())

Return

//--------------------------------------------------------------------------------------------------
/*/{Protheus.doc} RetMunSM0()
Função responsável por retornar o código do município do SIGAMAT.

@author joao.pellegrini
@since 05/07/2019
@version 1.0
/*/
//--------------------------------------------------------------------------------------------------
Static Function RetMunSM0()

Local cMunSM0 := Iif(Len(Alltrim(SM0->M0_CODMUN)) < 7, RetUfIBGE(SM0->M0_ESTENT)+SM0->M0_CODMUN, SM0->M0_CODMUN)

Return cMunSM0

//-------------------------------------------------------------------
/*/{Protheus.doc} Add0210
@Erick Dias
@since 18/07/2019
@version 12.1.23

Função que adicoona nova linha no array do registro 0210

/*/
//-------------------------------------------------------------------
Static Function Add0210(aReg0210, nPos, lConcFil, cFilSB1, cCoditem, nQtdComp, nQtdPerda)

Local nPos0210	:= 0

aAdd(aReg0210, {})
nPos0210    :=  Len(aReg0210)
aAdd(aReg0210[nPos0210], nPos)                                       //00-Relacionamento com o PAI
aAdd(aReg0210[nPos0210], "0210")                                    //01 - REG
aAdd(aReg0210[nPos0210], cCoditem + Iif(lConcFil,cFilSB1,"") )    	//02 - COD_ITEM_COMP 
aAdd(aReg0210[nPos0210], {nQtdComp,6})                     		//03 - QTD_COMP
aAdd(aReg0210[nPos0210], {nQtdPerda,4})                  			//04 - PERDA
	            
Return

//-------------------------------------------------------------------
/*/{Protheus.doc} Reg0002
@Weslley T. Pereira
@since 03/10/2019
@version 12.1.25

Função para geração e gravação do registro 0002

/*/
//-------------------------------------------------------------------
Static Function Reg0002(aWizard, cAlias)
Local aReg := {}
Local lRet := .T.
Local nPos := 0

//LAYOUT 2019       
aAdd(aReg, {})
nPos :=	Len(aReg)
aAdd(aReg[nPos], "0002")								//01 - REG	
aAdd(aReg[nPos], SubStr(aWizard[2][8], 1, 2))			//02 - CLAS_ESTAB_IND

GrvRegTrS(cAlias,, aReg)

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} C595C597
@Weslley T. Pereira
@since 14/10/2019
@version 12.1.25

Função para geração e gravação dos registros C595 e C597

/*/
//-------------------------------------------------------------------
Static Function C595C597(cAlias,nRelac,aLanCDA,aReg0460,aCmpAntSFT,cEspecie,aC595aux,aReg0200,aReg0190,aReg0220,dDataDe,dDataAte,aWizard )
Local nPos	   := 0
Local nPosC595 := 0
Local nX	   := 0
Local nPos595  := 0
Local aRegC595 := {}
Local aRegC597 := {}
Local cCodItem := ""

//Processando lancamentos do documento fiscal relacionados no CDA

For nX := 1 To len(aLanCDA)

	cCodItem := aLanCDA[nX,13]
	
	//Geracao do REGISTRO C595
	If (nPosC595 := aScan(aRegC595, {|aX| aX[2] == aLanCDA[nX][07]})) == 0
		aAdd(aRegC595, {})
		nPosC595 :=	Len(aRegC595)
		aAdd(aRegC595[nPosC595],          "C595")  //01 - REG
		aAdd(aRegC595[nPosC595], aLanCDA[nX][07])  //02 - COD_OBS
		aAdd(aRegC595[nPosC595], aLanCDA[nX][17])  //03 - TXT_COMPL		

		aAdd(aRegC595[nPosC595], RetRD(GetRelacPr())+strzero(nPosC595,nTamFT_IT))		//4 - Posição de Hierarquia  		
		
		//REGISTRO 0460 - TABELA DE OBSERVACOES DO LANCAMENTO FISCAL
		Reg0460(@aReg0460, {aLanCDA[nX][7], aLanCDA[nX][20]})
	EndIf
	
	//Geracao do REGISTRO C597
	If (nPos := aScan(aRegC597, {|x| x[5] == cCodItem .And. x[3] == aLanCDA[nX, 1]})) == 0
		aAdd(aRegC597, {})
		nPos := Len(aRegC597)
		aAdd(aRegC597[nPos],       nPosC595)  //RELACIONAMENTO COM C595 (PAI)
		aAdd(aRegC597[nPos],         "C597")  //01 - REG
		aAdd(aRegC597[nPos], aLanCDA[nX][1])  //02 - COD_AJ
		aAdd(aRegC597[nPos], aLanCDA[nX][2])  //03 - DESCR_COMPL_AJ
		aAdd(aRegC597[nPos],       cCodItem)  //04 - COD_ITEM
		aAdd(aRegC597[nPos], aLanCDA[nX][3])  //05 - VL_BC_ICMS
		aAdd(aRegC597[nPos], aLanCDA[nX][4])  //06 - ALIQ_ICMS
		aAdd(aRegC597[nPos], aLanCDA[nX][5])  //07 - VL_ICMS
		aAdd(aRegC597[nPos], aLanCDA[nX][6])  //08 - VL_OUTROS

		aAdd(aRegC597[nPos], RetRD(GetRelacPr())+strzero(nPosC595,nTamFT_IT))		//4 - Posição de Hierarquia  		
	Else
	    aRegC597[nPos][6] += aLanCDA[nX][3]	 //06 - VL_BC_ICMS
		aRegC597[nPos][8] += aLanCDA[nX][5]	 //07 - VL_ICMS
		aRegC597[nPos][9] += aLanCDA[nX][6]	 //08 - VL_OUTROS
	EndIf
Next

//³Tratamento para que os itens utilizados seja gerados no 0200³
If !Empty( cCodItem ) .And.  aScan ( aReg0200, { |aX| aX[2] == cCodItem }) == 0
	SPEDSeek("SB1",,aSPDFil[PFIL_SB1]+cCodItem)
	SFRG0200( cAlias, @aReg0200, @aReg0190, dDataDe, dDataAte, ,cCodItem , @aReg0220,,,,,,,,,,,,,,,,,,,aWizard  )
EndIf	

//Geracao do REGISTRO C595
For nX := 1 To Len(aC595aux)  
	If !(Empty(aC595aux[nX][3]))
		If (nPos595 := aScan(aRegC595, {|aX| aX[2] == aC595aux[nX][1]})) == 0
			aAdd(aRegC595, {})
			nPos595	:=	Len(aRegC595)
			aAdd(aRegC595[nPos595],          "C595")  //01 - REG
			aAdd(aRegC595[nPos595], aC595aux[nX][1])  //02 - COD_OBS
			aAdd(aRegC595[nPos595], aC595aux[nX][3])  //03 - TXT_COMPL

			aAdd(aRegC595[nPos595], RetRD(GetRelacPr())+strzero(nPos595,nTamFT_IT))		//4 - Posição de Hierarquia  		
			
			//REGISTRO 0460 - TABELA DE OBSERVACOES DO LANCAMENTO FISCAL
			Reg0460(@aReg0460, {aC595aux[nX][1], aC595aux[nX][2]})
		EndIf
	EndIf
Next nX

//GrRegDep(cAlias, aRegC595, aRegC597, , , , nRelac)
GrRegDep(cAlias, aRegC595, aRegC597,,,,,,.T.,.T.)

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} REGC870
@description REGISTRO C870:  ITENS DO RESUMO DIÁRIO DOS DOCUMENTOS (CF-E-SAT) (CÓDIGO 59)
@author Weslley Tadeu Pereira
@since 16/10/2019
@version 12.1.25
/*/
Static Function RegC870(nPosC860,aRegC870,cAliasSFT,cUnid,cSituaDoc,aReg0190,aReg0200,cAlias,aRegC880, cHierarq)

Local nPos 	   := 0
Local cChave   := ''
Local cCodItem := (cAliasSFT)->FT_PRODUTO

If !cSituaDoc$"02/03/04/05"
	// Se build superior a "7.00.131227A" faz a busca no HashMap para ganho de performance.
	If lBuild
		cChave := str(nPosC860)+cCodItem+str((cAliasSFT)->FT_QUANT)+cUnid+(cAliasSFT)->FT_CFOP+(cAliasSFT)->FT_CLASFIS
		nPos   := FisFindHash(oHashC870, cChave)
	Else
		nPos := Ascan(aRegC870, {|x| x[1]==nPosC860 .AND. x[2]==cCodItem .And. x[3]==(cAliasSFT)->FT_QUANT .And.;
					  x[4]==cUnid .AND. x[5]==(cAliasSFT)->FT_CFOP  .And. x[6]==(cAliasSFT)->FT_CLASFIS})
	EndIf

	If nPos == 0
		aAdd(aRegC870, {})
		nPos := Len(aRegC870)
		aAdd(aRegC870[nPos], 		        nPosC860)  //00 - RELACIONAMENTO COM REGISTRO PAI
		aAdd(aRegC870[nPos],                  "C870")  //01 - REG
		aAdd(aRegC870[nPos],                cCodItem)  //02 - COD_ITEM
		aAdd(aRegC870[nPos],   (cAliasSFT)->FT_QUANT)  //03 - QTD
		aAdd(aRegC870[nPos],                   cUnid)  //04 - UNID 
		aAdd(aRegC870[nPos], (cAliasSFT)->FT_CLASFIS)  //05 - CST_ICMS 
		aAdd(aRegC870[nPos],    (cAliasSFT)->FT_CFOP)  //06 - CFOP

		cHierarq :=  cHierarq + "C870" + StrZero(nPos, nTTRBITEM, 0)
	
		aAdd (aRegC870[nPos], cHierarq )				//07 - Posicao de Hierarquia, utilizada para organizacao dos registros

		If lBuild
			FisAddHash(oHashC870, cChave, nPos)
		EndIf
		RegApurST("C880",aRegC880,cAliasSFT,,,,nPosC860, ,cHierarq)
		//Tratamento para que os itens utilizados sejam gerados no 0200 e 0190
		SFRG0200(cAlias, @aReg0200, @aReg0190,,,, cCodItem,,, cUnid,,,,,,,,,,,,,,,,,)
	EndIf
EndIf

Return nPos

/*/{Protheus.doc} R12501255
@description  
REGISTRO 1250: INFORMAÇÕES CONSOLIDADAS DE SALDOS DE RESTITUIÇÃO, RESSARCIMENTO E COMPLEMENTAÇÃO DO ICMS
REGISTRO 1255: INFORMAÇÕES CONSOLIDADAS DE SALDOS DE RESTITUIÇÃO, RESSARCIMENTO E COMPLEMENTAÇÃO DO ICMS POR MOTIVO 
@author Raphael Augusto
@since 08/11/2019
@version 12.1.25
/*/
Static Function R12501255(bWhileSM0,cFilDe,dDataDe,dDataAte,cAlias,aWizard,oProcess,nRegsProc,nCtdFil,aLisFil,nCountTot,lEnd,cFilAte)
Local aReg1250 := {}
Local aReg1255 := {}
Local nPos1250 := 0
Local nPos1255 := 0
Local cDataDe  := DTOS(dDataDe)
Local cPeriodo := SubStr(cDataDe,1,4) + SubStr(cDataDe,5,2)

If lRegCompST
	CIG->(DbSetOrder(1))
	CIH->(DbSetOrder(1))

	 If CIG->( DbSeek( aSPDFil[PFIL_CIG] + cPeriodo ) )
		aAdd(aReg1250, {})
		nPos1250 :=	Len(aReg1250)
		aAdd(aReg1250[nPos1250],  "1250" )  //01 - REG
		aAdd(aReg1250[nPos1250], CIG->CIG_VCREDI )  //02 - VL_CREDITO_ICMS_OP - CIG_VCREDI
		aAdd(aReg1250[nPos1250], CIG->CIG_VRESSA )  //03 - VL_ICMS_ST_REST - CIG_VRESSA
		aAdd(aReg1250[nPos1250], CIG->CIG_REFECP )  //04 - VL_FCP_ST_REST - CIG_REFECP
		aAdd(aReg1250[nPos1250], CIG->CIG_VCMPL  )  //05 - VL_ICMS_ST_COMPL - CIG_VCMPL
		aAdd(aReg1250[nPos1250], CIG->CIG_VCMFCP )  //06 - VL_FCP_ST_COMPL - CIG_VCMFCP

		If CIH->( DbSeek( aSPDFil[PFIL_CIH] + CIG->CIG_PERIOD ) )
			While CIH->(!Eof()) .And. CIH->( CIH_FILIAL+CIH_PERIOD) == CIG->( CIG_FILIAL + CIG_PERIOD )

				//---Geracao do REGISTRO 1255---//
				nPos1255 := Ascan(aReg1255,{|a|a[3] == CIH->CIH_ENQLEG})
				If nPos1255 == 0
					aAdd(aReg1255, {})
					nPos1255 := Len(aReg1255)
					aAdd(aReg1255[nPos1255], nPos1250)  //RELACIONAMENTO COM PAI
					aAdd(aReg1255[nPos1255], "1255")  //01 - REG
					aAdd(aReg1255[nPos1255],  CIH->CIH_ENQLEG   )  //02 - COD_MOT_REST_COMPL -
					aAdd(aReg1255[nPos1255],  CIH->CIH_VCREDI   )  //03 - VL_CREDITO_ICMS_OP_MOT -
					aAdd(aReg1255[nPos1255],  CIH->CIH_VRESSA   )  //04 - VL_ICMS_ST_REST_MOT -
					aAdd(aReg1255[nPos1255],  CIH->CIH_REFECP   )  //05 - VL_FCP_ST_REST_MOT -
					aAdd(aReg1255[nPos1255],  CIH->CIH_VCOMPL   )  //06 - VL_ICMS_ST_COMPL_MOT -
					aAdd(aReg1255[nPos1255],  CIH->CIH_VCMFCP    )  //07 - VL_FCP_ST_COMPL_MOT -
				Else
					aReg1255[nPos1255][4] += CIH->CIH_VCREDI
					aReg1255[nPos1255][5] += CIH->CIH_VRESSA
					aReg1255[nPos1255][6] += CIH->CIH_REFECP
					aReg1255[nPos1255][7] += CIH->CIH_VCOMPL
					aReg1255[nPos1255][8] += CIH->CIH_VCMFCP
				EndIf

				CIH->(DbSkip())
			End
		EndIf
	EndIf

	If Len(aReg1255) > 0
		GrRegDep(cAlias, aReg1250, aReg1255)
	EndIf
EndIf

Return


//-------------------------------------------------------------------
/*/{Protheus.doc} RegApurST
@description REGISTRO XXX 
Centraliza a geração dos registros de apuração do ICMS ST ressarciamento /  restituição /  em uma única função.
c180, c185, C330, C380, C430, C480, C810 e C815
@author Raphael Augusto
@since 08/11/2019
@version 12.1.25
/*/
Function RegApurST(cReg,aReg,cAliasSFT,cAlias,cRelacDoc,nItem,nPosPai,aRegC170, cHierarq, cHiC815)
Local 	cEnq      := ''
Local   cUF11C185 := 'RS|' //---UFs que exigem o preenchimento do Campo 11-VL_UNIT_ICMS_OP_CONV do Registro C185 / Campo 17-VL_UNIT_ICMS_OP_CONV_SAIDA do Registro C181. ---//
Default cReg	  := ""
Default aReg	  := {}

// A formação dos array está atrelada ao tipo de relacionamento
// c180 SPDLeRegRel  > GrvRegTrS   | > GrRegDep > GrvRegTrS  
// c185 SPDRePorNf > GrvRegTrS | 
// C380 SPDLeRegRel
// C430 GrRegDep
// C480 GrRegDep
If lRegCompST .And. !Empty( (cAliasSFT)->CII_ITEM ) .And. (!aSPDSX3[FP_CII_SPED] .Or. (cAliasSFT)->CII_SPED != '2') 
	If cReg == "C180" //---Entradas---//

		AADD( aReg , {} )
		nPos	:= Len(aReg)
		AADD(aReg[nPos], cReg ) 						//01 - REG
		AADD(aReg[nPos],  (cAliasSFT)->CII_CODRES ) 	//02 - COD_RESP_RET CII_CODRES
		AADD(aReg[nPos], {(cAliasSFT)->CII_QTDMOV,6} ) 	//03 - QUANT_CONV CII_QTDMOV
		AADD(aReg[nPos],  (cAliasSFT)->CII_UNID ) 		//04 - UNID CII_UNID
		AADD(aReg[nPos], {(cAliasSFT)->CII_VUNIT,6} )	//05 - VL_UNIT_CONV CII_VUNIT
		AADD(aReg[nPos], {(cAliasSFT)->CII_ICMEFE,6} ) 	//06 - VL_UNIT_ICMS_OP_CONV CII_VUNIT
		AADD(aReg[nPos], {(cAliasSFT)->CII_BURET,6} ) 	//07 - VL_UNIT_BC_ICMS_ST_CONV CII_BURET
		AADD(aReg[nPos], {(cAliasSFT)->CII_VURET,6} ) 	//08 - VL_UNIT_ICMS_ST_CONV CII_VURET
		AADD(aReg[nPos], {(cAliasSFT)->CII_VURFCP,6} ) 	//09 - VL_UNIT_FCP_ST_CONV CII_VURFCP
		AADD(aReg[nPos],  (cAliasSFT)->CII_CODDA ) 		//10 - COD_DA CII_CODDA
		AADD(aReg[nPos],  (cAliasSFT)->CII_NUMDA ) 		//11 - NUM_DA CII_NUMDA
		//GrvRegTrS(cAlias,cRelacDoc,aReg,nItem)	
		GrvRegTrS(cAlias,GetRelaGrv(cRelacDoc, 5),aReg,nItem)	
		
	ElseIf cReg $ "C185,C330,C380,C430,C480,C810,C815,C880" //---Saídas---//
		cEnq	:= SubStr(AllTrim((cAliasSFT)->CII_ENQLEG),3,1)
		AADD( aReg , {} )
		nPos	:= Len(aReg)

		If cReg $ "C330,C430,C480,C810,C815,C880"
			AADD(aReg[nPos], nPosPai ) 						// REGISTRO PAI 
		EndIf

		AADD(aReg[nPos], cReg ) 							//01 - REG GENERICO

		If cReg $ "C185,C810"
			AADD(aReg[nPos], (cAliasSFT)->CII_ITEM ) 		//02 - NUM_ITEM CII_ITEM / AllTrim(Str(nItem))
			AADD(aReg[nPos], aRegC170[1][3] ) 				//03 - COD_ITEM CII_PRODUT
			If cReg == "C810"
				AADD(aReg[nPos], (cAliasSFT)->CII_QTDMOV ) 	//04 - QTD  CII_QTDMOV
				AADD(aReg[nPos], (cAliasSFT)->CII_UNID ) 	//05 - UNID CII_UNID	
				AADD(aReg[nPos], (cAliasSFT)->CII_VUNIT ) 	//06 - VL_ITEM CII_VUNIT	
			EndIf
			AADD(aReg[nPos], (cAliasSFT)->FT_CLASFIS ) 		//04 OU 07 - CST_ICMS CII_CST
			AADD(aReg[nPos], (cAliasSFT)->CII_CFOP ) 		//05 OU 08 - CFOP CII_CFOP
			If cReg == "C810"
				cHierarq :=  cHierarq + "C810" + StrZero(nPos, nTTRBITEM, 0) 
				aAdd (aReg[nPos], cHierarq )			//09 - Posicao de Hierarquia, utilizada para organizacao dos registros
				cHiC815 := cHierarq
				Return
			EndIf
		EndIf

		AADD(aReg[nPos], (cAliasSFT)->CII_ENQLEG) 			//02 OU 06 - COD_MOT_REST_COMPL / IND_REST_COMPL CII_ENQLEG
		AADD(aReg[nPos],{(cAliasSFT)->CII_QTDMOV,6}) 		//03 OU 07 - QUANT_CONV CII_QTDMOV
		AADD(aReg[nPos], (cAliasSFT)->CII_UNID) 			//04 OU 08 - UNID CII_UNID
		If !(cAliasSFT)->(FieldPos("CII_VUNCON")>0)			//05 OU 09 - VL_UNIT_CONV
			AADD(aReg[nPos], {(cAliasSFT)->CII_VUNIT ,6})
		Else 
			AADD(aReg[nPos], {(cAliasSFT)->CII_VUNCON,6}) 	 
		EndIf
																															//C815...    	    //C185
		AADD(aReg[nPos], Iif( cEnq $ "0|2|"                                       , '' , {(cAliasSFT)->CII_ICMEFS,6} )  )	//06 		OU 		10 - VL_UNIT_ICMS_NA_OPERACAO_CONV
		If aSPDSX6[MV_ESTADO] == "MG"	// Regras campo 11 de MG e RS são proprias para cada UF
			AADD(aReg[nPos], Iif( cEnq $ "0|1|3" .Or. (cAliasSFT)->CII_VUCRED == 0 , '' , {(cAliasSFT)->CII_VUCRED,6} )  )
		Else
			AADD(aReg[nPos], Iif( cEnq $ "0|1|3" .Or. !aSPDSX6[MV_ESTADO] $ cUF11C185 , '' , {(cAliasSFT)->CII_VUCRED,6} )  )
		Endif
		AADD(aReg[nPos], Iif( cEnq $ "0|"                                         , '' , {(cAliasSFT)->CII_MUCRED,6} )  )	//08 		OU 		12 - VL_UNIT_ICMS_OP_ESTOQUE_CONV
		AADD(aReg[nPos], Iif( cEnq $ "0|"                                         , '' , {(cAliasSFT)->CII_MUVSTF,6} )  )	//09 		OU 		13 - VL_UNIT_ICMS_ST_ESTOQUE_CONV
		AADD(aReg[nPos], Iif( cEnq $ "0|"                                         , '' , {(cAliasSFT)->CII_MUVSF ,6} )  )	//10 		OU 		14 - VL_UNIT_FCP_ICMS_ST_ESTOQUE_CONV
		AADD(aReg[nPos], Iif( cEnq $ "0|3|"                                       , '' , {(cAliasSFT)->CII_VUREST,6} )  )	//11 		OU 		15 - VL_UNIT_ICMS_ST_CONV_REST
		AADD(aReg[nPos], Iif( cEnq $ "0|3|"                                       , '' , {(cAliasSFT)->CII_VURTFC,6} )  )	//12 		OU 		16 - VL_UNIT_FCP_ST_CONV_REST
		AADD(aReg[nPos], Iif( cEnq $ "0|1|2|"                                     , '' , {(cAliasSFT)->CII_VUCST ,6} )  )	//13 		OU 		17 - VL_UNIT_ICMS_ST_CONV_COMPL
		AADD(aReg[nPos], Iif( cEnq $ "0|1|2|"                                     , '' , {(cAliasSFT)->CII_VUCFC ,6} )  )	//14 		OU 		18 - VL_UNIT_FCP_ST_CONV_COMPL

		If cReg $ "C815"
			cHierarq :=  cHierarq + "C815" + StrZero(nPos, nTTRBITEM, 0) 
			aAdd (aReg[nPos], cHierarq )			//19 - Posicao de Hierarquia, utilizada para organizacao dos registros
		Endif	

		If cReg $ "C880"
			cHierarq :=  cHierarq + "C880" + StrZero(nPos, nTTRBITEM, 0) 
			aAdd (aReg[nPos], cHierarq )			//19 - Posicao de Hierarquia, utilizada para organizacao dos registros
		Endif			

		If cReg $ "C430,C480"
			AADD(aReg[nPos], (cAliasSFT)->FT_CLASFIS )		//15 - CST_ICMS CII_CST
			AADD(aReg[nPos], (cAliasSFT)->CII_CFOP   )		//16 - CFOP CII_CFOP			
		EndIF

	ElseIf cReg == "C181" //---Devoluções de Saídas---//
		cEnq	 := SubStr(AllTrim((cAliasSFT)->CII_ENQLEG),3,1)
		cEspecie := AModNot((cAliasSFT)->FT_ESP_ORI)

		AADD( aReg , {} )
		nPos	:= Len(aReg)
		AADD(aReg[nPos], cReg )													//01 - REG
		AADD(aReg[nPos], (cAliasSFT)->CII_ENQLEG )								//02 - COD_MOT_REST_COMPL CII_ENQLEG
		AADD(aReg[nPos],{(cAliasSFT)->CII_QTDMOV,6} )							//03 - QUANT_CONV CII_QTDMOV
		AADD(aReg[nPos], (cAliasSFT)->CII_UNID )								//04 - UNID CII_UNID
		AADD(aReg[nPos], cEspecie )												//05 - COD_MOD_SAIDA

		If cEspecie $ "01|1B|04"
			AADD(aReg[nPos], (cAliasSFT)->FT_SERORI )							//06 - SERIE_SAIDA
		Else
			AADD(aReg[nPos], "" )												//06 - SERIE_SAIDA
		EndIf

		If cEspecie $ "02|2D" //Atualmente, esse modelo não é suportado pelo layout por conta 
			AADD(aReg[nPos], (cAliasSFT)->CII_PDV )								//07 - ECF_FAB_SAIDA 
		Else
			AADD(aReg[nPos], "" )												//07 - ECF_FAB_SAIDA 
		EndIf

		If cEspecie $ "01|1B|04|02|2D"
			AADD(aReg[nPos], (cAliasSFT)->FT_NFORI )							//08 - NUM_DOC_SAIDA
		Else
			AADD(aReg[nPos], "" )												//08 - NUM_DOC_SAIDA
		EndIf

		If cEspecie $ "55|59|60|65"
			AADD(aReg[nPos], (cAliasSFT)->FT_CHV_ORI)							//09 - CHV_DFE_SAIDA
		Else
			AADD(aReg[nPos], "" )												//09 - CHV_DFE_SAIDA
		EndIf

		AADD(aReg[nPos], StoD((cAliasSFT)->FT_EMI_ORI))							//10 - DT_DOC_SAIDA
		AADD(aReg[nPos], (cAliasSFT)->FT_ITEMORI )								//11 - NUM_ITEM_SAIDA
		AADD(aReg[nPos],{(cAliasSFT)->CII_VUNIT,6} )							//12 - VL_UNIT_CONV_SAIDA CII_VUNIT
		AADD(aReg[nPos],{(cAliasSFT)->CII_MUCRED,6} )							//13 - VL_UNIT_ICMS_OP_ESTOQUE_CONV_SAIDA CII_MUCRED
		AADD(aReg[nPos],{(cAliasSFT)->CII_MUVSTF,6} )							//14 - VL_UNIT_ICMS_ST_ESTOQUE_CONV_SAIDA CII_MUVSTF
		AADD(aReg[nPos],{(cAliasSFT)->CII_MUVSF,6} )							//15 - VL_UNIT_FCP_ICMS_ST_ESTOQUE_CONV_SAIDA CII_MUVSF

		AADD(aReg[nPos], Iif( cEnq $ "5|7"                                         , '' ,{(cAliasSFT)->CII_ICMEFS,6} ))	//16 - VL_UNIT_ICMS_NA_OPERACAO_CONV_SAIDA CII_ICMEFS
		AADD(aReg[nPos], Iif( cEnq $ "5|6|8" .Or. !aSPDSX6[MV_ESTADO] $ cUF11C185  , '' ,{(cAliasSFT)->CII_VUCRED,6} ))	//17 - VL_UNIT_ICMS_OP_CONV_SAIDA CII_VCREDI
		AADD(aReg[nPos], Iif( cEnq $ "5|6|7"                                       , '' ,{(cAliasSFT)->CII_VUREST,6} ))	//18 - VL_UNIT_ICMS_ST_CONV_REST CII_VUREST
		AADD(aReg[nPos], Iif( cEnq $ "5|6|7"                                       , '' ,{(cAliasSFT)->CII_VURTFC,6} ))	//19 - VL_UNIT_FCP_ST_CONV_REST CII_VURTFC
		AADD(aReg[nPos], Iif( cEnq $ "5|8|"                                        , '' ,{(cAliasSFT)->CII_VUCST ,6} ))	//20 - VL_UNIT_ICMS_ST_CONV_COMPL
		AADD(aReg[nPos], Iif( cEnq $ "5|8|"                                        , '' ,{(cAliasSFT)->CII_VUCFC ,6} ))	//21 - VL_UNIT_FCP_ST_CONV_COMPL

		//GrvRegTrS(cAlias,cRelacDoc,aReg,nItem)
		GrvRegTrS(cAlias,GetRelaGrv(cRelacDoc, 5),aReg,nItem)


	ElseIf cReg $ "C186"  //---Devoluções de Entradas---//
		cEspecie := AModNot((cAliasSFT)->FT_ESP_ORI)		

		AADD( aReg , {} )
		nPos	:= Len(aReg)
		AADD(aReg[nPos], cReg )								//01 - REG     
		AADD(aReg[nPos], (cAliasSFT)->CII_ITEM )			//02 - NUM_ITEM   
		AADD(aReg[nPos], aRegC170[1][3] )					//03 - COD_ITEM 
		AADD(aReg[nPos], (cAliasSFT)->FT_CLASFIS )			//04 - CST_ICMS
		AADD(aReg[nPos], (cAliasSFT)->CII_CFOP )			//05 - CFOP
		AADD(aReg[nPos], (cAliasSFT)->CII_ENQLEG)			//06 - COD_MOT_REST_COMPL  
		AADD(aReg[nPos],{(cAliasSFT)->CII_QTDMOV,6})		//07 - QUANT_CONV 
		AADD(aReg[nPos], (cAliasSFT)->CII_UNID)				//08 - UNID  
		AADD(aReg[nPos], cEspecie)							//09 - COD_MOD_ENTRADA 

		if cEspecie != "55"
			AADD(aReg[nPos], (cAliasSFT)->FT_SERORI)		//10 - SERIE_ENTRADA  
			AADD(aReg[nPos], (cAliasSFT)->FT_NFORI)			//11 - NUM_DOC_ENTRADA   
		else
			AADD(aReg[nPos], "")							//10 - SERIE_ENTRADA  
			AADD(aReg[nPos], "")							//11 - NUM_DOC_ENTRADA
		endif
		
		if cEspecie == "55"			
			AADD(aReg[nPos], (cAliasSFT)->FT_CHV_ORI)		//12 - CHV_DFE_ENTRADA 
		else
			AADD(aReg[nPos], "")							//12 - CHV_DFE_ENTRADA 
		endif

		AADD(aReg[nPos], StoD((cAliasSFT)->FT_EMI_ORI))		//13 - DT_DOC_ENTRADA
		AADD(aReg[nPos], SubStr((cAliasSFT)->FT_ITEMORI,2))	//14 - NUM_ITEM_ENTRADA
		AADD(aReg[nPos],{(cAliasSFT)->CII_VUNIT,6})			//15 - VL_UNIT_CONV_ENTRADA
		AADD(aReg[nPos],{(cAliasSFT)->CII_ICMEFE,6})		//16 - VL_UNIT_ICMS_OP_CONV_ENTRADA
		AADD(aReg[nPos],{(cAliasSFT)->CII_BURET,6})			//17 - VL_UNIT_BC_ICMS_ST_CONV_ENTRADA
		AADD(aReg[nPos],{(cAliasSFT)->CII_VURET,6})			//18 - VL_UNIT_ICMS_ST_CONV_ENTRADA
		AADD(aReg[nPos],{(cAliasSFT)->CII_VURFCP,6})		//19 - VL_UNIT_FCP_ST_CONV_ENTRADA
	EndIf

	If Len(aReg) > 0
		If 	cReg $ "C185|C186"

			//GrvRegTrS(cAlias,cRelacDoc,aReg,nItem)

			If cReg == "C185"
				GrvRegTrS(cAlias,GetRelaGrv(cRelacDoc, 4),aReg,nItem)				
			ElseIf cReg == "C186"
				GrvRegTrS(cAlias,GetRelaGrv(cRelacDoc, 3),aReg,nItem)				
			EndIf	
			
		ElseIf cReg == "C380"
			GrvRegTrS(cAlias,cRelacDoc,aReg,nItem)			
		EndIf
	EndIf	
EndIf

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} GerCompST
@description Define se gera os registros de complemento de ICMS ST 
@author Raphael Augusto
@since 08/11/2019
@version 12.1.25
/*/
Function GerCompST(aWizard,cDataDe,cDataAte)
Local cPeriodo  := SubStr(cDataDe,1,4) + SubStr(cDataDe,5,2)
Local lRet		:= .F. 

	If  aSPDSX2[AI_CIF] .And.  ;
		aSPDSX2[AI_CIG] .And.  ;
		aSPDSX2[AI_CIH] .And.  ;
		aSPDSX2[AI_CII] .And.  ;
		aSPDSX2[AI_CIJ] .And.  ;
		aSPDSX2[AI_CIK] .And.  ;
		aSPDSX2[AI_CIL] .And.  ;
		aSPDSX2[AI_CIM] .And.  ;
		cVersao >= "014" .And. ;
		"1" $ aWizard[1][26]

		CIG->(DbSetOrder(1))
		If CIG->( DbSeek( aSPDFil[PFIL_CIG] + cPeriodo ) )
			lRet := .T.
		EndIf
	EndIf
Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} ProcRegB
@description Processa registros B020, B025 e B420.
OBS: O código já existia, só transferi da função SPDBlocoB para cá
@author Matheus Massarotto
@since 14/05/2020
@version 12.1.27
/*/
//-------------------------------------------------------------------
Static Function ProcRegB(nValor,cAlsEnt,dDataDe,dDataAte,aRegB020,aRegB025,aRegB420,aRegB440,aReg0150,oObjSpdMov,aWizard,cAlias)
Local cEntSai	:= ""
Local lHistTab	:= aSPDSX6[MV_HISTTAB] .And. aSPDSX2[AI_AIF]
Local aHistSA	:= {}
Local cAlsSA	:= ''
Local lCadParti	:= aExistBloc[02]
Local cMvNfSS	:= aSPDSX6[MV_COTNFSS]
Local cIndEmit	:= ''
Local nPercBaixa:= 0
Local cEstPres	:= ''
Local cMunPres	:= ''
Local cDTCancela:=''
Local cDTEmissao:=''
Local aMunDevPre:= {}
Local lGrava0150:= .F.
Local cSituaDoc := "00"                               //---Verificar chamada da função SPEDSitDoc---//
Local aProd     := {"","","","","","","","","","",""} //---Verificar execoção do PE SPEDPROD---//

		(cAlsEnt)->(DbGoTop())
		If (cAlsEnt)->(!Eof())

			//---Tipo do movimento---//
			cEntSai := Iif("E"$(cAlsEnt)->FT_TIPOMOV, "1", "2")

			//---Alias Participante---//
			cAlsSA  := "SA"+Iif ((cEntSai=="1" .And. !(cAlsEnt)->FT_TIPO$"BD") .Or. (cEntSai=="2" .And. (cAlsEnt)->FT_TIPO$"BD"), "2", "1")

			//---Histórico de alterações Participante---//
			If lHistTab
				aHistSA := MsConHist(cAlsSA,(cAlsEnt)->FT_CLIEFOR,(cAlsEnt)->FT_LOJA,dDataDe)
			EndIf

			//---Informações Participante---//
			(cAlsSA)->(DbSeek(xFilial(cAlsSA) + (cAlsEnt)->FT_CLIEFOR + (cAlsEnt)->FT_LOJA))
			aPartDoc := InfPartDoc(cAlsSA,dDataDe,dDataAte,'',lCadParti,aHistSA,lHistTab)

			//---Modelo NF---//
			cEspecie := AModNot((cAlsEnt)->FT_ESPECIE)
			If (cAlsEnt)->FT_TIPO == "S"
				If AllTrim((cAlsEnt)->FT_ESPECIE) == Alltrim(Substr(cMvNfSS,At("=",cMvNfSS)+1,5))								
					cEspecie := Left(cMvNfSS,At("=",cMvNfSS)-1)
				ElseIF Empty(cEspecie)
					cEspecie := "03"
				EndIF
			EndIf

			//---Tipo de emissao do documento fiscal---//
			If (Empty((cAlsEnt)->FT_FORMUL)) .And. cEntSai=="1"
				cIndEmit := "1"	    //---Emissao de Terceiros
			ElseIf (Empty((cAlsEnt)->FT_FORMUL)) .And. cEntSai=="2"
				cIndEmit := "0"     //---Emissao Propria
			Else
				If ("S"$(cAlsEnt)->FT_FORMUL)
					cIndEmit := "0" //---Emissao Propria
				Else
					cIndEmit := "1" //--Emissao de Terceiros
				EndIf
			EndIf

			//---Percentual de baixa---//
			nPercBaixa := nValor

			While (cAlsEnt)->(!Eof())

				//Chama função para retornar estado e município onde o ISS foi prestado e devido
				If cEntSai == '1' .AND. aSPDSX3[FP_F1_ESTPRES] .And. aSPDSX3[FP_F1_INCISS]					
					cEstPres := (cAlsEnt)->F1_ESTPRES
					cMunPres := (cAlsEnt)->F1_INCISS					
				EndIF
				cDTCancela:=SUBSTR((cAlsEnt)->FT_DTCANC,7,8)+SUBSTR((cAlsEnt)->FT_DTCANC,5,2)+SUBSTR((cAlsEnt)->FT_DTCANC,1,4)
				cDTEmissao:=SUBSTR((cAlsEnt)->FT_EMISSAO,7,8)+SUBSTR((cAlsEnt)->FT_EMISSAO,5,2)+SUBSTR((cAlsEnt)->FT_EMISSAO,1,4)
				//Chama função para definir municípios onde o serviço foi prestado e ISS devido
				aMunDevPre	:= SPDDEFMUN(cEntSai,;
										(cAlsEnt)->B1_MEPLES,;
										aPartDoc[13],;
										aPartDoc[7],;
										cEstPres,;
										cMunPres,;
										SM0->M0_ESTENT,;
										SM0->M0_CODMUN)	
				
				//Popula objeto de movimento 
				oObjSpdMov:clear()
				oObjSpdMov:setVlCont(Iif(EMPTY(SM0->M0_INSC) .OR. ALLTRIM(SM0->M0_INSC) $ ("ISENTO","ISENTA"),(cAlsEnt)->F1_VALBRUT,(cAlsEnt)->FT_VALCONT))
				oObjSpdMov:setMatTer((cAlsEnt)->FT_ISSMAT)
				oObjSpdMov:setIssSub((cAlsEnt)->FT_ISSSUB)
				oObjSpdMov:setIseOut((cAlsEnt)->(FT_OUTRICM+FT_ISENICM))
				oObjSpdMov:setBCIss((cAlsEnt)->D1_BASEISS)
				oObjSpdMov:setAlqIss((cAlsEnt)->D1_ALIQISS)
				oObjSpdMov:setIss((cAlsEnt)->D1_VALISS)					
				oObjSpdMov:setRecISS((cAlsEnt)->FT_RECISS)					
				oObjSpdMov:setIndOpe(Str(Val(cEntSai)-1,1))
				oObjSpdMov:setIndEmi(cIndEmit)
				oObjSpdMov:setEspeci(cEspecie)
				oObjSpdMov:setSitDoc(cSituaDoc)
				oObjSpdMov:setNumNf((cAlsEnt)->FT_NFISCAL)
				oObjSpdMov:setSerie(SpedSerie((cAlsEnt)->FT_SERIE, cEspecie))
				oObjSpdMov:setChvNfe(IIf(cSituaDoc <> "05", (cAlsEnt)->FT_CHVNFE, ""))
				oObjSpdMov:setCodObs("")
				oObjSpdMov:setCodIss(DefCodIssB(aProd, (cAlsEnt)->FT_PRODUTO, (cAlsEnt)->D1_CODISS))
				oObjSpdMov:setEmiss(cDTEmissao)
				oObjSpdMov:setdCanc(cDTCancela)
				oObjSpdMov:setPart(aPartDoc[01])
				oObjSpdMov:setEntSai(cEntSai)					
				oObjSpdMov:setBCRet(Round(((cAlsEnt)->D1_BASEISS * nPercBaixa),2))
				oObjSpdMov:setIssRet(Round(((cAlsEnt)->D1_VALISS * nPercBaixa),2))
					
				//Envia para classe município prestado e de iss devido
				If Len(aMunDevPre) > 0
					oObjSpdMov:setEstPres(aMunDevPre[1])
					oObjSpdMov:setMunPres(aMunDevPre[2])
					oObjSpdMov:setEstDev(aMunDevPre[3])
					oObjSpdMov:setMunDev(aMunDevPre[4])
				EndIF

				//--------------------------------------
				//Processa registros B020, B025 e B420
				//--------------------------------------
				RegB020(@aRegB020,@aRegB025,@aRegB420,@aRegB440,@lGrava0150,oObjSpdMov, (cAlsEnt)->FT_ESTADO)						

				//---Gravação dos Registros [0150 - TABELA DE CADASTRO DE PARTICIPANTES] e [0175 - ALTERACAO DA TABELA DE CADASTRO DE PARTICIPANTE]---//
				If lGrava0150
					SDPF150175(@aReg0150,aPartDoc,cAlias,aWizard,aExistBloc)
				EndIf

				(cAlsEnt)->(dbSkip())
			EndDo

		EndIf

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} fInsTmpQry
@description Controla o tamanho da query de inserts para poder inserir dados na tabela temporaria via BulckInsert, 
ou seja, grava em lote.
@author Thiago Yoshiaki Miyabara Nascimento - Shiny
@since 12/03/2021
@version 12.1.27
/*/
//-------------------------------------------------------------------
Function fInsTmpQry(cDadosIns, lForce)

Local nTamInsert    := 100000 //Tamanho maximo de caracteres por query de INSERT.
Local aDadosTmp     := {}
Local nLimitBulk  	:= 1000 //- limite de registro para serem inseridos
Default cDadosIns   := ""
Default lForce      := .F.
Default lCanUseBulk	:= .F. //Quando não existir a variavel lCanUseBulk indica que processo não se iniciou pela função SPEDFISCAL, exemplo: TAF

	If lCanUseBulk
		aDadosTmp := ParseBulk(cDadosIns)
		
		oBulkTMP:AddData(aClone(aDadosTmp))
		
		FwFreeArray(aDadosTmp)

		If oBulkTMP:Count() >= nLimitBulk .Or. lForce
			//Descarrega todos os dados a serem inseridos na TemporaryTable
			SPDFlshINS() 
		EndIf 
	Else 
		If !Empty(cDadosIns) 
			if cSGBD $ "ORACLE" //Para o Oracle, o comando de insert de multiplas linhas é diferente, por isso o tratamento abaixo. 
				SetQryIns(cQryInsert+" INTO "+__cTblName+"(TRB_TPREG, TRB_RELAC, TRB_IDRDEP, TRB_CONT, TRB_ITEM, TRB_SUBREG, TRB_HIERAR, TRB_NVREG) VALUES "+cDadosIns +CHR(13) + CHR(10))
			else

				SetQryIns(cQryInsert + cDadosIns + ",")

			endif
			__nCountIns  += 1
		Else
			__nCountIns	 := 0		
		EndIf

		If (GetTamQry() >= nTamInsert) .Or. lForce
			SPDFlshINS() //Descarrega todos os dados a serem inseridos na TemporaryTable
		EndIf
	EndIf 		

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} SPDFlshINS
@description Grava na tabela temporaria principal, ou seja, executa o Flush de dados na tabela
OBS: Esta rotina a partir do momento em que a tabela temporaria foi criada ate antes do momento de sua exclusao,
podera ser invocada para descarregar tudo que estiver aguardando para ser gravado na tabela.
@author Thiago Yoshiaki Miyabara Nascimento - Shiny
@since 12/03/2021
@version 12.1.27
/*/
//-------------------------------------------------------------------
Function SPDFlshINS()
Local cStatement
Local lOracle	:= cSGBD $ "ORACLE"

Default lCanUseBulk	:= .F. //Quando não existir a variavel lCanUseBulk indica que processo não se iniciou pela função SPEDFISCAL, exemplo: TAF

	If lCanUseBulk
		If oBulkTMP:Count() > 0 
			//- valida a execução
			If !oBulkTMP:Flush()
				ConOut(oBulkTMP:GetError())
			EndIf 
			aDadosBulk := {}
		EndIf 
	Else 
		If !Empty(cQryInsert) // Só entro se tiver query

			If !lOracle  //Para o Oracle, não precisa retirar o último digito pois não terá , no fim do texto. 
				SetQryIns(Subs(cQryInsert, 1, Len(cQryInsert)-1))	
			EndIf

			cStatement := GetStatIns()
			cStatement += GetQryIns() 
			
			If lOracle //Para o Oracle, para fechar o comando do insert com multiplas linhas.
				cStatement+= CHR(13) + CHR(10)+" SELECT 1 FROM DUAL; END;" + CHR(13) + CHR(10)
			Else
				cStatement+= ";" + CHR(13) + CHR(10)
			Endif

			If (TCSqlExec(cStatement)) >= 0
				SetQryIns("")

				If lOracle
					TcSqlExec("COMMIT")
				EndIf

				TCRefresh(__cTblName)
			Else
				conout("SPEDFISCAL - Erro ao inserir dados na tabela " + __cTblName + " via rotina SPDFlshINS() - TCSQLError() : " + TCSQLError())
			EndIf		
		EndIf	
	EndIf 
Return

//-------------------------------------------------------------------
/*/{Protheus.doc} GetTamQry
@description Retorna o tamanho da variavel cQryInsert para o caso de inserção em Lote na tabela temporaria.
@author Thiago Yoshiaki Miyabara Nascimento - Shiny
@since 12/03/2021
@version 12.1.27
/*/
//-------------------------------------------------------------------
Function GetTamQry()
Return Len(cQryInsert)

Function SetQryIns(cQry)
Return cQryInsert := cQry

Function GetQryIns()
Return cQryInsert

Function GetStatIns()
Local cRet:= ""

	if cSGBD $ "ORACLE" //Para o Oracle, o inicio do comando do insert com multiplas linhas.
		cRet:="BEGIN INSERT ALL "+ CHR(13) + CHR(10)
	else
		cRet:=" INSERT INTO " + __cTblName + " (TRB_TPREG, TRB_RELAC, TRB_IDRDEP, TRB_CONT, TRB_ITEM, TRB_SUBREG, TRB_HIERAR, TRB_NVREG) VALUES "
	endif

Return cRet

 //-------------------------------------------------------------------
/*/{Protheus.doc} GetTamQry
@description Função criada para limpar array, cuja a estrutura é conhecida, pois quando o array 
possui varias combinações de estrutura como posições com tamanhos diferentes entre elas,
o mais performatico passa a ser o aSizeZero- Internamente percorre todas as posições do array verificando
se é necessario executar aSize e atribuicao de NIL na variavel do tipo Array 
@author Thiago Yoshiaki Miyabara Nascimento - Shiny
@since 12/03/2021
@version 12.1.27
/*/
//-------------------------------------------------------------------
Function aSizeZero(aArray)
	aSize(aArray, 0)
	aArray := Nil
Return 

//-------------------------------------------------------------------
/*/{Protheus.doc} fHashInfP
@description Retorna array com dados do aInfPartDoc, com base em busca de variavel Hash(Quando nao encontrar no hash é incluso novo registro para performar a proxima busca ao mesmo codigo)
Esta rotina tambem executa seek ou GoTo na tabela cAlsSA / SA1|SA2
@author Thiago Yoshiaki Miyabara Nascimento - Shiny
@since 13/06/2021
@version 12.1.27
/*/
//-------------------------------------------------------------------
Function fHashInfP(cAlsSA, cChvSeek, aPar, lBusca)

Local aRetHash 	:= FisRetHash(oHashINFP, cAlsSA + cChvSeek )
Local lTemHash 	:= (Len(aRetHash) > 0) //Variavel define se NAO tem dado no hash
Local lValEntr	:= .T.	

Default aPar	:= {}
Default lBusca	:= .T.

	If Len(aPar) > 0
		If (cAlsSA == "SA1" .And. !aSPDSX6[MV_CLIFAT] .And. ;
			SpdAvalEntr(aPar[4],(aPar[4])->FT_TIPO $ "DB",ALLTRIM((aPar[4])->FT_ESPECIE) == "CTE",ALLTRIM((aPar[4])->FT_TIPOMOV) == "S",aSPDSX6[MV_CLIFAT]))
			lValEntr := .F. 
			cChvSeek := aSPDFil[PFIL_SA1] + SA1->(A1_COD+A1_LOJA)
			aRetHash := FisRetHash(oHashINFP, cAlsSA + cChvSeek )
			If !(lTemHash := (Len(aRetHash) > 0)) //Variavel define se NAO tem dado no hash
				aPar[4] := ""//Limpo a variavel que possui o nome da tabela temporaria principal, para que internamente na funcao infPartDoc, seja assumida a tabela fisica SA1
			EndIf	
		EndIf

		If !lTemHash
			aRetHash  := InfPartDoc(aPar[1], aPar[2], aPar[3], aPar[4], aPar[5], aPar[6], aPar[7], , lValEntr)
			FisAddHash(oHashINFP, cAlsSA + cChvSeek, aRetHash)
		EndIf

	ElseIf !lTemHash
		If lBusca
			(cAlsSA)->(MsSeek(cChvSeek))
		EndIf

		aRetHash  := InfPartDoc(cAlsSA)
		FisAddHash(oHashINFP, cAlsSA + cChvSeek, aRetHash)
	EndIf	

Return aRetHash

//-------------------------------------------------------------------
/*/{Protheus.doc} fGrvBloco
@description Ordena e faz a impressão do TRB por blocos
@author Thiago Yoshiaki Miyabara Nascimento - Shiny
@since 23/06/2021
@version 12.1.27
/*/
//-------------------------------------------------------------------
Static Function fGrvBloco(nHandle, cAlias)	

Local cQuery	 := ''
Local cAlsQryAux := GetNextAlias()

	If __oORGTXT == Nil		
		
		cQuery := " SELECT TRB_TPREG, TRB_RELAC, TRB_IDRDEP, TRB_ITEM, TRB_CONT, TRB_HIERAR, TRB_NVREG, R_E_C_N_O_ AS RECNO FROM " + UPPER(__cTblName) + " "
		cQuery += " WHERE D_E_L_E_T_ = ' ' "
		cQuery += " AND TRB_FLAG     = ' ' "
		cQuery += " GROUP BY TRB_TPREG, TRB_RELAC, TRB_ITEM, TRB_CONT, TRB_HIERAR, TRB_NVREG, TRB_IDRDEP, R_E_C_N_O_ "				
		cQuery += " ORDER BY TRB_HIERAR, TRB_NVREG, TRB_IDRDEP, TRB_RELAC, TRB_TPREG, TRB_ITEM, R_E_C_N_O_ "
		
		cQuery 	:= ChangeQuery(cQuery)
		__oORGTXT := FWPreparedStatement():New(cQuery)
	EndIf

	cQuery 	   := __oORGTXT:GetFixQuery()
	MPSysOpenQuery(cQuery, cAlsQryAux)	

	While (cAlsQryAux)->(!Eof())
		SPEDGrvLin(nHandle, cAlsQryAux, (cAlsQryAux)->(RECNO))
		(cAlsQryAux)->(DbSkip())					
	EndDo	

	(cAlsQryAux)->(dbCloseArea()) //Fecha tabela temporaria	
	
	SPDFlshTXT(nHandle) //Forco atualizacao da flag de todos os registros
		
Return

//-------------------------------------------------------------------
/*/{Protheus.doc} SetHierarq Carrega Hash de Hierarquia de impressao dos registros no TXT
@description  Carrega Hash de Hierarquia de impressao dos registros no TXT
Incluir na lista da Terceira posição do __aHierar, todos os registros que devem ser impressos apos a impressão de todos os outros registros do bloco, ou seja, de ultima prioridade de impressao,
como por exemplo, registros de consolidação, como D600, que apesar de ter TRB_RELAC, não se associa ao registro exatamente anterior, pois este é um registro de consolidação de varios outros acima dele, como o D500 
@author Thiago Yoshiaki Miyabara Nascimento - Shiny
@since 24/06/2021
@version 12.1.27
/*/
//-------------------------------------------------------------------
Function SetHierarq() // Carrega Hash de Hierarquia 

Local __aHierar := {}
Local __aBloco0	:= {}	
Local __aBlocoB	:= {}
Local __aBlocoC	:= {}
Local __aBlocoD	:= {}
Local __aBlocoE	:= {}
Local __aBlocoG	:= {}
Local __aBlocoH	:= {}
Local __aBlocoK	:= {}
Local __aBloco1	:= {}
Local __aBloco9	:= {}
Local cNew		:= "HMNew()"

	oHHierarq := &cNew

	oHHBloco0 := &cNew
	oHHBlocoB := &cNew
	oHHBlocoC := &cNew
	oHHBlocoD := &cNew
	oHHBlocoE := &cNew
	oHHBlocoG := &cNew
	oHHBlocoH := &cNew
	oHHBlocoK := &cNew
	oHHBloco1 := &cNew
	oHHBloco9 := &cNew
	
	//Bloco 0
	aAdd(__aBloco0,{0 , "0000"}) //0 1
	aAdd(__aBloco0,{1 , "0001"}) //1 1
	aAdd(__aBloco0,{2 , "0002"}) //2 1
	aAdd(__aBloco0,{3 , "0005"}) //2 1
	aAdd(__aBloco0,{4 , "0015"}) //2 V
	aAdd(__aBloco0,{5 , "0100"}) //2 1
	aAdd(__aBloco0,{6 , "0150"}) //2 V
	aAdd(__aBloco0,{6 , "0175"}) //3 1:N
	aAdd(__aBloco0,{7 , "0190"}) //2 V
	aAdd(__aBloco0,{8 , "0200"}) //2 V
	aAdd(__aBloco0,{8 , "0205"}) //3 1:N
	aAdd(__aBloco0,{8 , "0206"}) //3 1:1
	aAdd(__aBloco0,{8 , "0210"}) //3 1:N
	aAdd(__aBloco0,{8 , "0220"}) //3 1:N
	aAdd(__aBloco0,{9 , "0300"}) //2 V
	aAdd(__aBloco0,{9 , "0305"}) //3 1:1
	aAdd(__aBloco0,{10, "0400"}) //2 V
	aAdd(__aBloco0,{11, "0450"}) //2 V
	aAdd(__aBloco0,{12, "0460"}) //2 V
	aAdd(__aBloco0,{13, "0500"}) //2 V
	aAdd(__aBloco0,{14, "0600"}) //2 V
	aAdd(__aBloco0,{99, "0990"}) //1 1
	oHHBloco0 := AToHM(__aBloco0, 2)// Alimento o objeto oHashMap  informando a coluna 2-Codigo Registro como chave de busca no hash

	//Bloco B
	aAdd(__aBlocoB,{0 , "B001"}) //B001 1 1
	aAdd(__aBlocoB,{1 , "B020"}) //B020 2 V
	aAdd(__aBlocoB,{1 , "B025"}) //3 1:N
	aAdd(__aBlocoB,{2 , "B030"}) //2 V
	aAdd(__aBlocoB,{2 , "B035"}) //1:N
	aAdd(__aBlocoB,{3 , "B350"}) //2 V
	aAdd(__aBlocoB,{4 , "B420"}) //2 V
	aAdd(__aBlocoB,{5 , "B440"}) //2 V
	aAdd(__aBlocoB,{6 , "B460"}) //2 V
	aAdd(__aBlocoB,{7 , "B470"}) //2 1
	aAdd(__aBlocoB,{8 , "B500"}) //2 1
	aAdd(__aBlocoB,{8 , "B510"}) //3 V
	aAdd(__aBlocoB,{99, "B990"}) //1 1
	oHHBlocoB := AToHM(__aBlocoB, 2)// Alimento o objeto oHashMap 

	//Bloco C
	aAdd(__aBlocoC,{0 , "C001"}) //0    1 1   
	aAdd(__aBlocoC,{1 , "C100"}) //1    2 V  
	aAdd(__aBlocoC,{1 , "C101"}) //1    3 1:1  
	aAdd(__aBlocoC,{1 , "C105"}) //1    3 1:1  
	aAdd(__aBlocoC,{1 , "C110"}) //1    3 1:N  
	aAdd(__aBlocoC,{1 , "C111"}) //1    4 1:N  
	aAdd(__aBlocoC,{1 , "C112"}) //1    4 1:N  
	aAdd(__aBlocoC,{1 , "C113"}) //1    4 1:N  
	aAdd(__aBlocoC,{1 , "C114"}) //1    4 1:N  
	aAdd(__aBlocoC,{1 , "C115"}) //1    4 1:N  
	aAdd(__aBlocoC,{1 , "C116"}) //1    4 1:N  
	aAdd(__aBlocoC,{1 , "C120"}) //1    3 1:N  
	aAdd(__aBlocoC,{1 , "C130"}) //1    3 1:1  
	aAdd(__aBlocoC,{1 , "C140"}) //1    3 1:1  
	aAdd(__aBlocoC,{1 , "C141"}) //1    4 1:N  
	aAdd(__aBlocoC,{1 , "C160"}) //1    3 1:1  
	aAdd(__aBlocoC,{1 , "C165"}) //1    3 1:N  
	aAdd(__aBlocoC,{1 , "C170"}) //1    3 1:N  
	aAdd(__aBlocoC,{1 , "C171"}) //1    4 1:N  
	aAdd(__aBlocoC,{1 , "C172"}) //1    4 1:1  
	aAdd(__aBlocoC,{1 , "C173"}) //1    4 1:N  
	aAdd(__aBlocoC,{1 , "C174"}) //1    4 1:N  
	aAdd(__aBlocoC,{1 , "C175"}) //1    4 1:N  
	aAdd(__aBlocoC,{1 , "C176"}) //1    4 1:N  
	aAdd(__aBlocoC,{1 , "C177"}) //1    4 1:1  
	aAdd(__aBlocoC,{1 , "C178"}) //1    4 1:1  
	aAdd(__aBlocoC,{1 , "C179"}) //1    4 1:1  
	aAdd(__aBlocoC,{1 , "C180"}) //1    4 1:1  
	aAdd(__aBlocoC,{1 , "C181"}) //1    4 1:N  
	aAdd(__aBlocoC,{1 , "C185"}) //1    3 1:N  
	aAdd(__aBlocoC,{1 , "C186"}) //1    3 1:N  
	aAdd(__aBlocoC,{1 , "C190"}) //1    3 1:N  
	aAdd(__aBlocoC,{1 , "C191"}) //1    4 1:1  
	aAdd(__aBlocoC,{1 , "C195"}) //1    3 1:N  
	aAdd(__aBlocoC,{1 , "C197"}) //1    4 1:N  
	aAdd(__aBlocoC,{2 , "C300"}) //2    2 V  
	aAdd(__aBlocoC,{2 , "C310"}) //2    3 1:N  
	aAdd(__aBlocoC,{2 , "C320"}) //2    3 1:N  
	aAdd(__aBlocoC,{2 , "C321"}) //2    4 1:N  
	aAdd(__aBlocoC,{2 , "C330"}) //2    5 1:1  
	aAdd(__aBlocoC,{3 , "C350"}) //3    2 V  
	aAdd(__aBlocoC,{3 , "C370"}) //3    3 1:N  
	aAdd(__aBlocoC,{3 , "C380"}) //3    4 1:1  
	aAdd(__aBlocoC,{3 , "C390"}) //3    3 1:N  
	aAdd(__aBlocoC,{4 , "C400"}) //4    2 V  
	aAdd(__aBlocoC,{4 , "C405"}) //4    3 1:N  
	aAdd(__aBlocoC,{4 , "C410"}) //4    4 1:1  
	aAdd(__aBlocoC,{4 , "C420"}) //4    4 1:N  
	aAdd(__aBlocoC,{4 , "C425"}) //4    5 1:N  
	aAdd(__aBlocoC,{4 , "C430"}) //4    6 1:N  
	aAdd(__aBlocoC,{4 , "C460"}) //4    4 1:N  
	aAdd(__aBlocoC,{4 , "C465"}) //4    5 1:1  
	aAdd(__aBlocoC,{4 , "C470"}) //4    5 1:N  
	aAdd(__aBlocoC,{4 , "C480"}) //4    6 1:1  
	aAdd(__aBlocoC,{4 , "C490"}) //4    4 1:N  
	aAdd(__aBlocoC,{5 , "C495"}) //5    2 V  
	aAdd(__aBlocoC,{6 , "C500"}) //6    2 V  
	aAdd(__aBlocoC,{6 , "C510"}) //6    3 1:N  
	aAdd(__aBlocoC,{6 , "C590"}) //6    3 1:N  
	aAdd(__aBlocoC,{6 , "C591"}) //6    4 1:1  
	aAdd(__aBlocoC,{6 , "C595"}) //6    3 1:N  
	aAdd(__aBlocoC,{6 , "C597"}) //6    4 1:N  
	aAdd(__aBlocoC,{7 , "C600"}) //7    2 V  
	aAdd(__aBlocoC,{7 , "C601"}) //7    3 1:N  
	aAdd(__aBlocoC,{7 , "C610"}) //7    3 1:N  
	aAdd(__aBlocoC,{7 , "C690"}) //7    3 1:N  
	aAdd(__aBlocoC,{8 , "C700"}) //8    2 V  
	aAdd(__aBlocoC,{8 , "C790"}) //8    3 1:N  
	aAdd(__aBlocoC,{8 , "C791"}) //8    4 1:N  
	aAdd(__aBlocoC,{9 , "C800"}) //9    2 V  
	aAdd(__aBlocoC,{9 , "C810"}) //9    3 1:N  
	aAdd(__aBlocoC,{9 , "C815"}) //9    4 1:1  
	aAdd(__aBlocoC,{9 , "C850"}) //9    3 1:N  
	aAdd(__aBlocoC,{9 , "C855"})
	aAdd(__aBlocoC,{9 , "C857"})
	aAdd(__aBlocoC,{10, "C860"}) //10   2 V  
	aAdd(__aBlocoC,{10, "C870"}) //10   3 1:N  
	aAdd(__aBlocoC,{10, "C880"}) //10   4 1:1  
	aAdd(__aBlocoC,{10, "C890"}) //10   3 1:N  
	aAdd(__aBlocoC,{10, "C895"}) //10   3 1:N
	aAdd(__aBlocoC,{10, "C897"}) //10	4 1:N
	aAdd(__aBlocoC,{99, "C990"}) //99   1 1  
	oHHBlocoC := AToHM(__aBlocoC, 2)// Alimento o objeto oHashMap 

	//Bloco D
	aAdd(__aBlocoD,{0 , "D001"}) //1 1
	aAdd(__aBlocoD,{1 , "D100"}) //2 V
	aAdd(__aBlocoD,{1 , "D101"}) //3 1:1
	aAdd(__aBlocoD,{1 , "D110"}) //3 1:N
	aAdd(__aBlocoD,{1 , "D120"}) //4 1:N
	aAdd(__aBlocoD,{1 , "D130"}) //3 1:N
	aAdd(__aBlocoD,{1 , "D140"}) //3 1:1
	aAdd(__aBlocoD,{1 , "D150"}) //3 1:1
	aAdd(__aBlocoD,{1 , "D160"}) //3 1:N
	aAdd(__aBlocoD,{1 , "D161"}) //4 1:1
	aAdd(__aBlocoD,{1 , "D162"}) //4 1:N
	aAdd(__aBlocoD,{1 , "D170"}) //3 1:1
	aAdd(__aBlocoD,{1 , "D180"}) //3 1:N
	aAdd(__aBlocoD,{1 , "D190"}) //3 1:N
	aAdd(__aBlocoD,{1 , "D195"}) //3 1:N
	aAdd(__aBlocoD,{1 , "D197"}) //4 1:N
	aAdd(__aBlocoD,{2 , "D300"}) //2 V
	aAdd(__aBlocoD,{2 , "D301"}) //3 1:N
	aAdd(__aBlocoD,{2 , "D310"}) //3 1:N
	aAdd(__aBlocoD,{3 , "D350"}) //2 V
	aAdd(__aBlocoD,{3 , "D355"}) //3 1:N
	aAdd(__aBlocoD,{3 , "D360"}) //4 1:1
	aAdd(__aBlocoD,{3 , "D365"}) //4 1:N
	aAdd(__aBlocoD,{3 , "D370"}) //5 1:N
	aAdd(__aBlocoD,{3 , "D390"}) //4 1:N
	aAdd(__aBlocoD,{4 , "D400"}) //2 V
	aAdd(__aBlocoD,{4 , "D410"}) //3 1:N
	aAdd(__aBlocoD,{4 , "D411"}) //4 1:N
	aAdd(__aBlocoD,{4 , "D420"}) //3 1:N
	aAdd(__aBlocoD,{5 , "D500"}) //2 V
	aAdd(__aBlocoD,{5 , "D510"}) //3 1:N
	aAdd(__aBlocoD,{5 , "D530"}) //3 1:N
	aAdd(__aBlocoD,{5 , "D590"}) //3 1:N
	aAdd(__aBlocoD,{6 , "D600"}) //2 V
	aAdd(__aBlocoD,{6 , "D610"}) //3 1:N
	aAdd(__aBlocoD,{6 , "D690"}) //3 1:N
	aAdd(__aBlocoD,{7 , "D695"}) //2 V
	aAdd(__aBlocoD,{7 , "D696"}) //3 1:N
	aAdd(__aBlocoD,{7 , "D697"}) //4 1:N
	aAdd(__aBlocoD,{99, "D990"}) //1 1
	oHHBlocoD := AToHM(__aBlocoD, 2)// Alimento o objeto oHashMap 

	//Bloco E
	aAdd(__aBlocoE,{0 , "E001"}) //1 1
	aAdd(__aBlocoE,{1 , "E100"}) //2 V
	aAdd(__aBlocoE,{1 , "E110"}) //3 1:1
	aAdd(__aBlocoE,{1 , "E111"}) //4 1:N
	aAdd(__aBlocoE,{1 , "E112"}) //5 1:N
	aAdd(__aBlocoE,{1 , "E113"}) //5 1:N
	aAdd(__aBlocoE,{1 , "E115"}) //4 1:N
	aAdd(__aBlocoE,{1 , "E116"}) //4 1:N //Apesar deste registro estar no mesmo nivel do E110, o mesmo não possui TRB_RELAC informado de acordo comdo com E110
	aAdd(__aBlocoE,{2 , "E200"}) //2 V
	aAdd(__aBlocoE,{2 , "E210"}) //3 1:1
	aAdd(__aBlocoE,{2 , "E220"}) //4 1:N
	aAdd(__aBlocoE,{2 , "E230"}) //5 1:N
	aAdd(__aBlocoE,{2 , "E240"}) //5 1:N
	aAdd(__aBlocoE,{2 , "E250"}) //4 1:N
	aAdd(__aBlocoE,{3 , "E300"}) //2 1:N
	aAdd(__aBlocoE,{3 , "E310"}) //3 1:1
	aAdd(__aBlocoE,{3 , "E311"}) //4 1:N
	aAdd(__aBlocoE,{3 , "E312"}) //5 1:N
	aAdd(__aBlocoE,{3 , "E313"}) //5 1:N
	aAdd(__aBlocoE,{3 , "E316"}) //4 1:N
	aAdd(__aBlocoE,{4 , "E500"}) //2 V
	aAdd(__aBlocoE,{4 , "E510"}) //3 1:N
	aAdd(__aBlocoE,{4 , "E520"}) //3 1:1
	aAdd(__aBlocoE,{4 , "E530"}) //4 1:N
	aAdd(__aBlocoE,{4 , "E531"}) //5 1:N
	aAdd(__aBlocoE,{99, "E990"}) //1 1
	oHHBlocoE := AToHM(__aBlocoE, 2)// Alimento o objeto oHashMap 

	//Bloco G
	aAdd(__aBlocoG,{0 , "G001"}) //1 1
	aAdd(__aBlocoG,{1 , "G110"}) //2 V
	aAdd(__aBlocoG,{1 , "G125"}) //3 1:N
	aAdd(__aBlocoG,{1 , "G126"}) //4 1:N
	aAdd(__aBlocoG,{1 , "G130"}) //4 1:N
	aAdd(__aBlocoG,{1 , "G140"}) //5 1:N
	aAdd(__aBlocoG,{99, "G990"}) //1 1
	oHHBlocoG := AToHM(__aBlocoG, 2)// Alimento o objeto oHashMap 

	//Bloco H
	aAdd(__aBlocoH,{0 , "H001"}) //1 1
	aAdd(__aBlocoH,{1 , "H005"}) //2 V
	aAdd(__aBlocoH,{1 , "H010"}) //3 1:N
	aAdd(__aBlocoH,{1 , "H020"}) //4 1:N
	aAdd(__aBlocoH,{1 , "H030"}) //4 1:1
	aAdd(__aBlocoH,{99, "H990"}) //1 1
	oHHBlocoH := AToHM(__aBlocoH, 2)// Alimento o objeto oHashMap 

	//Bloco K
	aAdd(__aBlocoK,{0 , "K001"}) //1 1
	aAdd(__aBlocoK,{1 , "K010"}) //2 1
	aAdd(__aBlocoK,{1 , "K100"}) //2 V
	aAdd(__aBlocoK,{2 , "K200"}) //3 1:N
	aAdd(__aBlocoK,{3 , "K210"}) //3 1:N
	aAdd(__aBlocoK,{3 , "K215"}) //4 1:N
	aAdd(__aBlocoK,{4 , "K220"}) //3 1:N
	aAdd(__aBlocoK,{5 , "K230"}) //3 1:N
	aAdd(__aBlocoK,{5 , "K235"}) //4 1:N
	aAdd(__aBlocoK,{6 , "K250"}) //3 1:N
	aAdd(__aBlocoK,{6 , "K255"}) //4 1:N
	aAdd(__aBlocoK,{7 , "K260"}) //3 1:N
	aAdd(__aBlocoK,{7 , "K265"}) //4 1:N
	aAdd(__aBlocoK,{8 , "K270"}) //3 1:N
	aAdd(__aBlocoK,{8 , "K275"}) //4 1:N
	aAdd(__aBlocoK,{9 , "K280"}) //3 1:N
	aAdd(__aBlocoK,{10, "K290"}) //3 1:N
	aAdd(__aBlocoK,{10, "K291"}) //4 1:N
	aAdd(__aBlocoK,{10, "K292"}) //4 1:N
	aAdd(__aBlocoK,{11, "K300"}) //3 1:N
	aAdd(__aBlocoK,{11, "K301"}) //4 1:N
	aAdd(__aBlocoK,{11, "K302"}) //4 1:N
	aAdd(__aBlocoK,{99, "K990"}) //1 1
	oHHBlocoK := AToHM(__aBlocoK, 2)// Alimento o objeto oHashMap 

	//Bloco 1
	aAdd(__aBloco1,{0 , "1001"}) //1 1
	aAdd(__aBloco1,{1 , "1010"}) //2 1
	aAdd(__aBloco1,{2 , "1100"}) //2 V
	aAdd(__aBloco1,{2 , "1105"}) //3 1:N
	aAdd(__aBloco1,{2 , "1110"}) //4 1:N
	aAdd(__aBloco1,{3 , "1200"}) //2 V
	aAdd(__aBloco1,{3 , "1210"}) //3 1:N
	aAdd(__aBloco1,{4 , "1250"}) //2 1:1
	aAdd(__aBloco1,{4 , "1255"}) //3 1:N
	aAdd(__aBloco1,{5 , "1300"}) //2 V
	aAdd(__aBloco1,{5 , "1310"}) //3 1:N
	aAdd(__aBloco1,{5 , "1320"}) //4 1:N
	aAdd(__aBloco1,{6 , "1350"}) //2 V
	aAdd(__aBloco1,{6 , "1360"}) //3 1:N
	aAdd(__aBloco1,{6 , "1370"}) //3 1:N
	aAdd(__aBloco1,{7 , "1390"}) //2 V
	aAdd(__aBloco1,{7 , "1391"}) //3 1:N
	aAdd(__aBloco1,{8 , "1400"}) //2 V
	aAdd(__aBloco1,{9 , "1500"}) //2 V
	aAdd(__aBloco1,{9 , "1510"}) //3 1:N
	aAdd(__aBloco1,{10, "1600"}) //2 V
	aAdd(__aBloco1,{10, "1601"}) //2 V
	aAdd(__aBloco1,{11, "1700"}) //2 V
	aAdd(__aBloco1,{11, "1710"}) //3 1:N
	aAdd(__aBloco1,{12, "1800"}) //2 1
	aAdd(__aBloco1,{13, "1900"}) //2 V
	aAdd(__aBloco1,{13, "1910"}) //3 1:N
	aAdd(__aBloco1,{13, "1920"}) //4 1:1
	aAdd(__aBloco1,{13, "1921"}) //5 1:N
	aAdd(__aBloco1,{13, "1922"}) //6 1:N
	aAdd(__aBloco1,{13, "1923"}) //6 1N
	aAdd(__aBloco1,{13, "1925"}) //5 1:N
	aAdd(__aBloco1,{13, "1926"}) //5 1:N
	aAdd(__aBloco1,{14, "1960"}) //2 1:N
	aAdd(__aBloco1,{15, "1970"}) //2 1:N
	aAdd(__aBloco1,{15, "1975"}) //3 1:4
	aAdd(__aBloco1,{16, "1980"}) //2 1
	aAdd(__aBloco1,{99, "1990"}) //1 1
	oHHBloco1 := AToHM(__aBloco1, 2)// Alimento o objeto oHashMap 

	//Bloco 9
	aAdd(__aBloco9,{0 , "9001"}) // 1 1
	aAdd(__aBloco9,{1 , "9900"}) // 2 V
	aAdd(__aBloco9,{99, "9990"}) // 1 1
	aAdd(__aBloco9,{99, "9999"}) // 0 1
	oHHBloco9 := AToHM(__aBloco9, 2)// Alimento o objeto oHashMap 

	//Defino a Hierarquia do Bloco ao que se refere o registro a ser gravado
	aAdd(__aHierar,{ '0', 0 , oHHBloco0})   //0 - Abertura, Identificação e Referências
	aAdd(__aHierar,{ 'B', 1 , oHHBlocoB})   //B - Escrituração e Apuração do ISS
	aAdd(__aHierar,{ 'C', 2 , oHHBlocoC}) 	//C - Documentos Fiscais I – Mercadorias (ICMS/IPI)
	aAdd(__aHierar,{ 'D', 3 , oHHBlocoD})	//D - Documentos Fiscais II – Serviços (ICMS)
	aAdd(__aHierar,{ 'E', 4 , oHHBlocoE}) 	//E - Apuração do ICMS e do IPI
	aAdd(__aHierar,{ 'G', 5 , oHHBlocoG}) 	//G - Controle do Crédito de ICMS do Ativo Permanente – CIAP
	aAdd(__aHierar,{ 'H', 6 , oHHBlocoH}) 	//H - Inventário Físico
	aAdd(__aHierar,{ 'K', 7 , oHHBlocoK}) 	//K - Controle da Produção e do Estoque
	aAdd(__aHierar,{ '1', 8 , oHHBloco1}) 	//1 - Outras Informações
	aAdd(__aHierar,{ '9', 9 , oHHBloco9}) 	//9 - Controle e Encerramento do Arquivo Digital

	oHHierarq := AToHM(__aHierar, 1)// Alimento o objeto oHashMap 

	aSizeZero(__aHierar)
	//aSizeZero(__aBloco0) Caso eu mate os arrays filhos, o HashMap perde referencia
	//aSizeZero(__aBlocoD)

Return	

//-------------------------------------------------------------------
/*/{Protheus.doc} GetHierarq Retorna o objeto de mapeamento de hierarquia oHHierarq.
@description Seta o cRelacDoc, neste caso, o cRelacDoc do primeiro Item.
@author Thiago Yoshiaki Miyabara Nascimento - Shiny / Matheus Massarotto
@since 28/08/2021
@version 12.1.27
/*/
Function GetHierarq()
	If oHHierarq == Nil
		SetHierarq()
	EndIf	
Return oHHierarq

//-------------------------------------------------------------------
/*/{Protheus.doc} GetlGrvLoja Retorna variavel STATIC de controle de execucao 
das funcoes do SIGALOJA que sao executadas em MultiThread.
@author Thiago Yoshiaki Miyabara Nascimento - Shiny / Matheus Massarotto
@since 28/08/2021
@version 12.1.27
/*/
Function GetlGrvLoja()
Return lGrvLoja

//-------------------------------------------------------------------
/*/{Protheus.doc} SetlGrvLoja Seta a variavel STATIC de controle de execucao 
das funcoes do SIGALOJA que sao executadas em MultiThread.
@author Thiago Yoshiaki Miyabara Nascimento - Shiny / Matheus Massarotto
@since 28/08/2021
@version 12.1.27
/*/
Function SetlGrvLoja(lVal)
	lGrvLoja := lVal
Return

//-------------------------------------------------------------------
/*/{Protheus.doc} GetSemLoja Retorna semaforo de controle de gravacao
das funcoes do SIGALOJA que sao executadas em MultiThread.
@author Thiago Yoshiaki Miyabara Nascimento - Shiny / Matheus Massarotto
@since 28/08/2021
@version 12.1.27
/*/
Function GetSemLoja() //Pega Semforo do loja
Return cSemafLoj

//-------------------------------------------------------------------
/*/{Protheus.doc} SetSemLoja Seta semaforo de controle de gravacao
das funcoes do SIGALOJA que sao executadas em MultiThread.
@author Thiago Yoshiaki Miyabara Nascimento - Shiny / Matheus Massarotto
@since 28/08/2021
@version 12.1.27
/*/
Function SetSemLoja(cSemaf) //Seta o Semaforo do Loja	
Return cSemafLoj := UPPER(cSemaf)

//LAYOUT 2010       
//-------------------------------------------------------------------
/*/{Protheus.doc} GetSPDVer Retorna Código da versão do leiaute conforme a tabela indicada no 
Ato COTEPE. 
@description Conforme parametro com o ano, do tipo data analisa-se qual o codigo de versao do LAYOUT do arquivo SPEDFISCAL.
@author Thiago Yoshiaki Miyabara Nascimento - Shiny
@since 02/08/2021
@version 12.1.27
/*/
Function GetSPDVer(dData)

	Do Case 
		Case(Year(dData)>=2023)
			cVersao := "017"
		Case(Year(dData)>=2022)
			cVersao := "016"
		Case(Year(dData)==2021)  
			cVersao := "015" 
		Case(Year(dData)==2020)  
			cVersao := "014"
		Case(Year(dData)==2019)  
			cVersao := "013"
		Case(Year(dData)==2018)  
			cVersao := "012"
		Case(Year(dData)==2017)  
			cVersao := "011"
		Case(Year(dData)==2016)	
			cVersao := "010"
		Case(Year(dData)==2015)
			cVersao := "009"
		Case(Year(dData)==2014)
			cVersao := "008"
		Case(Year(dData)==2013)
			cVersao	:= "007" 
		Case(Year(dData)==2012)
			If DTOS(dData) <= "20120630"
				cVersao := "005"
			Else
				cVersao := "006"
			Endif
		Case(Year(dData)==2011)
			cVersao := "004"
		Case(Year(dData)==2010)
			cVersao := "003"
		Case(Year(dData)==2009)
			cVersao := "002"
		Case(Year(dData)<=2008)
			cVersao := "001"
	EndCase

Return cVersao

//-------------------------------------------------------------------
/*/{Protheus.doc} RetRD Retorna cRelacDoc(TRB_RELAC) tratado sem o item final. 
@description Os registros cuja a hierarquia dentro do seu bloco forem pais, exemplo: C100, C350, C500, D100, D500, 1500 
e tiverem como relacionamento entre seus filhos a variável cRelacDoc devem ser tratados para que não possuam o código do item na chave.
No SPEDFISCAL são percorridos todos os itens da nota incrementando o cRelacDoc, que é utilizado na gravação da chave TRB_RELAC. Porém depois de percorrer os itens, 
é chamado as funções para gravar os pais, e neste momento o cRelacDoc está com a ultima posição de item, fazendo com que a ordenação na tabela TRB ficasse errada
, esta função resolve isso.  
@author Thiago Yoshiaki Miyabara Nascimento - Shiny / Matheus Massarotto
@since 28/08/2021
@version 12.1.27
/*/
Static function RetRD(cRelacDoc)
Return(SUBSTR(cRelacDoc,1,len(cRelacDoc)-nTamFT_IT))

//-------------------------------------------------------------------
/*/{Protheus.doc} GetRelacPr Retorna cRelacDoc(TRB_RELAC) do primeiro ITEM
@author Thiago Yoshiaki Miyabara Nascimento - Shiny / Matheus Massarotto
@since 28/08/2021
@version 12.1.27
/*/
Static Function GetRelacPr()
Return cRelacPri


//-------------------------------------------------------------------
/*/{Protheus.doc} SetRelacPr Retorna cRelacDoc(TRB_RELAC) do primeiro ITEM
@description Seta o cRelacDoc, neste caso, o cRelacDoc do primeiro Item.
@author Thiago Yoshiaki Miyabara Nascimento - Shiny / Matheus Massarotto
@since 28/08/2021
@version 12.1.27
/*/
Static Function SetRelacPr(cRelac)
	cRelacPri	 := cRelac
Return cRelacPri


//-------------------------------------------------------------------
/*/{Protheus.doc} RetItem 
@description Retorna  Item do cRelacDoc
@author Thiago Yoshiaki Miyabara Nascimento - Shiny
@since 16/10/2021
@version 12.1.27
/*/
Static function RetItem(cRelacDoc)
Return Alltrim(SUBSTR(cRelacDoc,len(cRelacDoc)-nTamFT_IT+1, len(cRelacDoc)))


//-------------------------------------------------------------------
/*/{Protheus.doc} GetRelaGrv 
@description Retorna  cRelacDoc tratado com o item necessario ja tratando tambem o tamanho da chave
@author Thiago Yoshiaki Miyabara Nascimento - Shiny
@since 16/10/2021
@version 12.1.27
/*/
Static Function GetRelaGrv(cRelac, nQtdChave)
Return RetRD(cRelac)+PadL(RetItem(cRelac),nTamFT_IT * nQtdChave,"0")

//-------------------------------------------------------------------
/*/{Protheus.doc} GeraCodBar 
@description Retorna  cCodBarra Código de Barras para registros 0200 e 0220
@author Bruce Mello
@since 23/11/2021
@version 12.1.33
/*/
Static function GeraCodBar(cAliasSB1,cAliasSB5, aProd,aReg0200,aReg0220)
Local cCodBarra := ""
Local cRetorno	:= ""
Local nTamBar	:= 0
Local lSpedProd := ExistBlock("SPEDPROD")

If aReg0200<>Nil  .And. aReg0200[1][1] == "0200"
	If lSpedProd .And. Len(aProd) >= 3
		cCodBarra := Alltrim(aProd[3])
	Else		
		If aSPDSX3[FP_B1_CODGTIN] .And. !Empty((cAliasSB1)->B1_CODGTIN) //Campo: B1_CODGTIN			
			cCodBarra := (cAliasSB1)->B1_CODGTIN	
		ElseiF  Len(AllTrim((cAliasSB1)->B1_CODBAR)) > 0				
			cCodBarra := (cAliasSB1)->B1_CODBAR	
		Endif
	EndIf
Endif

		If aReg0220<>Nil .And. aReg0220[1][2] == "0220"
			//Verifica se quando chamada 0200 passou alias com SB5
			//Caso alias não tenha sido enviado é nescessario posicionar SB5
			IF cAliasSB5 == "SB5" .and. (cAliasSB1)->B1_COD <> (cAliasSB5)->B5_COD
				If SPEDSeek("SB5",1, aSPDFil[PFIL_SB5]+(cAliasSB1)->B1_COD)
					cCodBarra := SB5->B5_2CODBAR
				Endif
			Endif
			IF !Empty((cAliasSB5)->B5_UMDIPI) .And. !Empty((cAliasSB1)->B1_UM)			
				cCodBarra := (cAliasSB5)->B5_2CODBAR			
			EndIF
Endif

nTamBar := Len(AllTrim(cCodBarra))
//Verifica o tamanho do código de barras. Deve estar dentro do padrão GTIN (8,12,13,14)
If	(nTamBar ==  8 .Or. nTamBar == 12 .Or. nTamBar == 13 .Or. nTamBar == 14)
	cRetorno := cCodBarra
Endif

return cRetorno

//-------------------------------------------------------------------
/*/{Protheus.doc} ParseBulk 
@description Retira as string de insert e convert num array
@author Nilton A. Rodrigues
@since 11/02/2022
@version 12.1.33
/*/
Static Function ParseBulk(cDadosIns)
	//- retira o primeiro (' e o ultimo de fechamento ')
	//- 123456789+........
	//- ('0000','00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000',
	//- '0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
	//- 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000',
	//- '|0000|001|0|01012000|31122021|TOTVS SP|56809338000143||SP|612000646114|3550308|||A|0|','0000000','0','0','00')
	cDadosIns := AllTrim(cDadosIns)
	cDadosIns := SubStr(cDadosIns,3,Len(cDadosIns)-4)
	//- troca as aspa e virgulas ',' por ponto e virgula ;
    cDadosIns := Alltrim(STRTRAN( cDadosIns, "','", chr(254)+"_"+chr(255)))

Return aClone(StrTokArr2( cDadosIns, chr(254)+"_"+chr(255)))

//-------------------------------------------------------------------
/*/{Protheus.doc} NfOrItXml 
@description Retorna dados do item do XML da NF origem vinculada.
@author Delleon Fernandes
@since 27/09/2022
@version 12.1.33
/*/
Static Function NfOrItXml(nTipoRet, cNFORI, cSERORI, cCLIEFOR, cLOJA, cITEMORI)

Local xRet   := ""	
Local aArea	 := GetArea()
Local cAlias := GetNextAlias()
Local cQuery := " "

	If oNfOrItXml == Nil

		cQuery := " SELECT DKA.DKA_DESCFO "
		cQuery += " FROM " + RetSqlName("DKC") + " DKC "
		cQuery += " INNER JOIN " + RetSqlName("DKA") + " DKA ON (DKA.DKA_FILIAL = ? AND DKA.DKA_DOC = DKC.DKC_DOC AND DKA.DKA_SERIE = DKC.DKC_SERIE AND DKA.DKA_FORNEC = DKC.DKC_FORNEC "
		cQuery += " AND DKA.DKA_LOJA = DKC.DKC_LOJA AND DKA.DKA_ITXML = DKC.DKC_ITXML AND DKA.D_E_L_E_T_='') "
		cQuery += " WHERE DKC_FILIAL   = ? "
		cQuery += " AND DKC.DKC_DOC    = ? "
		cQuery += " AND DKC.DKC_SERIE  = ? "
		cQuery += " AND DKC.DKC_FORNEC = ? "
		cQuery += " AND DKC.DKC_LOJA   = ? "
		cQuery += " AND DKC.DKC_ITEMNF = ? "
		cQuery += " AND DKC.D_E_L_E_T_ = ? "

		cQuery 	:= ChangeQuery(cQuery)
		oNfOrItXml := FWPreparedStatement():New(cQuery)

	EndIf
	
	oNfOrItXml:SetString(1, xFilial("DKA"))
	oNfOrItXml:SetString(2, xFilial("DKC"))
	oNfOrItXml:SetString(3, cNFORI)
	oNfOrItXml:SetString(4, cSERORI)
	oNfOrItXml:SetString(5, cCLIEFOR)
	oNfOrItXml:SetString(6, cLOJA)
	oNfOrItXml:SetString(7, cITEMORI)
	oNfOrItXml:SetString(8, Space(1))

	cQuery	:= oNfOrItXml:GetFixQuery()
	MPSysOpenQuery(cQuery, cAlias)	
	
	DbSelectArea(cAlias)
	
	If (cAlias)->(!Eof())
		If nTipoRet == 1
			xRet :=  (cAlias)->DKA_DESCFO
		EndIf
	EndIf
	
	(cAlias)->(dbCloseArea()) //Fecha tabela temporaria	

	RestArea(aArea)

Return xRet

//-------------------------------------------------------------------
/*/{Protheus.doc} RetCodBarPE 
@description Retorna o código de barras quando utilizado o ponto de entrada SPDFIS02
@author Rodrigo Cesar Candido
@since 20/09/2022
@version 12.1.33
/*/
Static Function RetCodBarPE(cAliasSFT, cAliasSB1)

	Local cCodBarra := ""

	If aExistBloc[01]
		aSpdFis02 := ExecBlock("SPDFIS02", .F., .F., {cAliasSFT,"","0220"})
		If ValType(aSpdFis02)=="A"
			If Len(aSpdFis02) > 4 .And. Alltrim((cAliasSB1)->B1_CODBAR) <> aSpdFis02[5]
				cCodBarra := aSpdFis02[5]
			EndIf	
		EndIf
	EndIf
	
Return cCodBarra

//-------------------------------------------------------------------
/*/{Protheus.doc} C895C897() 
@description Registro complementar de cupom fiscal modelo SAT - 59
@author Adilson Roberto
@since 25/11/2022
@version 12.1.2210
/*/
//-------------------------------------------------------------------
Static Function C895C897( cAlias, aLanCDA, aReg0460, aReg0200, aReg0190, aReg0220, dDataDe, dDataAte, aWizard, aRegC895, aRegC897, cChv890, nPosC890)

Local	nPos		:=	0
Local	nX			:=	0
Local	nPosC895	:=	0
Local   cChavC895	:= 	""
Local   cChavC897	:= 	""
Local	cCodItem	:=	""
Local 	nTamCDA		:= len(aLanCDA)

Default aC195aux 	:=	{}
DEFAULT aWizard		:= 	{}
Default aRegC895	:=	{}
Default aRegC897	:=	{}
Default nPosC890	:=  1

//Processando lancamentos do documento fiscal relacionados no CDA
For nX := 1 to nTamCDA

	cCodItem	:=	aLanCDA[nX,13]
		
	//³Geracao do REGISTRO C195 ³
	If (nPosC895 := aScan(aRegC895,{|aX| aX[3]==aLanCDA[nX][07] .And. aX[1] == nPosC890 })) == 0		

		aAdd(aRegC895, {})
		nPosC895	:=	Len (aRegC895)
		cChavC895 := cChv890 + "C895" + StrZero(nPosC895, nTTRBITEM, 0)
		aAdd (aRegC895[nPosC895], nPosC890) 							//00 - RELACIONAMENTO COM REGISTRO PAI
		aAdd (aRegC895[nPosC895], "C895")		 	   					//01 - REG
		aAdd (aRegC895[nPosC895], aLanCDA[nX][07])						//02 - COD_OBS
		aAdd (aRegC895[nPosC895], aLanCDA[nX][17])						//03 - TXT_COMPL		
		aAdd (aRegC895[nPosC895],cChavC895)
		//aAdd (aRegC895[nPosC895], RetRD(GetRelacPr())+strzero(nPosC895,nTamFT_IT))		//04 - Posição de Hierarquia
			
		//³REGISTRO 0460 - TABELA DE OBSERVACOES DO LANCAMENTO FISCAL      ³
		Reg0460(@aReg0460,{aRegC895[nPosC895][3],aLanCDA[nX][20]})

	EndIf

	If !aLanCDA[nX,24] // Legado (Código de lançamento vindo da TES)
		nPos := aScan(aRegC897,{|x| x[1] == nPosC895 .And. x[5]==cCodItem .And. x[3]==aLanCDA[nX,1] })
	Else
		//Estrutura do configurador
		If aLanCDA[nX,23] == "01"
			nPos := aScan(aRegC897,{|x| x[1] == nPosC895 .And. x[3]==aLanCDA[nX,1] })
		ElseIf aLanCDA[nX,23] == "02"
			nPos := aScan(aRegC897,{|x| x[1] == nPosC895 .And. x[3]==aLanCDA[nX,1] .And. x[4]==aLanCDA[nX][2] })
		Else
			nPos := aScan(aRegC897,{|x| x[1] == nPosC895 .And. x[5]==cCodItem .And. x[3]==aLanCDA[nX,1] })
		Endif	
	Endif
	//³Geracao do REGISTRO C197 ³
	If nPos == 0
		cChavC897 := cChavC895 + "C897" + StrZero(nPos, nTTRBITEM, 0)
		aAdd(aRegC897, {})
		nPos	:=	Len (aRegC897)
		aAdd (aRegC897[nPos], nPosC895)									//01 - RELACIONAMENTO COM C195 (PAI)
		aAdd (aRegC897[nPos], "C897")	   								//02 - REG
		aAdd (aRegC897[nPos], aLanCDA[nX,1])				       		//03 - COD_AJ
		aAdd (aRegC897[nPos], aLanCDA[nX][2])					   		//04 - DESCR_COMPL_AJ
		aAdd (aRegC897[nPos], cCodItem)									//05 - COD_ITEM
		aAdd (aRegC897[nPos], aLanCDA[nX][3])							//06 - VL_BC_ICMS
		aAdd (aRegC897[nPos], aLanCDA[nX][4])						 	//07 - ALIQ_ICMS
		aAdd (aRegC897[nPos], aLanCDA[nX][5])							//08 - VL_ICMS
		aAdd (aRegC897[nPos], aLanCDA[nX][6])							//09 - VL_OUTROS
		aAdd (aRegC897[nPos], cChavC897)
		//aAdd (aRegC897[nPos], RetRD(GetRelacPr())+strzero(nPosC895,nTamFT_IT))
	Else
		aRegC897[nPos][6]	+=  aLanCDA[nX][3]	//06 - VL_BC_ICMS
		aRegC897[nPos][8]	+=  aLanCDA[nX][5]	//08 - VL_ICMS
		aRegC897[nPos][9]	+=  aLanCDA[nX][6]	//09 - VL_OUTROS
	EndIf    
	//³Tratamento para que os itens utilizados seja gerados no 0200³
	If !Empty( cCodItem ) .And.  aScan ( aReg0200, { |aX| aX[2] == cCodItem }) == 0
		SPEDSeek("SB1",,aSPDFil[PFIL_SB1]+cCodItem)
		SFRG0200( cAlias, @aReg0200, @aReg0190, dDataDe, dDataAte, ,cCodItem , @aReg0220,,,,,,,,,,,,,,,,,,,aWizard  )
	EndIf	

Next        

Return